{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yelee/source/background/bg-1.jpg","path":"background/bg-1.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-3.jpg","path":"background/bg-3.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-2.jpg","path":"background/bg-2.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-4.jpg","path":"background/bg-4.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/AcFun.png","path":"img/AcFun.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/CSDN.png","path":"img/CSDN.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/Coding.png","path":"img/Coding.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/LOFTER.png","path":"img/LOFTER.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/Plunker.png","path":"img/Plunker.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/Quora.png","path":"img/Quora.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/bilibili.png","path":"img/bilibili.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/niconico.png","path":"img/niconico.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/博客园.png","path":"img/博客园.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/知乎.png","path":"img/知乎.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/简书.png","path":"img/简书.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-5.jpg","path":"background/bg-5.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/bg-6.jpg","path":"background/bg-6.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","path":"background/backup/bg-1.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","path":"background/backup/bg-2.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","path":"background/backup/bg-3.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","path":"background/backup/bg-4.jpg","modified":0,"renderable":1},{"_id":"themes/yelee/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/yelee/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yelee/.gitignore","hash":"237760b38ce80bcc3a8b556566bef0295c145393","modified":1516935531692},{"_id":"themes/yelee/_config.yml","hash":"430d877ebfc5e895244cb839857e68be3263f2af","modified":1517828181123},{"_id":"themes/yelee/README.md","hash":"12bc9cdb68f51df81bcc36a5263e0a6c5860f646","modified":1516935531696},{"_id":"source/_posts/2017-08-11-structural-command-of-shell.md","hash":"5d5cd96ebcb95f4308e6f0833e3cb78529e4bf15","modified":1517026085774},{"_id":"source/_posts/2017-08-19-working-with-user-input.md","hash":"5a362aee5c543f073fdd19a9a97872ebc26ccf02","modified":1517026091150},{"_id":"source/_posts/2017-08-22-shell-show-data.md","hash":"b12b6bc4141eb2db8545d5ef3256ccb4499b05e8","modified":1517026096958},{"_id":"themes/yelee/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1516935531696},{"_id":"source/_posts/2017-08-11-basic-shell.md","hash":"421154034731838921e396735066becbfd4ac8a1","modified":1517026059126},{"_id":"source/_posts/2017-09-03-Linux-data-analysis-tools.md","hash":"92f7e41ba5dfaf0a4a6cde117c01c6dcb3feb43c","modified":1517026102086},{"_id":"source/404/index.md","hash":"1663716dcc98e5211399d67b241556056dd4750d","modified":1516979560529},{"_id":"source/_posts/2017-09-15-Class-in-R.md","hash":"0ce1817bdb8cf0ef0d635cf28263371689b55fa3","modified":1517026113334},{"_id":"source/_posts/2017-11-29-shell-create-text-menu-and-window.md","hash":"0a73bd2f1f1c83eb02f6184accc60c2963b200b3","modified":1517026127822},{"_id":"source/_posts/2017-09-20-OOPinR.md","hash":"6c06b629715ffaa88298f993ac1d920b1a358e9b","modified":1517026118410},{"_id":"source/_posts/2017-12-08-Git-basic-operation.md","hash":"509e2fef11ce01e383c95bb524ca42d6e1ac262f","modified":1517026134162},{"_id":"source/_posts/2018-01-31-sed-how-to-filter-rows-before-using-command.md","hash":"620153e97dc0a1c4a6884a1b7dc486b53e0d8a81","modified":1517405024285},{"_id":"source/_posts/2017-12-25-sed-and-gawk.md","hash":"9cac408d1750c120970baef33f893ce4eb6838ac","modified":1517026139634},{"_id":"source/_posts/2017-09-04-control_shell.md","hash":"9f17ce2d1efa741ecd08362f40c2025de8fcc976","modified":1517026106410},{"_id":"source/_posts/2017-11-26-shell-create-function.md","hash":"4939a51ee91efd172c64e3bb0b3ba901ccd7121b","modified":1517026122946},{"_id":"source/_rmd/.Rhistory","hash":"9913218fee6e3706c51f4978c0c243fd57e3a220","modified":1517588644425},{"_id":"source/_rmd/2018-02-03-test.md","hash":"e2bd7379585407ee223894d9f53f7f0da7546909","modified":1517635636099},{"_id":"source/_rmd/template.Rmd","hash":"e2bd7379585407ee223894d9f53f7f0da7546909","modified":1517588544725},{"_id":"source/_rmd/2018-02-03-how-to-write-rmd-post-for-hexo-blogsystem.Rmd","hash":"1bd3c3b8828722a4db8057fba67f26b8db2159ec","modified":1517635998716},{"_id":"source/_posts/2018-01-31-sync-deploy-tools.md","hash":"4df8dd030ca2532f01f8f8bbc14c8a5df45b2f3b","modified":1517829052150},{"_id":"source/tags/index.md","hash":"42a0dcef017652888ed4eb216364d7f8c5e4d968","modified":1516978378247},{"_id":"source/about/index.md","hash":"0912b79ec165f49e4e4f14ba0e3011e1576710a5","modified":1516978646632},{"_id":"themes/yelee/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1516935531696},{"_id":"themes/yelee/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1516935531696},{"_id":"themes/yelee/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1516935531696},{"_id":"themes/yelee/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1516935531696},{"_id":"themes/yelee/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1516935531696},{"_id":"themes/yelee/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1516935531696},{"_id":"themes/yelee/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1516935531696},{"_id":"themes/yelee/languages/default.yml","hash":"80cc17267333753accc0b1c85a73678fedcbce76","modified":1516935531696},{"_id":"themes/yelee/languages/en.yml","hash":"2c096d06c0af4ddf9c128fc8f77fb276b59a47fb","modified":1516935531696},{"_id":"themes/yelee/languages/zh-Hans.yml","hash":"b5b2d20cde04db3773962284a002d025b09134b0","modified":1516935531696},{"_id":"themes/yelee/languages/zh-Hant-HK.yml","hash":"c38a95f5076ad951839aaf7748295d7eea277c61","modified":1516935531696},{"_id":"themes/yelee/languages/zh-Hant-TW.yml","hash":"f372cc0d758a7d8bbb885aa9756d607bec26469a","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/after-footer.ejs","hash":"748391b89b661fa1ed7da0b15ed6870981ec4dc3","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/archive-post.ejs","hash":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/article.ejs","hash":"afd85b362d732fa9b439af7dc44b657d0d1aae3d","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/background.ejs","hash":"aeef39abef66ee0bd6c9efe856eaeb1b81416d41","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/footer.ejs","hash":"82653e3bbdc605b51e1b0a36e30f3ac1180c838e","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/head.ejs","hash":"55e90c3d5de6d7ffcfe26c4dc22189a7a27b6651","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/ie-updater.ejs","hash":"3e5f2e41bbb1a5b93a8a7a6cb9ccd191ced54408","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/mathjax.ejs","hash":"ce868f8b2b5b377cadc270e3a5bb5826f8bf0dee","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/mobile-nav.ejs","hash":"306be982577b0ef968f855d0dfeaab6b180b8a50","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/open-in-new-tab.ejs","hash":"a6046bc322ce9194faa9559c70e1618a7e1e4cbc","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/page.ejs","hash":"cfce60062cdb60893baeda7fa0266ae4086c2bc8","modified":1516935531696},{"_id":"themes/yelee/.github/ISSUE_TEMPLATE.md","hash":"09e2580d457ce93b4d7d554b75618036b45f8717","modified":1516935531692},{"_id":"themes/yelee/layout/_partial/post-nav-button.ejs","hash":"0a98bffdd14f6677721841c0ac4487a86c77266c","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/scrolling-button.ejs","hash":"c5e1c3a8e1e6b0d927ac25a7fb8720ee7ac83ad8","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/tag-cloud-page.ejs","hash":"432ded02bcc1f0d52cd833e8eeac688ee886169a","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/toc.ejs","hash":"7ee88b1a98eea5cbd44c0f9a11b86b46aa2d6752","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/left-col.ejs","hash":"90fd7c763faf8d64d58612f592cbacbefdaea161","modified":1516935531696},{"_id":"source/_rmd/new_post.R","hash":"b98db46a9191e7d18a6d287d0e6eca93ea9c7a23","modified":1517635752339},{"_id":"themes/yelee/source/background/bg-1.jpg","hash":"9a5241de4c880f13a278f6980bf11d4dfb214d82","modified":1516935531696},{"_id":"themes/yelee/source/background/bg-3.jpg","hash":"d476909f06fe8267c676952e3582bf9e9ff73585","modified":1516935531696},{"_id":"themes/yelee/source/background/bg-2.jpg","hash":"d1e0b92e8fa822e44d185b5e1bf94ab47bc98a0a","modified":1516935531696},{"_id":"themes/yelee/source/background/bg-4.jpg","hash":"8e80d0b7786c3bf7b9648c0190719e78001e9eeb","modified":1516935531700},{"_id":"themes/yelee/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1516935531700},{"_id":"themes/yelee/source/css/_variables.styl","hash":"f429eb9bc9f0a270ec68c4f4c63903250746a01c","modified":1516935531700},{"_id":"themes/yelee/source/img/AcFun.png","hash":"df6b0fa39ced4dc988359fc7b7cd1e5403de08a6","modified":1516935531700},{"_id":"themes/yelee/source/css/style.styl","hash":"b285f9a75abd09c7d06fe89e70f9e1819eac27dd","modified":1516935531700},{"_id":"themes/yelee/source/img/CSDN.png","hash":"59f7d89eda8a7310a0ee1607e153c0829af7eb6e","modified":1516935531700},{"_id":"themes/yelee/source/img/Coding.png","hash":"afb4bce19bebf61e3c486fd5199369d6eb191b78","modified":1516935531700},{"_id":"themes/yelee/source/img/LOFTER.png","hash":"88670eaea8612839e9d6a40a3636e4231ab56c0f","modified":1516935531700},{"_id":"themes/yelee/source/img/Plunker.png","hash":"14a0054b9b4a0e459987f34b9ab48ab22dbe5cf9","modified":1516935531700},{"_id":"themes/yelee/source/img/Quora.png","hash":"1a624ade0d07f2482b21bef1e2a5ddd0110ba352","modified":1516935531700},{"_id":"themes/yelee/source/img/SegmentFault.png","hash":"1afbc7e575e2e9ed9404be84a3f92f7ca8345a9c","modified":1516935531700},{"_id":"themes/yelee/source/img/TiddlyWiki.png","hash":"b7f68f8f9c45561a9455aee0bfb80e35cae6f8df","modified":1516935531700},{"_id":"themes/yelee/source/img/V2EX.png","hash":"d0768de8555f9be0ee8ce956198cef454d4e4d7c","modified":1516935531700},{"_id":"themes/yelee/source/img/bilibili.png","hash":"be37b7e9a091c8547b8ee8b9d29583af8ded61c0","modified":1516935531700},{"_id":"themes/yelee/source/img/niconico.png","hash":"fabc7ca45e9ee5698db33a25de8b1f8a7c7d6723","modified":1516935531700},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","hash":"af987032f2171867bb58b165d2180eb5dcbea637","modified":1516935531700},{"_id":"themes/yelee/source/img/博客园.png","hash":"5ff6f4c9f1fc1695217a57436d58b246d9d2f197","modified":1516935531700},{"_id":"themes/yelee/source/img/新浪微博.png","hash":"7a145ed1daee0c172cda77098f4254fc21f9eeee","modified":1516935531700},{"_id":"themes/yelee/source/img/知乎.png","hash":"ed6d3c304789e112d09f40784fa6add1f1a38bd6","modified":1516935531700},{"_id":"themes/yelee/source/img/简书.png","hash":"5c91ee83cab4abe160240e09de345b6935c8cb37","modified":1516935531700},{"_id":"themes/yelee/source/img/网易云音乐.png","hash":"4fd1275fd988584811cf710207eb077f2306f271","modified":1516935531700},{"_id":"themes/yelee/source/img/虾米音乐.png","hash":"a0039b049779b1f37c0b0b91760943b7bf25c8f1","modified":1516935531700},{"_id":"themes/yelee/source/img/豆瓣.png","hash":"f1fc97f98612bcdf4a681542e5388483b40a5300","modified":1516935531700},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","hash":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df","modified":1516935531700},{"_id":"themes/yelee/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1516935531700},{"_id":"themes/yelee/source/js/main.js","hash":"369774a7ff45a2e5117a796330a04aeb50a61fdf","modified":1516935531700},{"_id":"themes/yelee/source/js/mobile.js","hash":"8abc32d18f16db56f51caad607cffb6ca756eca9","modified":1516935531700},{"_id":"themes/yelee/source/js/pc.js","hash":"bc289c5dc610e2a34d308daeb9adea96d01f7788","modified":1516935531700},{"_id":"themes/yelee/source/js/search.js","hash":"b456aaab98bbc3b0906f8a16d1e6e4f74dfcffda","modified":1516935531700},{"_id":"themes/yelee/source/js/toc.js","hash":"72ba1228fc1a44df45b8f4b562eba78594f13016","modified":1516935531700},{"_id":"themes/yelee/source/background/bg-5.jpg","hash":"e4a3631b6b0f94ebce30a6f01ecb2b6ed7cfdb0b","modified":1516935531700},{"_id":"themes/yelee/source/background/bg-6.jpg","hash":"51b427f07ffc6f2ad97651f23cc16e8f19ed02f9","modified":1516935531700},{"_id":"themes/yelee/layout/_partial/comments/click2show.ejs","hash":"678f3aec2980d378ea44be60eec3eb504c8ba668","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/comments/count-comment.ejs","hash":"d3c1b0b31db9d80e857f3054d010ea49c0f88134","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/comments/duoshuo.ejs","hash":"e7f12f1246a67a5b556c2d5b37dc78733f1cf15a","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/comments/disqus.ejs","hash":"df7ee469b648b12b5ee3104ef513d54cbb7418af","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/comments/youyan.ejs","hash":"bcf2070587645afd20a4eb046b9c8bb9c44d1cf5","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/post/category.ejs","hash":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/post/date.ejs","hash":"329ed372296a86bce73ff8936af5601723fdd70a","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/post/share.ejs","hash":"58c2db54a9867aaafe68a7f052b04701c7c3df0f","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/post/tag.ejs","hash":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1516935531696},{"_id":"themes/yelee/source/background/backup/bg-1.jpg","hash":"31d7bb15211000c05656899302f8ec9ee3de0e9f","modified":1516935531696},{"_id":"themes/yelee/source/background/backup/bg-2.jpg","hash":"7ae358f3ab8b41558444053400e796c41b3ba0e2","modified":1516935531696},{"_id":"themes/yelee/layout/_partial/post/nav.ejs","hash":"7f9dbe52741a7b7e6857ab35d96ab1952586cbaa","modified":1517029079416},{"_id":"themes/yelee/source/background/backup/bg-3.jpg","hash":"1a06d3a660bfb99b62d760e4e1e09de168a4c74c","modified":1516935531696},{"_id":"themes/yelee/source/css/_partial/article.styl","hash":"190828c822096bb3098a7d14c3340eb004057aa0","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/archive.styl","hash":"102c23dbb6cde3cbfca3b151c742e0d77911186e","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/footer.styl","hash":"a419108f1b820c59fcc56d218bfaaa4ffc4f1d4d","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/highlight.styl","hash":"4e34bf9340ce9b15d2d59fc4ea761d1d110927cf","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/instagram.styl","hash":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/main.styl","hash":"405db411896f3c7de9e7dd27e58c920fb90b9834","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/mobile-slider.styl","hash":"39db458d4e9f6973afc1390b4d3fc0291fff4c40","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/page.styl","hash":"ca3f871adf8fdb296e4394070605dded53d93cb2","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/scroll.styl","hash":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/search.styl","hash":"fcaa5deaa654aaec69e267e23b49df07f84f633a","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/share.styl","hash":"88c1277397b71eb1f3473a94d9542314f983cd09","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/mobile.styl","hash":"dfb20f2515a26d75e42fe09741e91cc889426b11","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/toc.styl","hash":"eb19bbd37fc2c1abd238e2ed96b22cb1aae41ab7","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/tagcloud.styl","hash":"b38b275728bfe11809defe1077b03cb423c3c92f","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1516935531700},{"_id":"themes/yelee/source/background/backup/bg-4.jpg","hash":"6df1383d0f6134016d844df9abb740a6e0c0b2c5","modified":1516935531696},{"_id":"themes/yelee/source/apple-touch-icon.png","hash":"2b85a60c52c38511cba052e044d140ede5798e12","modified":1516981102242},{"_id":"themes/yelee/source/img/avatar.png","hash":"2b85a60c52c38511cba052e044d140ede5798e12","modified":1516946584256},{"_id":"themes/yelee/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1516935531700},{"_id":"themes/yelee/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/customise/blockquote.styl","hash":"5e6edb9ad49288743ed550a2bd8c9a3c8e208455","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/customise/code-block.styl","hash":"4db1a992a06fd92b779f0afc9bb8bb3667bdb101","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/customise/color-scheme.styl","hash":"b58262a9f8903e75df431291745e19ccd8ff243a","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/customise/heading.styl","hash":"f309241c1daa9b6c04aa04063307537c219fdd59","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/customise/inline-code.styl","hash":"a15292b2b3541ea022c0fb7441875192dee5ad9d","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/customise/list.styl","hash":"b1e564ed76d6e892556b61b4278270fc9eeea961","modified":1516935531700},{"_id":"themes/yelee/source/css/_partial/customise/social-icon.styl","hash":"bfa5c863d474266f32a570e34a0effda964f7f40","modified":1516935531700},{"_id":"themes/yelee/layout/_partial/tab-title-change.ejs","hash":"1bebab6eb7a849319cd48fe051f3c71b9349a723","modified":1516935531696},{"_id":"public/atom.xml","hash":"a50fd94f30f8037aa1fc5dd49a89f30e206b54ca","modified":1517829059795},{"_id":"public/search.xml","hash":"326cd1ba7ce4c2faab797a9ce26e2ce77d851dfe","modified":1517828192543},{"_id":"public/post-sitemap.xml","hash":"40153553cd5c33e2c62de322b4eecaf3ddb62735","modified":1517829060372},{"_id":"public/page-sitemap.xml","hash":"99b6a7e4837b20cb20047dc8a19b2423dfbf6fcc","modified":1517828192560},{"_id":"public/category-sitemap.xml","hash":"4d0a2b1c45f67b524048beb2937037b068705a6c","modified":1517829060387},{"_id":"public/tag-sitemap.xml","hash":"251eb91fff3bbc15e0be6158abf7173d958150a9","modified":1517828192560},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1517828192560},{"_id":"public/sitemap.xml","hash":"af963d6babb6d573170923cffe593da20dd3c4d1","modified":1517829060387},{"_id":"public/404.html","hash":"45629b65b2174eb0ad7e7d469177964c99843048","modified":1517828192568},{"_id":"public/tags/index.html","hash":"0f6aa7ab0220d91d24169e6cd10a2f59b4637201","modified":1517828192568},{"_id":"public/about/index.html","hash":"4ee42c7a03261638d80ecb6688a1c8773efd31b8","modified":1517828192568},{"_id":"public/2018/01/31/sed-how-to-filter-rows-before-using-command/index.html","hash":"17a82bab5c1ca6cacd652956fdbab3edf94f903e","modified":1517828192568},{"_id":"public/2018/01/31/sync-deploy-tools/index.html","hash":"e9c4cb543f60662e618e5dd71463dc1bbeef0e01","modified":1517829060396},{"_id":"public/2017/12/25/sed-and-gawk/index.html","hash":"9068b06281f893b18dec077816f371c7ad1d499c","modified":1517828192568},{"_id":"public/2017/12/08/Git-basic-operation/index.html","hash":"c7c2005a678e3c47a23affb2b65c7b6f036ed42b","modified":1517828192568},{"_id":"public/2017/11/29/shell-create-text-menu-and-window/index.html","hash":"c9295b644c75870e8eabbdc6c1a7674e2ffeb3c8","modified":1517828192568},{"_id":"public/2017/11/26/shell-create-function/index.html","hash":"39ae7299d179770bb58591559781bc5b5dca9c56","modified":1517828192568},{"_id":"public/2017/09/20/OOPinR/index.html","hash":"9aea49737ac2cd81bd97f097567b7789a2f4bb48","modified":1517828192568},{"_id":"public/2017/09/15/Class-in-R/index.html","hash":"53d8a6a8b3f50bfcdf19bb25d3a046076f52531f","modified":1517828192568},{"_id":"public/2017/09/04/control_shell/index.html","hash":"ba77f575bd944a0ee4fc2e7d5f388ee9de6be939","modified":1517828192568},{"_id":"public/2017/09/03/Linux-data-analysis-tools/index.html","hash":"a1931a446689494b728282d41122029b74deae8a","modified":1517828192568},{"_id":"public/2017/08/21/shell-show-data/index.html","hash":"d1a49db20236a86d3cdc5310b78cdc292c398878","modified":1517828192568},{"_id":"public/2017/08/19/working-with-user-input/index.html","hash":"2b8a59c78697075b7bc269611020dd05e75b167d","modified":1517828192568},{"_id":"public/2017/08/11/basic-shell/index.html","hash":"a10151e122ce9d65b8e7b1cdd6075e5a2caffc8e","modified":1517828192569},{"_id":"public/2017/08/11/structural-command-of-shell/index.html","hash":"5d22a72848295900f785ad67aa33e9da816c4c0b","modified":1517828192569},{"_id":"public/archives/index.html","hash":"bc16ce58109d4c4d4a3cc5f848a6828552fcbb4d","modified":1517828192569},{"_id":"public/archives/page/2/index.html","hash":"ebd54f1c4c703b3bc6782ffd78073694acb46f2f","modified":1517828192569},{"_id":"public/archives/2017/index.html","hash":"2cf44e5a836d3fe5615b422517c190734da33d0b","modified":1517828192570},{"_id":"public/archives/2017/page/2/index.html","hash":"940e65aed555597ae9768d65f78b2d4bf64931b0","modified":1517828192570},{"_id":"public/archives/2017/08/index.html","hash":"54289d3e30fb4952ad7a259647220674ef6f4d56","modified":1517828192570},{"_id":"public/archives/2017/09/index.html","hash":"a88e6ce66fbeb4dda9eab9659546b81b2ac2f490","modified":1517828192570},{"_id":"public/archives/2017/11/index.html","hash":"bc28bb3918fd21a3c91147b11b11a244e459b4ea","modified":1517828192570},{"_id":"public/archives/2017/12/index.html","hash":"f309ddaedd3315c464265f9759e38e5489b64832","modified":1517828192570},{"_id":"public/archives/2018/index.html","hash":"1b737a5e1a9bdb174950e10e5874961e8fc69b96","modified":1517828192570},{"_id":"public/archives/2018/01/index.html","hash":"1cc39017fd820490a2ef4a4742eedac2a4193c18","modified":1517828192570},{"_id":"public/index.html","hash":"0e9dde21720d5a63d1acfdbff061ca8aa435c4fa","modified":1517829060396},{"_id":"public/page/2/index.html","hash":"5e2baf91c9e184862db4de0dcadda2bc5b4e74d0","modified":1517828192570},{"_id":"public/categories/Linux杂烩/index.html","hash":"8b1afb9fd1fceb3c4ebfe76a4d4da8389697d1b8","modified":1517828192570},{"_id":"public/categories/Linux杂烩/page/2/index.html","hash":"2a2440d80aa273b61c95d3e88a482815811d4ddf","modified":1517828192570},{"_id":"public/categories/Linux杂烩/shell编程/index.html","hash":"f4baf2a9d7298e5421b1daf143ae58d2256ca19b","modified":1517828192570},{"_id":"public/categories/Linux杂烩/文本处理/index.html","hash":"4a1a09ba6f38c0105fc3d249c52bd00e49fb7db8","modified":1517828192570},{"_id":"public/categories/极客R/index.html","hash":"cb240b667ed8284393af32cd2c546cf41b3fe931","modified":1517828192570},{"_id":"public/categories/Linux杂烩/Git/index.html","hash":"6f46758b9a2d444cf9bf63e477d03bb9cfad3f25","modified":1517828192570},{"_id":"public/categories/开源工具/index.html","hash":"71b70c2107502e4d93279109bc752b84f5e1875c","modified":1517828192570},{"_id":"public/categories/极客R/基本理论/index.html","hash":"01ade2069952035953ce304bc549f8a18bd6fb30","modified":1517828192571},{"_id":"public/tags/bash-shell/index.html","hash":"f8a76ffa4f72c7a28b0e2362d6e5fdb6cd0cae30","modified":1517829060396},{"_id":"public/tags/shell笔记/index.html","hash":"b5bab3fb10ce870bcf2e485137dd4308710a24a6","modified":1517829060396},{"_id":"public/tags/Linux-shell/index.html","hash":"eff59d4d7688e6ce999c0e73df9daa47a09945d8","modified":1517828192571},{"_id":"public/tags/数据处理/index.html","hash":"d4177fac88f4ee9c5250d54e7256d07f6246c4ea","modified":1517828192571},{"_id":"public/tags/R/index.html","hash":"0e6b91fa536974030605dff6269c743b322fe6b8","modified":1517828192571},{"_id":"public/tags/类/index.html","hash":"50282c0e2702026042b412b0b986f4f5b3f1a825","modified":1517828192571},{"_id":"public/tags/linux/index.html","hash":"8f470ca3829ae80ab46a4205b3b32c2d63c6305c","modified":1517828192571},{"_id":"public/tags/OOP/index.html","hash":"145ead4faac5d02124e04940d0b1dee21fffc607","modified":1517828192571},{"_id":"public/tags/git/index.html","hash":"21da4eaf4860548c9366246e11ac0e20f60caaeb","modified":1517828192571},{"_id":"public/tags/github/index.html","hash":"6abc541475110d11dec96ead76154ee669130267","modified":1517828192571},{"_id":"public/tags/sed/index.html","hash":"397b656f7d29f5a13f98df1a78a8460f84908cdf","modified":1517828192571},{"_id":"public/tags/生物信息学/index.html","hash":"783eb0606bf7ade42f82fc8e44e05481ff118dfb","modified":1517828192571},{"_id":"public/tags/文本处理/index.html","hash":"e2feb21e461b54c83db348dba398aa5ba67bb585","modified":1517828192571},{"_id":"public/tags/fasta/index.html","hash":"930e83d6fac85b934683659db4c94a7562941cfb","modified":1517828192571}],"Category":[{"name":"Linux杂烩","_id":"cjda3cwu000049taxkkw9vdgx"},{"name":"shell编程","parent":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwur000i9taxevvfv109"},{"name":"文本处理","parent":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwv2000u9taxssoh092o"},{"name":"极客R","_id":"cjda3cwv700109taxg9a2un47"},{"name":"Git","parent":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwvk001p9taxupuy7vlf"},{"name":"开源工具","_id":"cjda3cwvm00209taxhoep72u8"},{"name":"基本理论","parent":"cjda3cwv700109taxg9a2un47","_id":"cjda3cwvo00269taxxieiecut"}],"Data":[],"Page":[{"title":"404 Not Found：该页无法显示","toc":false,"comments":0,"_content":"<style type=\"text/css\">\n\t.article-header {\n\t\tpadding: 0;\n\t\tpadding-top: 26px;\n\t\tborder-left: none;\n\t\ttext-align: center;\n\t}\n\t.article-header:hover {\n\t\tborder-left: none;\n\t}\n\t.article-title {\n\t\tfont-size: 2.1em;\n\t}\n\tstrong a {\n\t\tcolor: #747474;\n\t}\n\t.article-meta {\n\t\tdisplay: none;\n\t}\n\t.share {\n\t\tdisplay: none;\n\t}\n\t.ds-meta {\n\t\tdisplay: none;\n\t}\n\t.player {\n\t\tmargin-left: -10px;\n\t}\n\t.sign {\n\t\ttext-align: right;\n\t\tfont-style: italic;\n\t}\n  \t#page-visit {\n\t\tdisplay: none;\n\t}\n\t.center {\n\t\ttext-align: center;\n\t\theight: 2.5em;\n\t\tfont-weight: bold;\n\t}\n\t.article-entry hr {\n\t\tmargin: 0;\n\t}\n\t.pic {\n\t\ttext-align: center;\n\t\tmargin: 0;\n\t}\n\t.pic br {\n  \t\tdisplay: none;\n  \t}\n\t#container .article-info-post.article-info {\n  \tdisplay: none;\n  \t}\n\t#container .article .article-title {\n\tpadding: 0;\n\t}\n</style>\n","source":"404/index.md","raw":"title: 404 Not Found：该页无法显示\ntoc: false\ncomments: false\npermalink: /404\n---\n<style type=\"text/css\">\n\t.article-header {\n\t\tpadding: 0;\n\t\tpadding-top: 26px;\n\t\tborder-left: none;\n\t\ttext-align: center;\n\t}\n\t.article-header:hover {\n\t\tborder-left: none;\n\t}\n\t.article-title {\n\t\tfont-size: 2.1em;\n\t}\n\tstrong a {\n\t\tcolor: #747474;\n\t}\n\t.article-meta {\n\t\tdisplay: none;\n\t}\n\t.share {\n\t\tdisplay: none;\n\t}\n\t.ds-meta {\n\t\tdisplay: none;\n\t}\n\t.player {\n\t\tmargin-left: -10px;\n\t}\n\t.sign {\n\t\ttext-align: right;\n\t\tfont-style: italic;\n\t}\n  \t#page-visit {\n\t\tdisplay: none;\n\t}\n\t.center {\n\t\ttext-align: center;\n\t\theight: 2.5em;\n\t\tfont-weight: bold;\n\t}\n\t.article-entry hr {\n\t\tmargin: 0;\n\t}\n\t.pic {\n\t\ttext-align: center;\n\t\tmargin: 0;\n\t}\n\t.pic br {\n  \t\tdisplay: none;\n  \t}\n\t#container .article-info-post.article-info {\n  \tdisplay: none;\n  \t}\n\t#container .article .article-title {\n\tpadding: 0;\n\t}\n</style>\n","date":"2018-01-26T15:12:40.529Z","updated":"2018-01-26T15:12:40.529Z","path":"/404.html","layout":"page","_id":"cjda3cwtq00019taxsyzj2pzp","content":"<style type=\"text/css\">\n    .article-header {\n        padding: 0;\n        padding-top: 26px;\n        border-left: none;\n        text-align: center;\n    }\n    .article-header:hover {\n        border-left: none;\n    }\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .article-meta {\n        display: none;\n    }\n    .share {\n        display: none;\n    }\n    .ds-meta {\n        display: none;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n      #page-visit {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n    .pic br {\n          display: none;\n      }\n    #container .article-info-post.article-info {\n      display: none;\n      }\n    #container .article .article-title {\n    padding: 0;\n    }\n</style>\n","site":{"data":{}},"excerpt":"","more":"<style type=\"text/css\">\n    .article-header {\n        padding: 0;\n        padding-top: 26px;\n        border-left: none;\n        text-align: center;\n    }\n    .article-header:hover {\n        border-left: none;\n    }\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .article-meta {\n        display: none;\n    }\n    .share {\n        display: none;\n    }\n    .ds-meta {\n        display: none;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n      #page-visit {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n    .pic br {\n          display: none;\n      }\n    #container .article-info-post.article-info {\n      display: none;\n      }\n    #container .article .article-title {\n    padding: 0;\n    }\n</style>\n"},{"title":"tags","date":"2018-01-26T14:52:58.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-01-26 22:52:58\n---\n","updated":"2018-01-26T14:52:58.247Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjda3cwtx00039taxiesq480q","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2018-01-26T14:57:26.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-01-26 22:57:26\n---\n","updated":"2018-01-26T14:57:26.632Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjda3cww900339taxhb9e92et","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Linux结构化命令","author":"王诗翔","date":"2017-08-10T16:00:00.000Z","_content":"\n<!-- more -->\n\n## 条件控制\n\n\n\n> **内容**\n>\n> - 使用if-then语句\n> - 嵌套if语句\n> - test命令\n> - 复合条件测试\n> - 使用双方括号和双括号\n> - case命令\n\n许多程序要求对shell脚本中的命令施加一些逻辑流程控制。而某些命令会根据条件判断执行相应的命令，这样的命令通常叫做**结构化命令**。从概念上理解，结构化命令是shell脚本的逻辑结构，不像顺序执行shell脚本，而是有组织地执行命令以应对复杂任务需求。\n\n### if-then语句\n\n最基本的结构化命令是if-then语句，它的格式如下：\n\n```shell\nif command\nthen\n\tcommands\nfi\n```\n\n**注意**，在其他编程语言中，`if`语句之后的对象是一个等式，等式的结果为`TRUE`或者`FALSE`，但是bash shell中的`if`语句是运行`if`后面的命令，如果该命令的退出状态码是0（命令成功执行），则运行`then`语句后面的命令。`fi`表示`if`语句到此结束。\n\n下面是一个简单的例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test1.sh\n#! /bin/bash\n# testing the if statement\nif pwd\nthen\n    echo \"It worked\"\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test1.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test1.sh\n/home/wsx/script_learn\nIt worked\n```\n\n这个例子中在判断成功执行`pwd`命令后，执行输出文本字符串。\n\n大家可以尝试把`pwd`命令改成随便乱打的字符试试结果。它会显示报错信息，`then`后面的语句也不会执行。\n\nif-then语句的另一种形式：\n\n```shell\nif command; then\ncommands\nfi\n```\n\n在then部分，我们可以使用多个命令（从格式中command结尾有没有s也可以看出）。\n\n我们再来一个例子：在`if`语句中用`grep`命令在`/etc/passwd`文件中查找某个用户名当前是否在系统上使用。如果有用户使用了哪个登录名，脚本会显示一些文本信息并列出该用户HOME目录的bash文件。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test3.sh\n#!/bin/bash\n# testing multiple commands in the then section\n#\ntestuser=wsx\n#\nif grep $testuser /etc/passwd\nthen\n  echo \"This is my first command\"\n  echo \"This is my second command\"\n  echo \"I can even put in other commands besides echo:\"\n  ls -a /home/$testuser/.b*\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test3.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test3.sh\nwsx:x:1000:1000:wsx,,,:/home/wsx:/bin/bash\nThis is my first command\nThis is my second command\nI can even put in other commands besides echo:\n/home/wsx/.bash_history  /home/wsx/.bashrc\n/home/wsx/.bash_logout\t /home/wsx/.bashrc-anaconda3.bak\n\n```\n\n如果设置的用户名不存在，那么就没有输出。那么如果在这里显示的一些消息可以说明用户名在系统中未找到，这样可能就会显得更友好。所以接下来看看`if-then-else`语句。\n\n### if-then-else语句\n\n我相信意思非常容易理解，这里较之前我们添加了一个`else`块来处理`if`中命令没有成功执行的步骤。格式为：\n\n```shell\nif command\nthen\n  commands\nelse commands\nfi\n```\n\n### 嵌套if\n\n有时我们需要检查脚本代码中的多种条件，可以是用嵌套的`if-then`语句。\n\n处理一个例子：检查`/etc/passwd`文件中是否存在某个用户名以及该用户名的目录是否存在。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test5.sh\n#!/bin/bash\n\n# Testing nested ifs\n#\ntestuser=NoSuchUser\n#\nif grep $testuser /etc/passwd\nthen\n  echo \"The user $testuser exits on this system.\"\nelse\n  echo \"The user $testuser does not exit on this system.\"\n  if ls -d /home/$testuser/\n  then\n     echo \"However, $testuser has a directory.\"\n  fi\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test5.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test5.sh\nThe user NoSuchUser does not exit on this system.\nls: 无法访问'/home/NoSuchUser/': 没有那个文件或目录\n```\n\n可以使用`else`部分的另一种形式:`elif`。这样我们就不再用书写多个`if-then`语句了。在其他语言中，有的是用`elif`的形式，有的使用`else if`等形式。面对相同内含在不同语言中不同的表示方式，我们需要有意识地区别，以免接触的东西多了可能各种语言代码串写喔。\n\n```shell\nif command1\nthen\n\tcommands\nelif command2\nthen\n\tmore commands\nfi\n```\n\n这种表示方式逻辑更为清晰，但是也有点容易让写的人搞混。其实可以看到一个`if`对应一个`fi`。这是一个大的嵌套`if`结构。\n\n**记住**，在`elif`语句中，紧跟其后的`else`语句属于`elif`代码块，而不是属于`if-then`代码块。\n\n### test命令\n\n到此为止，我们很清楚`if`后面跟着的是普通的shell命令，那么我们需要测试其他条件怎么办呢？\n\n`test`命令提供了在`if-then`语句中测试不同条件的途径。如果`test`命令中列出的条件成立，`test`命令就会退出并返回状态码0。这样`if-then`语句就与其他编程语言中的`if-then`语句以类似的方式工作了。\n\ntest命令格式：\n\n```\ntest condition\n```\n\n`condition`是`test`命令要测试的一系列参数和值。如果不写这个`condition`，`test`返回非0，`if`语句跳转到`else`进行执行。\n\nbash shell提供了一种条件测试方法，无需在`if-then`语句中声明`test`命令。\n\n```shell\nif [ condition ]\nthen commands\nfi\n```\n\n这跟我们其他的编程习惯非常接近。建议使用这种方式。\n\n如果使用`test`命令，需要记住的是各种条件参数。\n\n**数值比较**\n\n| 比较        | 描述         |\n| --------- | ---------- |\n| n1 -eq n2 | (n1)等于(n2) |\n| n1 -ge n2 | 大于或等于      |\n| n1 -gt n2 | 大于         |\n| n1 -le n2 | 小于或等于      |\n| n1 -lt n2 | 小于         |\n| n1 -ne n2 | 不等于        |\n\n**字符串比较**\n\n| 比较           | 描述               |\n| ------------ | ---------------- |\n| str1 = str2  | （str1与str2比较）相同  |\n| str1 != str2 | 不同               |\n| str1 < str2  | 小                |\n| str1 > str2  | 大                |\n| -n str1      | 检查string1的长度非0   |\n| -z str1      | 检查string1的长度是否为0 |\n\n注意，大于和小于号必须转义；大于和小于顺序和sort命令所采用的不同。\n\n**文件比较**\n\n| 比较              | 描述                |\n| --------------- | ----------------- |\n| -d file         | 检查file是否存在并是一个目录  |\n| -e file         | ～是否存在             |\n| -f file         | ～是否存在并是一个文件       |\n| -r file         | ～是否存在并可读          |\n| -s file         | ～是否存在并非空          |\n| -w file         | ～是否存在并可写          |\n|                 |                   |\n| -x file         | ～是否存在并可执行         |\n| -O file         | ～是否存在并属当前用户所有     |\n| -G file         | ～是否存在并且默认组与当前用户相同 |\n| file1 -nt file2 | 检查file1是否比file2新  |\n| file1 -ot file2 | 检查file1是否比file2旧  |\n\n### 复合条件测试\n\n`if-then`语句允许我们使用布尔逻辑来组合测试。可用\n\n- [ condition1] && [ condition2]\n- `[ condition1] || [ condition2]`\n\n### if-then的高级特性\n\n- 用于数学表达式的双括号\n- 用于高级字符串处理功能的双方括号\n\n**双括号**\n\n命令格式：\n\n```\n(( expresiion ))\n```\n\n`expression`可以是任意的数学赋值或比较表达式。除了`test`命令使用的标准数学运算符，下面列出了一些其他的：\n\n| 符号     | 描述   |\n| ------ | ---- |\n| val ++ | 后增   |\n| val -- | 后减   |\n| ++ val | 先增   |\n| -- val | 先减   |\n| !      | 逻辑取反 |\n| ~      | 位求反  |\n| **     | 幂运算  |\n| <<     | 左位移  |\n| >>     | 右位移  |\n| &      | 位布尔和 |\n| \\|     | 位布尔或 |\n| &&     | 逻辑和  |\n| \\|\\|   | 逻辑或  |\n\n看一个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test23.sh\n#!/bin/bash\n# using doble parenthesis\n#\nval1=10\n#\nif (( $val1 ** 2 > 90 ))\nthen\n  (( val2 = $val1 ** 2 ))\n  echo \"The square of $val1 is $val2\"\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test23.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test23.sh\nThe square of 10 is 100\n\n```\n\n**双方括号**\n\n双方括号命令提供了针对字符串比较的高级特性。命令格式如下：\n\n```\n[[ expression ]]\n```\n\n双方括号里的`expression`使用了`test`命令中采用的标准字符串比较。但它提供了`test`没有提供的一个特性——模式匹配。\n\n在模式匹配中，可以定义一个正则表达式来匹配字符串值。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test24.sh\n#! /bin/bash\n# using pattern matching\n#\nif [[ $USER == r* ]]\nthen\n  echo \"Hello $USER\"\nelse\n  echo \"Sorry, I do not know you\"\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test24.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test24.sh\nSorry, I do not know you\n```\n\n上面一个脚本中，我们使用了双等号。双等号将右边的字符串视为一个模式，并将其应用模式匹配规则。\n\n### case命令\n\n有了`case`命令，就不需要写出所有的`elif`语句来不停地检查同一个变量的值了。`case`命令会采用列表格式来检查单个变量的多值。\n\n下面是两个脚本实现相同功能进行对比：\n\nif语句：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test25.sh\n#!/bin/bash\n# looking for a possible value\n#\nif [ $USER = \"rich\" ]\nthen\n  echo \"Welcome $USER\"\n  echo \"Please enjoy you visit\"\nelif [ $USER = \"barbara\" ]\nthen\n  echo \"Welcome $USER\"\n  echo \"Please enjoy you visit\"\nelif [ $USER = \"testing\" ]\nthen\n  echo \"Special testing account\"\nelif [ $USER = \"jessica\" ]\nthen\n  echo \"Do not forget to logout when you're done\"\n```\n\ncase语句：\n\n```\ncase variable in\npattern1 | pattern2) commands1;;\npattern3) commands2;;\n*) default commands;;\nesac\n```\n\n上面的实例可以用`case`语句表示为：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test26.sh\n#!/bin/bash\n# using the case command\n#\ncase $USER in\nrich | barbara)\n  echo \"Welcome, $USER\"\n  echo \"Please enjoy your visits\";;\ntesting)\n  echo \"Special testing account\";;\njessica)\n  echo \"Do not forget to log off whe you're done\";;\n*)\n  echo \"Sorry, you are not allowed here\";;\nesac\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test26.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test26.sh\nSorry, you are not allowed here\n\n```\n\n`case`命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式。星号会捕获所有与已知模式不匹配的值。注意双分号的使用。\n\n### 小结\n\n> 最基本的命令是`if-then`语句；\n>\n> 可以拓展`if-then`语句为`if-then-else`语句；\n>\n> 可以将`if-then-else`语句通过`elif`语句连接起来；\n>\n> 在脚本中，我们需要测试一种条件而不是命令时，比如数值、字符串内容、文件或目录的状态，`test`命令提供了简单方法；\n>\n> 方括号是`test`命令统一的特殊bash命令；\n>\n> 双括号使用另一种操作符进行高级数学运算双方括号允许高级字符串模式匹配运算；\n>\n> `case`命令是执行多个`if-then-else`命令的简便方式，它会参照一个值列表来检查单个变量的值。\n\n关于结构化命令中循环，将在下次整理的笔记中阐述。\n\n\n\n## 循环控制\n\n\n\n> **内容**\n>\n> - for循环语句\n> - until迭代语句使用while语句\n> - 循环\n> - 重定向循环的输出\n\n这一节我们来了解如何重复一些过程和命令，也就是循环执行一组命令直到达到了某个特定条件。\n\n### for命令\n\n基本格式：\n\n```shell\nfor var in list\ndo\n\tcommands\ndone\n```\n\n也可以\n\n```shell\nfor var in list; do\n```\n\n分号只用来分隔命令的，让代码更简约。\n\n来个简单例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test1\n#!/bin/bash\n# basic for command\n\nfor test in Alabama Alaska Arizona Arkansas California Colorado\ndo\n    echo The next state is $test\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ ./test1\nThe next state is Alabama\nThe next state is Alaska\nThe next state is Arizona\nThe next state is Arkansas\nThe next state is California\nThe next state is Colorado\n```\n\n这里操作基本和其他语言一致（格式不同），不多讲啦。\n\n**在读取列表中的复杂值时**，我们可能会遇到问题。比如下面这个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat badtest1\n#!/bin/bash\n# another example of how not to use the for command\n\nfor test in I don't know if this'll work\ndo\n    echo \"word:$test\"\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ ./badtest1\nword:I\nword:dont know if thisll\nword:work\n```\n\n我们可以看到shell看到了列表值中的单引号尝试使用它们来定义一个单独的数据值。\n\n这里有两种解决办法：\n\n- 使用转义字符将单引号转义\n- 使用双引号来定义用到单引号的值\n\n我们将这两种解决办法同时用到上个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test2\n#! /bin/bash\n# another example of how not to use the for command\n\nfor test in I don\\'t know if \"this'll\" work; do\necho  \"word:$test\"\ndone\nwsx@wsx-ubuntu:~/script_learn$ ./test2\nword:I\nword:don't\nword:know\nword:if\nword:this'll\nword:work\n```\n\n我们可能明白了`for`循环是假定每个值是用空格分隔的，所以当有包含空格的数据时，我们需要用双引号括起来。\n\n**通常我们会将列表值存储在一个变量中**，然后通过遍历变量的方式遍历了其内容的的列表。\n\n看看怎么完成这个任务：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test3\n#!/bin/bash\n\n# using a variable to hold the list\nlist=\"Alabama Alaska Arizona Arkansas Colorado\"\nlist=$list\" Connecticut\" # 在尾部拼接文本\n\nfor state in $list; do\n  echo \"Have you ever visited $state?\"\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ ./test3\nHave you ever visited Alabama?\nHave you ever visited Alaska?\nHave you ever visited Arizona?\nHave you ever visited Arkansas?\nHave you ever visited Colorado?\nHave you ever visited Connecticut?\n```\n\n注意，代码中还用了另一个赋值语句向`$list`变量包含的已有列表中添加了一个值。这是在已有文本字符串尾部添加文本的一种常用方法。\n\n我们还可以**用命令来输出我们需要的列表内容**：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test4\n#!/bin/bash\n# reading values from a file\n\nfile=\"states\"\n\nfor state in $(cat $file)\ndo\n    echo \"Visit beautiful $state\"\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ cat states\nAlabama\nAlaska\nArizona\nArkansas\nColorado\nConnecticut\nDelaware\nFlorida\nGeorgia\nwsx@wsx-ubuntu:~/script_learn$ ./test4\nVisit beautiful Alabama\nVisit beautiful Alaska\nVisit beautiful Arizona\nVisit beautiful Arkansas\nVisit beautiful Colorado\nVisit beautiful Connecticut\nVisit beautiful Delaware\nVisit beautiful Florida\nVisit beautiful Georgia\n```\n\n\n\n**更改字段分隔符**\n\n环境变量`IFS`，也叫作字段分隔符。它定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将**空格、制表符和换行符**当作字段分隔符。\n\n如果想修改`IFS`的值，比如使其只能识别换行符，我们可以将下面这行代码加入脚本：\n\n```shell\nIFS=$'\\n'\n```\n\n在处理大量脚本时，我们可能只在某一部分使用其他的分隔符，这时候可以先保存原有的`IFS`值，然后修改，最后恢复：\n\n```shell\nIFS.OLD=$IFS\nIFS=$'\\n'\n<在代码中使用新的IFS值>\nIFS=$IFS.OLD\n```\n\n假如我们要遍历一个文件中用冒号分隔的值：\n\n```shell\nIFS=:\n```\n\n假如要指定多个`IFS`字符，只要将它们的赋值行串起来：\n\n```shell\nIFS=$'\\n':;\"\n```\n\n这个赋值会将换行符、冒号、分号以及双引号作为字段分隔符。\n\n\n\n**用通配符读取目录**\n\n我们可以用`for`命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用**文件扩展匹配**。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。\n\n我拿我的一个目录来尝试一下：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test5\n#!/bin/bash\n\n# iterate through all the files in a directory\n\nfor file in /home/wsx/python_learn/*\ndo\n  if [ -d \"$file\" ]\n  then\n    echo \"$file is a directory\"\n  elif [ -f \"$file\" ]\n  then\n    echo \"$file is a file\"\n  fi\ndone\nwsx@wsx-ubuntu:~/script_learn$ ./test5\n/home/wsx/python_learn/athletelist.py is a file\n/home/wsx/python_learn/athletemodel.py is a file\n/home/wsx/python_learn/ch2_data_input.py is a file\n/home/wsx/python_learn/chapter5_first.py is a file\n/home/wsx/python_learn/chapter6_first.py is a file\n/home/wsx/python_learn/chapter6_second.py is a file\n/home/wsx/python_learn/chapter6_third.py is a file\n/home/wsx/python_learn/coinFlips.py is a file\n/home/wsx/python_learn/Dive_into_python is a directory\n```\n\n**注意：**第一个方括号之后和第二个方括号之前必须加上一个空格，否则会报错。\n\n在Linux中，目录名和文件名中包含空格是合法的，所以将`$file`变量用双引号圈起来。当然，大家尽量不要让文件或目录包含空格，不然很容易出问题（命令会把空格当做文件的分隔符）。\n\n### C语言风格的for命令\n\nC语言风格的`for`命令看起来如下：\n\n```shell\nfor (( a = 1; a < 10; a++ ))\n```\n\n值得注意的是，这里有些部分没有遵循bash shell标准的`for`命令：\n\n- 变量赋值可以有空格；\n- 条件中的变量不以美元符开头；\n- 迭代过程的算式未用`expr`命令格式。\n\n在使用这种格式时要小心，不同的格式不注意就会出错。\n\n下面举个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test6\n#!/bin/bash\n\n# testing the C-style for loop\n\nfor (( i=1; i <= 10; i++ ))\ndo\n  echo \"The next number is $i\"\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ ./test6\nThe next number is 1\nThe next number is 2\nThe next number is 3\nThe next number is 4\nThe next number is 5\nThe next number is 6\nThe next number is 7\nThe next number is 8\nThe next number is 9\nThe next number is 10\n```\n\n\n\n### while命令\n`while`命令的格式为：\n```shell\nwhile test command\ndo\n  other commands\ndone\n```\n\n`while`命令某种意义上是`if-then`语句和`for`循环的混杂体。注意，这里`while`后面接的也是命令。`while`命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码是0（类似一般语言中 的TRUE）。直到非0时退出循环。\n\n`while`命令中定义的`test command`和`if-then`语句中的格式一模一样。可以使用任何普通的bash shell命令，或者用`test`命令进行条件测试，比如测试变量值。\n\n最常见的用法是用方括号来检查循环命令中用到的`shell`变量的值。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test\n#/bin/bash\n# while command test\n\nvar1=10\nwhile [ $var1 -gt 0 ]\ndo\n        echo $var1\n        var1=$[ $var1 - 1 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n```\n\n**使用多个测试命令**\n`while`命令允许我们在`while`语句行中定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。\n比如` while echo $var1 [ $var1 -ge 0 ] `检测的就是后面方括号命令的退出状态码。\n\n### until命令\n`until`命令和`while`命令工作的方式完全相反。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。\n\n```{shell}\nuntil test command\ndo\n  other commands\ndone\n```\n一个例子：\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test12\n#!/bin/bash\n# using the until command\n\nvar1=100\n\nuntil [ $var1 -eq 0 ]\ndo\n        echo $var1\n        var1=$[ $var1 - 25 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test12\n100\n75\n50\n25\n```\n同样地，在`until`命令中放入多个测试命令时也要注意（类似`while`）。\n\n### 嵌套循环\n\n在循环语句内使用任意类型的命令，包括其他循环命令，叫做嵌套循环。因为是在迭代中迭代，需要注意变量的使用以及程序的效率问题。\n\n下面举一个`for`循环嵌套`for`循环的例子：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test14\n#!/bin/bash\n# nesting for loops\n\nfor (( a = 1; a <= 3; a++ ))\ndo\n        echo \"Starting loop $a:\"\n        for (( b = 1; b <= 3; b++ ))\n        do\n                echo \"    Inside loop: $b\"\n        done\ndone\n\nwangsx@SC-201708020022:~/tmp$ . test14\nStarting loop 1:\n    Inside loop: 1\n    Inside loop: 2\n    Inside loop: 3\nStarting loop 2:\n    Inside loop: 1\n    Inside loop: 2\n    Inside loop: 3\nStarting loop 3:\n    Inside loop: 1\n    Inside loop: 2\n    Inside loop: 3\n```\n\nshell能够自动识别匹配的`do`和`done`字符。这种模式很常见，比如通常的小括号（`(`与`)`）、中括号、花括号匹配等等。它们的本质都是字符匹配。\n\n在混用循环命令时也一样，比如在`while`循环中内嵌一个`for`循环：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test15\n#!/bin/bash\n# placing a for loop inside a while loop\n\nvar1=5\n\nwhile [ $var1 -ge 0 ]\ndo\n        echo \"Outer loop: $var1\"\n        for (( var2 = 1; $var2 < 3; var2++))\n        do\n                var3=$[ $var1 * $var2 ]\n                echo \"  Inner loop: $var1 * $var2 = $var3\"\n        done\n        var1=$[ $var1 - 1 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ . test15\nOuter loop: 5\n  Inner loop: 5 * 1 = 5\n  Inner loop: 5 * 2 = 10\nOuter loop: 4\n  Inner loop: 4 * 1 = 4\n  Inner loop: 4 * 2 = 8\nOuter loop: 3\n  Inner loop: 3 * 1 = 3\n  Inner loop: 3 * 2 = 6\nOuter loop: 2\n  Inner loop: 2 * 1 = 2\n  Inner loop: 2 * 2 = 4\nOuter loop: 1\n  Inner loop: 1 * 1 = 1\n  Inner loop: 1 * 2 = 2\nOuter loop: 0\n  Inner loop: 0 * 1 = 0\n  Inner loop: 0 * 2 = 0\n```\n\n如果想要挑战脑力，可以混用`until`和`while`循环。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test16\n#!/bin/bash\n# using until and while loop\n\nvar1=3\n\nuntil [ $var1 -eq 0 ]\ndo\n        echo \"Outer loop: $var1\"\n        var2=1\n        while [ $var2 -lt 5 ]\n        do\n                var3=$(echo \"scale=4; $var1 / $var2\" | bc)\n                echo \"  Inner loop: $var1 / $var2 = $var3\"\n                var2=$[ $var2 + 1 ]\n        done\n        var1=$[ $var1 - 1 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ . test16\nOuter loop: 3\n  Inner loop: 3 / 1 = 3.0000\n  Inner loop: 3 / 2 = 1.5000\n  Inner loop: 3 / 3 = 1.0000\n  Inner loop: 3 / 4 = .7500\nOuter loop: 2\n  Inner loop: 2 / 1 = 2.0000\n  Inner loop: 2 / 2 = 1.0000\n  Inner loop: 2 / 3 = .6666\n  Inner loop: 2 / 4 = .5000\nOuter loop: 1\n  Inner loop: 1 / 1 = 1.0000\n  Inner loop: 1 / 2 = .5000\n  Inner loop: 1 / 3 = .3333\n  Inner loop: 1 / 4 = .2500\n```\n\n外部的`until`循环以值3开始，并继续执行到值等于0。内部`while`循环以值1开始一直执行，只要值小于5。需要注意循环条件的设置，我跑的几次都没写完整，然后无限循环只好重开终端。\n\n### 控制循环\n\n之前的学的命令已经可以让我们写循环程序了，设定好以后等待命令开始执行和等待循环结束。但是很多情况下，在循环中我们设定的某个（多个）变量达到某种条件时，我们就想要停止循环，然后运行循环下面的命令。这时候我们需要用到`break`和`continue`命令来帮我们控制住循环。\n\n这两个命令在其他语言中基本都时关键字，特别是`C`，用法差不多。我也就不具体介绍了，只点出它们的功能。\n\n**break**\n\n> 在shell执行break命令时，它会尝试跳出当前正在执行的循环。\n>\n> 在处理多个循环时，break命令会自动终止你所在的最内层循环。\n>\n> break命令接受单个命令行参数值：\n>\n> ​\tbreak n\n>\n> ​\t其中n制订了要跳出的循环层级（层数）\n\n**continue**\n\n>continue命令可以提前终止某次循环的命令，但并不会完全终止整个循环。可以在循环内部设置shell不执行命令的条件。\n>\n>也就是说使用continue命令时，它会自动跳过本次循环中接下来的运行步骤，跳转到下一次循环。但注意不是跳出，跳出时break的功能。\n>\n>同样的可以使用continue n         n制定要继续执行哪一级循环\n\n\n\n### 处理循环的输出\n\n在shell脚本中，我们可以对循环的输出使用管道或进行重定向。这是通过在`done`命令之后添加一个处理命令来实现的。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test\n#!/bin/bash\nfor file in /home/*\ndo\n        if [ -d \"$file\" ]\n        then\n                echo \"$file is a directory\"\n        else\n                echo \"$file is a file\"\n        fi\ndone > output.txt\nwangsx@SC-201708020022:~/tmp$ cat output.txt\n/home/wangsx is a directory\n```\n\nshell将`for`命令的结果重定向到文件`output.txt`中，而不是显示在屏幕上。\n\n\n\n### 实例\n\n下面两个例子演示如何用简单循环来处理数据。\n\n**查找可执行文件**\n\nLinux运行程序时通过环境变量`$PATH`提供的目录搜索可执行文件。如果徒手找的话，比较费时间，我们可以写个脚本来搞定它。\n\n```shell\nwangsx@SC-201708020022:~$ cat test25\n#!/bin/bash\n# finding files in the PATH\n\nIFS=:\nfor folder in $PATH\ndo\n        echo \"$folder:\"\n        for file in $folder/*\n        do\n                if [ -x $file ]\n                then\n                        echo \"  $file\"\n                fi\n        done\ndone\n\n# 输出结果太多，我就不拷贝结果了\n```\n\n先设定`IFS`分隔符以便于能正确分隔目录，然后将目录存放在`$folder`中，用`for`循环来迭代特定的目录中所有文件，然后用`if-then`命令检查文件的可执行权限。\n\nLinux有一个`tree`工具，非常方便输出目录结构，推荐使用下。\n\n\n\n**创建多个用户账号**\n\n如果你是管理员，需要创建大量账号时。不必每次都有`useradd`命令添加用户。将用户信息存放在指定文件，然后用脚本进行处理就可以了。\n\n用户信息的格式如下：\n\n```\nuserid, user name\n```\n\n第一个是你为用户选择的id，第二个是用户的全名。这是`csv`文件格式。\n\n为了能够读取它，我们使用以下命令：\n\n```shell\nwhile IFS=',' read -r userid name\n```\n\n`read`命令会自动获取`.csv`文本文件的下一行内容，所以不用再写一个循环来处理。当`read`命令返回`FALSE`时（也就是读完了），`while`命令就会退出。\n\n为了把数据从文件导向`while`命令，只要再`while`命令尾部加一个重定向符号。\n\n处理过程写成脚本如下：\n\n```shell\n#!/bin/bash\n# process new user accounts\n\ninput=\"users.csv\"\nwhile IFS=',', read -r userid name\ndo\n\techo \"adding $userid\"\n\tuseradd -c \"$name\" -m $userid\ndone < \"$input\"\n```\n","source":"_posts/2017-08-11-structural-command-of-shell.md","raw":"---\ntitle: Linux结构化命令\nauthor: 王诗翔\ndate: 2017-08-11\ncategories:\n- Linux杂烩\n- shell编程\ntags:\n- bash shell\n- shell笔记\n\n---\n\n<!-- more -->\n\n## 条件控制\n\n\n\n> **内容**\n>\n> - 使用if-then语句\n> - 嵌套if语句\n> - test命令\n> - 复合条件测试\n> - 使用双方括号和双括号\n> - case命令\n\n许多程序要求对shell脚本中的命令施加一些逻辑流程控制。而某些命令会根据条件判断执行相应的命令，这样的命令通常叫做**结构化命令**。从概念上理解，结构化命令是shell脚本的逻辑结构，不像顺序执行shell脚本，而是有组织地执行命令以应对复杂任务需求。\n\n### if-then语句\n\n最基本的结构化命令是if-then语句，它的格式如下：\n\n```shell\nif command\nthen\n\tcommands\nfi\n```\n\n**注意**，在其他编程语言中，`if`语句之后的对象是一个等式，等式的结果为`TRUE`或者`FALSE`，但是bash shell中的`if`语句是运行`if`后面的命令，如果该命令的退出状态码是0（命令成功执行），则运行`then`语句后面的命令。`fi`表示`if`语句到此结束。\n\n下面是一个简单的例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test1.sh\n#! /bin/bash\n# testing the if statement\nif pwd\nthen\n    echo \"It worked\"\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test1.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test1.sh\n/home/wsx/script_learn\nIt worked\n```\n\n这个例子中在判断成功执行`pwd`命令后，执行输出文本字符串。\n\n大家可以尝试把`pwd`命令改成随便乱打的字符试试结果。它会显示报错信息，`then`后面的语句也不会执行。\n\nif-then语句的另一种形式：\n\n```shell\nif command; then\ncommands\nfi\n```\n\n在then部分，我们可以使用多个命令（从格式中command结尾有没有s也可以看出）。\n\n我们再来一个例子：在`if`语句中用`grep`命令在`/etc/passwd`文件中查找某个用户名当前是否在系统上使用。如果有用户使用了哪个登录名，脚本会显示一些文本信息并列出该用户HOME目录的bash文件。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test3.sh\n#!/bin/bash\n# testing multiple commands in the then section\n#\ntestuser=wsx\n#\nif grep $testuser /etc/passwd\nthen\n  echo \"This is my first command\"\n  echo \"This is my second command\"\n  echo \"I can even put in other commands besides echo:\"\n  ls -a /home/$testuser/.b*\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test3.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test3.sh\nwsx:x:1000:1000:wsx,,,:/home/wsx:/bin/bash\nThis is my first command\nThis is my second command\nI can even put in other commands besides echo:\n/home/wsx/.bash_history  /home/wsx/.bashrc\n/home/wsx/.bash_logout\t /home/wsx/.bashrc-anaconda3.bak\n\n```\n\n如果设置的用户名不存在，那么就没有输出。那么如果在这里显示的一些消息可以说明用户名在系统中未找到，这样可能就会显得更友好。所以接下来看看`if-then-else`语句。\n\n### if-then-else语句\n\n我相信意思非常容易理解，这里较之前我们添加了一个`else`块来处理`if`中命令没有成功执行的步骤。格式为：\n\n```shell\nif command\nthen\n  commands\nelse commands\nfi\n```\n\n### 嵌套if\n\n有时我们需要检查脚本代码中的多种条件，可以是用嵌套的`if-then`语句。\n\n处理一个例子：检查`/etc/passwd`文件中是否存在某个用户名以及该用户名的目录是否存在。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test5.sh\n#!/bin/bash\n\n# Testing nested ifs\n#\ntestuser=NoSuchUser\n#\nif grep $testuser /etc/passwd\nthen\n  echo \"The user $testuser exits on this system.\"\nelse\n  echo \"The user $testuser does not exit on this system.\"\n  if ls -d /home/$testuser/\n  then\n     echo \"However, $testuser has a directory.\"\n  fi\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test5.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test5.sh\nThe user NoSuchUser does not exit on this system.\nls: 无法访问'/home/NoSuchUser/': 没有那个文件或目录\n```\n\n可以使用`else`部分的另一种形式:`elif`。这样我们就不再用书写多个`if-then`语句了。在其他语言中，有的是用`elif`的形式，有的使用`else if`等形式。面对相同内含在不同语言中不同的表示方式，我们需要有意识地区别，以免接触的东西多了可能各种语言代码串写喔。\n\n```shell\nif command1\nthen\n\tcommands\nelif command2\nthen\n\tmore commands\nfi\n```\n\n这种表示方式逻辑更为清晰，但是也有点容易让写的人搞混。其实可以看到一个`if`对应一个`fi`。这是一个大的嵌套`if`结构。\n\n**记住**，在`elif`语句中，紧跟其后的`else`语句属于`elif`代码块，而不是属于`if-then`代码块。\n\n### test命令\n\n到此为止，我们很清楚`if`后面跟着的是普通的shell命令，那么我们需要测试其他条件怎么办呢？\n\n`test`命令提供了在`if-then`语句中测试不同条件的途径。如果`test`命令中列出的条件成立，`test`命令就会退出并返回状态码0。这样`if-then`语句就与其他编程语言中的`if-then`语句以类似的方式工作了。\n\ntest命令格式：\n\n```\ntest condition\n```\n\n`condition`是`test`命令要测试的一系列参数和值。如果不写这个`condition`，`test`返回非0，`if`语句跳转到`else`进行执行。\n\nbash shell提供了一种条件测试方法，无需在`if-then`语句中声明`test`命令。\n\n```shell\nif [ condition ]\nthen commands\nfi\n```\n\n这跟我们其他的编程习惯非常接近。建议使用这种方式。\n\n如果使用`test`命令，需要记住的是各种条件参数。\n\n**数值比较**\n\n| 比较        | 描述         |\n| --------- | ---------- |\n| n1 -eq n2 | (n1)等于(n2) |\n| n1 -ge n2 | 大于或等于      |\n| n1 -gt n2 | 大于         |\n| n1 -le n2 | 小于或等于      |\n| n1 -lt n2 | 小于         |\n| n1 -ne n2 | 不等于        |\n\n**字符串比较**\n\n| 比较           | 描述               |\n| ------------ | ---------------- |\n| str1 = str2  | （str1与str2比较）相同  |\n| str1 != str2 | 不同               |\n| str1 < str2  | 小                |\n| str1 > str2  | 大                |\n| -n str1      | 检查string1的长度非0   |\n| -z str1      | 检查string1的长度是否为0 |\n\n注意，大于和小于号必须转义；大于和小于顺序和sort命令所采用的不同。\n\n**文件比较**\n\n| 比较              | 描述                |\n| --------------- | ----------------- |\n| -d file         | 检查file是否存在并是一个目录  |\n| -e file         | ～是否存在             |\n| -f file         | ～是否存在并是一个文件       |\n| -r file         | ～是否存在并可读          |\n| -s file         | ～是否存在并非空          |\n| -w file         | ～是否存在并可写          |\n|                 |                   |\n| -x file         | ～是否存在并可执行         |\n| -O file         | ～是否存在并属当前用户所有     |\n| -G file         | ～是否存在并且默认组与当前用户相同 |\n| file1 -nt file2 | 检查file1是否比file2新  |\n| file1 -ot file2 | 检查file1是否比file2旧  |\n\n### 复合条件测试\n\n`if-then`语句允许我们使用布尔逻辑来组合测试。可用\n\n- [ condition1] && [ condition2]\n- `[ condition1] || [ condition2]`\n\n### if-then的高级特性\n\n- 用于数学表达式的双括号\n- 用于高级字符串处理功能的双方括号\n\n**双括号**\n\n命令格式：\n\n```\n(( expresiion ))\n```\n\n`expression`可以是任意的数学赋值或比较表达式。除了`test`命令使用的标准数学运算符，下面列出了一些其他的：\n\n| 符号     | 描述   |\n| ------ | ---- |\n| val ++ | 后增   |\n| val -- | 后减   |\n| ++ val | 先增   |\n| -- val | 先减   |\n| !      | 逻辑取反 |\n| ~      | 位求反  |\n| **     | 幂运算  |\n| <<     | 左位移  |\n| >>     | 右位移  |\n| &      | 位布尔和 |\n| \\|     | 位布尔或 |\n| &&     | 逻辑和  |\n| \\|\\|   | 逻辑或  |\n\n看一个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test23.sh\n#!/bin/bash\n# using doble parenthesis\n#\nval1=10\n#\nif (( $val1 ** 2 > 90 ))\nthen\n  (( val2 = $val1 ** 2 ))\n  echo \"The square of $val1 is $val2\"\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test23.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test23.sh\nThe square of 10 is 100\n\n```\n\n**双方括号**\n\n双方括号命令提供了针对字符串比较的高级特性。命令格式如下：\n\n```\n[[ expression ]]\n```\n\n双方括号里的`expression`使用了`test`命令中采用的标准字符串比较。但它提供了`test`没有提供的一个特性——模式匹配。\n\n在模式匹配中，可以定义一个正则表达式来匹配字符串值。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test24.sh\n#! /bin/bash\n# using pattern matching\n#\nif [[ $USER == r* ]]\nthen\n  echo \"Hello $USER\"\nelse\n  echo \"Sorry, I do not know you\"\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test24.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test24.sh\nSorry, I do not know you\n```\n\n上面一个脚本中，我们使用了双等号。双等号将右边的字符串视为一个模式，并将其应用模式匹配规则。\n\n### case命令\n\n有了`case`命令，就不需要写出所有的`elif`语句来不停地检查同一个变量的值了。`case`命令会采用列表格式来检查单个变量的多值。\n\n下面是两个脚本实现相同功能进行对比：\n\nif语句：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test25.sh\n#!/bin/bash\n# looking for a possible value\n#\nif [ $USER = \"rich\" ]\nthen\n  echo \"Welcome $USER\"\n  echo \"Please enjoy you visit\"\nelif [ $USER = \"barbara\" ]\nthen\n  echo \"Welcome $USER\"\n  echo \"Please enjoy you visit\"\nelif [ $USER = \"testing\" ]\nthen\n  echo \"Special testing account\"\nelif [ $USER = \"jessica\" ]\nthen\n  echo \"Do not forget to logout when you're done\"\n```\n\ncase语句：\n\n```\ncase variable in\npattern1 | pattern2) commands1;;\npattern3) commands2;;\n*) default commands;;\nesac\n```\n\n上面的实例可以用`case`语句表示为：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test26.sh\n#!/bin/bash\n# using the case command\n#\ncase $USER in\nrich | barbara)\n  echo \"Welcome, $USER\"\n  echo \"Please enjoy your visits\";;\ntesting)\n  echo \"Special testing account\";;\njessica)\n  echo \"Do not forget to log off whe you're done\";;\n*)\n  echo \"Sorry, you are not allowed here\";;\nesac\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test26.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test26.sh\nSorry, you are not allowed here\n\n```\n\n`case`命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式。星号会捕获所有与已知模式不匹配的值。注意双分号的使用。\n\n### 小结\n\n> 最基本的命令是`if-then`语句；\n>\n> 可以拓展`if-then`语句为`if-then-else`语句；\n>\n> 可以将`if-then-else`语句通过`elif`语句连接起来；\n>\n> 在脚本中，我们需要测试一种条件而不是命令时，比如数值、字符串内容、文件或目录的状态，`test`命令提供了简单方法；\n>\n> 方括号是`test`命令统一的特殊bash命令；\n>\n> 双括号使用另一种操作符进行高级数学运算双方括号允许高级字符串模式匹配运算；\n>\n> `case`命令是执行多个`if-then-else`命令的简便方式，它会参照一个值列表来检查单个变量的值。\n\n关于结构化命令中循环，将在下次整理的笔记中阐述。\n\n\n\n## 循环控制\n\n\n\n> **内容**\n>\n> - for循环语句\n> - until迭代语句使用while语句\n> - 循环\n> - 重定向循环的输出\n\n这一节我们来了解如何重复一些过程和命令，也就是循环执行一组命令直到达到了某个特定条件。\n\n### for命令\n\n基本格式：\n\n```shell\nfor var in list\ndo\n\tcommands\ndone\n```\n\n也可以\n\n```shell\nfor var in list; do\n```\n\n分号只用来分隔命令的，让代码更简约。\n\n来个简单例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test1\n#!/bin/bash\n# basic for command\n\nfor test in Alabama Alaska Arizona Arkansas California Colorado\ndo\n    echo The next state is $test\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ ./test1\nThe next state is Alabama\nThe next state is Alaska\nThe next state is Arizona\nThe next state is Arkansas\nThe next state is California\nThe next state is Colorado\n```\n\n这里操作基本和其他语言一致（格式不同），不多讲啦。\n\n**在读取列表中的复杂值时**，我们可能会遇到问题。比如下面这个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat badtest1\n#!/bin/bash\n# another example of how not to use the for command\n\nfor test in I don't know if this'll work\ndo\n    echo \"word:$test\"\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ ./badtest1\nword:I\nword:dont know if thisll\nword:work\n```\n\n我们可以看到shell看到了列表值中的单引号尝试使用它们来定义一个单独的数据值。\n\n这里有两种解决办法：\n\n- 使用转义字符将单引号转义\n- 使用双引号来定义用到单引号的值\n\n我们将这两种解决办法同时用到上个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test2\n#! /bin/bash\n# another example of how not to use the for command\n\nfor test in I don\\'t know if \"this'll\" work; do\necho  \"word:$test\"\ndone\nwsx@wsx-ubuntu:~/script_learn$ ./test2\nword:I\nword:don't\nword:know\nword:if\nword:this'll\nword:work\n```\n\n我们可能明白了`for`循环是假定每个值是用空格分隔的，所以当有包含空格的数据时，我们需要用双引号括起来。\n\n**通常我们会将列表值存储在一个变量中**，然后通过遍历变量的方式遍历了其内容的的列表。\n\n看看怎么完成这个任务：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test3\n#!/bin/bash\n\n# using a variable to hold the list\nlist=\"Alabama Alaska Arizona Arkansas Colorado\"\nlist=$list\" Connecticut\" # 在尾部拼接文本\n\nfor state in $list; do\n  echo \"Have you ever visited $state?\"\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ ./test3\nHave you ever visited Alabama?\nHave you ever visited Alaska?\nHave you ever visited Arizona?\nHave you ever visited Arkansas?\nHave you ever visited Colorado?\nHave you ever visited Connecticut?\n```\n\n注意，代码中还用了另一个赋值语句向`$list`变量包含的已有列表中添加了一个值。这是在已有文本字符串尾部添加文本的一种常用方法。\n\n我们还可以**用命令来输出我们需要的列表内容**：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test4\n#!/bin/bash\n# reading values from a file\n\nfile=\"states\"\n\nfor state in $(cat $file)\ndo\n    echo \"Visit beautiful $state\"\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ cat states\nAlabama\nAlaska\nArizona\nArkansas\nColorado\nConnecticut\nDelaware\nFlorida\nGeorgia\nwsx@wsx-ubuntu:~/script_learn$ ./test4\nVisit beautiful Alabama\nVisit beautiful Alaska\nVisit beautiful Arizona\nVisit beautiful Arkansas\nVisit beautiful Colorado\nVisit beautiful Connecticut\nVisit beautiful Delaware\nVisit beautiful Florida\nVisit beautiful Georgia\n```\n\n\n\n**更改字段分隔符**\n\n环境变量`IFS`，也叫作字段分隔符。它定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将**空格、制表符和换行符**当作字段分隔符。\n\n如果想修改`IFS`的值，比如使其只能识别换行符，我们可以将下面这行代码加入脚本：\n\n```shell\nIFS=$'\\n'\n```\n\n在处理大量脚本时，我们可能只在某一部分使用其他的分隔符，这时候可以先保存原有的`IFS`值，然后修改，最后恢复：\n\n```shell\nIFS.OLD=$IFS\nIFS=$'\\n'\n<在代码中使用新的IFS值>\nIFS=$IFS.OLD\n```\n\n假如我们要遍历一个文件中用冒号分隔的值：\n\n```shell\nIFS=:\n```\n\n假如要指定多个`IFS`字符，只要将它们的赋值行串起来：\n\n```shell\nIFS=$'\\n':;\"\n```\n\n这个赋值会将换行符、冒号、分号以及双引号作为字段分隔符。\n\n\n\n**用通配符读取目录**\n\n我们可以用`for`命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用**文件扩展匹配**。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。\n\n我拿我的一个目录来尝试一下：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test5\n#!/bin/bash\n\n# iterate through all the files in a directory\n\nfor file in /home/wsx/python_learn/*\ndo\n  if [ -d \"$file\" ]\n  then\n    echo \"$file is a directory\"\n  elif [ -f \"$file\" ]\n  then\n    echo \"$file is a file\"\n  fi\ndone\nwsx@wsx-ubuntu:~/script_learn$ ./test5\n/home/wsx/python_learn/athletelist.py is a file\n/home/wsx/python_learn/athletemodel.py is a file\n/home/wsx/python_learn/ch2_data_input.py is a file\n/home/wsx/python_learn/chapter5_first.py is a file\n/home/wsx/python_learn/chapter6_first.py is a file\n/home/wsx/python_learn/chapter6_second.py is a file\n/home/wsx/python_learn/chapter6_third.py is a file\n/home/wsx/python_learn/coinFlips.py is a file\n/home/wsx/python_learn/Dive_into_python is a directory\n```\n\n**注意：**第一个方括号之后和第二个方括号之前必须加上一个空格，否则会报错。\n\n在Linux中，目录名和文件名中包含空格是合法的，所以将`$file`变量用双引号圈起来。当然，大家尽量不要让文件或目录包含空格，不然很容易出问题（命令会把空格当做文件的分隔符）。\n\n### C语言风格的for命令\n\nC语言风格的`for`命令看起来如下：\n\n```shell\nfor (( a = 1; a < 10; a++ ))\n```\n\n值得注意的是，这里有些部分没有遵循bash shell标准的`for`命令：\n\n- 变量赋值可以有空格；\n- 条件中的变量不以美元符开头；\n- 迭代过程的算式未用`expr`命令格式。\n\n在使用这种格式时要小心，不同的格式不注意就会出错。\n\n下面举个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test6\n#!/bin/bash\n\n# testing the C-style for loop\n\nfor (( i=1; i <= 10; i++ ))\ndo\n  echo \"The next number is $i\"\ndone\n\nwsx@wsx-ubuntu:~/script_learn$ ./test6\nThe next number is 1\nThe next number is 2\nThe next number is 3\nThe next number is 4\nThe next number is 5\nThe next number is 6\nThe next number is 7\nThe next number is 8\nThe next number is 9\nThe next number is 10\n```\n\n\n\n### while命令\n`while`命令的格式为：\n```shell\nwhile test command\ndo\n  other commands\ndone\n```\n\n`while`命令某种意义上是`if-then`语句和`for`循环的混杂体。注意，这里`while`后面接的也是命令。`while`命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码是0（类似一般语言中 的TRUE）。直到非0时退出循环。\n\n`while`命令中定义的`test command`和`if-then`语句中的格式一模一样。可以使用任何普通的bash shell命令，或者用`test`命令进行条件测试，比如测试变量值。\n\n最常见的用法是用方括号来检查循环命令中用到的`shell`变量的值。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test\n#/bin/bash\n# while command test\n\nvar1=10\nwhile [ $var1 -gt 0 ]\ndo\n        echo $var1\n        var1=$[ $var1 - 1 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n```\n\n**使用多个测试命令**\n`while`命令允许我们在`while`语句行中定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。\n比如` while echo $var1 [ $var1 -ge 0 ] `检测的就是后面方括号命令的退出状态码。\n\n### until命令\n`until`命令和`while`命令工作的方式完全相反。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。\n\n```{shell}\nuntil test command\ndo\n  other commands\ndone\n```\n一个例子：\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test12\n#!/bin/bash\n# using the until command\n\nvar1=100\n\nuntil [ $var1 -eq 0 ]\ndo\n        echo $var1\n        var1=$[ $var1 - 25 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test12\n100\n75\n50\n25\n```\n同样地，在`until`命令中放入多个测试命令时也要注意（类似`while`）。\n\n### 嵌套循环\n\n在循环语句内使用任意类型的命令，包括其他循环命令，叫做嵌套循环。因为是在迭代中迭代，需要注意变量的使用以及程序的效率问题。\n\n下面举一个`for`循环嵌套`for`循环的例子：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test14\n#!/bin/bash\n# nesting for loops\n\nfor (( a = 1; a <= 3; a++ ))\ndo\n        echo \"Starting loop $a:\"\n        for (( b = 1; b <= 3; b++ ))\n        do\n                echo \"    Inside loop: $b\"\n        done\ndone\n\nwangsx@SC-201708020022:~/tmp$ . test14\nStarting loop 1:\n    Inside loop: 1\n    Inside loop: 2\n    Inside loop: 3\nStarting loop 2:\n    Inside loop: 1\n    Inside loop: 2\n    Inside loop: 3\nStarting loop 3:\n    Inside loop: 1\n    Inside loop: 2\n    Inside loop: 3\n```\n\nshell能够自动识别匹配的`do`和`done`字符。这种模式很常见，比如通常的小括号（`(`与`)`）、中括号、花括号匹配等等。它们的本质都是字符匹配。\n\n在混用循环命令时也一样，比如在`while`循环中内嵌一个`for`循环：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test15\n#!/bin/bash\n# placing a for loop inside a while loop\n\nvar1=5\n\nwhile [ $var1 -ge 0 ]\ndo\n        echo \"Outer loop: $var1\"\n        for (( var2 = 1; $var2 < 3; var2++))\n        do\n                var3=$[ $var1 * $var2 ]\n                echo \"  Inner loop: $var1 * $var2 = $var3\"\n        done\n        var1=$[ $var1 - 1 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ . test15\nOuter loop: 5\n  Inner loop: 5 * 1 = 5\n  Inner loop: 5 * 2 = 10\nOuter loop: 4\n  Inner loop: 4 * 1 = 4\n  Inner loop: 4 * 2 = 8\nOuter loop: 3\n  Inner loop: 3 * 1 = 3\n  Inner loop: 3 * 2 = 6\nOuter loop: 2\n  Inner loop: 2 * 1 = 2\n  Inner loop: 2 * 2 = 4\nOuter loop: 1\n  Inner loop: 1 * 1 = 1\n  Inner loop: 1 * 2 = 2\nOuter loop: 0\n  Inner loop: 0 * 1 = 0\n  Inner loop: 0 * 2 = 0\n```\n\n如果想要挑战脑力，可以混用`until`和`while`循环。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test16\n#!/bin/bash\n# using until and while loop\n\nvar1=3\n\nuntil [ $var1 -eq 0 ]\ndo\n        echo \"Outer loop: $var1\"\n        var2=1\n        while [ $var2 -lt 5 ]\n        do\n                var3=$(echo \"scale=4; $var1 / $var2\" | bc)\n                echo \"  Inner loop: $var1 / $var2 = $var3\"\n                var2=$[ $var2 + 1 ]\n        done\n        var1=$[ $var1 - 1 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ . test16\nOuter loop: 3\n  Inner loop: 3 / 1 = 3.0000\n  Inner loop: 3 / 2 = 1.5000\n  Inner loop: 3 / 3 = 1.0000\n  Inner loop: 3 / 4 = .7500\nOuter loop: 2\n  Inner loop: 2 / 1 = 2.0000\n  Inner loop: 2 / 2 = 1.0000\n  Inner loop: 2 / 3 = .6666\n  Inner loop: 2 / 4 = .5000\nOuter loop: 1\n  Inner loop: 1 / 1 = 1.0000\n  Inner loop: 1 / 2 = .5000\n  Inner loop: 1 / 3 = .3333\n  Inner loop: 1 / 4 = .2500\n```\n\n外部的`until`循环以值3开始，并继续执行到值等于0。内部`while`循环以值1开始一直执行，只要值小于5。需要注意循环条件的设置，我跑的几次都没写完整，然后无限循环只好重开终端。\n\n### 控制循环\n\n之前的学的命令已经可以让我们写循环程序了，设定好以后等待命令开始执行和等待循环结束。但是很多情况下，在循环中我们设定的某个（多个）变量达到某种条件时，我们就想要停止循环，然后运行循环下面的命令。这时候我们需要用到`break`和`continue`命令来帮我们控制住循环。\n\n这两个命令在其他语言中基本都时关键字，特别是`C`，用法差不多。我也就不具体介绍了，只点出它们的功能。\n\n**break**\n\n> 在shell执行break命令时，它会尝试跳出当前正在执行的循环。\n>\n> 在处理多个循环时，break命令会自动终止你所在的最内层循环。\n>\n> break命令接受单个命令行参数值：\n>\n> ​\tbreak n\n>\n> ​\t其中n制订了要跳出的循环层级（层数）\n\n**continue**\n\n>continue命令可以提前终止某次循环的命令，但并不会完全终止整个循环。可以在循环内部设置shell不执行命令的条件。\n>\n>也就是说使用continue命令时，它会自动跳过本次循环中接下来的运行步骤，跳转到下一次循环。但注意不是跳出，跳出时break的功能。\n>\n>同样的可以使用continue n         n制定要继续执行哪一级循环\n\n\n\n### 处理循环的输出\n\n在shell脚本中，我们可以对循环的输出使用管道或进行重定向。这是通过在`done`命令之后添加一个处理命令来实现的。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test\n#!/bin/bash\nfor file in /home/*\ndo\n        if [ -d \"$file\" ]\n        then\n                echo \"$file is a directory\"\n        else\n                echo \"$file is a file\"\n        fi\ndone > output.txt\nwangsx@SC-201708020022:~/tmp$ cat output.txt\n/home/wangsx is a directory\n```\n\nshell将`for`命令的结果重定向到文件`output.txt`中，而不是显示在屏幕上。\n\n\n\n### 实例\n\n下面两个例子演示如何用简单循环来处理数据。\n\n**查找可执行文件**\n\nLinux运行程序时通过环境变量`$PATH`提供的目录搜索可执行文件。如果徒手找的话，比较费时间，我们可以写个脚本来搞定它。\n\n```shell\nwangsx@SC-201708020022:~$ cat test25\n#!/bin/bash\n# finding files in the PATH\n\nIFS=:\nfor folder in $PATH\ndo\n        echo \"$folder:\"\n        for file in $folder/*\n        do\n                if [ -x $file ]\n                then\n                        echo \"  $file\"\n                fi\n        done\ndone\n\n# 输出结果太多，我就不拷贝结果了\n```\n\n先设定`IFS`分隔符以便于能正确分隔目录，然后将目录存放在`$folder`中，用`for`循环来迭代特定的目录中所有文件，然后用`if-then`命令检查文件的可执行权限。\n\nLinux有一个`tree`工具，非常方便输出目录结构，推荐使用下。\n\n\n\n**创建多个用户账号**\n\n如果你是管理员，需要创建大量账号时。不必每次都有`useradd`命令添加用户。将用户信息存放在指定文件，然后用脚本进行处理就可以了。\n\n用户信息的格式如下：\n\n```\nuserid, user name\n```\n\n第一个是你为用户选择的id，第二个是用户的全名。这是`csv`文件格式。\n\n为了能够读取它，我们使用以下命令：\n\n```shell\nwhile IFS=',' read -r userid name\n```\n\n`read`命令会自动获取`.csv`文本文件的下一行内容，所以不用再写一个循环来处理。当`read`命令返回`FALSE`时（也就是读完了），`while`命令就会退出。\n\n为了把数据从文件导向`while`命令，只要再`while`命令尾部加一个重定向符号。\n\n处理过程写成脚本如下：\n\n```shell\n#!/bin/bash\n# process new user accounts\n\ninput=\"users.csv\"\nwhile IFS=',', read -r userid name\ndo\n\techo \"adding $userid\"\n\tuseradd -c \"$name\" -m $userid\ndone < \"$input\"\n```\n","slug":"structural-command-of-shell","published":1,"updated":"2018-01-27T04:08:05.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwtk00009taxuz8xf5q2","content":"<a id=\"more\"></a>\n<h2 id=\"条件控制\"><a href=\"#条件控制\" class=\"headerlink\" title=\"条件控制\"></a>条件控制</h2><blockquote>\n<p><strong>内容</strong></p>\n<ul>\n<li>使用if-then语句</li>\n<li>嵌套if语句</li>\n<li>test命令</li>\n<li>复合条件测试</li>\n<li>使用双方括号和双括号</li>\n<li>case命令</li>\n</ul>\n</blockquote>\n<p>许多程序要求对shell脚本中的命令施加一些逻辑流程控制。而某些命令会根据条件判断执行相应的命令，这样的命令通常叫做<strong>结构化命令</strong>。从概念上理解，结构化命令是shell脚本的逻辑结构，不像顺序执行shell脚本，而是有组织地执行命令以应对复杂任务需求。</p>\n<h3 id=\"if-then语句\"><a href=\"#if-then语句\" class=\"headerlink\" title=\"if-then语句\"></a>if-then语句</h3><p>最基本的结构化命令是if-then语句，它的格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if command</span><br><span class=\"line\">then</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>，在其他编程语言中，<code>if</code>语句之后的对象是一个等式，等式的结果为<code>TRUE</code>或者<code>FALSE</code>，但是bash shell中的<code>if</code>语句是运行<code>if</code>后面的命令，如果该命令的退出状态码是0（命令成功执行），则运行<code>then</code>语句后面的命令。<code>fi</code>表示<code>if</code>语句到此结束。</p>\n<p>下面是一个简单的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1.sh</span><br><span class=\"line\"><span class=\"meta\">#</span>! /bin/bash</span><br><span class=\"line\"><span class=\"meta\">#</span> testing the if statement</span><br><span class=\"line\">if pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">    echo \"It worked\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test1.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1.sh</span><br><span class=\"line\">/home/wsx/script_learn</span><br><span class=\"line\">It worked</span><br></pre></td></tr></table></figure>\n<p>这个例子中在判断成功执行<code>pwd</code>命令后，执行输出文本字符串。</p>\n<p>大家可以尝试把<code>pwd</code>命令改成随便乱打的字符试试结果。它会显示报错信息，<code>then</code>后面的语句也不会执行。</p>\n<p>if-then语句的另一种形式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if command; then</span><br><span class=\"line\">commands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>在then部分，我们可以使用多个命令（从格式中command结尾有没有s也可以看出）。</p>\n<p>我们再来一个例子：在<code>if</code>语句中用<code>grep</code>命令在<code>/etc/passwd</code>文件中查找某个用户名当前是否在系统上使用。如果有用户使用了哪个登录名，脚本会显示一些文本信息并列出该用户HOME目录的bash文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test3.sh</span><br><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\"><span class=\"meta\">#</span> testing multiple commands in the then section</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">testuser=wsx</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">if grep $testuser /etc/passwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"This is my first command\"</span><br><span class=\"line\">  echo \"This is my second command\"</span><br><span class=\"line\">  echo \"I can even put in other commands besides echo:\"</span><br><span class=\"line\">  ls -a /home/$testuser/.b*</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test3.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3.sh</span><br><span class=\"line\">wsx:x:1000:1000:wsx,,,:/home/wsx:/bin/bash</span><br><span class=\"line\">This is my first command</span><br><span class=\"line\">This is my second command</span><br><span class=\"line\">I can even put in other commands besides echo:</span><br><span class=\"line\">/home/wsx/.bash_history  /home/wsx/.bashrc</span><br><span class=\"line\">/home/wsx/.bash_logout\t /home/wsx/.bashrc-anaconda3.bak</span><br></pre></td></tr></table></figure>\n<p>如果设置的用户名不存在，那么就没有输出。那么如果在这里显示的一些消息可以说明用户名在系统中未找到，这样可能就会显得更友好。所以接下来看看<code>if-then-else</code>语句。</p>\n<h3 id=\"if-then-else语句\"><a href=\"#if-then-else语句\" class=\"headerlink\" title=\"if-then-else语句\"></a>if-then-else语句</h3><p>我相信意思非常容易理解，这里较之前我们添加了一个<code>else</code>块来处理<code>if</code>中命令没有成功执行的步骤。格式为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if command</span><br><span class=\"line\">then</span><br><span class=\"line\">  commands</span><br><span class=\"line\">else commands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套if\"><a href=\"#嵌套if\" class=\"headerlink\" title=\"嵌套if\"></a>嵌套if</h3><p>有时我们需要检查脚本代码中的多种条件，可以是用嵌套的<code>if-then</code>语句。</p>\n<p>处理一个例子：检查<code>/etc/passwd</code>文件中是否存在某个用户名以及该用户名的目录是否存在。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test5.sh</span><br><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> Testing nested ifs</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">testuser=NoSuchUser</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">if grep $testuser /etc/passwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"The user $testuser exits on this system.\"</span><br><span class=\"line\">else</span><br><span class=\"line\">  echo \"The user $testuser does not exit on this system.\"</span><br><span class=\"line\">  if ls -d /home/$testuser/</span><br><span class=\"line\">  then</span><br><span class=\"line\">     echo \"However, $testuser has a directory.\"</span><br><span class=\"line\">  fi</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test5.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test5.sh</span><br><span class=\"line\">The user NoSuchUser does not exit on this system.</span><br><span class=\"line\">ls: 无法访问'/home/NoSuchUser/': 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n<p>可以使用<code>else</code>部分的另一种形式:<code>elif</code>。这样我们就不再用书写多个<code>if-then</code>语句了。在其他语言中，有的是用<code>elif</code>的形式，有的使用<code>else if</code>等形式。面对相同内含在不同语言中不同的表示方式，我们需要有意识地区别，以免接触的东西多了可能各种语言代码串写喔。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if command1</span><br><span class=\"line\">then</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">elif command2</span><br><span class=\"line\">then</span><br><span class=\"line\">truemore commands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>这种表示方式逻辑更为清晰，但是也有点容易让写的人搞混。其实可以看到一个<code>if</code>对应一个<code>fi</code>。这是一个大的嵌套<code>if</code>结构。</p>\n<p><strong>记住</strong>，在<code>elif</code>语句中，紧跟其后的<code>else</code>语句属于<code>elif</code>代码块，而不是属于<code>if-then</code>代码块。</p>\n<h3 id=\"test命令\"><a href=\"#test命令\" class=\"headerlink\" title=\"test命令\"></a>test命令</h3><p>到此为止，我们很清楚<code>if</code>后面跟着的是普通的shell命令，那么我们需要测试其他条件怎么办呢？</p>\n<p><code>test</code>命令提供了在<code>if-then</code>语句中测试不同条件的途径。如果<code>test</code>命令中列出的条件成立，<code>test</code>命令就会退出并返回状态码0。这样<code>if-then</code>语句就与其他编程语言中的<code>if-then</code>语句以类似的方式工作了。</p>\n<p>test命令格式：</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">test </span>condition</span><br></pre></td></tr></table></figure>\n<p><code>condition</code>是<code>test</code>命令要测试的一系列参数和值。如果不写这个<code>condition</code>，<code>test</code>返回非0，<code>if</code>语句跳转到<code>else</code>进行执行。</p>\n<p>bash shell提供了一种条件测试方法，无需在<code>if-then</code>语句中声明<code>test</code>命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if [ condition ]</span><br><span class=\"line\">then commands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>这跟我们其他的编程习惯非常接近。建议使用这种方式。</p>\n<p>如果使用<code>test</code>命令，需要记住的是各种条件参数。</p>\n<p><strong>数值比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>n1 -eq n2</td>\n<td>(n1)等于(n2)</td>\n</tr>\n<tr>\n<td>n1 -ge n2</td>\n<td>大于或等于</td>\n</tr>\n<tr>\n<td>n1 -gt n2</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>n1 -le n2</td>\n<td>小于或等于</td>\n</tr>\n<tr>\n<td>n1 -lt n2</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>n1 -ne n2</td>\n<td>不等于</td>\n</tr>\n</tbody>\n</table>\n<p><strong>字符串比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>str1 = str2</td>\n<td>（str1与str2比较）相同</td>\n</tr>\n<tr>\n<td>str1 != str2</td>\n<td>不同</td>\n</tr>\n<tr>\n<td>str1 &lt; str2</td>\n<td>小</td>\n</tr>\n<tr>\n<td>str1 &gt; str2</td>\n<td>大</td>\n</tr>\n<tr>\n<td>-n str1</td>\n<td>检查string1的长度非0</td>\n</tr>\n<tr>\n<td>-z str1</td>\n<td>检查string1的长度是否为0</td>\n</tr>\n</tbody>\n</table>\n<p>注意，大于和小于号必须转义；大于和小于顺序和sort命令所采用的不同。</p>\n<p><strong>文件比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d file</td>\n<td>检查file是否存在并是一个目录</td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>～是否存在</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>～是否存在并是一个文件</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>～是否存在并可读</td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>～是否存在并非空</td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>～是否存在并可写</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>～是否存在并可执行</td>\n</tr>\n<tr>\n<td>-O file</td>\n<td>～是否存在并属当前用户所有</td>\n</tr>\n<tr>\n<td>-G file</td>\n<td>～是否存在并且默认组与当前用户相同</td>\n</tr>\n<tr>\n<td>file1 -nt file2</td>\n<td>检查file1是否比file2新</td>\n</tr>\n<tr>\n<td>file1 -ot file2</td>\n<td>检查file1是否比file2旧</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"复合条件测试\"><a href=\"#复合条件测试\" class=\"headerlink\" title=\"复合条件测试\"></a>复合条件测试</h3><p><code>if-then</code>语句允许我们使用布尔逻辑来组合测试。可用</p>\n<ul>\n<li>[ condition1] &amp;&amp; [ condition2]</li>\n<li><code>[ condition1] || [ condition2]</code></li>\n</ul>\n<h3 id=\"if-then的高级特性\"><a href=\"#if-then的高级特性\" class=\"headerlink\" title=\"if-then的高级特性\"></a>if-then的高级特性</h3><ul>\n<li>用于数学表达式的双括号</li>\n<li>用于高级字符串处理功能的双方括号</li>\n</ul>\n<p><strong>双括号</strong></p>\n<p>命令格式：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(( <span class=\"name\">expresiion</span> ))</span><br></pre></td></tr></table></figure>\n<p><code>expression</code>可以是任意的数学赋值或比较表达式。除了<code>test</code>命令使用的标准数学运算符，下面列出了一些其他的：</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>val ++</td>\n<td>后增</td>\n</tr>\n<tr>\n<td>val –</td>\n<td>后减</td>\n</tr>\n<tr>\n<td>++ val</td>\n<td>先增</td>\n</tr>\n<tr>\n<td>– val</td>\n<td>先减</td>\n</tr>\n<tr>\n<td>!</td>\n<td>逻辑取反</td>\n</tr>\n<tr>\n<td>~</td>\n<td>位求反</td>\n</tr>\n<tr>\n<td>**</td>\n<td>幂运算</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>左位移</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>右位移</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>位布尔和</td>\n</tr>\n<tr>\n<td>\\</td>\n<td></td>\n<td>位布尔或</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑和</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>\\</td>\n<td></td>\n<td>逻辑或</td>\n</tr>\n</tbody>\n</table>\n<p>看一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test23.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using doble parenthesis</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">val1=10</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if (( $val1 ** 2 &gt; 90 ))</span><br><span class=\"line\">then</span><br><span class=\"line\">  (( val2 = $val1 ** 2 ))</span><br><span class=\"line\">  echo \"The square of $val1 is $val2\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test23.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test23.sh</span><br><span class=\"line\">The square of 10 is 100</span><br></pre></td></tr></table></figure>\n<p><strong>双方括号</strong></p>\n<p>双方括号命令提供了针对字符串比较的高级特性。命令格式如下：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">[[ expression ]]</span></span><br></pre></td></tr></table></figure>\n<p>双方括号里的<code>expression</code>使用了<code>test</code>命令中采用的标准字符串比较。但它提供了<code>test</code>没有提供的一个特性——模式匹配。</p>\n<p>在模式匹配中，可以定义一个正则表达式来匹配字符串值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test24.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using pattern matching</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [[ $USER == r* ]]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Hello $USER\"</span><br><span class=\"line\">else</span><br><span class=\"line\">  echo \"Sorry, I do not know you\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test24.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test24.sh</span><br><span class=\"line\">Sorry, I do not know you</span><br></pre></td></tr></table></figure>\n<p>上面一个脚本中，我们使用了双等号。双等号将右边的字符串视为一个模式，并将其应用模式匹配规则。</p>\n<h3 id=\"case命令\"><a href=\"#case命令\" class=\"headerlink\" title=\"case命令\"></a>case命令</h3><p>有了<code>case</code>命令，就不需要写出所有的<code>elif</code>语句来不停地检查同一个变量的值了。<code>case</code>命令会采用列表格式来检查单个变量的多值。</p>\n<p>下面是两个脚本实现相同功能进行对比：</p>\n<p>if语句：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test25.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> looking <span class=\"keyword\">for</span> a possible value</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [ $USER = \"rich\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Welcome $USER\"</span><br><span class=\"line\">  echo \"Please enjoy you visit\"</span><br><span class=\"line\">elif [ $USER = \"barbara\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Welcome $USER\"</span><br><span class=\"line\">  echo \"Please enjoy you visit\"</span><br><span class=\"line\">elif [ $USER = \"testing\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Special testing account\"</span><br><span class=\"line\">elif [ $USER = \"jessica\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Do not forget to logout when you're done\"</span><br></pre></td></tr></table></figure>\n<p>case语句：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case variable <span class=\"keyword\">in</span></span><br><span class=\"line\">pattern1 | pattern2) commands1;;</span><br><span class=\"line\">pattern3) commands2;;</span><br><span class=\"line\">*)<span class=\"built_in\"> default </span>commands;;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<p>上面的实例可以用<code>case</code>语句表示为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test26.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using the <span class=\"keyword\">case</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">case $USER in</span><br><span class=\"line\">rich | barbara)</span><br><span class=\"line\">  echo \"Welcome, $USER\"</span><br><span class=\"line\">  echo \"Please enjoy your visits\";;</span><br><span class=\"line\">testing)</span><br><span class=\"line\">  echo \"Special testing account\";;</span><br><span class=\"line\">jessica)</span><br><span class=\"line\">  echo \"Do not forget to log off whe you're done\";;</span><br><span class=\"line\">*)</span><br><span class=\"line\">  echo \"Sorry, you are not allowed here\";;</span><br><span class=\"line\">esac</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test26.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test26.sh</span><br><span class=\"line\">Sorry, you are not allowed here</span><br></pre></td></tr></table></figure>\n<p><code>case</code>命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式。星号会捕获所有与已知模式不匹配的值。注意双分号的使用。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><blockquote>\n<p>最基本的命令是<code>if-then</code>语句；</p>\n<p>可以拓展<code>if-then</code>语句为<code>if-then-else</code>语句；</p>\n<p>可以将<code>if-then-else</code>语句通过<code>elif</code>语句连接起来；</p>\n<p>在脚本中，我们需要测试一种条件而不是命令时，比如数值、字符串内容、文件或目录的状态，<code>test</code>命令提供了简单方法；</p>\n<p>方括号是<code>test</code>命令统一的特殊bash命令；</p>\n<p>双括号使用另一种操作符进行高级数学运算双方括号允许高级字符串模式匹配运算；</p>\n<p><code>case</code>命令是执行多个<code>if-then-else</code>命令的简便方式，它会参照一个值列表来检查单个变量的值。</p>\n</blockquote>\n<p>关于结构化命令中循环，将在下次整理的笔记中阐述。</p>\n<h2 id=\"循环控制\"><a href=\"#循环控制\" class=\"headerlink\" title=\"循环控制\"></a>循环控制</h2><blockquote>\n<p><strong>内容</strong></p>\n<ul>\n<li>for循环语句</li>\n<li>until迭代语句使用while语句</li>\n<li>循环</li>\n<li>重定向循环的输出</li>\n</ul>\n</blockquote>\n<p>这一节我们来了解如何重复一些过程和命令，也就是循环执行一组命令直到达到了某个特定条件。</p>\n<h3 id=\"for命令\"><a href=\"#for命令\" class=\"headerlink\" title=\"for命令\"></a>for命令</h3><p>基本格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for var in list</span><br><span class=\"line\">do</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>也可以</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for var in list; do</span><br></pre></td></tr></table></figure>\n<p>分号只用来分隔命令的，让代码更简约。</p>\n<p>来个简单例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> basic <span class=\"keyword\">for</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">for test in Alabama Alaska Arizona Arkansas California Colorado</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo The next state is $test</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1</span><br><span class=\"line\">The next state is Alabama</span><br><span class=\"line\">The next state is Alaska</span><br><span class=\"line\">The next state is Arizona</span><br><span class=\"line\">The next state is Arkansas</span><br><span class=\"line\">The next state is California</span><br><span class=\"line\">The next state is Colorado</span><br></pre></td></tr></table></figure>\n<p>这里操作基本和其他语言一致（格式不同），不多讲啦。</p>\n<p><strong>在读取列表中的复杂值时</strong>，我们可能会遇到问题。比如下面这个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat badtest1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> another example of how not to use the <span class=\"keyword\">for</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">for test in I don't know if this'll work</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"word:$test\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./badtest1</span><br><span class=\"line\">word:I</span><br><span class=\"line\">word:dont know if thisll</span><br><span class=\"line\">word:work</span><br></pre></td></tr></table></figure>\n<p>我们可以看到shell看到了列表值中的单引号尝试使用它们来定义一个单独的数据值。</p>\n<p>这里有两种解决办法：</p>\n<ul>\n<li>使用转义字符将单引号转义</li>\n<li>使用双引号来定义用到单引号的值</li>\n</ul>\n<p>我们将这两种解决办法同时用到上个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> another example of how not to use the <span class=\"keyword\">for</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">for test in I don\\'t know if \"this'll\" work; do</span><br><span class=\"line\">echo  \"word:$test\"</span><br><span class=\"line\">done</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test2</span><br><span class=\"line\">word:I</span><br><span class=\"line\">word:don't</span><br><span class=\"line\">word:know</span><br><span class=\"line\">word:if</span><br><span class=\"line\">word:this'll</span><br><span class=\"line\">word:work</span><br></pre></td></tr></table></figure>\n<p>我们可能明白了<code>for</code>循环是假定每个值是用空格分隔的，所以当有包含空格的数据时，我们需要用双引号括起来。</p>\n<p><strong>通常我们会将列表值存储在一个变量中</strong>，然后通过遍历变量的方式遍历了其内容的的列表。</p>\n<p>看看怎么完成这个任务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using a variable to hold the list</span></span><br><span class=\"line\">list=\"Alabama Alaska Arizona Arkansas Colorado\"</span><br><span class=\"line\">list=$list\" Connecticut\" # 在尾部拼接文本</span><br><span class=\"line\"></span><br><span class=\"line\">for state in $list; do</span><br><span class=\"line\">  echo \"Have you ever visited $state?\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3</span><br><span class=\"line\">Have you ever visited Alabama?</span><br><span class=\"line\">Have you ever visited Alaska?</span><br><span class=\"line\">Have you ever visited Arizona?</span><br><span class=\"line\">Have you ever visited Arkansas?</span><br><span class=\"line\">Have you ever visited Colorado?</span><br><span class=\"line\">Have you ever visited Connecticut?</span><br></pre></td></tr></table></figure>\n<p>注意，代码中还用了另一个赋值语句向<code>$list</code>变量包含的已有列表中添加了一个值。这是在已有文本字符串尾部添加文本的一种常用方法。</p>\n<p>我们还可以<strong>用命令来输出我们需要的列表内容</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> reading values from a file</span></span><br><span class=\"line\"></span><br><span class=\"line\">file=\"states\"</span><br><span class=\"line\"></span><br><span class=\"line\">for state in $(cat $file)</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Visit beautiful $state\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat states</span><br><span class=\"line\">Alabama</span><br><span class=\"line\">Alaska</span><br><span class=\"line\">Arizona</span><br><span class=\"line\">Arkansas</span><br><span class=\"line\">Colorado</span><br><span class=\"line\">Connecticut</span><br><span class=\"line\">Delaware</span><br><span class=\"line\">Florida</span><br><span class=\"line\">Georgia</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test4</span><br><span class=\"line\">Visit beautiful Alabama</span><br><span class=\"line\">Visit beautiful Alaska</span><br><span class=\"line\">Visit beautiful Arizona</span><br><span class=\"line\">Visit beautiful Arkansas</span><br><span class=\"line\">Visit beautiful Colorado</span><br><span class=\"line\">Visit beautiful Connecticut</span><br><span class=\"line\">Visit beautiful Delaware</span><br><span class=\"line\">Visit beautiful Florida</span><br><span class=\"line\">Visit beautiful Georgia</span><br></pre></td></tr></table></figure>\n<p><strong>更改字段分隔符</strong></p>\n<p>环境变量<code>IFS</code>，也叫作字段分隔符。它定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将<strong>空格、制表符和换行符</strong>当作字段分隔符。</p>\n<p>如果想修改<code>IFS</code>的值，比如使其只能识别换行符，我们可以将下面这行代码加入脚本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFS=$'\\n'</span><br></pre></td></tr></table></figure>\n<p>在处理大量脚本时，我们可能只在某一部分使用其他的分隔符，这时候可以先保存原有的<code>IFS</code>值，然后修改，最后恢复：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFS.OLD=$IFS</span><br><span class=\"line\">IFS=$'\\n'</span><br><span class=\"line\">&lt;在代码中使用新的IFS值&gt;</span><br><span class=\"line\">IFS=$IFS.OLD</span><br></pre></td></tr></table></figure>\n<p>假如我们要遍历一个文件中用冒号分隔的值：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFS=:</span><br></pre></td></tr></table></figure>\n<p>假如要指定多个<code>IFS</code>字符，只要将它们的赋值行串起来：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFS=$'\\n':;\"</span><br></pre></td></tr></table></figure>\n<p>这个赋值会将换行符、冒号、分号以及双引号作为字段分隔符。</p>\n<p><strong>用通配符读取目录</strong></p>\n<p>我们可以用<code>for</code>命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用<strong>文件扩展匹配</strong>。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。</p>\n<p>我拿我的一个目录来尝试一下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test5</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> iterate through all the files <span class=\"keyword\">in</span> a directory</span></span><br><span class=\"line\"></span><br><span class=\"line\">for file in /home/wsx/python_learn/*</span><br><span class=\"line\">do</span><br><span class=\"line\">  if [ -d \"$file\" ]</span><br><span class=\"line\">  then</span><br><span class=\"line\">    echo \"$file is a directory\"</span><br><span class=\"line\">  elif [ -f \"$file\" ]</span><br><span class=\"line\">  then</span><br><span class=\"line\">    echo \"$file is a file\"</span><br><span class=\"line\">  fi</span><br><span class=\"line\">done</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test5</span><br><span class=\"line\">/home/wsx/python_learn/athletelist.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/athletemodel.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/ch2_data_input.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/chapter5_first.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/chapter6_first.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/chapter6_second.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/chapter6_third.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/coinFlips.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/Dive_into_python is a directory</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong>第一个方括号之后和第二个方括号之前必须加上一个空格，否则会报错。</p>\n<p>在Linux中，目录名和文件名中包含空格是合法的，所以将<code>$file</code>变量用双引号圈起来。当然，大家尽量不要让文件或目录包含空格，不然很容易出问题（命令会把空格当做文件的分隔符）。</p>\n<h3 id=\"C语言风格的for命令\"><a href=\"#C语言风格的for命令\" class=\"headerlink\" title=\"C语言风格的for命令\"></a>C语言风格的for命令</h3><p>C语言风格的<code>for</code>命令看起来如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (( a = 1; a &lt; 10; a++ ))</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，这里有些部分没有遵循bash shell标准的<code>for</code>命令：</p>\n<ul>\n<li>变量赋值可以有空格；</li>\n<li>条件中的变量不以美元符开头；</li>\n<li>迭代过程的算式未用<code>expr</code>命令格式。</li>\n</ul>\n<p>在使用这种格式时要小心，不同的格式不注意就会出错。</p>\n<p>下面举个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test6</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the C-style <span class=\"keyword\">for</span> loop</span></span><br><span class=\"line\"></span><br><span class=\"line\">for (( i=1; i &lt;= 10; i++ ))</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo \"The next number is $i\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test6</span><br><span class=\"line\">The next number is 1</span><br><span class=\"line\">The next number is 2</span><br><span class=\"line\">The next number is 3</span><br><span class=\"line\">The next number is 4</span><br><span class=\"line\">The next number is 5</span><br><span class=\"line\">The next number is 6</span><br><span class=\"line\">The next number is 7</span><br><span class=\"line\">The next number is 8</span><br><span class=\"line\">The next number is 9</span><br><span class=\"line\">The next number is 10</span><br></pre></td></tr></table></figure>\n<h3 id=\"while命令\"><a href=\"#while命令\" class=\"headerlink\" title=\"while命令\"></a>while命令</h3><p><code>while</code>命令的格式为：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while test command</span><br><span class=\"line\">do</span><br><span class=\"line\">  other commands</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p><code>while</code>命令某种意义上是<code>if-then</code>语句和<code>for</code>循环的混杂体。注意，这里<code>while</code>后面接的也是命令。<code>while</code>命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码是0（类似一般语言中 的TRUE）。直到非0时退出循环。</p>\n<p><code>while</code>命令中定义的<code>test command</code>和<code>if-then</code>语句中的格式一模一样。可以使用任何普通的bash shell命令，或者用<code>test</code>命令进行条件测试，比如测试变量值。</p>\n<p>最常见的用法是用方括号来检查循环命令中用到的<code>shell</code>变量的值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"keyword\">while</span> <span class=\"built_in\">command</span> <span class=\"built_in\">test</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=10</span><br><span class=\"line\">while [ $var1 -gt 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo $var1</span><br><span class=\"line\">        var1=$[ $var1 - 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test</span><br><span class=\"line\">10</span><br><span class=\"line\">9</span><br><span class=\"line\">8</span><br><span class=\"line\">7</span><br><span class=\"line\">6</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n<p><strong>使用多个测试命令</strong><br><code>while</code>命令允许我们在<code>while</code>语句行中定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。<br>比如<code>while echo $var1 [ $var1 -ge 0 ]</code>检测的就是后面方括号命令的退出状态码。</p>\n<h3 id=\"until命令\"><a href=\"#until命令\" class=\"headerlink\" title=\"until命令\"></a>until命令</h3><p><code>until</code>命令和<code>while</code>命令工作的方式完全相反。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">until test command</span><br><span class=\"line\">do</span><br><span class=\"line\">  other commands</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>一个例子：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test12</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using the until <span class=\"built_in\">command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=100</span><br><span class=\"line\"></span><br><span class=\"line\">until [ $var1 -eq 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo $var1</span><br><span class=\"line\">        var1=$[ $var1 - 25 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test12</span><br><span class=\"line\">100</span><br><span class=\"line\">75</span><br><span class=\"line\">50</span><br><span class=\"line\">25</span><br></pre></td></tr></table></figure></p>\n<p>同样地，在<code>until</code>命令中放入多个测试命令时也要注意（类似<code>while</code>）。</p>\n<h3 id=\"嵌套循环\"><a href=\"#嵌套循环\" class=\"headerlink\" title=\"嵌套循环\"></a>嵌套循环</h3><p>在循环语句内使用任意类型的命令，包括其他循环命令，叫做嵌套循环。因为是在迭代中迭代，需要注意变量的使用以及程序的效率问题。</p>\n<p>下面举一个<code>for</code>循环嵌套<code>for</code>循环的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test14</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nesting <span class=\"keyword\">for</span> loops</span></span><br><span class=\"line\"></span><br><span class=\"line\">for (( a = 1; a &lt;= 3; a++ ))</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo \"Starting loop $a:\"</span><br><span class=\"line\">        for (( b = 1; b &lt;= 3; b++ ))</span><br><span class=\"line\">        do</span><br><span class=\"line\">                echo \"    Inside loop: $b\"</span><br><span class=\"line\">        done</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ . test14</span><br><span class=\"line\">Starting loop 1:</span><br><span class=\"line\">    Inside loop: 1</span><br><span class=\"line\">    Inside loop: 2</span><br><span class=\"line\">    Inside loop: 3</span><br><span class=\"line\">Starting loop 2:</span><br><span class=\"line\">    Inside loop: 1</span><br><span class=\"line\">    Inside loop: 2</span><br><span class=\"line\">    Inside loop: 3</span><br><span class=\"line\">Starting loop 3:</span><br><span class=\"line\">    Inside loop: 1</span><br><span class=\"line\">    Inside loop: 2</span><br><span class=\"line\">    Inside loop: 3</span><br></pre></td></tr></table></figure>\n<p>shell能够自动识别匹配的<code>do</code>和<code>done</code>字符。这种模式很常见，比如通常的小括号（<code>(</code>与<code>)</code>）、中括号、花括号匹配等等。它们的本质都是字符匹配。</p>\n<p>在混用循环命令时也一样，比如在<code>while</code>循环中内嵌一个<code>for</code>循环：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test15</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> placing a <span class=\"keyword\">for</span> loop inside a <span class=\"keyword\">while</span> loop</span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=5</span><br><span class=\"line\"></span><br><span class=\"line\">while [ $var1 -ge 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo \"Outer loop: $var1\"</span><br><span class=\"line\">        for (( var2 = 1; $var2 &lt; 3; var2++))</span><br><span class=\"line\">        do</span><br><span class=\"line\">                var3=$[ $var1 * $var2 ]</span><br><span class=\"line\">                echo \"  Inner loop: $var1 * $var2 = $var3\"</span><br><span class=\"line\">        done</span><br><span class=\"line\">        var1=$[ $var1 - 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ . test15</span><br><span class=\"line\">Outer loop: 5</span><br><span class=\"line\">  Inner loop: 5 * 1 = 5</span><br><span class=\"line\">  Inner loop: 5 * 2 = 10</span><br><span class=\"line\">Outer loop: 4</span><br><span class=\"line\">  Inner loop: 4 * 1 = 4</span><br><span class=\"line\">  Inner loop: 4 * 2 = 8</span><br><span class=\"line\">Outer loop: 3</span><br><span class=\"line\">  Inner loop: 3 * 1 = 3</span><br><span class=\"line\">  Inner loop: 3 * 2 = 6</span><br><span class=\"line\">Outer loop: 2</span><br><span class=\"line\">  Inner loop: 2 * 1 = 2</span><br><span class=\"line\">  Inner loop: 2 * 2 = 4</span><br><span class=\"line\">Outer loop: 1</span><br><span class=\"line\">  Inner loop: 1 * 1 = 1</span><br><span class=\"line\">  Inner loop: 1 * 2 = 2</span><br><span class=\"line\">Outer loop: 0</span><br><span class=\"line\">  Inner loop: 0 * 1 = 0</span><br><span class=\"line\">  Inner loop: 0 * 2 = 0</span><br></pre></td></tr></table></figure>\n<p>如果想要挑战脑力，可以混用<code>until</code>和<code>while</code>循环。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test16</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using until and <span class=\"keyword\">while</span> loop</span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=3</span><br><span class=\"line\"></span><br><span class=\"line\">until [ $var1 -eq 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo \"Outer loop: $var1\"</span><br><span class=\"line\">        var2=1</span><br><span class=\"line\">        while [ $var2 -lt 5 ]</span><br><span class=\"line\">        do</span><br><span class=\"line\">                var3=$(echo \"scale=4; $var1 / $var2\" | bc)</span><br><span class=\"line\">                echo \"  Inner loop: $var1 / $var2 = $var3\"</span><br><span class=\"line\">                var2=$[ $var2 + 1 ]</span><br><span class=\"line\">        done</span><br><span class=\"line\">        var1=$[ $var1 - 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ . test16</span><br><span class=\"line\">Outer loop: 3</span><br><span class=\"line\">  Inner loop: 3 / 1 = 3.0000</span><br><span class=\"line\">  Inner loop: 3 / 2 = 1.5000</span><br><span class=\"line\">  Inner loop: 3 / 3 = 1.0000</span><br><span class=\"line\">  Inner loop: 3 / 4 = .7500</span><br><span class=\"line\">Outer loop: 2</span><br><span class=\"line\">  Inner loop: 2 / 1 = 2.0000</span><br><span class=\"line\">  Inner loop: 2 / 2 = 1.0000</span><br><span class=\"line\">  Inner loop: 2 / 3 = .6666</span><br><span class=\"line\">  Inner loop: 2 / 4 = .5000</span><br><span class=\"line\">Outer loop: 1</span><br><span class=\"line\">  Inner loop: 1 / 1 = 1.0000</span><br><span class=\"line\">  Inner loop: 1 / 2 = .5000</span><br><span class=\"line\">  Inner loop: 1 / 3 = .3333</span><br><span class=\"line\">  Inner loop: 1 / 4 = .2500</span><br></pre></td></tr></table></figure>\n<p>外部的<code>until</code>循环以值3开始，并继续执行到值等于0。内部<code>while</code>循环以值1开始一直执行，只要值小于5。需要注意循环条件的设置，我跑的几次都没写完整，然后无限循环只好重开终端。</p>\n<h3 id=\"控制循环\"><a href=\"#控制循环\" class=\"headerlink\" title=\"控制循环\"></a>控制循环</h3><p>之前的学的命令已经可以让我们写循环程序了，设定好以后等待命令开始执行和等待循环结束。但是很多情况下，在循环中我们设定的某个（多个）变量达到某种条件时，我们就想要停止循环，然后运行循环下面的命令。这时候我们需要用到<code>break</code>和<code>continue</code>命令来帮我们控制住循环。</p>\n<p>这两个命令在其他语言中基本都时关键字，特别是<code>C</code>，用法差不多。我也就不具体介绍了，只点出它们的功能。</p>\n<p><strong>break</strong></p>\n<blockquote>\n<p>在shell执行break命令时，它会尝试跳出当前正在执行的循环。</p>\n<p>在处理多个循环时，break命令会自动终止你所在的最内层循环。</p>\n<p>break命令接受单个命令行参数值：</p>\n<p>​    break n</p>\n<p>​    其中n制订了要跳出的循环层级（层数）</p>\n</blockquote>\n<p><strong>continue</strong></p>\n<blockquote>\n<p>continue命令可以提前终止某次循环的命令，但并不会完全终止整个循环。可以在循环内部设置shell不执行命令的条件。</p>\n<p>也就是说使用continue命令时，它会自动跳过本次循环中接下来的运行步骤，跳转到下一次循环。但注意不是跳出，跳出时break的功能。</p>\n<p>同样的可以使用continue n         n制定要继续执行哪一级循环</p>\n</blockquote>\n<h3 id=\"处理循环的输出\"><a href=\"#处理循环的输出\" class=\"headerlink\" title=\"处理循环的输出\"></a>处理循环的输出</h3><p>在shell脚本中，我们可以对循环的输出使用管道或进行重定向。这是通过在<code>done</code>命令之后添加一个处理命令来实现的。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">for file in /home/*</span><br><span class=\"line\">do</span><br><span class=\"line\">        if [ -d \"$file\" ]</span><br><span class=\"line\">        then</span><br><span class=\"line\">                echo \"$file is a directory\"</span><br><span class=\"line\">        else</span><br><span class=\"line\">                echo \"$file is a file\"</span><br><span class=\"line\">        fi</span><br><span class=\"line\">done &gt; output.txt</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat output.txt</span><br><span class=\"line\">/home/wangsx is a directory</span><br></pre></td></tr></table></figure>\n<p>shell将<code>for</code>命令的结果重定向到文件<code>output.txt</code>中，而不是显示在屏幕上。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>下面两个例子演示如何用简单循环来处理数据。</p>\n<p><strong>查找可执行文件</strong></p>\n<p>Linux运行程序时通过环境变量<code>$PATH</code>提供的目录搜索可执行文件。如果徒手找的话，比较费时间，我们可以写个脚本来搞定它。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test25</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> finding files <span class=\"keyword\">in</span> the PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\">IFS=:</span><br><span class=\"line\">for folder in $PATH</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo \"$folder:\"</span><br><span class=\"line\">        for file in $folder/*</span><br><span class=\"line\">        do</span><br><span class=\"line\">                if [ -x $file ]</span><br><span class=\"line\">                then</span><br><span class=\"line\">                        echo \"  $file\"</span><br><span class=\"line\">                fi</span><br><span class=\"line\">        done</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出结果太多，我就不拷贝结果了</span></span><br></pre></td></tr></table></figure>\n<p>先设定<code>IFS</code>分隔符以便于能正确分隔目录，然后将目录存放在<code>$folder</code>中，用<code>for</code>循环来迭代特定的目录中所有文件，然后用<code>if-then</code>命令检查文件的可执行权限。</p>\n<p>Linux有一个<code>tree</code>工具，非常方便输出目录结构，推荐使用下。</p>\n<p><strong>创建多个用户账号</strong></p>\n<p>如果你是管理员，需要创建大量账号时。不必每次都有<code>useradd</code>命令添加用户。将用户信息存放在指定文件，然后用脚本进行处理就可以了。</p>\n<p>用户信息的格式如下：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userid,<span class=\"built_in\"> user </span>name</span><br></pre></td></tr></table></figure>\n<p>第一个是你为用户选择的id，第二个是用户的全名。这是<code>csv</code>文件格式。</p>\n<p>为了能够读取它，我们使用以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while IFS=',' read -r userid name</span><br></pre></td></tr></table></figure>\n<p><code>read</code>命令会自动获取<code>.csv</code>文本文件的下一行内容，所以不用再写一个循环来处理。当<code>read</code>命令返回<code>FALSE</code>时（也就是读完了），<code>while</code>命令就会退出。</p>\n<p>为了把数据从文件导向<code>while</code>命令，只要再<code>while</code>命令尾部加一个重定向符号。</p>\n<p>处理过程写成脚本如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> process new user accounts</span></span><br><span class=\"line\"></span><br><span class=\"line\">input=\"users.csv\"</span><br><span class=\"line\">while IFS=',', read -r userid name</span><br><span class=\"line\">do</span><br><span class=\"line\">trueecho \"adding $userid\"</span><br><span class=\"line\">trueuseradd -c \"$name\" -m $userid</span><br><span class=\"line\">done &lt; \"$input\"</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"条件控制\"><a href=\"#条件控制\" class=\"headerlink\" title=\"条件控制\"></a>条件控制</h2><blockquote>\n<p><strong>内容</strong></p>\n<ul>\n<li>使用if-then语句</li>\n<li>嵌套if语句</li>\n<li>test命令</li>\n<li>复合条件测试</li>\n<li>使用双方括号和双括号</li>\n<li>case命令</li>\n</ul>\n</blockquote>\n<p>许多程序要求对shell脚本中的命令施加一些逻辑流程控制。而某些命令会根据条件判断执行相应的命令，这样的命令通常叫做<strong>结构化命令</strong>。从概念上理解，结构化命令是shell脚本的逻辑结构，不像顺序执行shell脚本，而是有组织地执行命令以应对复杂任务需求。</p>\n<h3 id=\"if-then语句\"><a href=\"#if-then语句\" class=\"headerlink\" title=\"if-then语句\"></a>if-then语句</h3><p>最基本的结构化命令是if-then语句，它的格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if command</span><br><span class=\"line\">then</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>，在其他编程语言中，<code>if</code>语句之后的对象是一个等式，等式的结果为<code>TRUE</code>或者<code>FALSE</code>，但是bash shell中的<code>if</code>语句是运行<code>if</code>后面的命令，如果该命令的退出状态码是0（命令成功执行），则运行<code>then</code>语句后面的命令。<code>fi</code>表示<code>if</code>语句到此结束。</p>\n<p>下面是一个简单的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1.sh</span><br><span class=\"line\"><span class=\"meta\">#</span>! /bin/bash</span><br><span class=\"line\"><span class=\"meta\">#</span> testing the if statement</span><br><span class=\"line\">if pwd</span><br><span class=\"line\">then</span><br><span class=\"line\">    echo \"It worked\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test1.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1.sh</span><br><span class=\"line\">/home/wsx/script_learn</span><br><span class=\"line\">It worked</span><br></pre></td></tr></table></figure>\n<p>这个例子中在判断成功执行<code>pwd</code>命令后，执行输出文本字符串。</p>\n<p>大家可以尝试把<code>pwd</code>命令改成随便乱打的字符试试结果。它会显示报错信息，<code>then</code>后面的语句也不会执行。</p>\n<p>if-then语句的另一种形式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if command; then</span><br><span class=\"line\">commands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>在then部分，我们可以使用多个命令（从格式中command结尾有没有s也可以看出）。</p>\n<p>我们再来一个例子：在<code>if</code>语句中用<code>grep</code>命令在<code>/etc/passwd</code>文件中查找某个用户名当前是否在系统上使用。如果有用户使用了哪个登录名，脚本会显示一些文本信息并列出该用户HOME目录的bash文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test3.sh</span><br><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\"><span class=\"meta\">#</span> testing multiple commands in the then section</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">testuser=wsx</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">if grep $testuser /etc/passwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"This is my first command\"</span><br><span class=\"line\">  echo \"This is my second command\"</span><br><span class=\"line\">  echo \"I can even put in other commands besides echo:\"</span><br><span class=\"line\">  ls -a /home/$testuser/.b*</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test3.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3.sh</span><br><span class=\"line\">wsx:x:1000:1000:wsx,,,:/home/wsx:/bin/bash</span><br><span class=\"line\">This is my first command</span><br><span class=\"line\">This is my second command</span><br><span class=\"line\">I can even put in other commands besides echo:</span><br><span class=\"line\">/home/wsx/.bash_history  /home/wsx/.bashrc</span><br><span class=\"line\">/home/wsx/.bash_logout\t /home/wsx/.bashrc-anaconda3.bak</span><br></pre></td></tr></table></figure>\n<p>如果设置的用户名不存在，那么就没有输出。那么如果在这里显示的一些消息可以说明用户名在系统中未找到，这样可能就会显得更友好。所以接下来看看<code>if-then-else</code>语句。</p>\n<h3 id=\"if-then-else语句\"><a href=\"#if-then-else语句\" class=\"headerlink\" title=\"if-then-else语句\"></a>if-then-else语句</h3><p>我相信意思非常容易理解，这里较之前我们添加了一个<code>else</code>块来处理<code>if</code>中命令没有成功执行的步骤。格式为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if command</span><br><span class=\"line\">then</span><br><span class=\"line\">  commands</span><br><span class=\"line\">else commands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套if\"><a href=\"#嵌套if\" class=\"headerlink\" title=\"嵌套if\"></a>嵌套if</h3><p>有时我们需要检查脚本代码中的多种条件，可以是用嵌套的<code>if-then</code>语句。</p>\n<p>处理一个例子：检查<code>/etc/passwd</code>文件中是否存在某个用户名以及该用户名的目录是否存在。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test5.sh</span><br><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> Testing nested ifs</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">testuser=NoSuchUser</span><br><span class=\"line\"><span class=\"meta\">#</span></span><br><span class=\"line\">if grep $testuser /etc/passwd</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"The user $testuser exits on this system.\"</span><br><span class=\"line\">else</span><br><span class=\"line\">  echo \"The user $testuser does not exit on this system.\"</span><br><span class=\"line\">  if ls -d /home/$testuser/</span><br><span class=\"line\">  then</span><br><span class=\"line\">     echo \"However, $testuser has a directory.\"</span><br><span class=\"line\">  fi</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test5.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test5.sh</span><br><span class=\"line\">The user NoSuchUser does not exit on this system.</span><br><span class=\"line\">ls: 无法访问'/home/NoSuchUser/': 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n<p>可以使用<code>else</code>部分的另一种形式:<code>elif</code>。这样我们就不再用书写多个<code>if-then</code>语句了。在其他语言中，有的是用<code>elif</code>的形式，有的使用<code>else if</code>等形式。面对相同内含在不同语言中不同的表示方式，我们需要有意识地区别，以免接触的东西多了可能各种语言代码串写喔。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if command1</span><br><span class=\"line\">then</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">elif command2</span><br><span class=\"line\">then</span><br><span class=\"line\">truemore commands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>这种表示方式逻辑更为清晰，但是也有点容易让写的人搞混。其实可以看到一个<code>if</code>对应一个<code>fi</code>。这是一个大的嵌套<code>if</code>结构。</p>\n<p><strong>记住</strong>，在<code>elif</code>语句中，紧跟其后的<code>else</code>语句属于<code>elif</code>代码块，而不是属于<code>if-then</code>代码块。</p>\n<h3 id=\"test命令\"><a href=\"#test命令\" class=\"headerlink\" title=\"test命令\"></a>test命令</h3><p>到此为止，我们很清楚<code>if</code>后面跟着的是普通的shell命令，那么我们需要测试其他条件怎么办呢？</p>\n<p><code>test</code>命令提供了在<code>if-then</code>语句中测试不同条件的途径。如果<code>test</code>命令中列出的条件成立，<code>test</code>命令就会退出并返回状态码0。这样<code>if-then</code>语句就与其他编程语言中的<code>if-then</code>语句以类似的方式工作了。</p>\n<p>test命令格式：</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">test </span>condition</span><br></pre></td></tr></table></figure>\n<p><code>condition</code>是<code>test</code>命令要测试的一系列参数和值。如果不写这个<code>condition</code>，<code>test</code>返回非0，<code>if</code>语句跳转到<code>else</code>进行执行。</p>\n<p>bash shell提供了一种条件测试方法，无需在<code>if-then</code>语句中声明<code>test</code>命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if [ condition ]</span><br><span class=\"line\">then commands</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>这跟我们其他的编程习惯非常接近。建议使用这种方式。</p>\n<p>如果使用<code>test</code>命令，需要记住的是各种条件参数。</p>\n<p><strong>数值比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>n1 -eq n2</td>\n<td>(n1)等于(n2)</td>\n</tr>\n<tr>\n<td>n1 -ge n2</td>\n<td>大于或等于</td>\n</tr>\n<tr>\n<td>n1 -gt n2</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>n1 -le n2</td>\n<td>小于或等于</td>\n</tr>\n<tr>\n<td>n1 -lt n2</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>n1 -ne n2</td>\n<td>不等于</td>\n</tr>\n</tbody>\n</table>\n<p><strong>字符串比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>str1 = str2</td>\n<td>（str1与str2比较）相同</td>\n</tr>\n<tr>\n<td>str1 != str2</td>\n<td>不同</td>\n</tr>\n<tr>\n<td>str1 &lt; str2</td>\n<td>小</td>\n</tr>\n<tr>\n<td>str1 &gt; str2</td>\n<td>大</td>\n</tr>\n<tr>\n<td>-n str1</td>\n<td>检查string1的长度非0</td>\n</tr>\n<tr>\n<td>-z str1</td>\n<td>检查string1的长度是否为0</td>\n</tr>\n</tbody>\n</table>\n<p>注意，大于和小于号必须转义；大于和小于顺序和sort命令所采用的不同。</p>\n<p><strong>文件比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-d file</td>\n<td>检查file是否存在并是一个目录</td>\n</tr>\n<tr>\n<td>-e file</td>\n<td>～是否存在</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>～是否存在并是一个文件</td>\n</tr>\n<tr>\n<td>-r file</td>\n<td>～是否存在并可读</td>\n</tr>\n<tr>\n<td>-s file</td>\n<td>～是否存在并非空</td>\n</tr>\n<tr>\n<td>-w file</td>\n<td>～是否存在并可写</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>-x file</td>\n<td>～是否存在并可执行</td>\n</tr>\n<tr>\n<td>-O file</td>\n<td>～是否存在并属当前用户所有</td>\n</tr>\n<tr>\n<td>-G file</td>\n<td>～是否存在并且默认组与当前用户相同</td>\n</tr>\n<tr>\n<td>file1 -nt file2</td>\n<td>检查file1是否比file2新</td>\n</tr>\n<tr>\n<td>file1 -ot file2</td>\n<td>检查file1是否比file2旧</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"复合条件测试\"><a href=\"#复合条件测试\" class=\"headerlink\" title=\"复合条件测试\"></a>复合条件测试</h3><p><code>if-then</code>语句允许我们使用布尔逻辑来组合测试。可用</p>\n<ul>\n<li>[ condition1] &amp;&amp; [ condition2]</li>\n<li><code>[ condition1] || [ condition2]</code></li>\n</ul>\n<h3 id=\"if-then的高级特性\"><a href=\"#if-then的高级特性\" class=\"headerlink\" title=\"if-then的高级特性\"></a>if-then的高级特性</h3><ul>\n<li>用于数学表达式的双括号</li>\n<li>用于高级字符串处理功能的双方括号</li>\n</ul>\n<p><strong>双括号</strong></p>\n<p>命令格式：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(( <span class=\"name\">expresiion</span> ))</span><br></pre></td></tr></table></figure>\n<p><code>expression</code>可以是任意的数学赋值或比较表达式。除了<code>test</code>命令使用的标准数学运算符，下面列出了一些其他的：</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>val ++</td>\n<td>后增</td>\n</tr>\n<tr>\n<td>val –</td>\n<td>后减</td>\n</tr>\n<tr>\n<td>++ val</td>\n<td>先增</td>\n</tr>\n<tr>\n<td>– val</td>\n<td>先减</td>\n</tr>\n<tr>\n<td>!</td>\n<td>逻辑取反</td>\n</tr>\n<tr>\n<td>~</td>\n<td>位求反</td>\n</tr>\n<tr>\n<td>**</td>\n<td>幂运算</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>左位移</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>右位移</td>\n</tr>\n<tr>\n<td>&amp;</td>\n<td>位布尔和</td>\n</tr>\n<tr>\n<td>\\</td>\n<td></td>\n<td>位布尔或</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑和</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>\\</td>\n<td></td>\n<td>逻辑或</td>\n</tr>\n</tbody>\n</table>\n<p>看一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test23.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using doble parenthesis</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">val1=10</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if (( $val1 ** 2 &gt; 90 ))</span><br><span class=\"line\">then</span><br><span class=\"line\">  (( val2 = $val1 ** 2 ))</span><br><span class=\"line\">  echo \"The square of $val1 is $val2\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test23.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test23.sh</span><br><span class=\"line\">The square of 10 is 100</span><br></pre></td></tr></table></figure>\n<p><strong>双方括号</strong></p>\n<p>双方括号命令提供了针对字符串比较的高级特性。命令格式如下：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">[[ expression ]]</span></span><br></pre></td></tr></table></figure>\n<p>双方括号里的<code>expression</code>使用了<code>test</code>命令中采用的标准字符串比较。但它提供了<code>test</code>没有提供的一个特性——模式匹配。</p>\n<p>在模式匹配中，可以定义一个正则表达式来匹配字符串值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test24.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using pattern matching</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [[ $USER == r* ]]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Hello $USER\"</span><br><span class=\"line\">else</span><br><span class=\"line\">  echo \"Sorry, I do not know you\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test24.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test24.sh</span><br><span class=\"line\">Sorry, I do not know you</span><br></pre></td></tr></table></figure>\n<p>上面一个脚本中，我们使用了双等号。双等号将右边的字符串视为一个模式，并将其应用模式匹配规则。</p>\n<h3 id=\"case命令\"><a href=\"#case命令\" class=\"headerlink\" title=\"case命令\"></a>case命令</h3><p>有了<code>case</code>命令，就不需要写出所有的<code>elif</code>语句来不停地检查同一个变量的值了。<code>case</code>命令会采用列表格式来检查单个变量的多值。</p>\n<p>下面是两个脚本实现相同功能进行对比：</p>\n<p>if语句：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test25.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> looking <span class=\"keyword\">for</span> a possible value</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [ $USER = \"rich\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Welcome $USER\"</span><br><span class=\"line\">  echo \"Please enjoy you visit\"</span><br><span class=\"line\">elif [ $USER = \"barbara\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Welcome $USER\"</span><br><span class=\"line\">  echo \"Please enjoy you visit\"</span><br><span class=\"line\">elif [ $USER = \"testing\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Special testing account\"</span><br><span class=\"line\">elif [ $USER = \"jessica\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  echo \"Do not forget to logout when you're done\"</span><br></pre></td></tr></table></figure>\n<p>case语句：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case variable <span class=\"keyword\">in</span></span><br><span class=\"line\">pattern1 | pattern2) commands1;;</span><br><span class=\"line\">pattern3) commands2;;</span><br><span class=\"line\">*)<span class=\"built_in\"> default </span>commands;;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<p>上面的实例可以用<code>case</code>语句表示为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test26.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using the <span class=\"keyword\">case</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">case $USER in</span><br><span class=\"line\">rich | barbara)</span><br><span class=\"line\">  echo \"Welcome, $USER\"</span><br><span class=\"line\">  echo \"Please enjoy your visits\";;</span><br><span class=\"line\">testing)</span><br><span class=\"line\">  echo \"Special testing account\";;</span><br><span class=\"line\">jessica)</span><br><span class=\"line\">  echo \"Do not forget to log off whe you're done\";;</span><br><span class=\"line\">*)</span><br><span class=\"line\">  echo \"Sorry, you are not allowed here\";;</span><br><span class=\"line\">esac</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test26.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test26.sh</span><br><span class=\"line\">Sorry, you are not allowed here</span><br></pre></td></tr></table></figure>\n<p><code>case</code>命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式。星号会捕获所有与已知模式不匹配的值。注意双分号的使用。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><blockquote>\n<p>最基本的命令是<code>if-then</code>语句；</p>\n<p>可以拓展<code>if-then</code>语句为<code>if-then-else</code>语句；</p>\n<p>可以将<code>if-then-else</code>语句通过<code>elif</code>语句连接起来；</p>\n<p>在脚本中，我们需要测试一种条件而不是命令时，比如数值、字符串内容、文件或目录的状态，<code>test</code>命令提供了简单方法；</p>\n<p>方括号是<code>test</code>命令统一的特殊bash命令；</p>\n<p>双括号使用另一种操作符进行高级数学运算双方括号允许高级字符串模式匹配运算；</p>\n<p><code>case</code>命令是执行多个<code>if-then-else</code>命令的简便方式，它会参照一个值列表来检查单个变量的值。</p>\n</blockquote>\n<p>关于结构化命令中循环，将在下次整理的笔记中阐述。</p>\n<h2 id=\"循环控制\"><a href=\"#循环控制\" class=\"headerlink\" title=\"循环控制\"></a>循环控制</h2><blockquote>\n<p><strong>内容</strong></p>\n<ul>\n<li>for循环语句</li>\n<li>until迭代语句使用while语句</li>\n<li>循环</li>\n<li>重定向循环的输出</li>\n</ul>\n</blockquote>\n<p>这一节我们来了解如何重复一些过程和命令，也就是循环执行一组命令直到达到了某个特定条件。</p>\n<h3 id=\"for命令\"><a href=\"#for命令\" class=\"headerlink\" title=\"for命令\"></a>for命令</h3><p>基本格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for var in list</span><br><span class=\"line\">do</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>也可以</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for var in list; do</span><br></pre></td></tr></table></figure>\n<p>分号只用来分隔命令的，让代码更简约。</p>\n<p>来个简单例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> basic <span class=\"keyword\">for</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">for test in Alabama Alaska Arizona Arkansas California Colorado</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo The next state is $test</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1</span><br><span class=\"line\">The next state is Alabama</span><br><span class=\"line\">The next state is Alaska</span><br><span class=\"line\">The next state is Arizona</span><br><span class=\"line\">The next state is Arkansas</span><br><span class=\"line\">The next state is California</span><br><span class=\"line\">The next state is Colorado</span><br></pre></td></tr></table></figure>\n<p>这里操作基本和其他语言一致（格式不同），不多讲啦。</p>\n<p><strong>在读取列表中的复杂值时</strong>，我们可能会遇到问题。比如下面这个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat badtest1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> another example of how not to use the <span class=\"keyword\">for</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">for test in I don't know if this'll work</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"word:$test\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./badtest1</span><br><span class=\"line\">word:I</span><br><span class=\"line\">word:dont know if thisll</span><br><span class=\"line\">word:work</span><br></pre></td></tr></table></figure>\n<p>我们可以看到shell看到了列表值中的单引号尝试使用它们来定义一个单独的数据值。</p>\n<p>这里有两种解决办法：</p>\n<ul>\n<li>使用转义字符将单引号转义</li>\n<li>使用双引号来定义用到单引号的值</li>\n</ul>\n<p>我们将这两种解决办法同时用到上个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> another example of how not to use the <span class=\"keyword\">for</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">for test in I don\\'t know if \"this'll\" work; do</span><br><span class=\"line\">echo  \"word:$test\"</span><br><span class=\"line\">done</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test2</span><br><span class=\"line\">word:I</span><br><span class=\"line\">word:don't</span><br><span class=\"line\">word:know</span><br><span class=\"line\">word:if</span><br><span class=\"line\">word:this'll</span><br><span class=\"line\">word:work</span><br></pre></td></tr></table></figure>\n<p>我们可能明白了<code>for</code>循环是假定每个值是用空格分隔的，所以当有包含空格的数据时，我们需要用双引号括起来。</p>\n<p><strong>通常我们会将列表值存储在一个变量中</strong>，然后通过遍历变量的方式遍历了其内容的的列表。</p>\n<p>看看怎么完成这个任务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using a variable to hold the list</span></span><br><span class=\"line\">list=\"Alabama Alaska Arizona Arkansas Colorado\"</span><br><span class=\"line\">list=$list\" Connecticut\" # 在尾部拼接文本</span><br><span class=\"line\"></span><br><span class=\"line\">for state in $list; do</span><br><span class=\"line\">  echo \"Have you ever visited $state?\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3</span><br><span class=\"line\">Have you ever visited Alabama?</span><br><span class=\"line\">Have you ever visited Alaska?</span><br><span class=\"line\">Have you ever visited Arizona?</span><br><span class=\"line\">Have you ever visited Arkansas?</span><br><span class=\"line\">Have you ever visited Colorado?</span><br><span class=\"line\">Have you ever visited Connecticut?</span><br></pre></td></tr></table></figure>\n<p>注意，代码中还用了另一个赋值语句向<code>$list</code>变量包含的已有列表中添加了一个值。这是在已有文本字符串尾部添加文本的一种常用方法。</p>\n<p>我们还可以<strong>用命令来输出我们需要的列表内容</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> reading values from a file</span></span><br><span class=\"line\"></span><br><span class=\"line\">file=\"states\"</span><br><span class=\"line\"></span><br><span class=\"line\">for state in $(cat $file)</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Visit beautiful $state\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat states</span><br><span class=\"line\">Alabama</span><br><span class=\"line\">Alaska</span><br><span class=\"line\">Arizona</span><br><span class=\"line\">Arkansas</span><br><span class=\"line\">Colorado</span><br><span class=\"line\">Connecticut</span><br><span class=\"line\">Delaware</span><br><span class=\"line\">Florida</span><br><span class=\"line\">Georgia</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test4</span><br><span class=\"line\">Visit beautiful Alabama</span><br><span class=\"line\">Visit beautiful Alaska</span><br><span class=\"line\">Visit beautiful Arizona</span><br><span class=\"line\">Visit beautiful Arkansas</span><br><span class=\"line\">Visit beautiful Colorado</span><br><span class=\"line\">Visit beautiful Connecticut</span><br><span class=\"line\">Visit beautiful Delaware</span><br><span class=\"line\">Visit beautiful Florida</span><br><span class=\"line\">Visit beautiful Georgia</span><br></pre></td></tr></table></figure>\n<p><strong>更改字段分隔符</strong></p>\n<p>环境变量<code>IFS</code>，也叫作字段分隔符。它定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将<strong>空格、制表符和换行符</strong>当作字段分隔符。</p>\n<p>如果想修改<code>IFS</code>的值，比如使其只能识别换行符，我们可以将下面这行代码加入脚本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFS=$'\\n'</span><br></pre></td></tr></table></figure>\n<p>在处理大量脚本时，我们可能只在某一部分使用其他的分隔符，这时候可以先保存原有的<code>IFS</code>值，然后修改，最后恢复：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFS.OLD=$IFS</span><br><span class=\"line\">IFS=$'\\n'</span><br><span class=\"line\">&lt;在代码中使用新的IFS值&gt;</span><br><span class=\"line\">IFS=$IFS.OLD</span><br></pre></td></tr></table></figure>\n<p>假如我们要遍历一个文件中用冒号分隔的值：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFS=:</span><br></pre></td></tr></table></figure>\n<p>假如要指定多个<code>IFS</code>字符，只要将它们的赋值行串起来：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IFS=$'\\n':;\"</span><br></pre></td></tr></table></figure>\n<p>这个赋值会将换行符、冒号、分号以及双引号作为字段分隔符。</p>\n<p><strong>用通配符读取目录</strong></p>\n<p>我们可以用<code>for</code>命令来自动遍历目录中的文件。进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用<strong>文件扩展匹配</strong>。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程。</p>\n<p>我拿我的一个目录来尝试一下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test5</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> iterate through all the files <span class=\"keyword\">in</span> a directory</span></span><br><span class=\"line\"></span><br><span class=\"line\">for file in /home/wsx/python_learn/*</span><br><span class=\"line\">do</span><br><span class=\"line\">  if [ -d \"$file\" ]</span><br><span class=\"line\">  then</span><br><span class=\"line\">    echo \"$file is a directory\"</span><br><span class=\"line\">  elif [ -f \"$file\" ]</span><br><span class=\"line\">  then</span><br><span class=\"line\">    echo \"$file is a file\"</span><br><span class=\"line\">  fi</span><br><span class=\"line\">done</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test5</span><br><span class=\"line\">/home/wsx/python_learn/athletelist.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/athletemodel.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/ch2_data_input.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/chapter5_first.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/chapter6_first.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/chapter6_second.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/chapter6_third.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/coinFlips.py is a file</span><br><span class=\"line\">/home/wsx/python_learn/Dive_into_python is a directory</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong>第一个方括号之后和第二个方括号之前必须加上一个空格，否则会报错。</p>\n<p>在Linux中，目录名和文件名中包含空格是合法的，所以将<code>$file</code>变量用双引号圈起来。当然，大家尽量不要让文件或目录包含空格，不然很容易出问题（命令会把空格当做文件的分隔符）。</p>\n<h3 id=\"C语言风格的for命令\"><a href=\"#C语言风格的for命令\" class=\"headerlink\" title=\"C语言风格的for命令\"></a>C语言风格的for命令</h3><p>C语言风格的<code>for</code>命令看起来如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (( a = 1; a &lt; 10; a++ ))</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，这里有些部分没有遵循bash shell标准的<code>for</code>命令：</p>\n<ul>\n<li>变量赋值可以有空格；</li>\n<li>条件中的变量不以美元符开头；</li>\n<li>迭代过程的算式未用<code>expr</code>命令格式。</li>\n</ul>\n<p>在使用这种格式时要小心，不同的格式不注意就会出错。</p>\n<p>下面举个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test6</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the C-style <span class=\"keyword\">for</span> loop</span></span><br><span class=\"line\"></span><br><span class=\"line\">for (( i=1; i &lt;= 10; i++ ))</span><br><span class=\"line\">do</span><br><span class=\"line\">  echo \"The next number is $i\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test6</span><br><span class=\"line\">The next number is 1</span><br><span class=\"line\">The next number is 2</span><br><span class=\"line\">The next number is 3</span><br><span class=\"line\">The next number is 4</span><br><span class=\"line\">The next number is 5</span><br><span class=\"line\">The next number is 6</span><br><span class=\"line\">The next number is 7</span><br><span class=\"line\">The next number is 8</span><br><span class=\"line\">The next number is 9</span><br><span class=\"line\">The next number is 10</span><br></pre></td></tr></table></figure>\n<h3 id=\"while命令\"><a href=\"#while命令\" class=\"headerlink\" title=\"while命令\"></a>while命令</h3><p><code>while</code>命令的格式为：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while test command</span><br><span class=\"line\">do</span><br><span class=\"line\">  other commands</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p><code>while</code>命令某种意义上是<code>if-then</code>语句和<code>for</code>循环的混杂体。注意，这里<code>while</code>后面接的也是命令。<code>while</code>命令允许定义一个要测试的命令，然后循环执行一组命令，只要定义的测试命令返回的是退出状态码是0（类似一般语言中 的TRUE）。直到非0时退出循环。</p>\n<p><code>while</code>命令中定义的<code>test command</code>和<code>if-then</code>语句中的格式一模一样。可以使用任何普通的bash shell命令，或者用<code>test</code>命令进行条件测试，比如测试变量值。</p>\n<p>最常见的用法是用方括号来检查循环命令中用到的<code>shell</code>变量的值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"keyword\">while</span> <span class=\"built_in\">command</span> <span class=\"built_in\">test</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=10</span><br><span class=\"line\">while [ $var1 -gt 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo $var1</span><br><span class=\"line\">        var1=$[ $var1 - 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test</span><br><span class=\"line\">10</span><br><span class=\"line\">9</span><br><span class=\"line\">8</span><br><span class=\"line\">7</span><br><span class=\"line\">6</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n<p><strong>使用多个测试命令</strong><br><code>while</code>命令允许我们在<code>while</code>语句行中定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。<br>比如<code>while echo $var1 [ $var1 -ge 0 ]</code>检测的就是后面方括号命令的退出状态码。</p>\n<h3 id=\"until命令\"><a href=\"#until命令\" class=\"headerlink\" title=\"until命令\"></a>until命令</h3><p><code>until</code>命令和<code>while</code>命令工作的方式完全相反。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">until test command</span><br><span class=\"line\">do</span><br><span class=\"line\">  other commands</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>一个例子：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test12</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using the until <span class=\"built_in\">command</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=100</span><br><span class=\"line\"></span><br><span class=\"line\">until [ $var1 -eq 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo $var1</span><br><span class=\"line\">        var1=$[ $var1 - 25 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test12</span><br><span class=\"line\">100</span><br><span class=\"line\">75</span><br><span class=\"line\">50</span><br><span class=\"line\">25</span><br></pre></td></tr></table></figure></p>\n<p>同样地，在<code>until</code>命令中放入多个测试命令时也要注意（类似<code>while</code>）。</p>\n<h3 id=\"嵌套循环\"><a href=\"#嵌套循环\" class=\"headerlink\" title=\"嵌套循环\"></a>嵌套循环</h3><p>在循环语句内使用任意类型的命令，包括其他循环命令，叫做嵌套循环。因为是在迭代中迭代，需要注意变量的使用以及程序的效率问题。</p>\n<p>下面举一个<code>for</code>循环嵌套<code>for</code>循环的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test14</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> nesting <span class=\"keyword\">for</span> loops</span></span><br><span class=\"line\"></span><br><span class=\"line\">for (( a = 1; a &lt;= 3; a++ ))</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo \"Starting loop $a:\"</span><br><span class=\"line\">        for (( b = 1; b &lt;= 3; b++ ))</span><br><span class=\"line\">        do</span><br><span class=\"line\">                echo \"    Inside loop: $b\"</span><br><span class=\"line\">        done</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ . test14</span><br><span class=\"line\">Starting loop 1:</span><br><span class=\"line\">    Inside loop: 1</span><br><span class=\"line\">    Inside loop: 2</span><br><span class=\"line\">    Inside loop: 3</span><br><span class=\"line\">Starting loop 2:</span><br><span class=\"line\">    Inside loop: 1</span><br><span class=\"line\">    Inside loop: 2</span><br><span class=\"line\">    Inside loop: 3</span><br><span class=\"line\">Starting loop 3:</span><br><span class=\"line\">    Inside loop: 1</span><br><span class=\"line\">    Inside loop: 2</span><br><span class=\"line\">    Inside loop: 3</span><br></pre></td></tr></table></figure>\n<p>shell能够自动识别匹配的<code>do</code>和<code>done</code>字符。这种模式很常见，比如通常的小括号（<code>(</code>与<code>)</code>）、中括号、花括号匹配等等。它们的本质都是字符匹配。</p>\n<p>在混用循环命令时也一样，比如在<code>while</code>循环中内嵌一个<code>for</code>循环：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test15</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> placing a <span class=\"keyword\">for</span> loop inside a <span class=\"keyword\">while</span> loop</span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=5</span><br><span class=\"line\"></span><br><span class=\"line\">while [ $var1 -ge 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo \"Outer loop: $var1\"</span><br><span class=\"line\">        for (( var2 = 1; $var2 &lt; 3; var2++))</span><br><span class=\"line\">        do</span><br><span class=\"line\">                var3=$[ $var1 * $var2 ]</span><br><span class=\"line\">                echo \"  Inner loop: $var1 * $var2 = $var3\"</span><br><span class=\"line\">        done</span><br><span class=\"line\">        var1=$[ $var1 - 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ . test15</span><br><span class=\"line\">Outer loop: 5</span><br><span class=\"line\">  Inner loop: 5 * 1 = 5</span><br><span class=\"line\">  Inner loop: 5 * 2 = 10</span><br><span class=\"line\">Outer loop: 4</span><br><span class=\"line\">  Inner loop: 4 * 1 = 4</span><br><span class=\"line\">  Inner loop: 4 * 2 = 8</span><br><span class=\"line\">Outer loop: 3</span><br><span class=\"line\">  Inner loop: 3 * 1 = 3</span><br><span class=\"line\">  Inner loop: 3 * 2 = 6</span><br><span class=\"line\">Outer loop: 2</span><br><span class=\"line\">  Inner loop: 2 * 1 = 2</span><br><span class=\"line\">  Inner loop: 2 * 2 = 4</span><br><span class=\"line\">Outer loop: 1</span><br><span class=\"line\">  Inner loop: 1 * 1 = 1</span><br><span class=\"line\">  Inner loop: 1 * 2 = 2</span><br><span class=\"line\">Outer loop: 0</span><br><span class=\"line\">  Inner loop: 0 * 1 = 0</span><br><span class=\"line\">  Inner loop: 0 * 2 = 0</span><br></pre></td></tr></table></figure>\n<p>如果想要挑战脑力，可以混用<code>until</code>和<code>while</code>循环。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test16</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using until and <span class=\"keyword\">while</span> loop</span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=3</span><br><span class=\"line\"></span><br><span class=\"line\">until [ $var1 -eq 0 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo \"Outer loop: $var1\"</span><br><span class=\"line\">        var2=1</span><br><span class=\"line\">        while [ $var2 -lt 5 ]</span><br><span class=\"line\">        do</span><br><span class=\"line\">                var3=$(echo \"scale=4; $var1 / $var2\" | bc)</span><br><span class=\"line\">                echo \"  Inner loop: $var1 / $var2 = $var3\"</span><br><span class=\"line\">                var2=$[ $var2 + 1 ]</span><br><span class=\"line\">        done</span><br><span class=\"line\">        var1=$[ $var1 - 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ . test16</span><br><span class=\"line\">Outer loop: 3</span><br><span class=\"line\">  Inner loop: 3 / 1 = 3.0000</span><br><span class=\"line\">  Inner loop: 3 / 2 = 1.5000</span><br><span class=\"line\">  Inner loop: 3 / 3 = 1.0000</span><br><span class=\"line\">  Inner loop: 3 / 4 = .7500</span><br><span class=\"line\">Outer loop: 2</span><br><span class=\"line\">  Inner loop: 2 / 1 = 2.0000</span><br><span class=\"line\">  Inner loop: 2 / 2 = 1.0000</span><br><span class=\"line\">  Inner loop: 2 / 3 = .6666</span><br><span class=\"line\">  Inner loop: 2 / 4 = .5000</span><br><span class=\"line\">Outer loop: 1</span><br><span class=\"line\">  Inner loop: 1 / 1 = 1.0000</span><br><span class=\"line\">  Inner loop: 1 / 2 = .5000</span><br><span class=\"line\">  Inner loop: 1 / 3 = .3333</span><br><span class=\"line\">  Inner loop: 1 / 4 = .2500</span><br></pre></td></tr></table></figure>\n<p>外部的<code>until</code>循环以值3开始，并继续执行到值等于0。内部<code>while</code>循环以值1开始一直执行，只要值小于5。需要注意循环条件的设置，我跑的几次都没写完整，然后无限循环只好重开终端。</p>\n<h3 id=\"控制循环\"><a href=\"#控制循环\" class=\"headerlink\" title=\"控制循环\"></a>控制循环</h3><p>之前的学的命令已经可以让我们写循环程序了，设定好以后等待命令开始执行和等待循环结束。但是很多情况下，在循环中我们设定的某个（多个）变量达到某种条件时，我们就想要停止循环，然后运行循环下面的命令。这时候我们需要用到<code>break</code>和<code>continue</code>命令来帮我们控制住循环。</p>\n<p>这两个命令在其他语言中基本都时关键字，特别是<code>C</code>，用法差不多。我也就不具体介绍了，只点出它们的功能。</p>\n<p><strong>break</strong></p>\n<blockquote>\n<p>在shell执行break命令时，它会尝试跳出当前正在执行的循环。</p>\n<p>在处理多个循环时，break命令会自动终止你所在的最内层循环。</p>\n<p>break命令接受单个命令行参数值：</p>\n<p>​    break n</p>\n<p>​    其中n制订了要跳出的循环层级（层数）</p>\n</blockquote>\n<p><strong>continue</strong></p>\n<blockquote>\n<p>continue命令可以提前终止某次循环的命令，但并不会完全终止整个循环。可以在循环内部设置shell不执行命令的条件。</p>\n<p>也就是说使用continue命令时，它会自动跳过本次循环中接下来的运行步骤，跳转到下一次循环。但注意不是跳出，跳出时break的功能。</p>\n<p>同样的可以使用continue n         n制定要继续执行哪一级循环</p>\n</blockquote>\n<h3 id=\"处理循环的输出\"><a href=\"#处理循环的输出\" class=\"headerlink\" title=\"处理循环的输出\"></a>处理循环的输出</h3><p>在shell脚本中，我们可以对循环的输出使用管道或进行重定向。这是通过在<code>done</code>命令之后添加一个处理命令来实现的。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">for file in /home/*</span><br><span class=\"line\">do</span><br><span class=\"line\">        if [ -d \"$file\" ]</span><br><span class=\"line\">        then</span><br><span class=\"line\">                echo \"$file is a directory\"</span><br><span class=\"line\">        else</span><br><span class=\"line\">                echo \"$file is a file\"</span><br><span class=\"line\">        fi</span><br><span class=\"line\">done &gt; output.txt</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat output.txt</span><br><span class=\"line\">/home/wangsx is a directory</span><br></pre></td></tr></table></figure>\n<p>shell将<code>for</code>命令的结果重定向到文件<code>output.txt</code>中，而不是显示在屏幕上。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>下面两个例子演示如何用简单循环来处理数据。</p>\n<p><strong>查找可执行文件</strong></p>\n<p>Linux运行程序时通过环境变量<code>$PATH</code>提供的目录搜索可执行文件。如果徒手找的话，比较费时间，我们可以写个脚本来搞定它。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test25</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> finding files <span class=\"keyword\">in</span> the PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\">IFS=:</span><br><span class=\"line\">for folder in $PATH</span><br><span class=\"line\">do</span><br><span class=\"line\">        echo \"$folder:\"</span><br><span class=\"line\">        for file in $folder/*</span><br><span class=\"line\">        do</span><br><span class=\"line\">                if [ -x $file ]</span><br><span class=\"line\">                then</span><br><span class=\"line\">                        echo \"  $file\"</span><br><span class=\"line\">                fi</span><br><span class=\"line\">        done</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出结果太多，我就不拷贝结果了</span></span><br></pre></td></tr></table></figure>\n<p>先设定<code>IFS</code>分隔符以便于能正确分隔目录，然后将目录存放在<code>$folder</code>中，用<code>for</code>循环来迭代特定的目录中所有文件，然后用<code>if-then</code>命令检查文件的可执行权限。</p>\n<p>Linux有一个<code>tree</code>工具，非常方便输出目录结构，推荐使用下。</p>\n<p><strong>创建多个用户账号</strong></p>\n<p>如果你是管理员，需要创建大量账号时。不必每次都有<code>useradd</code>命令添加用户。将用户信息存放在指定文件，然后用脚本进行处理就可以了。</p>\n<p>用户信息的格式如下：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userid,<span class=\"built_in\"> user </span>name</span><br></pre></td></tr></table></figure>\n<p>第一个是你为用户选择的id，第二个是用户的全名。这是<code>csv</code>文件格式。</p>\n<p>为了能够读取它，我们使用以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while IFS=',' read -r userid name</span><br></pre></td></tr></table></figure>\n<p><code>read</code>命令会自动获取<code>.csv</code>文本文件的下一行内容，所以不用再写一个循环来处理。当<code>read</code>命令返回<code>FALSE</code>时（也就是读完了），<code>while</code>命令就会退出。</p>\n<p>为了把数据从文件导向<code>while</code>命令，只要再<code>while</code>命令尾部加一个重定向符号。</p>\n<p>处理过程写成脚本如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> process new user accounts</span></span><br><span class=\"line\"></span><br><span class=\"line\">input=\"users.csv\"</span><br><span class=\"line\">while IFS=',', read -r userid name</span><br><span class=\"line\">do</span><br><span class=\"line\">trueecho \"adding $userid\"</span><br><span class=\"line\">trueuseradd -c \"$name\" -m $userid</span><br><span class=\"line\">done &lt; \"$input\"</span><br></pre></td></tr></table></figure>"},{"title":"Shell脚本之处理用户输入","author":"王诗翔","date":"2017-08-18T16:00:00.000Z","_content":"\n\n**Shell脚本笔记系列：**\n\n[构建基本shell脚本](http://www.flypeom.site/linux/2017/08/11/basic-shell/)\n\n[Linux结构化命令](http://www.flypeom.site/linux/2017/08/11/structural-command-of-shell/)\n\n\n\n\n> 内容：\n>\n> - 传递参数\n> - 跟踪参数\n> - 移动变量\n> - 处理选项\n> - 将选项标准化\n> - 获得用户输入\n\n\n\n经过前面的介绍，我们已经可以掌握一些流程化的脚本编程了。但有时候，我们需要编写的脚本能够跟使用者进行交互。它可以是静态的，输入相应的参数让它运行到底；也可以是动态的，脚本根据输入参数反馈不同的信息，使用者又能根据信息调整下一步的处理，实时与程序互动。\n\nbash shell提供了一些不同的方法来从**用户处获得数据，包括命令行参数、命令行选项以及直接从键盘读取输入**的能力。下面将一一介绍实现。\n\n<!-- more -->\n\n\n\n## 命令行参数\n\n使用命令行参数是向脚本传递数据的最基本方法，在运行脚本的同时可以在命令行添加数据。\n\n比如：\n\n```shell\n./addem 10 30\n```\n\n运行当前目录下名为`addem`脚本的同时向内部传递2个参数（10和30）。而脚本会通过特殊的变量来处理命令行参数。\n\n下面介绍如何使用它们。\n\n\n\n### 读入参数\n\nbash shell会将称为**位置参数**的特殊变量分配给输入到命令行的所有参数：`$0`是程序名，`$1`是第一个参数，`$2`是第二个参数，以此类推。书上介绍直到第九个参数`$9`，但这个应该不是受限的。[Shell最多可以输入多少个参数？](http://www.cnblogs.com/ivictor/p/4022382.html)一文探索了参数的个数限制，有兴趣的朋友不妨看看和试试。\n\n下面是单个参数的例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test1.sh\n#!/bin/bash\n\n# using one command line parameter\n#\nfactorial=1\nfor (( number = 1; number <= $1; number++ ))\ndo\n\tfactorial=$[ $factorial * $number ]\ndone\necho The factorial of $1 is $factorial\nwsx@wsx-ubuntu:~/script_learn$ ./test1.sh 5\nThe factorial of 5 is 120\n```\n\n我们可以像使用其他变量一样使用`$1`变量。shell脚本会自动分配，不需要我们做任何处理。可以看得出来这样非常方便，不过如果输入参数过多，很容易让人混淆。\n\n如果需要输入更多的参数，只需要用空格分隔即可。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test2.sh\n#!/bin/bash\n\n# using two command line parameters\n\ntotal=$[ $1 * $2 ]\necho The first parameter is $1.\necho The second parameter is $2.\necho The total value is $total.\n\nwsx@wsx-ubuntu:~/script_learn$ ./test2.sh 2 5\nThe first parameter is 2.\nThe second parameter is 5.\nThe total value is 10.\n```\n\n字符参数也是一样的。如果我没记错，在脚本中的数字默认都是做字符处理的，进行数学运算时会自动调整。不过当我们想要输入的一个参数是带空格的字符串时，需要在两边加上引号以保证shell能够正确识别。不然会被当做多个参数处理的。\n\n下面取个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test3.sh\n#!/bin/bash\n\necho Hello $1, glad to meet you.\nwsx@wsx-ubuntu:~/script_learn$ ./test3.sh shixiang wang\nHello shixiang, glad to meet you.\nwsx@wsx-ubuntu:~/script_learn$ ./test3.sh 'shixiang wang'\nHello shixiang wang, glad to meet you.\nwsx@wsx-ubuntu:~/script_learn$ ./test3.sh \"shixiang wang\"\nHello shixiang wang, glad to meet you.\n```\n\n看来使用时要注意正确使用引号喔。\n\n> 说明：在文本字符串作为参数传递时，引号并非数据的一部分。它们只是表明数据的起止位置。\n\n如果需要输入的命令行参数不止9个，写脚本需要修改一下变量名（第9个之后）。比如`${10}`表示输入的第十个变量（原来如此啊）。\n\n这样我们就可以向脚本添加任意多的参数啦～\n\n前面也说了，`$0`参数可以获取脚本名，这样在编程的时候很方便。但是这里存在一个潜在的问题：如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在`$0`中。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test4.sh\n#!/bin/bash\n# Testing the $0 parameter\n\necho The zero parameter is set to: $0\nwsx@wsx-ubuntu:~/script_learn$ ./test4.sh\nThe zero parameter is set to: ./test4.sh\n\nwsx@wsx-ubuntu:~/script_learn$ bash test4.sh\nThe zero parameter is set to: test4.sh\n\nwsx@wsx-ubuntu:~/script_learn$ bash ~/script_learn/test4.sh\nThe zero parameter is set to: /home/wsx/script_learn/test4.sh\n```\n\n而且，你发现没有，当指明脚本路径时，这个路径也会带入其中。\n\n如果我们要编写一个根据脚本名来执行不同功能的脚本，就得把脚本的运行路径剥离掉。还要删除与脚本名混在一起的命令。幸好有一个方便的小命令`basename`可以帮助我们返回不包含路径的脚本名。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test5.sh\n#!/bin/bash\n# Using basename with the $0 parameter\n\nname=$(basename $0)\necho\necho The script name is: $name\n\nwsx@wsx-ubuntu:~/script_learn$ bash ~/script_learn/test5.sh\n\nThe script name is: test5.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test5.sh\n\nThe script name is: test5.sh\n```\n\n下面编写基于脚本名执行不同功能的脚本。挺有意思的，我们看看吧：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test6.sh\n#!/bin/bash\n# Testing a Multi-function script\n#\nname=$(basename $0)\n#\nif [ $name = \"addem\" ]\nthen\n\ttotal=$[ $1 + $2 ]\nelif [ $name = \"multem\" ]\nthen\n\ttotal=$[ $1 * $2 ]\nfi\n#\necho\necho The calculated value is $total.\nwsx@wsx-ubuntu:~/script_learn$ cp test6.sh addem\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x addem\nwsx@wsx-ubuntu:~/script_learn$ ln -s test6.sh multem\nwsx@wsx-ubuntu:~/script_learn$ ll *em\n-rwxrw-r-- 1 wsx wsx 216 8月  18 16:47 addem*\nlrwxrwxrwx 1 wsx wsx   8 8月  18 16:47 multem -> test6.sh*\nwsx@wsx-ubuntu:~/script_learn$ ./addem 2 5\n\nThe calculated value is 7.\nwsx@wsx-ubuntu:~/script_learn$ ./multem 2 5\n\nThe calculated value is 10.\n\n```\n\n这个脚本中创建了两个不同的文件名：一个通过复制创建；另一个通过链接。在两种情况下都会先获得脚本的基本名称，然后根据该值执行相应的功能。\n\n\n\n### 测试参数\n\n如果在脚本中使用了参数，但是运行脚本时没用参数，这会导致错误发生，需要小心。因此我们在使用参数前应该测试。\n\n好比下面这个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test7.sh\n#!/bin/bash\n# testing parameters before use\n#\nif [ -n \"$1\" ] # -n 选项检查字符是否非空\nthen\n\techo Hello $1, glad to meet you.\nelse\n\techo \"Sorry, you did not identify yourself.\"\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ ./test7.sh shixiang\nHello shixiang, glad to meet you.\nwsx@wsx-ubuntu:~/script_learn$ ./test7.sh\nSorry, you did not identify yourself.\n```\n\n\n\n## 特殊参数变量\n\nbash shell中有些特殊变量，它们会记录命令行参数。\n\n\n\n### 参数统计\n\nbash shell提供了一个特殊的变量`$#`来统计命令行中输入了多少个参数。我们可以像使用普通变量一样使用它。\n\n现在能在使用参数前测试参数的总数了。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test9.sh\n#!/bin/bash\n# Testing parameters\n#\nif [ $# -ne 2 ]\nthen\n    echo\n    echo Usage: test9.sh a b\n    echo\nelse\n    total=$[ $1 + $2 ]\n    echo\n    echo The total is $total\n    echo\nfi\n\nwangsx@SC-201708020022:~/tmp$ bash test9.sh\n\nUsage: test9.sh a b\n\nwangsx@SC-201708020022:~/tmp$ bash test9.sh 10\n\nUsage: test9.sh a b\n\nwangsx@SC-201708020022:~/tmp$ bash test9.sh 2 5\n\nThe total is 7\n```\n\n例子中，`if-then`语句用`-ne`测试命令行参数数量。如果参数数量不对，会显示一条错误信息告诉脚本的正确用法。\n\n这个变量还提供了一个简便方法来获取命令行最后一个参数，完全不需要知道实际上有多少个参数。不过要实现它需要花些功夫。\n\n\n也许，我们会有这样的想法，既然`$#`变量含有参数的总数，那么变量`{% raw %}${$#}{% endraw %}`就代表了最后一个命令行参数变量。试试看呗：\n\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test10.sh\n#!/bin/bash\n\n# testing grabbing last parameter\n#\necho The last parameter was ${$#}\n\nwangsx@SC-201708020022:~/tmp$ ./test10.sh 10\nThe last parameter was 65\n\n```\n\n我擦，明显不对。这说明`{% raw %}${$#}{% endraw %}`的用法错误。实际上，花括号能不能使用美元符，必须把它换成感叹号。虽然有点奇怪，但的确有用。\n\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test10.sh\n#!/bin/bash\n\n# testing grabbing last parameter\n#\necho The last parameter was ${!#}\n\nwangsx@SC-201708020022:~/tmp$ ./test10.sh 10\nThe last parameter was 10\nwangsx@SC-201708020022:~/tmp$ ./test10.sh 1 2 3 4 5\nThe last parameter was 5\n```\n\n\n\n### 抓取所有的数据\n\n`$*`与`$@`变量可以用来轻松访问所有的参数。它们都能够在单个变量中存储所有的命令行参数。\n\n`$*`变量会将命令行提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上`$*`变量会将这些参数视为一个整体，而不是多个个体。\n\n`$@`则将所有参数当作同一字符串中的多个独立的单词。这样能够遍历所有的参数值，得到每个参数。这通常交给`for`命令完成。\n\n弄个例子吧，理解两者的区别。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test11.sh\n#!/bin/bash\n# testing $* and $@\n#\necho\necho \"Using then \\$* method: $*\"\necho\necho \"Using the \\$@ method: $@\"\nwangsx@SC-201708020022:~/tmp$ ./test11.sh rich barbara katie jessica\n\nUsing then $* method: rich barbara katie jessica\n\nUsing the $@ method: rich barbara katie jessica\n\n# 下面给出两者差异\nwangsx@SC-201708020022:~/tmp$ cat test12.sh\n#!/bin/bash\necho\ncount=1\n#\nfor param in \"$*\"\ndo\n    echo \"\\$* Parameter #$count = $param\"\n    count=$[ $count + 1 ]\ndone\n#\necho\ncount=1\n#\n\nfor param in \"$@\"\ndo\n    echo \"\\$@ Parameter #$count = $param\"\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~/tmp$ ./test12.sh rich barbara katie jessica\n\n$* Parameter #1 = rich barbara katie jessica\n\n$@ Parameter #1 = rich\n$@ Parameter #2 = barbara\n$@ Parameter #3 = katie\n$@ Parameter #4 = jessica\n```\n\n\n\n## 移动变量\n\nbash shell的`shift`命令能够用来操作命令行参数。默认情况下它会将每个参数变量向左移动一个位置。So, 变量`$3`的值会移到`$2`，`$2`移到`$1`，而`$1`的值会被删除（`$0`的值，也就是脚本名，是不会变的）。\n\n这是遍历命令行参数的另一个好方法，不需要知道参数的个数，我们只需要操作第一个参数，然后移动参数，继续操作第一个参数。\n\n下面解释它怎么工作的：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test13.sh\n#!/bin/bash\n# demonstrating the shift command\n#\necho\ncount=1\nwhile [ -n \"$1\" ]\ndo\n    echo \"Parameter #$count = $1\"\n    count=$[ $count + 1 ]\n    shift\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test13.sh rich barbara katie jessica\n\nParameter #1 = rich\nParameter #2 = barbara\nParameter #3 = katie\nParameter #4 = jessica\n```\n\n> 使用shift命令时需要注意，一旦参数被移除，它的值就被丢弃了 ，无法再恢复。\n\n`shift n`中`n`可以指定移动多个位置。\n\n\n\n## 处理选项\n\n熟悉Linux的朋友必然见过不少同时提供参数和选项的bash命令。选项是跟在但破折线后面的单个字母，它能改变命令的行为。下面介绍3中再脚本中处理选项的方法。\n\n\n\n### 查找选项\n\n只要我们愿意，我们可以像处理命令行参数一样处理命令行选项。\n\n\n\n#### 处理简单选项\n\n前面一节最后我们用`shift`命令来依次处理脚本携带的命令行参数。我们也可以用同样的方法来处理命令行选项。\n\n在提取每个单独参数时，用`case`语句来判断某个参数是否为选项。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test15.sh\n#!/bin/bash\n# extracting command line option as parameter\n#\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n        -a) echo \"Found the -a option\";;\n        -b) echo \"Found the -b option\";;\n        -c) echo \"Found the -c option\";;\n        *)  echo \"$1 is not an option\";;\n    esac\n    shift\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test15.sh -a -b -c -d\n\nFound the -a option\nFound the -b option\nFound the -c option\n-d is not an option\n```\n\n`case`语句在命令行参数中找到一个选项，就处理一个选项。如果命令行上还提供了其他参数，你可以在`case`语句的通用情况处理部分中处理。\n\n\n\n#### 分离参数与选项\n\nshell脚本通常使用选项和参数，Linux中处理这个问题的标准方法是用**特殊字符**来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。\n\n这个所谓的特殊字符就是`--`双破折号。\n\n要检查双破折号，在`case`语句中加一项就行了。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test16.sh\n#!/bin/bash\n# extracting options and paramters\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n        -a) echo \"Found the -a option\";;\n        -b) echo \"Found the -b option\";;\n        -c) echo \"Found the -c option\";;\n        --) shift\n            break ;;\n        *) echo \"$1 is not an option\";;\n    esac\n    shift\ndone\n#\ncount=1\nfor param in $@\ndo\n    echo \"Parameter #$count: $param\"\n    count=$[ $count + 1 ]\ndone\n```\n\n当遇到双破折号时，先把它移除掉，然后跳出循环，这样shell就会把后面的参数当参数而不是选项处理了。\n\n先用一组普通的选项和参数来运行测试脚本：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test16.sh -c -a -b test1 test2 test3\n\nFound the -c option\nFound the -a option\nFound the -b option\ntest1 is not an option\ntest2 is not an option\ntest3 is not an option\n```\n\n现在加上双破折号，进行测试：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test16.sh -c -a -b -- test1 test2 test3\n\nFound the -c option\nFound the -a option\nFound the -b option\nParameter #1: test1\nParameter #2: test2\nParameter #3: test3\n```\n\n可以看到，当脚本遇到双破折号时，它会停止处理选项，并将剩下的参数都当做命令处理。\n\n这样如果顺序填写选项和参数的话，显然没什么问题。但是如果乱序写呢？很显然选项和参数对应不起来。如何解决？\n\n\n\n#### 处理带值的选项\n\n有些选项会带上一个额外的参数值，类似下面：\n\n```shell\n./testing.sh -a test1 -b -c -d test2\n```\n\n下面看看怎么正确处理。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test17.sh\n#!/bin/bash\n# extracting command line options and values\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n        -a) echo \"Found the -a option\";;\n        -b) param=\"$2\"\n            echo \"Found the -b option, with parameter value $param\"\n            shift;;\n        -c) echo \"Found the -c option\";;\n        --) shift\n            break;;\n        *) echo \"$1 is not an option\";;\n    esac\n    shift\ndone\n#\ncount=1\nfor param in \"$@\"\ndo\n    echo \"Paramter #$count: $param\"\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~/tmp$ ./test17.sh -a -b test1 -d\n\nFound the -a option\nFound the -b option, with parameter value test1\n-d is not an option\n```\n\n本例中，定义了3个要处理的选项，`-b`还带一个额外参数。因为处理的选项是`$1`，所以额外参数位于`$2`，另外因为加了额外参数，所以找到后应该用`shift`把它移除（这个选项占了两个位置，需要多移动一个）。\n\n这样，我们可以根据需求进行类似的设定了。不管什么顺序放置选项都可以正常工作。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test17.sh  -b test1 -a -d\n\nFound the -b option, with parameter value test1\nFound the -a option\n-d is not an option\n```\n\n不过，这里还有一些限制。如果我们想把多个选项放在一起，这样就行不通啦~\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test17.sh  -ac\n\n-ac is not an option\n```\n\n而这种功能是Linux常见的喔。那究竟怎么合并选项呢？幸好还有一种处理方法可以帮忙。\n\n\n\n### 使用getopt命令\n\n`getopt`命令是一个处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而更方便地进行解析。\n\n**命令的格式**\n\n```shell\ngetopt optstring parameters\n```\n\n`optstring`是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些字母需要带参数。\n\n**首先，在`optstring`中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。**\n\n> `getopt`的高级版本叫`getoptions`。需要注意区分\n\n下面看看`getopt`如何工作的：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ getopt ab:cd -a -b test1 -cd test2 test3\n -a -b test1 -c -d -- test2 test3\n```\n\n运行完后看到结果感觉自己晕乎乎的，让我们一起来看看解释：\n\n`optstring`定义了四个有效选项字母：a,b,c,d。（嗯，对的，这个没问题）。冒号被放在字母b后面，说明b选项需要一个参数。（这样啊）。当`getopt`命令运行时，它会检查参数列表（就时getopt命令后面跟的），并基于提供的`optstring`进行解析。值得注意，它会自动把`-cd`选项分成两个独立的选项，并插入双破折号来分隔行中的额外参数。\n\n如果指定的选项不在`optstring`中，会报错。`-q`选项可以忽略掉它（注意放在`optstring`之前，因为是命令本身的选项嘛）。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ getopt ab:cd -a -b test1 -cde test2 test3\ngetopt：无效选项 -- e\n -a -b test1 -c -d -- test2 test3\nwangsx@SC-201708020022:~/tmp$ getopt -q ab:cd -a -b test1 -cde test2 test3\n -a -b 'test1' -c -d -- 'test2' 'test3'\n```\n\n\n\n**在脚本中用getopt**\n\n用法稍微有点复杂，方法是用`getopt`命令生成的格式化后的版本替换已有的命令行选项和参数。用`set`可以做到。\n\n```shell\nset -- $(getopt -q ab:cd \"$@)\n```\n\n`set`命令的选项之一是`--`，它会将命令行参数替换成`set`命令的命令行值。\n\n该方法会将原始脚本的命令行参数传给`getopt`命令，之后将`getopt`命令的输出传给`set`命令，用`getopt`格式化的命令行参数来替换原始的命令行参数。\n\n现在写下处理命令行参数的脚本吧：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test18.sh\n#!/bin/bash\n# Extract command line options & values with getopt\n#\nset -- $(getopt -q ab:cd \"$@\")\n#\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n        -a) echo \"Found the -a option\";;\n        -b) param=\"$2\"\n            echo \"Found the -b option, with parameter value $param\"\n            shift ;;\n        -c) echo \"Found the -c option\";;\n        --) shift\n            break ;;\n        *) echo \"$1 is not an option\"\n    esac\n    shift\ndone\n#\ncount=1\nfor param in \"$@\"\ndo\n    echo \"Parameter #$count: $param\"\n    count=$[ $count + 1 ]\ndone\n#\n```\n\n可以看到它跟`test17.sh`不同的地方是加入了`getopt`命令来帮助格式化命令行参数。\n\n下面测试发现新加的功能实现了，之前的也没问题。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test18.sh -ac\n\nFound the -a option\nFound the -c option\nwangsx@SC-201708020022:~/tmp$ ./test18.sh -a -b test1 -cd  test2 test3 test4\n\nFound the -a option\nFound the -b option, with parameter value 'test1'\nFound the -c option\n-d is not an option\nParameter #1: 'test2'\nParameter #2: 'test3'\nParameter #3: 'test4'\n```\n\n相当不错啦。不过`getopt`命令隐藏一个问题。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test18.sh -a -b test1 -cd  \"test2 test3\" test4\n\nFound the -a option\nFound the -b option, with parameter value 'test1'\nFound the -c option\n-d is not an option\nParameter #1: 'test2\nParameter #2: test3'\nParameter #3: 'test4'\n```\n\n`getopt`命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将两者当作一个参数。\n\n幸而还有办法能够解决这个问题。\n\n\n\n### 使用更高级的getopts\n\n`getopts`命令内建于bash shell。它比`getopt`多一些扩展功能。\n\n`getopts`命令格式如下：\n\n```shell\ngetopts optstring variable\n```\n\n`optstring`值类似于`getopt`命令中的那个。要去掉错误信息的话，可以在`optstring`之前加一个冒号。`getopts`命令将当前参数保存在命令行中定义的`variable`中。\n\n**该命令会用到两个环境变量。如果选项需要跟一个参数值，`OPTARG`环境变量就会保存这个值。`OPTIND`环境变量保存了参数列表中`getopts`正在处理的参数位置。这样你就能在处理选项之后继续处理其他命令行参数了。**\n\n空说无益，还是来练练。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test19.sh\n#!/bin/bash\n# Simple demonstration of the getopts command\n#\necho\nwhile getopts :ab:c opt\ndo\n    case \"$opt\" in\n       a) echo \"Found the -a option\" ;;\n       b) echo \"Found the -b option, with value $OPTARG\";;\n       c) echo \"Found the -c option\";;\n       *) echo \"Unknown option: $opt\";;\n   esac\ndone\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -ab test1 -c\n\nFound the -a option\nFound the -b option, with value test1\nFound the -c option\n```\n\n`while`语句定义了`getopts`命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（`opt`）。\n\n`getopts`运行时，它一次只处理命令行上检测到的一个参数。处理完所有参数后，它会退出并返回一个大于0的退出状态码。这让它非常适合用于解析命令行所有的参数的循环中。\n\n这里我们可以已经注意到了例子中的`case`用法和之前不同。`getopts`命令解析命令行选项时会移除开头的单破折号，所以在`case`定义中不用单破折号了。\n\n上一小节末尾我们遇到的问题可以很好的解决了：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -ab \"test1 test2\" -c\n\nFound the -a option\nFound the -b option, with value test1 test2\nFound the -c option\n```\n\n另一个好用的功能是能够将选项字母和参数值放在一起，而且不用加空格。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -abtest1\n\nFound the -a option\nFound the -b option, with value test1\n```\n\n除此之外，`getopts`还能够将命令行上找到的所有未定义的选项统一输出成问号。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -d\n\nUnknown option: ?\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -acde\n\nFound the -a option\nFound the -c option\nUnknown option: ?\nUnknown option: ?\n```\n\n`getopts`命令知道何时停止处理选项，并将参数留给你处理。在`getopts`处理每一个选项时，它会将`OPTIND`环境变量值增一。在`getopts`完成处理后，你可以使用`shift`命令和`OPTIND`值来移动参数。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test20.sh\n#!/bin/bash\n# Processing options & parameters with getopts\n#\necho\nwhile getopts :ab:cd opt\ndo\n    case \"$opt\" in\n        a) echo \"Found the -a option\" ;;\n        b) echo \"Found the -a option, with value $OPTARG\" ;;\n        c) echo \"Found the -c option\" ;;\n        d) echo \"Found the -d option\" ;;\n        *) echo \"Unknown option: $opt\" ;;\n    esac\ndone\n#\nshift $[ $OPTIND -1 ]\n#\necho\ncount=1\nfor param in  \"$@\"\ndo\n    echo \"Parameter $count: $param\"\n    count=$[ $count + 1 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test20.sh -a -b test1 -d test2 test3 test4\n\nFound the -a option\nFound the -a option, with value test1\nFound the -d option\n\nParameter 1: test2\nParameter 2: test3\nParameter 3: test4\n```\n\n这里`shift $[ $OPTIND -1 ]`需要解释以下：前面提到`OPTIND`在`getopts`每次处理掉一个参数后会加1。比如`./test20.sh -a -b test1 -d test2 test3 test4`前面键入了4个参数，选项处理完成后`OPTIND`的值为5。它会指向`$5`，即第5个参数，后面为了值剩下命令行参数，所以去掉所有的选项（及带的参数），所以用`shift $[ $OPTIND - 1]`命令。\n\n\n\n## 将选项标准化\n\n有些字母在Linux世界里已经拥有了某种程度的标准含义。如果我们能在shellji奥本中支持这些选项，脚本看起来会更加友好。\n\n下面表格列出一些命令行选项的常用含义\n\n|  选项  |        描述        |\n| :--: | :--------------: |\n|  -a  |      显示所有对象      |\n|  -c  |      生成一个计数      |\n|  -d  |      指定一个目录      |\n|  -e  |      扩展一个对象      |\n|  -f  |    指定读入数据的文件     |\n|  -h  |    显示命令的帮助信息     |\n|  -i  |     忽略文本大小写      |\n|  -l  |    产生输出的长格式版本    |\n|  -n  |   使用非交互模式（批处理）   |\n|  -o  | 将所有输出重定向到指定的输出文件 |\n|  -q  |     以安静模式运行      |\n|  -r  |    递归地处理目录和文件    |\n|  -s  |     以安静模式运行      |\n|  -v  |      生成详细输出      |\n|  -x  |      排除某个对象      |\n|  -y  |    对所有问题答yes     |\n\n\n\n## 获得用户输入\n\n有时脚本地交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本地人来回答。bash shell为此提供了read命令。\n\n\n\n### 基本的读入\n\n`read`命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，`read`命令会将数据放进一个变量。\n\n简单用法如下：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test21.sh\n#!/bin/bash\n# testing the read -p option\n#\nread -p \"Please enter your age: \" age\n#\ndays=$[ $age * 365 ]\necho \"That makes you over $days days old!\"\n#\nwangsx@SC-201708020022:~/tmp$ ./test21.sh\nPlease enter your age: 23\nThat makes you over 8395 days old!\n```\n\n`read`命令会将提示符后输入的所有数据分配给单个变量，要么我们需要指定多个变量。当变量数量不够时，剩下的数据就全部分配给最后一个变量。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test22.sh\n#!/bin/bash\n# entering multiple variable\n#\nread -p \"Enter your name: \" first last\necho \"Checking data for $last, $first...\"\n\nwangsx@SC-201708020022:~/tmp$ ./test22.sh\nEnter your name: shixiang wang\nChecking data for wang, shixiang...\nwangsx@SC-201708020022:~/tmp$ ./test22.sh\nEnter your name: shixiang wang hhhhh\nChecking data for wang hhhhh, shixiang...\n```\n\n也可以在`read`命令行中不指定变量。如果这样的话，`read`命令会将它收到的任何数据都放进特殊环境变量`REPLY`中。我们直接可以使用它。\n\n\n\n### 超时\n\n脚本很可能一直苦苦等待脚本用户的输入。如果不管数据是否输入，脚本都执行的话，我们可以用`-t`选项设定一个计时器。`-t`指定`read`命令等待的秒数，计数完成后，`read`命令会返回一个非零退出状态码。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test23.sh\n#!/bin/bash\n# timing the data entry\n#\nif read -t 5 -p \"Please enter your name: \" name\nthen\n    echo \"Hello $name, welcome to my script\"\nelse\n    echo\n    echo \"Sorry, too slow!\"\nfi\n\nwangsx@SC-201708020022:~/tmp$ ./test23.sh\nPlease enter your name: shixiang wang\nHello shixiang wang, welcome to my script\nwangsx@SC-201708020022:~/tmp$ ./test23.sh # 这里输入后等以下 不要输入\nPlease enter your name:\nSorry, too slow!\n```\n\n\n\n也可以不对输入过程计时，而时让`read`命令来统计输入的字符数。当输入的字符数达到预设的字符数时，就自动退出，将输入的数据赋值给变量。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test24.sh\n#!/bin/bash\n# getting just one character of input\n#\nread -n1 -p \"Do you want to continue [Y/N]? \" answer\ncase $answer in\n    Y | y ) echo\n            echo \"fine, continue on...\";;\n    N | n ) echo\n            echo OK, goodbye\n            exit;;\nesac\necho \"This is the end of the script.\"\nwangsx@SC-201708020022:~/tmp$ ./test24.sh\nDo you want to continue [Y/N]? Y\nfine, continue on...\nThis is the end of the script.\nwangsx@SC-201708020022:~/tmp$ ./test24.sh\nDo you want to continue [Y/N]? n\nOK, goodbye\n```\n\n\n\n### 隐藏方式读取\n\n这种方式输入密码的时候有用。\n\n`-s`选项可以避免在`read`命令输入的数据出现在显示器上（实际上，数据会被显示，只是`read`命令会将文本颜色设成跟背景色一样）。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test25.sh\n#!/bin/bash\n# hiding input data from the monitor\n#\nread -s -p \"Enter your password: \" pass\necho\necho \"Is your password really $pass?\"\nwangsx@SC-201708020022:~/tmp$ ./test25.sh\nEnter your password:\nIs your password really what?\nwangsx@SC-201708020022:~/tmp$ ./test25.sh\nEnter your password:\nIs your password really shixiang?\n```\n\n\n\n### 从文件中读取\n\n当然，`read`也可以从系统文件中读取数据。每次调用`read`命令，它都会读取一行文本。当读完后，`read`命令会退出并返回非零退出状态码。\n\n最常见的方法时对文本使用`cat`命令，将结果通过管道直接传给含`read`命令的`while`命令。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test26.sh\n#!/bin/bash\n# reading data from a file\n#\ncount=1\ncat test | while read line\ndo\n    echo \"Line $count: $line\"\n    count=$[ $count + 1 ]\ndone\necho \"Finished processing the file\"\n\nwangsx@SC-201708020022:~/tmp$ cat test\nThe quick brown dog jumps over the lazy fox.\nThis is a test, this is only a test.\nO Romeo, Romeo! Wherefore art thou Romeo?\nwangsx@SC-201708020022:~/tmp$ ./test26.sh\nLine 1: The quick brown dog jumps over the lazy fox.\nLine 2: This is a test, this is only a test.\nLine 3: O Romeo, Romeo! Wherefore art thou Romeo?\nFinished processing the file\n```\n\n\n\n\n\n------------------------\n\n写shell脚本的基本内容大体已经整完了，我自己也是边看边想边码过来的。shell博大精深，更多高级内容有待继续学习整理。码字实属不易，觉得内容还行的点赞支持下吧~\n","source":"_posts/2017-08-19-working-with-user-input.md","raw":"---\ntitle:  Shell脚本之处理用户输入\nauthor: 王诗翔\ndate: 2017-08-19\ncategories:\n- Linux杂烩\n- shell编程\ntags:\n- bash shell\n- shell笔记\n\n---\n\n\n**Shell脚本笔记系列：**\n\n[构建基本shell脚本](http://www.flypeom.site/linux/2017/08/11/basic-shell/)\n\n[Linux结构化命令](http://www.flypeom.site/linux/2017/08/11/structural-command-of-shell/)\n\n\n\n\n> 内容：\n>\n> - 传递参数\n> - 跟踪参数\n> - 移动变量\n> - 处理选项\n> - 将选项标准化\n> - 获得用户输入\n\n\n\n经过前面的介绍，我们已经可以掌握一些流程化的脚本编程了。但有时候，我们需要编写的脚本能够跟使用者进行交互。它可以是静态的，输入相应的参数让它运行到底；也可以是动态的，脚本根据输入参数反馈不同的信息，使用者又能根据信息调整下一步的处理，实时与程序互动。\n\nbash shell提供了一些不同的方法来从**用户处获得数据，包括命令行参数、命令行选项以及直接从键盘读取输入**的能力。下面将一一介绍实现。\n\n<!-- more -->\n\n\n\n## 命令行参数\n\n使用命令行参数是向脚本传递数据的最基本方法，在运行脚本的同时可以在命令行添加数据。\n\n比如：\n\n```shell\n./addem 10 30\n```\n\n运行当前目录下名为`addem`脚本的同时向内部传递2个参数（10和30）。而脚本会通过特殊的变量来处理命令行参数。\n\n下面介绍如何使用它们。\n\n\n\n### 读入参数\n\nbash shell会将称为**位置参数**的特殊变量分配给输入到命令行的所有参数：`$0`是程序名，`$1`是第一个参数，`$2`是第二个参数，以此类推。书上介绍直到第九个参数`$9`，但这个应该不是受限的。[Shell最多可以输入多少个参数？](http://www.cnblogs.com/ivictor/p/4022382.html)一文探索了参数的个数限制，有兴趣的朋友不妨看看和试试。\n\n下面是单个参数的例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test1.sh\n#!/bin/bash\n\n# using one command line parameter\n#\nfactorial=1\nfor (( number = 1; number <= $1; number++ ))\ndo\n\tfactorial=$[ $factorial * $number ]\ndone\necho The factorial of $1 is $factorial\nwsx@wsx-ubuntu:~/script_learn$ ./test1.sh 5\nThe factorial of 5 is 120\n```\n\n我们可以像使用其他变量一样使用`$1`变量。shell脚本会自动分配，不需要我们做任何处理。可以看得出来这样非常方便，不过如果输入参数过多，很容易让人混淆。\n\n如果需要输入更多的参数，只需要用空格分隔即可。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test2.sh\n#!/bin/bash\n\n# using two command line parameters\n\ntotal=$[ $1 * $2 ]\necho The first parameter is $1.\necho The second parameter is $2.\necho The total value is $total.\n\nwsx@wsx-ubuntu:~/script_learn$ ./test2.sh 2 5\nThe first parameter is 2.\nThe second parameter is 5.\nThe total value is 10.\n```\n\n字符参数也是一样的。如果我没记错，在脚本中的数字默认都是做字符处理的，进行数学运算时会自动调整。不过当我们想要输入的一个参数是带空格的字符串时，需要在两边加上引号以保证shell能够正确识别。不然会被当做多个参数处理的。\n\n下面取个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test3.sh\n#!/bin/bash\n\necho Hello $1, glad to meet you.\nwsx@wsx-ubuntu:~/script_learn$ ./test3.sh shixiang wang\nHello shixiang, glad to meet you.\nwsx@wsx-ubuntu:~/script_learn$ ./test3.sh 'shixiang wang'\nHello shixiang wang, glad to meet you.\nwsx@wsx-ubuntu:~/script_learn$ ./test3.sh \"shixiang wang\"\nHello shixiang wang, glad to meet you.\n```\n\n看来使用时要注意正确使用引号喔。\n\n> 说明：在文本字符串作为参数传递时，引号并非数据的一部分。它们只是表明数据的起止位置。\n\n如果需要输入的命令行参数不止9个，写脚本需要修改一下变量名（第9个之后）。比如`${10}`表示输入的第十个变量（原来如此啊）。\n\n这样我们就可以向脚本添加任意多的参数啦～\n\n前面也说了，`$0`参数可以获取脚本名，这样在编程的时候很方便。但是这里存在一个潜在的问题：如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在`$0`中。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test4.sh\n#!/bin/bash\n# Testing the $0 parameter\n\necho The zero parameter is set to: $0\nwsx@wsx-ubuntu:~/script_learn$ ./test4.sh\nThe zero parameter is set to: ./test4.sh\n\nwsx@wsx-ubuntu:~/script_learn$ bash test4.sh\nThe zero parameter is set to: test4.sh\n\nwsx@wsx-ubuntu:~/script_learn$ bash ~/script_learn/test4.sh\nThe zero parameter is set to: /home/wsx/script_learn/test4.sh\n```\n\n而且，你发现没有，当指明脚本路径时，这个路径也会带入其中。\n\n如果我们要编写一个根据脚本名来执行不同功能的脚本，就得把脚本的运行路径剥离掉。还要删除与脚本名混在一起的命令。幸好有一个方便的小命令`basename`可以帮助我们返回不包含路径的脚本名。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test5.sh\n#!/bin/bash\n# Using basename with the $0 parameter\n\nname=$(basename $0)\necho\necho The script name is: $name\n\nwsx@wsx-ubuntu:~/script_learn$ bash ~/script_learn/test5.sh\n\nThe script name is: test5.sh\nwsx@wsx-ubuntu:~/script_learn$ ./test5.sh\n\nThe script name is: test5.sh\n```\n\n下面编写基于脚本名执行不同功能的脚本。挺有意思的，我们看看吧：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test6.sh\n#!/bin/bash\n# Testing a Multi-function script\n#\nname=$(basename $0)\n#\nif [ $name = \"addem\" ]\nthen\n\ttotal=$[ $1 + $2 ]\nelif [ $name = \"multem\" ]\nthen\n\ttotal=$[ $1 * $2 ]\nfi\n#\necho\necho The calculated value is $total.\nwsx@wsx-ubuntu:~/script_learn$ cp test6.sh addem\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x addem\nwsx@wsx-ubuntu:~/script_learn$ ln -s test6.sh multem\nwsx@wsx-ubuntu:~/script_learn$ ll *em\n-rwxrw-r-- 1 wsx wsx 216 8月  18 16:47 addem*\nlrwxrwxrwx 1 wsx wsx   8 8月  18 16:47 multem -> test6.sh*\nwsx@wsx-ubuntu:~/script_learn$ ./addem 2 5\n\nThe calculated value is 7.\nwsx@wsx-ubuntu:~/script_learn$ ./multem 2 5\n\nThe calculated value is 10.\n\n```\n\n这个脚本中创建了两个不同的文件名：一个通过复制创建；另一个通过链接。在两种情况下都会先获得脚本的基本名称，然后根据该值执行相应的功能。\n\n\n\n### 测试参数\n\n如果在脚本中使用了参数，但是运行脚本时没用参数，这会导致错误发生，需要小心。因此我们在使用参数前应该测试。\n\n好比下面这个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test7.sh\n#!/bin/bash\n# testing parameters before use\n#\nif [ -n \"$1\" ] # -n 选项检查字符是否非空\nthen\n\techo Hello $1, glad to meet you.\nelse\n\techo \"Sorry, you did not identify yourself.\"\nfi\n\nwsx@wsx-ubuntu:~/script_learn$ ./test7.sh shixiang\nHello shixiang, glad to meet you.\nwsx@wsx-ubuntu:~/script_learn$ ./test7.sh\nSorry, you did not identify yourself.\n```\n\n\n\n## 特殊参数变量\n\nbash shell中有些特殊变量，它们会记录命令行参数。\n\n\n\n### 参数统计\n\nbash shell提供了一个特殊的变量`$#`来统计命令行中输入了多少个参数。我们可以像使用普通变量一样使用它。\n\n现在能在使用参数前测试参数的总数了。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test9.sh\n#!/bin/bash\n# Testing parameters\n#\nif [ $# -ne 2 ]\nthen\n    echo\n    echo Usage: test9.sh a b\n    echo\nelse\n    total=$[ $1 + $2 ]\n    echo\n    echo The total is $total\n    echo\nfi\n\nwangsx@SC-201708020022:~/tmp$ bash test9.sh\n\nUsage: test9.sh a b\n\nwangsx@SC-201708020022:~/tmp$ bash test9.sh 10\n\nUsage: test9.sh a b\n\nwangsx@SC-201708020022:~/tmp$ bash test9.sh 2 5\n\nThe total is 7\n```\n\n例子中，`if-then`语句用`-ne`测试命令行参数数量。如果参数数量不对，会显示一条错误信息告诉脚本的正确用法。\n\n这个变量还提供了一个简便方法来获取命令行最后一个参数，完全不需要知道实际上有多少个参数。不过要实现它需要花些功夫。\n\n\n也许，我们会有这样的想法，既然`$#`变量含有参数的总数，那么变量`{% raw %}${$#}{% endraw %}`就代表了最后一个命令行参数变量。试试看呗：\n\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test10.sh\n#!/bin/bash\n\n# testing grabbing last parameter\n#\necho The last parameter was ${$#}\n\nwangsx@SC-201708020022:~/tmp$ ./test10.sh 10\nThe last parameter was 65\n\n```\n\n我擦，明显不对。这说明`{% raw %}${$#}{% endraw %}`的用法错误。实际上，花括号能不能使用美元符，必须把它换成感叹号。虽然有点奇怪，但的确有用。\n\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test10.sh\n#!/bin/bash\n\n# testing grabbing last parameter\n#\necho The last parameter was ${!#}\n\nwangsx@SC-201708020022:~/tmp$ ./test10.sh 10\nThe last parameter was 10\nwangsx@SC-201708020022:~/tmp$ ./test10.sh 1 2 3 4 5\nThe last parameter was 5\n```\n\n\n\n### 抓取所有的数据\n\n`$*`与`$@`变量可以用来轻松访问所有的参数。它们都能够在单个变量中存储所有的命令行参数。\n\n`$*`变量会将命令行提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上`$*`变量会将这些参数视为一个整体，而不是多个个体。\n\n`$@`则将所有参数当作同一字符串中的多个独立的单词。这样能够遍历所有的参数值，得到每个参数。这通常交给`for`命令完成。\n\n弄个例子吧，理解两者的区别。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test11.sh\n#!/bin/bash\n# testing $* and $@\n#\necho\necho \"Using then \\$* method: $*\"\necho\necho \"Using the \\$@ method: $@\"\nwangsx@SC-201708020022:~/tmp$ ./test11.sh rich barbara katie jessica\n\nUsing then $* method: rich barbara katie jessica\n\nUsing the $@ method: rich barbara katie jessica\n\n# 下面给出两者差异\nwangsx@SC-201708020022:~/tmp$ cat test12.sh\n#!/bin/bash\necho\ncount=1\n#\nfor param in \"$*\"\ndo\n    echo \"\\$* Parameter #$count = $param\"\n    count=$[ $count + 1 ]\ndone\n#\necho\ncount=1\n#\n\nfor param in \"$@\"\ndo\n    echo \"\\$@ Parameter #$count = $param\"\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~/tmp$ ./test12.sh rich barbara katie jessica\n\n$* Parameter #1 = rich barbara katie jessica\n\n$@ Parameter #1 = rich\n$@ Parameter #2 = barbara\n$@ Parameter #3 = katie\n$@ Parameter #4 = jessica\n```\n\n\n\n## 移动变量\n\nbash shell的`shift`命令能够用来操作命令行参数。默认情况下它会将每个参数变量向左移动一个位置。So, 变量`$3`的值会移到`$2`，`$2`移到`$1`，而`$1`的值会被删除（`$0`的值，也就是脚本名，是不会变的）。\n\n这是遍历命令行参数的另一个好方法，不需要知道参数的个数，我们只需要操作第一个参数，然后移动参数，继续操作第一个参数。\n\n下面解释它怎么工作的：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test13.sh\n#!/bin/bash\n# demonstrating the shift command\n#\necho\ncount=1\nwhile [ -n \"$1\" ]\ndo\n    echo \"Parameter #$count = $1\"\n    count=$[ $count + 1 ]\n    shift\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test13.sh rich barbara katie jessica\n\nParameter #1 = rich\nParameter #2 = barbara\nParameter #3 = katie\nParameter #4 = jessica\n```\n\n> 使用shift命令时需要注意，一旦参数被移除，它的值就被丢弃了 ，无法再恢复。\n\n`shift n`中`n`可以指定移动多个位置。\n\n\n\n## 处理选项\n\n熟悉Linux的朋友必然见过不少同时提供参数和选项的bash命令。选项是跟在但破折线后面的单个字母，它能改变命令的行为。下面介绍3中再脚本中处理选项的方法。\n\n\n\n### 查找选项\n\n只要我们愿意，我们可以像处理命令行参数一样处理命令行选项。\n\n\n\n#### 处理简单选项\n\n前面一节最后我们用`shift`命令来依次处理脚本携带的命令行参数。我们也可以用同样的方法来处理命令行选项。\n\n在提取每个单独参数时，用`case`语句来判断某个参数是否为选项。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test15.sh\n#!/bin/bash\n# extracting command line option as parameter\n#\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n        -a) echo \"Found the -a option\";;\n        -b) echo \"Found the -b option\";;\n        -c) echo \"Found the -c option\";;\n        *)  echo \"$1 is not an option\";;\n    esac\n    shift\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test15.sh -a -b -c -d\n\nFound the -a option\nFound the -b option\nFound the -c option\n-d is not an option\n```\n\n`case`语句在命令行参数中找到一个选项，就处理一个选项。如果命令行上还提供了其他参数，你可以在`case`语句的通用情况处理部分中处理。\n\n\n\n#### 分离参数与选项\n\nshell脚本通常使用选项和参数，Linux中处理这个问题的标准方法是用**特殊字符**来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。\n\n这个所谓的特殊字符就是`--`双破折号。\n\n要检查双破折号，在`case`语句中加一项就行了。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test16.sh\n#!/bin/bash\n# extracting options and paramters\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n        -a) echo \"Found the -a option\";;\n        -b) echo \"Found the -b option\";;\n        -c) echo \"Found the -c option\";;\n        --) shift\n            break ;;\n        *) echo \"$1 is not an option\";;\n    esac\n    shift\ndone\n#\ncount=1\nfor param in $@\ndo\n    echo \"Parameter #$count: $param\"\n    count=$[ $count + 1 ]\ndone\n```\n\n当遇到双破折号时，先把它移除掉，然后跳出循环，这样shell就会把后面的参数当参数而不是选项处理了。\n\n先用一组普通的选项和参数来运行测试脚本：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test16.sh -c -a -b test1 test2 test3\n\nFound the -c option\nFound the -a option\nFound the -b option\ntest1 is not an option\ntest2 is not an option\ntest3 is not an option\n```\n\n现在加上双破折号，进行测试：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test16.sh -c -a -b -- test1 test2 test3\n\nFound the -c option\nFound the -a option\nFound the -b option\nParameter #1: test1\nParameter #2: test2\nParameter #3: test3\n```\n\n可以看到，当脚本遇到双破折号时，它会停止处理选项，并将剩下的参数都当做命令处理。\n\n这样如果顺序填写选项和参数的话，显然没什么问题。但是如果乱序写呢？很显然选项和参数对应不起来。如何解决？\n\n\n\n#### 处理带值的选项\n\n有些选项会带上一个额外的参数值，类似下面：\n\n```shell\n./testing.sh -a test1 -b -c -d test2\n```\n\n下面看看怎么正确处理。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test17.sh\n#!/bin/bash\n# extracting command line options and values\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n        -a) echo \"Found the -a option\";;\n        -b) param=\"$2\"\n            echo \"Found the -b option, with parameter value $param\"\n            shift;;\n        -c) echo \"Found the -c option\";;\n        --) shift\n            break;;\n        *) echo \"$1 is not an option\";;\n    esac\n    shift\ndone\n#\ncount=1\nfor param in \"$@\"\ndo\n    echo \"Paramter #$count: $param\"\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~/tmp$ ./test17.sh -a -b test1 -d\n\nFound the -a option\nFound the -b option, with parameter value test1\n-d is not an option\n```\n\n本例中，定义了3个要处理的选项，`-b`还带一个额外参数。因为处理的选项是`$1`，所以额外参数位于`$2`，另外因为加了额外参数，所以找到后应该用`shift`把它移除（这个选项占了两个位置，需要多移动一个）。\n\n这样，我们可以根据需求进行类似的设定了。不管什么顺序放置选项都可以正常工作。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test17.sh  -b test1 -a -d\n\nFound the -b option, with parameter value test1\nFound the -a option\n-d is not an option\n```\n\n不过，这里还有一些限制。如果我们想把多个选项放在一起，这样就行不通啦~\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test17.sh  -ac\n\n-ac is not an option\n```\n\n而这种功能是Linux常见的喔。那究竟怎么合并选项呢？幸好还有一种处理方法可以帮忙。\n\n\n\n### 使用getopt命令\n\n`getopt`命令是一个处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而更方便地进行解析。\n\n**命令的格式**\n\n```shell\ngetopt optstring parameters\n```\n\n`optstring`是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些字母需要带参数。\n\n**首先，在`optstring`中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。**\n\n> `getopt`的高级版本叫`getoptions`。需要注意区分\n\n下面看看`getopt`如何工作的：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ getopt ab:cd -a -b test1 -cd test2 test3\n -a -b test1 -c -d -- test2 test3\n```\n\n运行完后看到结果感觉自己晕乎乎的，让我们一起来看看解释：\n\n`optstring`定义了四个有效选项字母：a,b,c,d。（嗯，对的，这个没问题）。冒号被放在字母b后面，说明b选项需要一个参数。（这样啊）。当`getopt`命令运行时，它会检查参数列表（就时getopt命令后面跟的），并基于提供的`optstring`进行解析。值得注意，它会自动把`-cd`选项分成两个独立的选项，并插入双破折号来分隔行中的额外参数。\n\n如果指定的选项不在`optstring`中，会报错。`-q`选项可以忽略掉它（注意放在`optstring`之前，因为是命令本身的选项嘛）。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ getopt ab:cd -a -b test1 -cde test2 test3\ngetopt：无效选项 -- e\n -a -b test1 -c -d -- test2 test3\nwangsx@SC-201708020022:~/tmp$ getopt -q ab:cd -a -b test1 -cde test2 test3\n -a -b 'test1' -c -d -- 'test2' 'test3'\n```\n\n\n\n**在脚本中用getopt**\n\n用法稍微有点复杂，方法是用`getopt`命令生成的格式化后的版本替换已有的命令行选项和参数。用`set`可以做到。\n\n```shell\nset -- $(getopt -q ab:cd \"$@)\n```\n\n`set`命令的选项之一是`--`，它会将命令行参数替换成`set`命令的命令行值。\n\n该方法会将原始脚本的命令行参数传给`getopt`命令，之后将`getopt`命令的输出传给`set`命令，用`getopt`格式化的命令行参数来替换原始的命令行参数。\n\n现在写下处理命令行参数的脚本吧：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test18.sh\n#!/bin/bash\n# Extract command line options & values with getopt\n#\nset -- $(getopt -q ab:cd \"$@\")\n#\necho\nwhile [ -n \"$1\" ]\ndo\n    case \"$1\" in\n        -a) echo \"Found the -a option\";;\n        -b) param=\"$2\"\n            echo \"Found the -b option, with parameter value $param\"\n            shift ;;\n        -c) echo \"Found the -c option\";;\n        --) shift\n            break ;;\n        *) echo \"$1 is not an option\"\n    esac\n    shift\ndone\n#\ncount=1\nfor param in \"$@\"\ndo\n    echo \"Parameter #$count: $param\"\n    count=$[ $count + 1 ]\ndone\n#\n```\n\n可以看到它跟`test17.sh`不同的地方是加入了`getopt`命令来帮助格式化命令行参数。\n\n下面测试发现新加的功能实现了，之前的也没问题。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test18.sh -ac\n\nFound the -a option\nFound the -c option\nwangsx@SC-201708020022:~/tmp$ ./test18.sh -a -b test1 -cd  test2 test3 test4\n\nFound the -a option\nFound the -b option, with parameter value 'test1'\nFound the -c option\n-d is not an option\nParameter #1: 'test2'\nParameter #2: 'test3'\nParameter #3: 'test4'\n```\n\n相当不错啦。不过`getopt`命令隐藏一个问题。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test18.sh -a -b test1 -cd  \"test2 test3\" test4\n\nFound the -a option\nFound the -b option, with parameter value 'test1'\nFound the -c option\n-d is not an option\nParameter #1: 'test2\nParameter #2: test3'\nParameter #3: 'test4'\n```\n\n`getopt`命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将两者当作一个参数。\n\n幸而还有办法能够解决这个问题。\n\n\n\n### 使用更高级的getopts\n\n`getopts`命令内建于bash shell。它比`getopt`多一些扩展功能。\n\n`getopts`命令格式如下：\n\n```shell\ngetopts optstring variable\n```\n\n`optstring`值类似于`getopt`命令中的那个。要去掉错误信息的话，可以在`optstring`之前加一个冒号。`getopts`命令将当前参数保存在命令行中定义的`variable`中。\n\n**该命令会用到两个环境变量。如果选项需要跟一个参数值，`OPTARG`环境变量就会保存这个值。`OPTIND`环境变量保存了参数列表中`getopts`正在处理的参数位置。这样你就能在处理选项之后继续处理其他命令行参数了。**\n\n空说无益，还是来练练。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test19.sh\n#!/bin/bash\n# Simple demonstration of the getopts command\n#\necho\nwhile getopts :ab:c opt\ndo\n    case \"$opt\" in\n       a) echo \"Found the -a option\" ;;\n       b) echo \"Found the -b option, with value $OPTARG\";;\n       c) echo \"Found the -c option\";;\n       *) echo \"Unknown option: $opt\";;\n   esac\ndone\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -ab test1 -c\n\nFound the -a option\nFound the -b option, with value test1\nFound the -c option\n```\n\n`while`语句定义了`getopts`命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（`opt`）。\n\n`getopts`运行时，它一次只处理命令行上检测到的一个参数。处理完所有参数后，它会退出并返回一个大于0的退出状态码。这让它非常适合用于解析命令行所有的参数的循环中。\n\n这里我们可以已经注意到了例子中的`case`用法和之前不同。`getopts`命令解析命令行选项时会移除开头的单破折号，所以在`case`定义中不用单破折号了。\n\n上一小节末尾我们遇到的问题可以很好的解决了：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -ab \"test1 test2\" -c\n\nFound the -a option\nFound the -b option, with value test1 test2\nFound the -c option\n```\n\n另一个好用的功能是能够将选项字母和参数值放在一起，而且不用加空格。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -abtest1\n\nFound the -a option\nFound the -b option, with value test1\n```\n\n除此之外，`getopts`还能够将命令行上找到的所有未定义的选项统一输出成问号。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -d\n\nUnknown option: ?\nwangsx@SC-201708020022:~/tmp$ ./test19.sh -acde\n\nFound the -a option\nFound the -c option\nUnknown option: ?\nUnknown option: ?\n```\n\n`getopts`命令知道何时停止处理选项，并将参数留给你处理。在`getopts`处理每一个选项时，它会将`OPTIND`环境变量值增一。在`getopts`完成处理后，你可以使用`shift`命令和`OPTIND`值来移动参数。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test20.sh\n#!/bin/bash\n# Processing options & parameters with getopts\n#\necho\nwhile getopts :ab:cd opt\ndo\n    case \"$opt\" in\n        a) echo \"Found the -a option\" ;;\n        b) echo \"Found the -a option, with value $OPTARG\" ;;\n        c) echo \"Found the -c option\" ;;\n        d) echo \"Found the -d option\" ;;\n        *) echo \"Unknown option: $opt\" ;;\n    esac\ndone\n#\nshift $[ $OPTIND -1 ]\n#\necho\ncount=1\nfor param in  \"$@\"\ndo\n    echo \"Parameter $count: $param\"\n    count=$[ $count + 1 ]\ndone\n\nwangsx@SC-201708020022:~/tmp$ ./test20.sh -a -b test1 -d test2 test3 test4\n\nFound the -a option\nFound the -a option, with value test1\nFound the -d option\n\nParameter 1: test2\nParameter 2: test3\nParameter 3: test4\n```\n\n这里`shift $[ $OPTIND -1 ]`需要解释以下：前面提到`OPTIND`在`getopts`每次处理掉一个参数后会加1。比如`./test20.sh -a -b test1 -d test2 test3 test4`前面键入了4个参数，选项处理完成后`OPTIND`的值为5。它会指向`$5`，即第5个参数，后面为了值剩下命令行参数，所以去掉所有的选项（及带的参数），所以用`shift $[ $OPTIND - 1]`命令。\n\n\n\n## 将选项标准化\n\n有些字母在Linux世界里已经拥有了某种程度的标准含义。如果我们能在shellji奥本中支持这些选项，脚本看起来会更加友好。\n\n下面表格列出一些命令行选项的常用含义\n\n|  选项  |        描述        |\n| :--: | :--------------: |\n|  -a  |      显示所有对象      |\n|  -c  |      生成一个计数      |\n|  -d  |      指定一个目录      |\n|  -e  |      扩展一个对象      |\n|  -f  |    指定读入数据的文件     |\n|  -h  |    显示命令的帮助信息     |\n|  -i  |     忽略文本大小写      |\n|  -l  |    产生输出的长格式版本    |\n|  -n  |   使用非交互模式（批处理）   |\n|  -o  | 将所有输出重定向到指定的输出文件 |\n|  -q  |     以安静模式运行      |\n|  -r  |    递归地处理目录和文件    |\n|  -s  |     以安静模式运行      |\n|  -v  |      生成详细输出      |\n|  -x  |      排除某个对象      |\n|  -y  |    对所有问题答yes     |\n\n\n\n## 获得用户输入\n\n有时脚本地交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本地人来回答。bash shell为此提供了read命令。\n\n\n\n### 基本的读入\n\n`read`命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，`read`命令会将数据放进一个变量。\n\n简单用法如下：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test21.sh\n#!/bin/bash\n# testing the read -p option\n#\nread -p \"Please enter your age: \" age\n#\ndays=$[ $age * 365 ]\necho \"That makes you over $days days old!\"\n#\nwangsx@SC-201708020022:~/tmp$ ./test21.sh\nPlease enter your age: 23\nThat makes you over 8395 days old!\n```\n\n`read`命令会将提示符后输入的所有数据分配给单个变量，要么我们需要指定多个变量。当变量数量不够时，剩下的数据就全部分配给最后一个变量。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test22.sh\n#!/bin/bash\n# entering multiple variable\n#\nread -p \"Enter your name: \" first last\necho \"Checking data for $last, $first...\"\n\nwangsx@SC-201708020022:~/tmp$ ./test22.sh\nEnter your name: shixiang wang\nChecking data for wang, shixiang...\nwangsx@SC-201708020022:~/tmp$ ./test22.sh\nEnter your name: shixiang wang hhhhh\nChecking data for wang hhhhh, shixiang...\n```\n\n也可以在`read`命令行中不指定变量。如果这样的话，`read`命令会将它收到的任何数据都放进特殊环境变量`REPLY`中。我们直接可以使用它。\n\n\n\n### 超时\n\n脚本很可能一直苦苦等待脚本用户的输入。如果不管数据是否输入，脚本都执行的话，我们可以用`-t`选项设定一个计时器。`-t`指定`read`命令等待的秒数，计数完成后，`read`命令会返回一个非零退出状态码。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test23.sh\n#!/bin/bash\n# timing the data entry\n#\nif read -t 5 -p \"Please enter your name: \" name\nthen\n    echo \"Hello $name, welcome to my script\"\nelse\n    echo\n    echo \"Sorry, too slow!\"\nfi\n\nwangsx@SC-201708020022:~/tmp$ ./test23.sh\nPlease enter your name: shixiang wang\nHello shixiang wang, welcome to my script\nwangsx@SC-201708020022:~/tmp$ ./test23.sh # 这里输入后等以下 不要输入\nPlease enter your name:\nSorry, too slow!\n```\n\n\n\n也可以不对输入过程计时，而时让`read`命令来统计输入的字符数。当输入的字符数达到预设的字符数时，就自动退出，将输入的数据赋值给变量。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test24.sh\n#!/bin/bash\n# getting just one character of input\n#\nread -n1 -p \"Do you want to continue [Y/N]? \" answer\ncase $answer in\n    Y | y ) echo\n            echo \"fine, continue on...\";;\n    N | n ) echo\n            echo OK, goodbye\n            exit;;\nesac\necho \"This is the end of the script.\"\nwangsx@SC-201708020022:~/tmp$ ./test24.sh\nDo you want to continue [Y/N]? Y\nfine, continue on...\nThis is the end of the script.\nwangsx@SC-201708020022:~/tmp$ ./test24.sh\nDo you want to continue [Y/N]? n\nOK, goodbye\n```\n\n\n\n### 隐藏方式读取\n\n这种方式输入密码的时候有用。\n\n`-s`选项可以避免在`read`命令输入的数据出现在显示器上（实际上，数据会被显示，只是`read`命令会将文本颜色设成跟背景色一样）。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test25.sh\n#!/bin/bash\n# hiding input data from the monitor\n#\nread -s -p \"Enter your password: \" pass\necho\necho \"Is your password really $pass?\"\nwangsx@SC-201708020022:~/tmp$ ./test25.sh\nEnter your password:\nIs your password really what?\nwangsx@SC-201708020022:~/tmp$ ./test25.sh\nEnter your password:\nIs your password really shixiang?\n```\n\n\n\n### 从文件中读取\n\n当然，`read`也可以从系统文件中读取数据。每次调用`read`命令，它都会读取一行文本。当读完后，`read`命令会退出并返回非零退出状态码。\n\n最常见的方法时对文本使用`cat`命令，将结果通过管道直接传给含`read`命令的`while`命令。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test26.sh\n#!/bin/bash\n# reading data from a file\n#\ncount=1\ncat test | while read line\ndo\n    echo \"Line $count: $line\"\n    count=$[ $count + 1 ]\ndone\necho \"Finished processing the file\"\n\nwangsx@SC-201708020022:~/tmp$ cat test\nThe quick brown dog jumps over the lazy fox.\nThis is a test, this is only a test.\nO Romeo, Romeo! Wherefore art thou Romeo?\nwangsx@SC-201708020022:~/tmp$ ./test26.sh\nLine 1: The quick brown dog jumps over the lazy fox.\nLine 2: This is a test, this is only a test.\nLine 3: O Romeo, Romeo! Wherefore art thou Romeo?\nFinished processing the file\n```\n\n\n\n\n\n------------------------\n\n写shell脚本的基本内容大体已经整完了，我自己也是边看边想边码过来的。shell博大精深，更多高级内容有待继续学习整理。码字实属不易，觉得内容还行的点赞支持下吧~\n","slug":"working-with-user-input","published":1,"updated":"2018-01-27T04:08:11.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwtu00029tax6ywo9ajr","content":"<p><strong>Shell脚本笔记系列：</strong></p>\n<p><a href=\"http://www.flypeom.site/linux/2017/08/11/basic-shell/\" target=\"_blank\" rel=\"noopener\">构建基本shell脚本</a></p>\n<p><a href=\"http://www.flypeom.site/linux/2017/08/11/structural-command-of-shell/\" target=\"_blank\" rel=\"noopener\">Linux结构化命令</a></p>\n<blockquote>\n<p>内容：</p>\n<ul>\n<li>传递参数</li>\n<li>跟踪参数</li>\n<li>移动变量</li>\n<li>处理选项</li>\n<li>将选项标准化</li>\n<li>获得用户输入</li>\n</ul>\n</blockquote>\n<p>经过前面的介绍，我们已经可以掌握一些流程化的脚本编程了。但有时候，我们需要编写的脚本能够跟使用者进行交互。它可以是静态的，输入相应的参数让它运行到底；也可以是动态的，脚本根据输入参数反馈不同的信息，使用者又能根据信息调整下一步的处理，实时与程序互动。</p>\n<p>bash shell提供了一些不同的方法来从<strong>用户处获得数据，包括命令行参数、命令行选项以及直接从键盘读取输入</strong>的能力。下面将一一介绍实现。</p>\n<a id=\"more\"></a>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><p>使用命令行参数是向脚本传递数据的最基本方法，在运行脚本的同时可以在命令行添加数据。</p>\n<p>比如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./addem 10 30</span><br></pre></td></tr></table></figure>\n<p>运行当前目录下名为<code>addem</code>脚本的同时向内部传递2个参数（10和30）。而脚本会通过特殊的变量来处理命令行参数。</p>\n<p>下面介绍如何使用它们。</p>\n<h3 id=\"读入参数\"><a href=\"#读入参数\" class=\"headerlink\" title=\"读入参数\"></a>读入参数</h3><p>bash shell会将称为<strong>位置参数</strong>的特殊变量分配给输入到命令行的所有参数：<code>$0</code>是程序名，<code>$1</code>是第一个参数，<code>$2</code>是第二个参数，以此类推。书上介绍直到第九个参数<code>$9</code>，但这个应该不是受限的。<a href=\"http://www.cnblogs.com/ivictor/p/4022382.html\" target=\"_blank\" rel=\"noopener\">Shell最多可以输入多少个参数？</a>一文探索了参数的个数限制，有兴趣的朋友不妨看看和试试。</p>\n<p>下面是单个参数的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using one <span class=\"built_in\">command</span> line parameter</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">factorial=1</span><br><span class=\"line\">for (( number = 1; number &lt;= $1; number++ ))</span><br><span class=\"line\">do</span><br><span class=\"line\">truefactorial=$[ $factorial * $number ]</span><br><span class=\"line\">done</span><br><span class=\"line\">echo The factorial of $1 is $factorial</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1.sh 5</span><br><span class=\"line\">The factorial of 5 is 120</span><br></pre></td></tr></table></figure>\n<p>我们可以像使用其他变量一样使用<code>$1</code>变量。shell脚本会自动分配，不需要我们做任何处理。可以看得出来这样非常方便，不过如果输入参数过多，很容易让人混淆。</p>\n<p>如果需要输入更多的参数，只需要用空格分隔即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test2.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using two <span class=\"built_in\">command</span> line parameters</span></span><br><span class=\"line\"></span><br><span class=\"line\">total=$[ $1 * $2 ]</span><br><span class=\"line\">echo The first parameter is $1.</span><br><span class=\"line\">echo The second parameter is $2.</span><br><span class=\"line\">echo The total value is $total.</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test2.sh 2 5</span><br><span class=\"line\">The first parameter is 2.</span><br><span class=\"line\">The second parameter is 5.</span><br><span class=\"line\">The total value is 10.</span><br></pre></td></tr></table></figure>\n<p>字符参数也是一样的。如果我没记错，在脚本中的数字默认都是做字符处理的，进行数学运算时会自动调整。不过当我们想要输入的一个参数是带空格的字符串时，需要在两边加上引号以保证shell能够正确识别。不然会被当做多个参数处理的。</p>\n<p>下面取个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test3.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo Hello $1, glad to meet you.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3.sh shixiang wang</span><br><span class=\"line\">Hello shixiang, glad to meet you.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3.sh 'shixiang wang'</span><br><span class=\"line\">Hello shixiang wang, glad to meet you.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3.sh \"shixiang wang\"</span><br><span class=\"line\">Hello shixiang wang, glad to meet you.</span><br></pre></td></tr></table></figure>\n<p>看来使用时要注意正确使用引号喔。</p>\n<blockquote>\n<p>说明：在文本字符串作为参数传递时，引号并非数据的一部分。它们只是表明数据的起止位置。</p>\n</blockquote>\n<p>如果需要输入的命令行参数不止9个，写脚本需要修改一下变量名（第9个之后）。比如<code>${10}</code>表示输入的第十个变量（原来如此啊）。</p>\n<p>这样我们就可以向脚本添加任意多的参数啦～</p>\n<p>前面也说了，<code>$0</code>参数可以获取脚本名，这样在编程的时候很方便。但是这里存在一个潜在的问题：如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在<code>$0</code>中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test4.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing the <span class=\"variable\">$0</span> parameter</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo The zero parameter is set to: $0</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test4.sh</span><br><span class=\"line\">The zero parameter is set to: ./test4.sh</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ bash test4.sh</span><br><span class=\"line\">The zero parameter is set to: test4.sh</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ bash ~/script_learn/test4.sh</span><br><span class=\"line\">The zero parameter is set to: /home/wsx/script_learn/test4.sh</span><br></pre></td></tr></table></figure>\n<p>而且，你发现没有，当指明脚本路径时，这个路径也会带入其中。</p>\n<p>如果我们要编写一个根据脚本名来执行不同功能的脚本，就得把脚本的运行路径剥离掉。还要删除与脚本名混在一起的命令。幸好有一个方便的小命令<code>basename</code>可以帮助我们返回不包含路径的脚本名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test5.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Using basename with the <span class=\"variable\">$0</span> parameter</span></span><br><span class=\"line\"></span><br><span class=\"line\">name=$(basename $0)</span><br><span class=\"line\">echo</span><br><span class=\"line\">echo The script name is: $name</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ bash ~/script_learn/test5.sh</span><br><span class=\"line\"></span><br><span class=\"line\">The script name is: test5.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test5.sh</span><br><span class=\"line\"></span><br><span class=\"line\">The script name is: test5.sh</span><br></pre></td></tr></table></figure>\n<p>下面编写基于脚本名执行不同功能的脚本。挺有意思的，我们看看吧：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test6.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing a Multi-function script</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">name=$(basename $0)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [ $name = \"addem\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">truetotal=$[ $1 + $2 ]</span><br><span class=\"line\">elif [ $name = \"multem\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">truetotal=$[ $1 * $2 ]</span><br><span class=\"line\">fi</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">echo The calculated value is $total.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cp test6.sh addem</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x addem</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ln -s test6.sh multem</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ll *em</span><br><span class=\"line\">-rwxrw-r-- 1 wsx wsx 216 8月  18 16:47 addem*</span><br><span class=\"line\">lrwxrwxrwx 1 wsx wsx   8 8月  18 16:47 multem -&gt; test6.sh*</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./addem 2 5</span><br><span class=\"line\"></span><br><span class=\"line\">The calculated value is 7.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./multem 2 5</span><br><span class=\"line\"></span><br><span class=\"line\">The calculated value is 10.</span><br></pre></td></tr></table></figure>\n<p>这个脚本中创建了两个不同的文件名：一个通过复制创建；另一个通过链接。在两种情况下都会先获得脚本的基本名称，然后根据该值执行相应的功能。</p>\n<h3 id=\"测试参数\"><a href=\"#测试参数\" class=\"headerlink\" title=\"测试参数\"></a>测试参数</h3><p>如果在脚本中使用了参数，但是运行脚本时没用参数，这会导致错误发生，需要小心。因此我们在使用参数前应该测试。</p>\n<p>好比下面这个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test7.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing parameters before use</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [ -n \"$1\" ] # -n 选项检查字符是否非空</span><br><span class=\"line\">then</span><br><span class=\"line\">trueecho Hello $1, glad to meet you.</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"Sorry, you did not identify yourself.\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test7.sh shixiang</span><br><span class=\"line\">Hello shixiang, glad to meet you.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test7.sh</span><br><span class=\"line\">Sorry, you did not identify yourself.</span><br></pre></td></tr></table></figure>\n<h2 id=\"特殊参数变量\"><a href=\"#特殊参数变量\" class=\"headerlink\" title=\"特殊参数变量\"></a>特殊参数变量</h2><p>bash shell中有些特殊变量，它们会记录命令行参数。</p>\n<h3 id=\"参数统计\"><a href=\"#参数统计\" class=\"headerlink\" title=\"参数统计\"></a>参数统计</h3><p>bash shell提供了一个特殊的变量<code>$#</code>来统计命令行中输入了多少个参数。我们可以像使用普通变量一样使用它。</p>\n<p>现在能在使用参数前测试参数的总数了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test9.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing parameters</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [ $# -ne 2 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">    echo</span><br><span class=\"line\">    echo Usage: test9.sh a b</span><br><span class=\"line\">    echo</span><br><span class=\"line\">else</span><br><span class=\"line\">    total=$[ $1 + $2 ]</span><br><span class=\"line\">    echo</span><br><span class=\"line\">    echo The total is $total</span><br><span class=\"line\">    echo</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ bash test9.sh</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: test9.sh a b</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ bash test9.sh 10</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: test9.sh a b</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ bash test9.sh 2 5</span><br><span class=\"line\"></span><br><span class=\"line\">The total is 7</span><br></pre></td></tr></table></figure>\n<p>例子中，<code>if-then</code>语句用<code>-ne</code>测试命令行参数数量。如果参数数量不对，会显示一条错误信息告诉脚本的正确用法。</p>\n<p>这个变量还提供了一个简便方法来获取命令行最后一个参数，完全不需要知道实际上有多少个参数。不过要实现它需要花些功夫。</p>\n<p>也许，我们会有这样的想法，既然<code>$#</code>变量含有参数的总数，那么变量<code>${$#}</code>就代表了最后一个命令行参数变量。试试看呗：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test10.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing grabbing last parameter</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo The last parameter was $&#123;$#&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh 10</span><br><span class=\"line\">The last parameter was 65</span><br></pre></td></tr></table></figure>\n<p>我擦，明显不对。这说明<code>${$#}</code>的用法错误。实际上，花括号能不能使用美元符，必须把它换成感叹号。虽然有点奇怪，但的确有用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test10.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing grabbing last parameter</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo The last parameter was $&#123;!#&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh 10</span><br><span class=\"line\">The last parameter was 10</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh 1 2 3 4 5</span><br><span class=\"line\">The last parameter was 5</span><br></pre></td></tr></table></figure>\n<h3 id=\"抓取所有的数据\"><a href=\"#抓取所有的数据\" class=\"headerlink\" title=\"抓取所有的数据\"></a>抓取所有的数据</h3><p><code>$*</code>与<code>$@</code>变量可以用来轻松访问所有的参数。它们都能够在单个变量中存储所有的命令行参数。</p>\n<p><code>$*</code>变量会将命令行提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上<code>$*</code>变量会将这些参数视为一个整体，而不是多个个体。</p>\n<p><code>$@</code>则将所有参数当作同一字符串中的多个独立的单词。这样能够遍历所有的参数值，得到每个参数。这通常交给<code>for</code>命令完成。</p>\n<p>弄个例子吧，理解两者的区别。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test11.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing $* and <span class=\"variable\">$@</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">echo \"Using then \\$* method: $*\"</span><br><span class=\"line\">echo</span><br><span class=\"line\">echo \"Using the \\$@ method: $@\"</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test11.sh rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\">Using then $* method: rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\">Using the $@ method: rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 下面给出两者差异</span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test12.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">echo</span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">for param in \"$*\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"\\$* Parameter #$count = $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"></span><br><span class=\"line\">for param in \"$@\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"\\$@ Parameter #$count = $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test12.sh rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">* Parameter <span class=\"comment\">#1 = rich barbara katie jessica</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ Parameter <span class=\"comment\">#1 = rich</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ Parameter <span class=\"comment\">#2 = barbara</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ Parameter <span class=\"comment\">#3 = katie</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ Parameter <span class=\"comment\">#4 = jessica</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"移动变量\"><a href=\"#移动变量\" class=\"headerlink\" title=\"移动变量\"></a>移动变量</h2><p>bash shell的<code>shift</code>命令能够用来操作命令行参数。默认情况下它会将每个参数变量向左移动一个位置。So, 变量<code>$3</code>的值会移到<code>$2</code>，<code>$2</code>移到<code>$1</code>，而<code>$1</code>的值会被删除（<code>$0</code>的值，也就是脚本名，是不会变的）。</p>\n<p>这是遍历命令行参数的另一个好方法，不需要知道参数的个数，我们只需要操作第一个参数，然后移动参数，继续操作第一个参数。</p>\n<p>下面解释它怎么工作的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test13.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> demonstrating the <span class=\"built_in\">shift</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Parameter #$count = $1\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test13.sh rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\">Parameter #1 = rich</span><br><span class=\"line\">Parameter #2 = barbara</span><br><span class=\"line\">Parameter #3 = katie</span><br><span class=\"line\">Parameter #4 = jessica</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用shift命令时需要注意，一旦参数被移除，它的值就被丢弃了 ，无法再恢复。</p>\n</blockquote>\n<p><code>shift n</code>中<code>n</code>可以指定移动多个位置。</p>\n<h2 id=\"处理选项\"><a href=\"#处理选项\" class=\"headerlink\" title=\"处理选项\"></a>处理选项</h2><p>熟悉Linux的朋友必然见过不少同时提供参数和选项的bash命令。选项是跟在但破折线后面的单个字母，它能改变命令的行为。下面介绍3中再脚本中处理选项的方法。</p>\n<h3 id=\"查找选项\"><a href=\"#查找选项\" class=\"headerlink\" title=\"查找选项\"></a>查找选项</h3><p>只要我们愿意，我们可以像处理命令行参数一样处理命令行选项。</p>\n<h4 id=\"处理简单选项\"><a href=\"#处理简单选项\" class=\"headerlink\" title=\"处理简单选项\"></a>处理简单选项</h4><p>前面一节最后我们用<code>shift</code>命令来依次处理脚本携带的命令行参数。我们也可以用同样的方法来处理命令行选项。</p>\n<p>在提取每个单独参数时，用<code>case</code>语句来判断某个参数是否为选项。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test15.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> extracting <span class=\"built_in\">command</span> line option as parameter</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$1\" in</span><br><span class=\"line\">        -a) echo \"Found the -a option\";;</span><br><span class=\"line\">        -b) echo \"Found the -b option\";;</span><br><span class=\"line\">        -c) echo \"Found the -c option\";;</span><br><span class=\"line\">        *)  echo \"$1 is not an option\";;</span><br><span class=\"line\">    esac</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test15.sh -a -b -c -d</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">-d is not an option</span><br></pre></td></tr></table></figure>\n<p><code>case</code>语句在命令行参数中找到一个选项，就处理一个选项。如果命令行上还提供了其他参数，你可以在<code>case</code>语句的通用情况处理部分中处理。</p>\n<h4 id=\"分离参数与选项\"><a href=\"#分离参数与选项\" class=\"headerlink\" title=\"分离参数与选项\"></a>分离参数与选项</h4><p>shell脚本通常使用选项和参数，Linux中处理这个问题的标准方法是用<strong>特殊字符</strong>来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。</p>\n<p>这个所谓的特殊字符就是<code>--</code>双破折号。</p>\n<p>要检查双破折号，在<code>case</code>语句中加一项就行了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test16.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> extracting options and paramters</span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$1\" in</span><br><span class=\"line\">        -a) echo \"Found the -a option\";;</span><br><span class=\"line\">        -b) echo \"Found the -b option\";;</span><br><span class=\"line\">        -c) echo \"Found the -c option\";;</span><br><span class=\"line\">        --) shift</span><br><span class=\"line\">            break ;;</span><br><span class=\"line\">        *) echo \"$1 is not an option\";;</span><br><span class=\"line\">    esac</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">for param in $@</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Parameter #$count: $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>当遇到双破折号时，先把它移除掉，然后跳出循环，这样shell就会把后面的参数当参数而不是选项处理了。</p>\n<p>先用一组普通的选项和参数来运行测试脚本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test16.sh -c -a -b test1 test2 test3</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option</span><br><span class=\"line\">test1 is not an option</span><br><span class=\"line\">test2 is not an option</span><br><span class=\"line\">test3 is not an option</span><br></pre></td></tr></table></figure>\n<p>现在加上双破折号，进行测试：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test16.sh -c -a -b -- test1 test2 test3</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option</span><br><span class=\"line\">Parameter #1: test1</span><br><span class=\"line\">Parameter #2: test2</span><br><span class=\"line\">Parameter #3: test3</span><br></pre></td></tr></table></figure>\n<p>可以看到，当脚本遇到双破折号时，它会停止处理选项，并将剩下的参数都当做命令处理。</p>\n<p>这样如果顺序填写选项和参数的话，显然没什么问题。但是如果乱序写呢？很显然选项和参数对应不起来。如何解决？</p>\n<h4 id=\"处理带值的选项\"><a href=\"#处理带值的选项\" class=\"headerlink\" title=\"处理带值的选项\"></a>处理带值的选项</h4><p>有些选项会带上一个额外的参数值，类似下面：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./testing.sh -a test1 -b -c -d test2</span><br></pre></td></tr></table></figure>\n<p>下面看看怎么正确处理。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test17.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> extracting <span class=\"built_in\">command</span> line options and values</span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$1\" in</span><br><span class=\"line\">        -a) echo \"Found the -a option\";;</span><br><span class=\"line\">        -b) param=\"$2\"</span><br><span class=\"line\">            echo \"Found the -b option, with parameter value $param\"</span><br><span class=\"line\">            shift;;</span><br><span class=\"line\">        -c) echo \"Found the -c option\";;</span><br><span class=\"line\">        --) shift</span><br><span class=\"line\">            break;;</span><br><span class=\"line\">        *) echo \"$1 is not an option\";;</span><br><span class=\"line\">    esac</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">for param in \"$@\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Paramter #$count: $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test17.sh -a -b test1 -d</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with parameter value test1</span><br><span class=\"line\">-d is not an option</span><br></pre></td></tr></table></figure>\n<p>本例中，定义了3个要处理的选项，<code>-b</code>还带一个额外参数。因为处理的选项是<code>$1</code>，所以额外参数位于<code>$2</code>，另外因为加了额外参数，所以找到后应该用<code>shift</code>把它移除（这个选项占了两个位置，需要多移动一个）。</p>\n<p>这样，我们可以根据需求进行类似的设定了。不管什么顺序放置选项都可以正常工作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test17.sh  -b test1 -a -d</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -b option, with parameter value test1</span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">-d is not an option</span><br></pre></td></tr></table></figure>\n<p>不过，这里还有一些限制。如果我们想把多个选项放在一起，这样就行不通啦~</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test17.sh  -ac</span><br><span class=\"line\"></span><br><span class=\"line\">-ac is not an option</span><br></pre></td></tr></table></figure>\n<p>而这种功能是Linux常见的喔。那究竟怎么合并选项呢？幸好还有一种处理方法可以帮忙。</p>\n<h3 id=\"使用getopt命令\"><a href=\"#使用getopt命令\" class=\"headerlink\" title=\"使用getopt命令\"></a>使用getopt命令</h3><p><code>getopt</code>命令是一个处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而更方便地进行解析。</p>\n<p><strong>命令的格式</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getopt optstring parameters</span><br></pre></td></tr></table></figure>\n<p><code>optstring</code>是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些字母需要带参数。</p>\n<p><strong>首先，在<code>optstring</code>中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。</strong></p>\n<blockquote>\n<p><code>getopt</code>的高级版本叫<code>getoptions</code>。需要注意区分</p>\n</blockquote>\n<p>下面看看<code>getopt</code>如何工作的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ getopt ab:cd -a -b test1 -cd test2 test3</span><br><span class=\"line\"> -a -b test1 -c -d -- test2 test3</span><br></pre></td></tr></table></figure>\n<p>运行完后看到结果感觉自己晕乎乎的，让我们一起来看看解释：</p>\n<p><code>optstring</code>定义了四个有效选项字母：a,b,c,d。（嗯，对的，这个没问题）。冒号被放在字母b后面，说明b选项需要一个参数。（这样啊）。当<code>getopt</code>命令运行时，它会检查参数列表（就时getopt命令后面跟的），并基于提供的<code>optstring</code>进行解析。值得注意，它会自动把<code>-cd</code>选项分成两个独立的选项，并插入双破折号来分隔行中的额外参数。</p>\n<p>如果指定的选项不在<code>optstring</code>中，会报错。<code>-q</code>选项可以忽略掉它（注意放在<code>optstring</code>之前，因为是命令本身的选项嘛）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ getopt ab:cd -a -b test1 -cde test2 test3</span><br><span class=\"line\">getopt：无效选项 -- e</span><br><span class=\"line\"> -a -b test1 -c -d -- test2 test3</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ getopt -q ab:cd -a -b test1 -cde test2 test3</span><br><span class=\"line\"> -a -b 'test1' -c -d -- 'test2' 'test3'</span><br></pre></td></tr></table></figure>\n<p><strong>在脚本中用getopt</strong></p>\n<p>用法稍微有点复杂，方法是用<code>getopt</code>命令生成的格式化后的版本替换已有的命令行选项和参数。用<code>set</code>可以做到。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set -- $(getopt -q ab:cd \"$@)</span><br></pre></td></tr></table></figure>\n<p><code>set</code>命令的选项之一是<code>--</code>，它会将命令行参数替换成<code>set</code>命令的命令行值。</p>\n<p>该方法会将原始脚本的命令行参数传给<code>getopt</code>命令，之后将<code>getopt</code>命令的输出传给<code>set</code>命令，用<code>getopt</code>格式化的命令行参数来替换原始的命令行参数。</p>\n<p>现在写下处理命令行参数的脚本吧：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test18.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Extract <span class=\"built_in\">command</span> line options &amp; values with getopt</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">set -- $(getopt -q ab:cd \"$@\")</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$1\" in</span><br><span class=\"line\">        -a) echo \"Found the -a option\";;</span><br><span class=\"line\">        -b) param=\"$2\"</span><br><span class=\"line\">            echo \"Found the -b option, with parameter value $param\"</span><br><span class=\"line\">            shift ;;</span><br><span class=\"line\">        -c) echo \"Found the -c option\";;</span><br><span class=\"line\">        --) shift</span><br><span class=\"line\">            break ;;</span><br><span class=\"line\">        *) echo \"$1 is not an option\"</span><br><span class=\"line\">    esac</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">for param in \"$@\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Parameter #$count: $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n<p>可以看到它跟<code>test17.sh</code>不同的地方是加入了<code>getopt</code>命令来帮助格式化命令行参数。</p>\n<p>下面测试发现新加的功能实现了，之前的也没问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test18.sh -ac</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test18.sh -a -b test1 -cd  test2 test3 test4</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with parameter value 'test1'</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">-d is not an option</span><br><span class=\"line\">Parameter #1: 'test2'</span><br><span class=\"line\">Parameter #2: 'test3'</span><br><span class=\"line\">Parameter #3: 'test4'</span><br></pre></td></tr></table></figure>\n<p>相当不错啦。不过<code>getopt</code>命令隐藏一个问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test18.sh -a -b test1 -cd  \"test2 test3\" test4</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with parameter value 'test1'</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">-d is not an option</span><br><span class=\"line\">Parameter #1: 'test2</span><br><span class=\"line\">Parameter #2: test3'</span><br><span class=\"line\">Parameter #3: 'test4'</span><br></pre></td></tr></table></figure>\n<p><code>getopt</code>命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将两者当作一个参数。</p>\n<p>幸而还有办法能够解决这个问题。</p>\n<h3 id=\"使用更高级的getopts\"><a href=\"#使用更高级的getopts\" class=\"headerlink\" title=\"使用更高级的getopts\"></a>使用更高级的getopts</h3><p><code>getopts</code>命令内建于bash shell。它比<code>getopt</code>多一些扩展功能。</p>\n<p><code>getopts</code>命令格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getopts optstring variable</span><br></pre></td></tr></table></figure>\n<p><code>optstring</code>值类似于<code>getopt</code>命令中的那个。要去掉错误信息的话，可以在<code>optstring</code>之前加一个冒号。<code>getopts</code>命令将当前参数保存在命令行中定义的<code>variable</code>中。</p>\n<p><strong>该命令会用到两个环境变量。如果选项需要跟一个参数值，<code>OPTARG</code>环境变量就会保存这个值。<code>OPTIND</code>环境变量保存了参数列表中<code>getopts</code>正在处理的参数位置。这样你就能在处理选项之后继续处理其他命令行参数了。</strong></p>\n<p>空说无益，还是来练练。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test19.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Simple demonstration of the <span class=\"built_in\">getopts</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while getopts :ab:c opt</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$opt\" in</span><br><span class=\"line\">       a) echo \"Found the -a option\" ;;</span><br><span class=\"line\">       b) echo \"Found the -b option, with value $OPTARG\";;</span><br><span class=\"line\">       c) echo \"Found the -c option\";;</span><br><span class=\"line\">       *) echo \"Unknown option: $opt\";;</span><br><span class=\"line\">   esac</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -ab test1 -c</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with value test1</span><br><span class=\"line\">Found the -c option</span><br></pre></td></tr></table></figure>\n<p><code>while</code>语句定义了<code>getopts</code>命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（<code>opt</code>）。</p>\n<p><code>getopts</code>运行时，它一次只处理命令行上检测到的一个参数。处理完所有参数后，它会退出并返回一个大于0的退出状态码。这让它非常适合用于解析命令行所有的参数的循环中。</p>\n<p>这里我们可以已经注意到了例子中的<code>case</code>用法和之前不同。<code>getopts</code>命令解析命令行选项时会移除开头的单破折号，所以在<code>case</code>定义中不用单破折号了。</p>\n<p>上一小节末尾我们遇到的问题可以很好的解决了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -ab \"test1 test2\" -c</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with value test1 test2</span><br><span class=\"line\">Found the -c option</span><br></pre></td></tr></table></figure>\n<p>另一个好用的功能是能够将选项字母和参数值放在一起，而且不用加空格。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -abtest1</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with value test1</span><br></pre></td></tr></table></figure>\n<p>除此之外，<code>getopts</code>还能够将命令行上找到的所有未定义的选项统一输出成问号。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -d</span><br><span class=\"line\"></span><br><span class=\"line\">Unknown option: ?</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -acde</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">Unknown option: ?</span><br><span class=\"line\">Unknown option: ?</span><br></pre></td></tr></table></figure>\n<p><code>getopts</code>命令知道何时停止处理选项，并将参数留给你处理。在<code>getopts</code>处理每一个选项时，它会将<code>OPTIND</code>环境变量值增一。在<code>getopts</code>完成处理后，你可以使用<code>shift</code>命令和<code>OPTIND</code>值来移动参数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test20.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Processing options &amp; parameters with <span class=\"built_in\">getopts</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while getopts :ab:cd opt</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$opt\" in</span><br><span class=\"line\">        a) echo \"Found the -a option\" ;;</span><br><span class=\"line\">        b) echo \"Found the -a option, with value $OPTARG\" ;;</span><br><span class=\"line\">        c) echo \"Found the -c option\" ;;</span><br><span class=\"line\">        d) echo \"Found the -d option\" ;;</span><br><span class=\"line\">        *) echo \"Unknown option: $opt\" ;;</span><br><span class=\"line\">    esac</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">shift $[ $OPTIND -1 ]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">count=1</span><br><span class=\"line\">for param in  \"$@\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Parameter $count: $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test20.sh -a -b test1 -d test2 test3 test4</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -a option, with value test1</span><br><span class=\"line\">Found the -d option</span><br><span class=\"line\"></span><br><span class=\"line\">Parameter 1: test2</span><br><span class=\"line\">Parameter 2: test3</span><br><span class=\"line\">Parameter 3: test4</span><br></pre></td></tr></table></figure>\n<p>这里<code>shift $[ $OPTIND -1 ]</code>需要解释以下：前面提到<code>OPTIND</code>在<code>getopts</code>每次处理掉一个参数后会加1。比如<code>./test20.sh -a -b test1 -d test2 test3 test4</code>前面键入了4个参数，选项处理完成后<code>OPTIND</code>的值为5。它会指向<code>$5</code>，即第5个参数，后面为了值剩下命令行参数，所以去掉所有的选项（及带的参数），所以用<code>shift $[ $OPTIND - 1]</code>命令。</p>\n<h2 id=\"将选项标准化\"><a href=\"#将选项标准化\" class=\"headerlink\" title=\"将选项标准化\"></a>将选项标准化</h2><p>有些字母在Linux世界里已经拥有了某种程度的标准含义。如果我们能在shellji奥本中支持这些选项，脚本看起来会更加友好。</p>\n<p>下面表格列出一些命令行选项的常用含义</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">选项</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">显示所有对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">生成一个计数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">指定一个目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e</td>\n<td style=\"text-align:center\">扩展一个对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:center\">指定读入数据的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-h</td>\n<td style=\"text-align:center\">显示命令的帮助信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-i</td>\n<td style=\"text-align:center\">忽略文本大小写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">产生输出的长格式版本</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">使用非交互模式（批处理）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-o</td>\n<td style=\"text-align:center\">将所有输出重定向到指定的输出文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-q</td>\n<td style=\"text-align:center\">以安静模式运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归地处理目录和文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:center\">以安静模式运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-v</td>\n<td style=\"text-align:center\">生成详细输出</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-x</td>\n<td style=\"text-align:center\">排除某个对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-y</td>\n<td style=\"text-align:center\">对所有问题答yes</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"获得用户输入\"><a href=\"#获得用户输入\" class=\"headerlink\" title=\"获得用户输入\"></a>获得用户输入</h2><p>有时脚本地交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本地人来回答。bash shell为此提供了read命令。</p>\n<h3 id=\"基本的读入\"><a href=\"#基本的读入\" class=\"headerlink\" title=\"基本的读入\"></a>基本的读入</h3><p><code>read</code>命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，<code>read</code>命令会将数据放进一个变量。</p>\n<p>简单用法如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test21.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the <span class=\"built_in\">read</span> -p option</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">read -p \"Please enter your age: \" age</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">days=$[ $age * 365 ]</span><br><span class=\"line\">echo \"That makes you over $days days old!\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test21.sh</span><br><span class=\"line\">Please enter your age: 23</span><br><span class=\"line\">That makes you over 8395 days old!</span><br></pre></td></tr></table></figure>\n<p><code>read</code>命令会将提示符后输入的所有数据分配给单个变量，要么我们需要指定多个变量。当变量数量不够时，剩下的数据就全部分配给最后一个变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test22.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> entering multiple variable</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">read -p \"Enter your name: \" first last</span><br><span class=\"line\">echo \"Checking data for $last, $first...\"</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test22.sh</span><br><span class=\"line\">Enter your name: shixiang wang</span><br><span class=\"line\">Checking data for wang, shixiang...</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test22.sh</span><br><span class=\"line\">Enter your name: shixiang wang hhhhh</span><br><span class=\"line\">Checking data for wang hhhhh, shixiang...</span><br></pre></td></tr></table></figure>\n<p>也可以在<code>read</code>命令行中不指定变量。如果这样的话，<code>read</code>命令会将它收到的任何数据都放进特殊环境变量<code>REPLY</code>中。我们直接可以使用它。</p>\n<h3 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h3><p>脚本很可能一直苦苦等待脚本用户的输入。如果不管数据是否输入，脚本都执行的话，我们可以用<code>-t</code>选项设定一个计时器。<code>-t</code>指定<code>read</code>命令等待的秒数，计数完成后，<code>read</code>命令会返回一个非零退出状态码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test23.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> timing the data entry</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if read -t 5 -p \"Please enter your name: \" name</span><br><span class=\"line\">then</span><br><span class=\"line\">    echo \"Hello $name, welcome to my script\"</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo</span><br><span class=\"line\">    echo \"Sorry, too slow!\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test23.sh</span><br><span class=\"line\">Please enter your name: shixiang wang</span><br><span class=\"line\">Hello shixiang wang, welcome to my script</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test23.sh # 这里输入后等以下 不要输入</span><br><span class=\"line\">Please enter your name:</span><br><span class=\"line\">Sorry, too slow!</span><br></pre></td></tr></table></figure>\n<p>也可以不对输入过程计时，而时让<code>read</code>命令来统计输入的字符数。当输入的字符数达到预设的字符数时，就自动退出，将输入的数据赋值给变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test24.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> getting just one character of input</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">read -n1 -p \"Do you want to continue [Y/N]? \" answer</span><br><span class=\"line\">case $answer in</span><br><span class=\"line\">    Y | y ) echo</span><br><span class=\"line\">            echo \"fine, continue on...\";;</span><br><span class=\"line\">    N | n ) echo</span><br><span class=\"line\">            echo OK, goodbye</span><br><span class=\"line\">            exit;;</span><br><span class=\"line\">esac</span><br><span class=\"line\">echo \"This is the end of the script.\"</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test24.sh</span><br><span class=\"line\">Do you want to continue [Y/N]? Y</span><br><span class=\"line\">fine, continue on...</span><br><span class=\"line\">This is the end of the script.</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test24.sh</span><br><span class=\"line\">Do you want to continue [Y/N]? n</span><br><span class=\"line\">OK, goodbye</span><br></pre></td></tr></table></figure>\n<h3 id=\"隐藏方式读取\"><a href=\"#隐藏方式读取\" class=\"headerlink\" title=\"隐藏方式读取\"></a>隐藏方式读取</h3><p>这种方式输入密码的时候有用。</p>\n<p><code>-s</code>选项可以避免在<code>read</code>命令输入的数据出现在显示器上（实际上，数据会被显示，只是<code>read</code>命令会将文本颜色设成跟背景色一样）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test25.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hiding input data from the monitor</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">read -s -p \"Enter your password: \" pass</span><br><span class=\"line\">echo</span><br><span class=\"line\">echo \"Is your password really $pass?\"</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test25.sh</span><br><span class=\"line\">Enter your password:</span><br><span class=\"line\">Is your password really what?</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test25.sh</span><br><span class=\"line\">Enter your password:</span><br><span class=\"line\">Is your password really shixiang?</span><br></pre></td></tr></table></figure>\n<h3 id=\"从文件中读取\"><a href=\"#从文件中读取\" class=\"headerlink\" title=\"从文件中读取\"></a>从文件中读取</h3><p>当然，<code>read</code>也可以从系统文件中读取数据。每次调用<code>read</code>命令，它都会读取一行文本。当读完后，<code>read</code>命令会退出并返回非零退出状态码。</p>\n<p>最常见的方法时对文本使用<code>cat</code>命令，将结果通过管道直接传给含<code>read</code>命令的<code>while</code>命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test26.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> reading data from a file</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">cat test | while read line</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Line $count: $line\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">echo \"Finished processing the file\"</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test</span><br><span class=\"line\">The quick brown dog jumps over the lazy fox.</span><br><span class=\"line\">This is a test, this is only a test.</span><br><span class=\"line\">O Romeo, Romeo! Wherefore art thou Romeo?</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test26.sh</span><br><span class=\"line\">Line 1: The quick brown dog jumps over the lazy fox.</span><br><span class=\"line\">Line 2: This is a test, this is only a test.</span><br><span class=\"line\">Line 3: O Romeo, Romeo! Wherefore art thou Romeo?</span><br><span class=\"line\">Finished processing the file</span><br></pre></td></tr></table></figure>\n<hr>\n<p>写shell脚本的基本内容大体已经整完了，我自己也是边看边想边码过来的。shell博大精深，更多高级内容有待继续学习整理。码字实属不易，觉得内容还行的点赞支持下吧~</p>\n","site":{"data":{}},"excerpt":"<p><strong>Shell脚本笔记系列：</strong></p>\n<p><a href=\"http://www.flypeom.site/linux/2017/08/11/basic-shell/\" target=\"_blank\" rel=\"noopener\">构建基本shell脚本</a></p>\n<p><a href=\"http://www.flypeom.site/linux/2017/08/11/structural-command-of-shell/\" target=\"_blank\" rel=\"noopener\">Linux结构化命令</a></p>\n<blockquote>\n<p>内容：</p>\n<ul>\n<li>传递参数</li>\n<li>跟踪参数</li>\n<li>移动变量</li>\n<li>处理选项</li>\n<li>将选项标准化</li>\n<li>获得用户输入</li>\n</ul>\n</blockquote>\n<p>经过前面的介绍，我们已经可以掌握一些流程化的脚本编程了。但有时候，我们需要编写的脚本能够跟使用者进行交互。它可以是静态的，输入相应的参数让它运行到底；也可以是动态的，脚本根据输入参数反馈不同的信息，使用者又能根据信息调整下一步的处理，实时与程序互动。</p>\n<p>bash shell提供了一些不同的方法来从<strong>用户处获得数据，包括命令行参数、命令行选项以及直接从键盘读取输入</strong>的能力。下面将一一介绍实现。</p>","more":"<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><p>使用命令行参数是向脚本传递数据的最基本方法，在运行脚本的同时可以在命令行添加数据。</p>\n<p>比如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./addem 10 30</span><br></pre></td></tr></table></figure>\n<p>运行当前目录下名为<code>addem</code>脚本的同时向内部传递2个参数（10和30）。而脚本会通过特殊的变量来处理命令行参数。</p>\n<p>下面介绍如何使用它们。</p>\n<h3 id=\"读入参数\"><a href=\"#读入参数\" class=\"headerlink\" title=\"读入参数\"></a>读入参数</h3><p>bash shell会将称为<strong>位置参数</strong>的特殊变量分配给输入到命令行的所有参数：<code>$0</code>是程序名，<code>$1</code>是第一个参数，<code>$2</code>是第二个参数，以此类推。书上介绍直到第九个参数<code>$9</code>，但这个应该不是受限的。<a href=\"http://www.cnblogs.com/ivictor/p/4022382.html\" target=\"_blank\" rel=\"noopener\">Shell最多可以输入多少个参数？</a>一文探索了参数的个数限制，有兴趣的朋友不妨看看和试试。</p>\n<p>下面是单个参数的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using one <span class=\"built_in\">command</span> line parameter</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">factorial=1</span><br><span class=\"line\">for (( number = 1; number &lt;= $1; number++ ))</span><br><span class=\"line\">do</span><br><span class=\"line\">truefactorial=$[ $factorial * $number ]</span><br><span class=\"line\">done</span><br><span class=\"line\">echo The factorial of $1 is $factorial</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1.sh 5</span><br><span class=\"line\">The factorial of 5 is 120</span><br></pre></td></tr></table></figure>\n<p>我们可以像使用其他变量一样使用<code>$1</code>变量。shell脚本会自动分配，不需要我们做任何处理。可以看得出来这样非常方便，不过如果输入参数过多，很容易让人混淆。</p>\n<p>如果需要输入更多的参数，只需要用空格分隔即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test2.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using two <span class=\"built_in\">command</span> line parameters</span></span><br><span class=\"line\"></span><br><span class=\"line\">total=$[ $1 * $2 ]</span><br><span class=\"line\">echo The first parameter is $1.</span><br><span class=\"line\">echo The second parameter is $2.</span><br><span class=\"line\">echo The total value is $total.</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test2.sh 2 5</span><br><span class=\"line\">The first parameter is 2.</span><br><span class=\"line\">The second parameter is 5.</span><br><span class=\"line\">The total value is 10.</span><br></pre></td></tr></table></figure>\n<p>字符参数也是一样的。如果我没记错，在脚本中的数字默认都是做字符处理的，进行数学运算时会自动调整。不过当我们想要输入的一个参数是带空格的字符串时，需要在两边加上引号以保证shell能够正确识别。不然会被当做多个参数处理的。</p>\n<p>下面取个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test3.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo Hello $1, glad to meet you.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3.sh shixiang wang</span><br><span class=\"line\">Hello shixiang, glad to meet you.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3.sh 'shixiang wang'</span><br><span class=\"line\">Hello shixiang wang, glad to meet you.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3.sh \"shixiang wang\"</span><br><span class=\"line\">Hello shixiang wang, glad to meet you.</span><br></pre></td></tr></table></figure>\n<p>看来使用时要注意正确使用引号喔。</p>\n<blockquote>\n<p>说明：在文本字符串作为参数传递时，引号并非数据的一部分。它们只是表明数据的起止位置。</p>\n</blockquote>\n<p>如果需要输入的命令行参数不止9个，写脚本需要修改一下变量名（第9个之后）。比如<code>${10}</code>表示输入的第十个变量（原来如此啊）。</p>\n<p>这样我们就可以向脚本添加任意多的参数啦～</p>\n<p>前面也说了，<code>$0</code>参数可以获取脚本名，这样在编程的时候很方便。但是这里存在一个潜在的问题：如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在<code>$0</code>中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test4.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing the <span class=\"variable\">$0</span> parameter</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo The zero parameter is set to: $0</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test4.sh</span><br><span class=\"line\">The zero parameter is set to: ./test4.sh</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ bash test4.sh</span><br><span class=\"line\">The zero parameter is set to: test4.sh</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ bash ~/script_learn/test4.sh</span><br><span class=\"line\">The zero parameter is set to: /home/wsx/script_learn/test4.sh</span><br></pre></td></tr></table></figure>\n<p>而且，你发现没有，当指明脚本路径时，这个路径也会带入其中。</p>\n<p>如果我们要编写一个根据脚本名来执行不同功能的脚本，就得把脚本的运行路径剥离掉。还要删除与脚本名混在一起的命令。幸好有一个方便的小命令<code>basename</code>可以帮助我们返回不包含路径的脚本名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test5.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Using basename with the <span class=\"variable\">$0</span> parameter</span></span><br><span class=\"line\"></span><br><span class=\"line\">name=$(basename $0)</span><br><span class=\"line\">echo</span><br><span class=\"line\">echo The script name is: $name</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ bash ~/script_learn/test5.sh</span><br><span class=\"line\"></span><br><span class=\"line\">The script name is: test5.sh</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test5.sh</span><br><span class=\"line\"></span><br><span class=\"line\">The script name is: test5.sh</span><br></pre></td></tr></table></figure>\n<p>下面编写基于脚本名执行不同功能的脚本。挺有意思的，我们看看吧：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test6.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing a Multi-function script</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">name=$(basename $0)</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [ $name = \"addem\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">truetotal=$[ $1 + $2 ]</span><br><span class=\"line\">elif [ $name = \"multem\" ]</span><br><span class=\"line\">then</span><br><span class=\"line\">truetotal=$[ $1 * $2 ]</span><br><span class=\"line\">fi</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">echo The calculated value is $total.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cp test6.sh addem</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x addem</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ln -s test6.sh multem</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ll *em</span><br><span class=\"line\">-rwxrw-r-- 1 wsx wsx 216 8月  18 16:47 addem*</span><br><span class=\"line\">lrwxrwxrwx 1 wsx wsx   8 8月  18 16:47 multem -&gt; test6.sh*</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./addem 2 5</span><br><span class=\"line\"></span><br><span class=\"line\">The calculated value is 7.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./multem 2 5</span><br><span class=\"line\"></span><br><span class=\"line\">The calculated value is 10.</span><br></pre></td></tr></table></figure>\n<p>这个脚本中创建了两个不同的文件名：一个通过复制创建；另一个通过链接。在两种情况下都会先获得脚本的基本名称，然后根据该值执行相应的功能。</p>\n<h3 id=\"测试参数\"><a href=\"#测试参数\" class=\"headerlink\" title=\"测试参数\"></a>测试参数</h3><p>如果在脚本中使用了参数，但是运行脚本时没用参数，这会导致错误发生，需要小心。因此我们在使用参数前应该测试。</p>\n<p>好比下面这个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test7.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing parameters before use</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [ -n \"$1\" ] # -n 选项检查字符是否非空</span><br><span class=\"line\">then</span><br><span class=\"line\">trueecho Hello $1, glad to meet you.</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"Sorry, you did not identify yourself.\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test7.sh shixiang</span><br><span class=\"line\">Hello shixiang, glad to meet you.</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test7.sh</span><br><span class=\"line\">Sorry, you did not identify yourself.</span><br></pre></td></tr></table></figure>\n<h2 id=\"特殊参数变量\"><a href=\"#特殊参数变量\" class=\"headerlink\" title=\"特殊参数变量\"></a>特殊参数变量</h2><p>bash shell中有些特殊变量，它们会记录命令行参数。</p>\n<h3 id=\"参数统计\"><a href=\"#参数统计\" class=\"headerlink\" title=\"参数统计\"></a>参数统计</h3><p>bash shell提供了一个特殊的变量<code>$#</code>来统计命令行中输入了多少个参数。我们可以像使用普通变量一样使用它。</p>\n<p>现在能在使用参数前测试参数的总数了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test9.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing parameters</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if [ $# -ne 2 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">    echo</span><br><span class=\"line\">    echo Usage: test9.sh a b</span><br><span class=\"line\">    echo</span><br><span class=\"line\">else</span><br><span class=\"line\">    total=$[ $1 + $2 ]</span><br><span class=\"line\">    echo</span><br><span class=\"line\">    echo The total is $total</span><br><span class=\"line\">    echo</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ bash test9.sh</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: test9.sh a b</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ bash test9.sh 10</span><br><span class=\"line\"></span><br><span class=\"line\">Usage: test9.sh a b</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ bash test9.sh 2 5</span><br><span class=\"line\"></span><br><span class=\"line\">The total is 7</span><br></pre></td></tr></table></figure>\n<p>例子中，<code>if-then</code>语句用<code>-ne</code>测试命令行参数数量。如果参数数量不对，会显示一条错误信息告诉脚本的正确用法。</p>\n<p>这个变量还提供了一个简便方法来获取命令行最后一个参数，完全不需要知道实际上有多少个参数。不过要实现它需要花些功夫。</p>\n<p>也许，我们会有这样的想法，既然<code>$#</code>变量含有参数的总数，那么变量<code>${$#}</code>就代表了最后一个命令行参数变量。试试看呗：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test10.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing grabbing last parameter</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo The last parameter was $&#123;$#&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh 10</span><br><span class=\"line\">The last parameter was 65</span><br></pre></td></tr></table></figure>\n<p>我擦，明显不对。这说明<code>${$#}</code>的用法错误。实际上，花括号能不能使用美元符，必须把它换成感叹号。虽然有点奇怪，但的确有用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test10.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing grabbing last parameter</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo The last parameter was $&#123;!#&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh 10</span><br><span class=\"line\">The last parameter was 10</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh 1 2 3 4 5</span><br><span class=\"line\">The last parameter was 5</span><br></pre></td></tr></table></figure>\n<h3 id=\"抓取所有的数据\"><a href=\"#抓取所有的数据\" class=\"headerlink\" title=\"抓取所有的数据\"></a>抓取所有的数据</h3><p><code>$*</code>与<code>$@</code>变量可以用来轻松访问所有的参数。它们都能够在单个变量中存储所有的命令行参数。</p>\n<p><code>$*</code>变量会将命令行提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上<code>$*</code>变量会将这些参数视为一个整体，而不是多个个体。</p>\n<p><code>$@</code>则将所有参数当作同一字符串中的多个独立的单词。这样能够遍历所有的参数值，得到每个参数。这通常交给<code>for</code>命令完成。</p>\n<p>弄个例子吧，理解两者的区别。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test11.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing $* and <span class=\"variable\">$@</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">echo \"Using then \\$* method: $*\"</span><br><span class=\"line\">echo</span><br><span class=\"line\">echo \"Using the \\$@ method: $@\"</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test11.sh rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\">Using then $* method: rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\">Using the $@ method: rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 下面给出两者差异</span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test12.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">echo</span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">for param in \"$*\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"\\$* Parameter #$count = $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">count=1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"></span><br><span class=\"line\">for param in \"$@\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"\\$@ Parameter #$count = $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test12.sh rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">* Parameter <span class=\"comment\">#1 = rich barbara katie jessica</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ Parameter <span class=\"comment\">#1 = rich</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ Parameter <span class=\"comment\">#2 = barbara</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ Parameter <span class=\"comment\">#3 = katie</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ Parameter <span class=\"comment\">#4 = jessica</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"移动变量\"><a href=\"#移动变量\" class=\"headerlink\" title=\"移动变量\"></a>移动变量</h2><p>bash shell的<code>shift</code>命令能够用来操作命令行参数。默认情况下它会将每个参数变量向左移动一个位置。So, 变量<code>$3</code>的值会移到<code>$2</code>，<code>$2</code>移到<code>$1</code>，而<code>$1</code>的值会被删除（<code>$0</code>的值，也就是脚本名，是不会变的）。</p>\n<p>这是遍历命令行参数的另一个好方法，不需要知道参数的个数，我们只需要操作第一个参数，然后移动参数，继续操作第一个参数。</p>\n<p>下面解释它怎么工作的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test13.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> demonstrating the <span class=\"built_in\">shift</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Parameter #$count = $1\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test13.sh rich barbara katie jessica</span><br><span class=\"line\"></span><br><span class=\"line\">Parameter #1 = rich</span><br><span class=\"line\">Parameter #2 = barbara</span><br><span class=\"line\">Parameter #3 = katie</span><br><span class=\"line\">Parameter #4 = jessica</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用shift命令时需要注意，一旦参数被移除，它的值就被丢弃了 ，无法再恢复。</p>\n</blockquote>\n<p><code>shift n</code>中<code>n</code>可以指定移动多个位置。</p>\n<h2 id=\"处理选项\"><a href=\"#处理选项\" class=\"headerlink\" title=\"处理选项\"></a>处理选项</h2><p>熟悉Linux的朋友必然见过不少同时提供参数和选项的bash命令。选项是跟在但破折线后面的单个字母，它能改变命令的行为。下面介绍3中再脚本中处理选项的方法。</p>\n<h3 id=\"查找选项\"><a href=\"#查找选项\" class=\"headerlink\" title=\"查找选项\"></a>查找选项</h3><p>只要我们愿意，我们可以像处理命令行参数一样处理命令行选项。</p>\n<h4 id=\"处理简单选项\"><a href=\"#处理简单选项\" class=\"headerlink\" title=\"处理简单选项\"></a>处理简单选项</h4><p>前面一节最后我们用<code>shift</code>命令来依次处理脚本携带的命令行参数。我们也可以用同样的方法来处理命令行选项。</p>\n<p>在提取每个单独参数时，用<code>case</code>语句来判断某个参数是否为选项。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test15.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> extracting <span class=\"built_in\">command</span> line option as parameter</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$1\" in</span><br><span class=\"line\">        -a) echo \"Found the -a option\";;</span><br><span class=\"line\">        -b) echo \"Found the -b option\";;</span><br><span class=\"line\">        -c) echo \"Found the -c option\";;</span><br><span class=\"line\">        *)  echo \"$1 is not an option\";;</span><br><span class=\"line\">    esac</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test15.sh -a -b -c -d</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">-d is not an option</span><br></pre></td></tr></table></figure>\n<p><code>case</code>语句在命令行参数中找到一个选项，就处理一个选项。如果命令行上还提供了其他参数，你可以在<code>case</code>语句的通用情况处理部分中处理。</p>\n<h4 id=\"分离参数与选项\"><a href=\"#分离参数与选项\" class=\"headerlink\" title=\"分离参数与选项\"></a>分离参数与选项</h4><p>shell脚本通常使用选项和参数，Linux中处理这个问题的标准方法是用<strong>特殊字符</strong>来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始。</p>\n<p>这个所谓的特殊字符就是<code>--</code>双破折号。</p>\n<p>要检查双破折号，在<code>case</code>语句中加一项就行了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test16.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> extracting options and paramters</span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$1\" in</span><br><span class=\"line\">        -a) echo \"Found the -a option\";;</span><br><span class=\"line\">        -b) echo \"Found the -b option\";;</span><br><span class=\"line\">        -c) echo \"Found the -c option\";;</span><br><span class=\"line\">        --) shift</span><br><span class=\"line\">            break ;;</span><br><span class=\"line\">        *) echo \"$1 is not an option\";;</span><br><span class=\"line\">    esac</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">for param in $@</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Parameter #$count: $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>当遇到双破折号时，先把它移除掉，然后跳出循环，这样shell就会把后面的参数当参数而不是选项处理了。</p>\n<p>先用一组普通的选项和参数来运行测试脚本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test16.sh -c -a -b test1 test2 test3</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option</span><br><span class=\"line\">test1 is not an option</span><br><span class=\"line\">test2 is not an option</span><br><span class=\"line\">test3 is not an option</span><br></pre></td></tr></table></figure>\n<p>现在加上双破折号，进行测试：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test16.sh -c -a -b -- test1 test2 test3</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option</span><br><span class=\"line\">Parameter #1: test1</span><br><span class=\"line\">Parameter #2: test2</span><br><span class=\"line\">Parameter #3: test3</span><br></pre></td></tr></table></figure>\n<p>可以看到，当脚本遇到双破折号时，它会停止处理选项，并将剩下的参数都当做命令处理。</p>\n<p>这样如果顺序填写选项和参数的话，显然没什么问题。但是如果乱序写呢？很显然选项和参数对应不起来。如何解决？</p>\n<h4 id=\"处理带值的选项\"><a href=\"#处理带值的选项\" class=\"headerlink\" title=\"处理带值的选项\"></a>处理带值的选项</h4><p>有些选项会带上一个额外的参数值，类似下面：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./testing.sh -a test1 -b -c -d test2</span><br></pre></td></tr></table></figure>\n<p>下面看看怎么正确处理。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test17.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> extracting <span class=\"built_in\">command</span> line options and values</span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$1\" in</span><br><span class=\"line\">        -a) echo \"Found the -a option\";;</span><br><span class=\"line\">        -b) param=\"$2\"</span><br><span class=\"line\">            echo \"Found the -b option, with parameter value $param\"</span><br><span class=\"line\">            shift;;</span><br><span class=\"line\">        -c) echo \"Found the -c option\";;</span><br><span class=\"line\">        --) shift</span><br><span class=\"line\">            break;;</span><br><span class=\"line\">        *) echo \"$1 is not an option\";;</span><br><span class=\"line\">    esac</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">for param in \"$@\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Paramter #$count: $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test17.sh -a -b test1 -d</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with parameter value test1</span><br><span class=\"line\">-d is not an option</span><br></pre></td></tr></table></figure>\n<p>本例中，定义了3个要处理的选项，<code>-b</code>还带一个额外参数。因为处理的选项是<code>$1</code>，所以额外参数位于<code>$2</code>，另外因为加了额外参数，所以找到后应该用<code>shift</code>把它移除（这个选项占了两个位置，需要多移动一个）。</p>\n<p>这样，我们可以根据需求进行类似的设定了。不管什么顺序放置选项都可以正常工作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test17.sh  -b test1 -a -d</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -b option, with parameter value test1</span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">-d is not an option</span><br></pre></td></tr></table></figure>\n<p>不过，这里还有一些限制。如果我们想把多个选项放在一起，这样就行不通啦~</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test17.sh  -ac</span><br><span class=\"line\"></span><br><span class=\"line\">-ac is not an option</span><br></pre></td></tr></table></figure>\n<p>而这种功能是Linux常见的喔。那究竟怎么合并选项呢？幸好还有一种处理方法可以帮忙。</p>\n<h3 id=\"使用getopt命令\"><a href=\"#使用getopt命令\" class=\"headerlink\" title=\"使用getopt命令\"></a>使用getopt命令</h3><p><code>getopt</code>命令是一个处理命令行选项和参数时非常方便的工具。它能够识别命令行参数，从而更方便地进行解析。</p>\n<p><strong>命令的格式</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getopt optstring parameters</span><br></pre></td></tr></table></figure>\n<p><code>optstring</code>是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些字母需要带参数。</p>\n<p><strong>首先，在<code>optstring</code>中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。</strong></p>\n<blockquote>\n<p><code>getopt</code>的高级版本叫<code>getoptions</code>。需要注意区分</p>\n</blockquote>\n<p>下面看看<code>getopt</code>如何工作的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ getopt ab:cd -a -b test1 -cd test2 test3</span><br><span class=\"line\"> -a -b test1 -c -d -- test2 test3</span><br></pre></td></tr></table></figure>\n<p>运行完后看到结果感觉自己晕乎乎的，让我们一起来看看解释：</p>\n<p><code>optstring</code>定义了四个有效选项字母：a,b,c,d。（嗯，对的，这个没问题）。冒号被放在字母b后面，说明b选项需要一个参数。（这样啊）。当<code>getopt</code>命令运行时，它会检查参数列表（就时getopt命令后面跟的），并基于提供的<code>optstring</code>进行解析。值得注意，它会自动把<code>-cd</code>选项分成两个独立的选项，并插入双破折号来分隔行中的额外参数。</p>\n<p>如果指定的选项不在<code>optstring</code>中，会报错。<code>-q</code>选项可以忽略掉它（注意放在<code>optstring</code>之前，因为是命令本身的选项嘛）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ getopt ab:cd -a -b test1 -cde test2 test3</span><br><span class=\"line\">getopt：无效选项 -- e</span><br><span class=\"line\"> -a -b test1 -c -d -- test2 test3</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ getopt -q ab:cd -a -b test1 -cde test2 test3</span><br><span class=\"line\"> -a -b 'test1' -c -d -- 'test2' 'test3'</span><br></pre></td></tr></table></figure>\n<p><strong>在脚本中用getopt</strong></p>\n<p>用法稍微有点复杂，方法是用<code>getopt</code>命令生成的格式化后的版本替换已有的命令行选项和参数。用<code>set</code>可以做到。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set -- $(getopt -q ab:cd \"$@)</span><br></pre></td></tr></table></figure>\n<p><code>set</code>命令的选项之一是<code>--</code>，它会将命令行参数替换成<code>set</code>命令的命令行值。</p>\n<p>该方法会将原始脚本的命令行参数传给<code>getopt</code>命令，之后将<code>getopt</code>命令的输出传给<code>set</code>命令，用<code>getopt</code>格式化的命令行参数来替换原始的命令行参数。</p>\n<p>现在写下处理命令行参数的脚本吧：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test18.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Extract <span class=\"built_in\">command</span> line options &amp; values with getopt</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">set -- $(getopt -q ab:cd \"$@\")</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while [ -n \"$1\" ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$1\" in</span><br><span class=\"line\">        -a) echo \"Found the -a option\";;</span><br><span class=\"line\">        -b) param=\"$2\"</span><br><span class=\"line\">            echo \"Found the -b option, with parameter value $param\"</span><br><span class=\"line\">            shift ;;</span><br><span class=\"line\">        -c) echo \"Found the -c option\";;</span><br><span class=\"line\">        --) shift</span><br><span class=\"line\">            break ;;</span><br><span class=\"line\">        *) echo \"$1 is not an option\"</span><br><span class=\"line\">    esac</span><br><span class=\"line\">    shift</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">for param in \"$@\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Parameter #$count: $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n<p>可以看到它跟<code>test17.sh</code>不同的地方是加入了<code>getopt</code>命令来帮助格式化命令行参数。</p>\n<p>下面测试发现新加的功能实现了，之前的也没问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test18.sh -ac</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test18.sh -a -b test1 -cd  test2 test3 test4</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with parameter value 'test1'</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">-d is not an option</span><br><span class=\"line\">Parameter #1: 'test2'</span><br><span class=\"line\">Parameter #2: 'test3'</span><br><span class=\"line\">Parameter #3: 'test4'</span><br></pre></td></tr></table></figure>\n<p>相当不错啦。不过<code>getopt</code>命令隐藏一个问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test18.sh -a -b test1 -cd  \"test2 test3\" test4</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with parameter value 'test1'</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">-d is not an option</span><br><span class=\"line\">Parameter #1: 'test2</span><br><span class=\"line\">Parameter #2: test3'</span><br><span class=\"line\">Parameter #3: 'test4'</span><br></pre></td></tr></table></figure>\n<p><code>getopt</code>命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将两者当作一个参数。</p>\n<p>幸而还有办法能够解决这个问题。</p>\n<h3 id=\"使用更高级的getopts\"><a href=\"#使用更高级的getopts\" class=\"headerlink\" title=\"使用更高级的getopts\"></a>使用更高级的getopts</h3><p><code>getopts</code>命令内建于bash shell。它比<code>getopt</code>多一些扩展功能。</p>\n<p><code>getopts</code>命令格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getopts optstring variable</span><br></pre></td></tr></table></figure>\n<p><code>optstring</code>值类似于<code>getopt</code>命令中的那个。要去掉错误信息的话，可以在<code>optstring</code>之前加一个冒号。<code>getopts</code>命令将当前参数保存在命令行中定义的<code>variable</code>中。</p>\n<p><strong>该命令会用到两个环境变量。如果选项需要跟一个参数值，<code>OPTARG</code>环境变量就会保存这个值。<code>OPTIND</code>环境变量保存了参数列表中<code>getopts</code>正在处理的参数位置。这样你就能在处理选项之后继续处理其他命令行参数了。</strong></p>\n<p>空说无益，还是来练练。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test19.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Simple demonstration of the <span class=\"built_in\">getopts</span> <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while getopts :ab:c opt</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$opt\" in</span><br><span class=\"line\">       a) echo \"Found the -a option\" ;;</span><br><span class=\"line\">       b) echo \"Found the -b option, with value $OPTARG\";;</span><br><span class=\"line\">       c) echo \"Found the -c option\";;</span><br><span class=\"line\">       *) echo \"Unknown option: $opt\";;</span><br><span class=\"line\">   esac</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -ab test1 -c</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with value test1</span><br><span class=\"line\">Found the -c option</span><br></pre></td></tr></table></figure>\n<p><code>while</code>语句定义了<code>getopts</code>命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名（<code>opt</code>）。</p>\n<p><code>getopts</code>运行时，它一次只处理命令行上检测到的一个参数。处理完所有参数后，它会退出并返回一个大于0的退出状态码。这让它非常适合用于解析命令行所有的参数的循环中。</p>\n<p>这里我们可以已经注意到了例子中的<code>case</code>用法和之前不同。<code>getopts</code>命令解析命令行选项时会移除开头的单破折号，所以在<code>case</code>定义中不用单破折号了。</p>\n<p>上一小节末尾我们遇到的问题可以很好的解决了：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -ab \"test1 test2\" -c</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with value test1 test2</span><br><span class=\"line\">Found the -c option</span><br></pre></td></tr></table></figure>\n<p>另一个好用的功能是能够将选项字母和参数值放在一起，而且不用加空格。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -abtest1</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -b option, with value test1</span><br></pre></td></tr></table></figure>\n<p>除此之外，<code>getopts</code>还能够将命令行上找到的所有未定义的选项统一输出成问号。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -d</span><br><span class=\"line\"></span><br><span class=\"line\">Unknown option: ?</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test19.sh -acde</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -c option</span><br><span class=\"line\">Unknown option: ?</span><br><span class=\"line\">Unknown option: ?</span><br></pre></td></tr></table></figure>\n<p><code>getopts</code>命令知道何时停止处理选项，并将参数留给你处理。在<code>getopts</code>处理每一个选项时，它会将<code>OPTIND</code>环境变量值增一。在<code>getopts</code>完成处理后，你可以使用<code>shift</code>命令和<code>OPTIND</code>值来移动参数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test20.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Processing options &amp; parameters with <span class=\"built_in\">getopts</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">while getopts :ab:cd opt</span><br><span class=\"line\">do</span><br><span class=\"line\">    case \"$opt\" in</span><br><span class=\"line\">        a) echo \"Found the -a option\" ;;</span><br><span class=\"line\">        b) echo \"Found the -a option, with value $OPTARG\" ;;</span><br><span class=\"line\">        c) echo \"Found the -c option\" ;;</span><br><span class=\"line\">        d) echo \"Found the -d option\" ;;</span><br><span class=\"line\">        *) echo \"Unknown option: $opt\" ;;</span><br><span class=\"line\">    esac</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">shift $[ $OPTIND -1 ]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo</span><br><span class=\"line\">count=1</span><br><span class=\"line\">for param in  \"$@\"</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Parameter $count: $param\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test20.sh -a -b test1 -d test2 test3 test4</span><br><span class=\"line\"></span><br><span class=\"line\">Found the -a option</span><br><span class=\"line\">Found the -a option, with value test1</span><br><span class=\"line\">Found the -d option</span><br><span class=\"line\"></span><br><span class=\"line\">Parameter 1: test2</span><br><span class=\"line\">Parameter 2: test3</span><br><span class=\"line\">Parameter 3: test4</span><br></pre></td></tr></table></figure>\n<p>这里<code>shift $[ $OPTIND -1 ]</code>需要解释以下：前面提到<code>OPTIND</code>在<code>getopts</code>每次处理掉一个参数后会加1。比如<code>./test20.sh -a -b test1 -d test2 test3 test4</code>前面键入了4个参数，选项处理完成后<code>OPTIND</code>的值为5。它会指向<code>$5</code>，即第5个参数，后面为了值剩下命令行参数，所以去掉所有的选项（及带的参数），所以用<code>shift $[ $OPTIND - 1]</code>命令。</p>\n<h2 id=\"将选项标准化\"><a href=\"#将选项标准化\" class=\"headerlink\" title=\"将选项标准化\"></a>将选项标准化</h2><p>有些字母在Linux世界里已经拥有了某种程度的标准含义。如果我们能在shellji奥本中支持这些选项，脚本看起来会更加友好。</p>\n<p>下面表格列出一些命令行选项的常用含义</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">选项</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">显示所有对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">生成一个计数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">指定一个目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e</td>\n<td style=\"text-align:center\">扩展一个对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:center\">指定读入数据的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-h</td>\n<td style=\"text-align:center\">显示命令的帮助信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-i</td>\n<td style=\"text-align:center\">忽略文本大小写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">产生输出的长格式版本</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">使用非交互模式（批处理）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-o</td>\n<td style=\"text-align:center\">将所有输出重定向到指定的输出文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-q</td>\n<td style=\"text-align:center\">以安静模式运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归地处理目录和文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:center\">以安静模式运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-v</td>\n<td style=\"text-align:center\">生成详细输出</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-x</td>\n<td style=\"text-align:center\">排除某个对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-y</td>\n<td style=\"text-align:center\">对所有问题答yes</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"获得用户输入\"><a href=\"#获得用户输入\" class=\"headerlink\" title=\"获得用户输入\"></a>获得用户输入</h2><p>有时脚本地交互性还需要更强一些。比如你想要在脚本运行时问个问题，并等待运行脚本地人来回答。bash shell为此提供了read命令。</p>\n<h3 id=\"基本的读入\"><a href=\"#基本的读入\" class=\"headerlink\" title=\"基本的读入\"></a>基本的读入</h3><p><code>read</code>命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，<code>read</code>命令会将数据放进一个变量。</p>\n<p>简单用法如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test21.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the <span class=\"built_in\">read</span> -p option</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">read -p \"Please enter your age: \" age</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">days=$[ $age * 365 ]</span><br><span class=\"line\">echo \"That makes you over $days days old!\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test21.sh</span><br><span class=\"line\">Please enter your age: 23</span><br><span class=\"line\">That makes you over 8395 days old!</span><br></pre></td></tr></table></figure>\n<p><code>read</code>命令会将提示符后输入的所有数据分配给单个变量，要么我们需要指定多个变量。当变量数量不够时，剩下的数据就全部分配给最后一个变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test22.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> entering multiple variable</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">read -p \"Enter your name: \" first last</span><br><span class=\"line\">echo \"Checking data for $last, $first...\"</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test22.sh</span><br><span class=\"line\">Enter your name: shixiang wang</span><br><span class=\"line\">Checking data for wang, shixiang...</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test22.sh</span><br><span class=\"line\">Enter your name: shixiang wang hhhhh</span><br><span class=\"line\">Checking data for wang hhhhh, shixiang...</span><br></pre></td></tr></table></figure>\n<p>也可以在<code>read</code>命令行中不指定变量。如果这样的话，<code>read</code>命令会将它收到的任何数据都放进特殊环境变量<code>REPLY</code>中。我们直接可以使用它。</p>\n<h3 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h3><p>脚本很可能一直苦苦等待脚本用户的输入。如果不管数据是否输入，脚本都执行的话，我们可以用<code>-t</code>选项设定一个计时器。<code>-t</code>指定<code>read</code>命令等待的秒数，计数完成后，<code>read</code>命令会返回一个非零退出状态码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test23.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> timing the data entry</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">if read -t 5 -p \"Please enter your name: \" name</span><br><span class=\"line\">then</span><br><span class=\"line\">    echo \"Hello $name, welcome to my script\"</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo</span><br><span class=\"line\">    echo \"Sorry, too slow!\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test23.sh</span><br><span class=\"line\">Please enter your name: shixiang wang</span><br><span class=\"line\">Hello shixiang wang, welcome to my script</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test23.sh # 这里输入后等以下 不要输入</span><br><span class=\"line\">Please enter your name:</span><br><span class=\"line\">Sorry, too slow!</span><br></pre></td></tr></table></figure>\n<p>也可以不对输入过程计时，而时让<code>read</code>命令来统计输入的字符数。当输入的字符数达到预设的字符数时，就自动退出，将输入的数据赋值给变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test24.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> getting just one character of input</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">read -n1 -p \"Do you want to continue [Y/N]? \" answer</span><br><span class=\"line\">case $answer in</span><br><span class=\"line\">    Y | y ) echo</span><br><span class=\"line\">            echo \"fine, continue on...\";;</span><br><span class=\"line\">    N | n ) echo</span><br><span class=\"line\">            echo OK, goodbye</span><br><span class=\"line\">            exit;;</span><br><span class=\"line\">esac</span><br><span class=\"line\">echo \"This is the end of the script.\"</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test24.sh</span><br><span class=\"line\">Do you want to continue [Y/N]? Y</span><br><span class=\"line\">fine, continue on...</span><br><span class=\"line\">This is the end of the script.</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test24.sh</span><br><span class=\"line\">Do you want to continue [Y/N]? n</span><br><span class=\"line\">OK, goodbye</span><br></pre></td></tr></table></figure>\n<h3 id=\"隐藏方式读取\"><a href=\"#隐藏方式读取\" class=\"headerlink\" title=\"隐藏方式读取\"></a>隐藏方式读取</h3><p>这种方式输入密码的时候有用。</p>\n<p><code>-s</code>选项可以避免在<code>read</code>命令输入的数据出现在显示器上（实际上，数据会被显示，只是<code>read</code>命令会将文本颜色设成跟背景色一样）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test25.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> hiding input data from the monitor</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">read -s -p \"Enter your password: \" pass</span><br><span class=\"line\">echo</span><br><span class=\"line\">echo \"Is your password really $pass?\"</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test25.sh</span><br><span class=\"line\">Enter your password:</span><br><span class=\"line\">Is your password really what?</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test25.sh</span><br><span class=\"line\">Enter your password:</span><br><span class=\"line\">Is your password really shixiang?</span><br></pre></td></tr></table></figure>\n<h3 id=\"从文件中读取\"><a href=\"#从文件中读取\" class=\"headerlink\" title=\"从文件中读取\"></a>从文件中读取</h3><p>当然，<code>read</code>也可以从系统文件中读取数据。每次调用<code>read</code>命令，它都会读取一行文本。当读完后，<code>read</code>命令会退出并返回非零退出状态码。</p>\n<p>最常见的方法时对文本使用<code>cat</code>命令，将结果通过管道直接传给含<code>read</code>命令的<code>while</code>命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test26.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> reading data from a file</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">cat test | while read line</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Line $count: $line\"</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">echo \"Finished processing the file\"</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test</span><br><span class=\"line\">The quick brown dog jumps over the lazy fox.</span><br><span class=\"line\">This is a test, this is only a test.</span><br><span class=\"line\">O Romeo, Romeo! Wherefore art thou Romeo?</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test26.sh</span><br><span class=\"line\">Line 1: The quick brown dog jumps over the lazy fox.</span><br><span class=\"line\">Line 2: This is a test, this is only a test.</span><br><span class=\"line\">Line 3: O Romeo, Romeo! Wherefore art thou Romeo?</span><br><span class=\"line\">Finished processing the file</span><br></pre></td></tr></table></figure>\n<hr>\n<p>写shell脚本的基本内容大体已经整完了，我自己也是边看边想边码过来的。shell博大精深，更多高级内容有待继续学习整理。码字实属不易，觉得内容还行的点赞支持下吧~</p>"},{"title":"Linux脚本编程——呈现数据","author":"王诗翔","date":"2017-08-20T16:00:00.000Z","_content":"\n\n\n> 本章内容：\n>\n> - 再探重定向\n> - 标准输入和输出\n> - 报告错误\n> - 丢弃数据\n> - 创建日志文件\n\n\n\n<!-- more -->\n\n## 理解输入和输出\n\n显示输出的方法有：\n\n- 在显示器屏幕上输出\n- 将输出重定向到文件中\n- 有时将一部分数据显示在显示器上；一部分保存到文件中。\n\n之前涉及的脚本都是以第一种方式输出。现在我们来具体了解下输入和输出。\n\n### 标准文件描述符\n\n**Linux系统将每个对象当作文件处理**。着包括输入和输出进程。而标识文件对象是通过**文件描述符**完成的。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多有九个文件描述符，bash shell保留勒前三个（0,1,2），见下表。\n\n| 文件描述符 | 缩写     | 描述   |\n| ----- | ------ | ---- |\n| 0     | STDIN  | 标准输入 |\n| 1     | STDOUT | 标准输出 |\n| 2     | STDERR | 标准错误 |\n\nshell用他们将shell默认的输入和输出导向到相应的位置。\n\n**STDIN**\n\n在使用输入重定向符号（<）时，Linux会用重定向指定的文件夹来替换标准输入文件描述符。它会读取文件并提取数据，就像它是从键盘上键入的。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat\nthis is a test\nthis is a test\nthis is a second test\nthis is a second test\n```\n\n输入`cat`命令时，它从STDIN接受输入。输入一行，`cat`命令会显示一行。\n\n当然也可以通过`<`符号强制`cat`命令接受来自另一个非STDIN文件的输入。\n\n```shell\nwangsx@SC-201708020022:~$ cat < testfile\nThis is the first line.\nThis is the second line.\nThis is the third line.\n```\n\n**STDOUT**\n\n标准输出就是终端显示器。我们可以使用`<`输出重定向符号来改变它。\n\n```shell\nwangsx@SC-201708020022:~$ ls -l > test2\nwangsx@SC-201708020022:~$ cat test2\n总用量 28\ndrwxrwxrwx 0 wangsx wangsx 4096 8月   2 11:48 biosoft\n-rw-rw-rw- 1 wangsx wangsx 2156 8月   4 00:12 biostar.yml\ndrwxrwxrwx 0 wangsx wangsx 4096 8月   3 22:24 miniconda2\ndrwxrwxrwx 0 wangsx wangsx 4096 8月   2 11:50 ncbi\n-rw-rw-rw- 1 wangsx wangsx 5230 8月  14 00:14 spf13-vim.sh\ndrwxrwxrwx 0 wangsx wangsx 4096 8月  13 23:51 src\n-rw-rw-rw- 1 wangsx wangsx    0 8月  21 22:43 test2\n-rw-rw-rw- 1 wangsx wangsx   73 8月  21 22:39 testfile\ndrwxrwxrwx 0 wangsx wangsx 4096 8月  19 17:15 tmp\n-rw-rw-rw- 1 wangsx wangsx 2156 8月  14 12:20 wsx_biostar.yml\n```\n\n如果文件存在，`>`符号会将导向的文件全部重写。如果想要以追加的形式，则使用`>>`。\n\n**STDERR**\n\nSTDERR文件描述符代表shell的标准错误输出。运行脚本或命令的错误信息都会发送到这个位置。\n\n默认，STDERR会和STDOUT指向同样的地方（屏幕终端）。使用脚本时，我们常常会希望将错误信息保存到日志文件中。\n\n\n\n### 重定向错误\n\n几种实现方法：\n\n1. 只重定向错误\n\n   将文件描述符值（2）放在重定向符号前。\n\n   ```shell\n   wangsx@SC-201708020022:~$ ls -al badfile 2> test4\n   wangsx@SC-201708020022:~$ cat test4\n   ls: 无法访问'badfile': 没有那个文件或目录\n   ```\n\n   命令生成的任何错误信息都会保存在输出文件中。**这个方法只重定向错误信息。**\n\n2. 重定向错误和数据\n\n   这必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。\n\n   ```shell\n   wangsx@SC-201708020022:~$ ls -al test test2 test3 bad test 2> test6 1> test7\n   wangsx@SC-201708020022:~$ cat test6\n   ls: 无法访问'test': 没有那个文件或目录\n   ls: 无法访问'test3': 没有那个文件或目录\n   ls: 无法访问'bad': 没有那个文件或目录\n   ls: 无法访问'test': 没有那个文件或目录\n   wangsx@SC-201708020022:~$ cat test7\n   -rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2\n   ```\n\n   可以看到正常输出重定向到了test7，错误重定向到了test6。另外，也可以将STDERR和STDOUT的输出重定向到同一个输出文件，bash shell提供了符号`&>`。\n\n   ```shell\n   wangsx@SC-201708020022:~$ ls -al test test2 test3 bad &> test7\n   wangsx@SC-201708020022:~$ cat test7\n   ls: 无法访问'test': 没有那个文件或目录\n   ls: 无法访问'test3': 没有那个文件或目录\n   ls: 无法访问'bad': 没有那个文件或目录\n   -rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2\n   ```\n\n   使用这个符号的话，bash shell会自动赋予错误消息更高的优先级。这样能够集中浏览错误信息。\n\n   ​\n\n## 在脚本中重定向输出\n\n两种方法在脚本中重定向输出：\n\n- 临时重定向输出\n- 永久重定向脚本中的所有命令\n\n### 临时重定向\n\n如果**有意**在脚本中生成错误信息，可以将单独的一行输出重定向到STDERR。\n\n使用时需要在文件描述符数字前加`&`:\n\n```shell\necho \"This is an error message\" >&2\n```\n\n下面看个例子：\n\n```shell\nwangsx@SC-201708020022:~$ cat test8\n#!/bin/bash\n# testing STDERR message\n\necho \"This is an error\" >&2\necho \"This is normal output\"\n```\n\n像平常一样运行的话，看出不会有什么差别。\n\n```shell\nwangsx@SC-201708020022:~$ sh test8\nThis is an error\nThis is normal output\n```\n\n但是如果重定向STDERR的话，所有导向STDERR的文本都会被重定向\n\n```shell\nwangsx@SC-201708020022:~$ sh test8 2> test9\nThis is normal output\nwangsx@SC-201708020022:~$ cat test9\nThis is an error\n```\n\n**这个方法非常适合在脚本中生成错误信息**。\n\n### 永久重定向\n\n如果脚本中涉及大量重定向，上述的方法就会非常繁琐。我们可以用`exec`命令告诉shell在脚本执行期间重定向某个特定文件描述符。\n\n```shell\nwangsx@SC-201708020022:~$ cat test10\n#!/bin/bash\n# redirecting all output to a file\nexec 1>testout\n\necho \"This is a test of redirecting all output\"\necho \"from a script to another file\"\necho \"without having to redirect every individual line\"\nwangsx@SC-201708020022:~$ sh test10\nwangsx@SC-201708020022:~$ cat testout\nThis is a test of redirecting all output\nfrom a script to another file\nwithout having to redirect every individual line\n```\n\n再结合STDERR看看\n\n```shell\nwangsx@SC-201708020022:~$ cat test11\n#!/bin/bash\n# redirecting output to different locations\n\nexec 2>testerror\n\necho \"This is the start of the script\"\necho \"now redirecting all output to another location\"\n\nexec 1>testout\necho \"This output should go to the testout file\"\necho \"but this should go to the testerror file\" >&2\nwangsx@SC-201708020022:~$ sh test11\nThis is the start of the script\nnow redirecting all output to another location\nwangsx@SC-201708020022:~$ cat testout\nThis output should go to the testout file\nwangsx@SC-201708020022:~$ cat testerror\nbut this should go to the testerror file\n```\n\n**这个脚本用`exec`命令将STDERR的输出重定向到文件testerror。接着echo语句向STDOUT显示几行文本。随后使用`exec`命令将STDOUT重定向到testout文件。**最后，虽然STDOUT被重定向了，但依然可以将echo语句发给STDERR。\n\n这里存在一个问题，一旦重定向了STDOUT或STDERR，就很难将他们重定向回原来的位置。\n\n这个问题可以用以下方式解决。\n\n前面提到shell只用了3个文件描述符，而总共有9个，我们可以利用其他6个来操作。\n\n这里只需要另外使用一个，就可以重定向文件描述符：\n\n```shell\nwangsx@SC-201708020022:~$ cat test14\n#!/bin/bash\n# storing STDOUT, the coming back to it\n\nexec 3>&1\nexec 1>test14out\n\necho \"This should store in the output file\"\necho \"along with this line\"\n\nexec 1>&3\necho \"Now things should be back to normal\"\nwangsx@SC-201708020022:~$ sh test14\nNow things should be back to normal\nwangsx@SC-201708020022:~$ cat test14out\nThis should store in the output file\nalong with this line\n```\n\n这里有意思的是把重定向当程序变量在玩，类似\n\n```shell\na=b # 把b的内容存到a\nb=c # 修改b的内容\n# 使用完后\nb=a # 将b原来的内容还原\n```\n\n输入文件描述符也可以进行类似的操作。\n\n\n\n## 阻止命令输出\n\n有时候不想显示脚本的输出就要这么干。\n\n一种通用的方法是将STDERR重定向到`null`的特殊文件（里面什么都没有）。shell输出到null文件的任何数据都不会保存，全部被丢掉了。\n\nnull文件在Linux中的标准位置是`/dev/null`。\n\n```shell\nwangsx@SC-201708020022:~$ ls -al > /dev/null\nwangsx@SC-201708020022:~$ cat /dev/null\nwangsx@SC-201708020022:~$\n```\n\n这是避免出现错误消息，也无需保存它们的一个常用方法。\n\n```shell\nwangsx@SC-201708020022:~$ ls -al badfile test2 2> /dev/null\n-rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2\n```\n\n由于null文件不含有任何内容，程序员通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建。\n\n```shell\nwangsx@SC-201708020022:~$ cat testfile\nThis is the first line.\nThis is the second line.\nThis is the third line.\nwangsx@SC-201708020022:~$ cat /dev/null > testfile\nwangsx@SC-201708020022:~$ cat testfile\nwangsx@SC-201708020022:~$\n```\n\n\n\n## 创建临时文件\n\nLinux使用/tmp目录来存放不需要永久保留的文件。大多数Linux发行版配置了在启动时删除/tmp目录的所有文件。\n\n### 创建本地临时文件\n\n默认`mktemp`会在本地目录创建一个文件。你只需要指定文件名模板，可以是任意文本名，后面加六个`X`即可。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ mktemp testing.XXXXXX\nwangsx@SC-201708020022:~/tmp$ mktemp testing.XXXXXX\nwangsx@SC-201708020022:~/tmp$ ll\n总用量 12\ndrwxrwxrwx 0 wangsx wangsx 4096 8月  22 21:34 ./\ndrwxr-xr-x 0 wangsx wangsx 4096 8月  22 21:31 ../\n-rw------- 1 wangsx wangsx    0 8月  22 21:33 testing.R6dAku\n-rw------- 1 wangsx wangsx    0 8月  22 21:32 testing.V5psXP\n```\n\n`mktemp`命令会用6个字符码替换这6个`X`，从而保证文件名在目录中是唯一的。\n\n在脚本中使用`mktemp`命令时，可能要将文件名保存到变量中，这样就可以在脚本后面引用了。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test19\n#!/bin/bash t nomore\" \\\n# creating and using a temp file\ntempfile=$(mktemp test19.XXXXXX)\n\nexec 3>$tempfile\necho \"This script writes to temp file $tempfile\necho \"This is the first line.\" >&3\necho \"This is the last line.\" >&3\nexec 3>&-\n\necho \"Done creating temp file. The contents are:\"\ncat $tempfile\nrm -f $tempfile 2> /dev/null\nwangsx@SC-201708020022:~/tmp$ sh test19\nThis script writes to temp file test19.fVVEwn\nDone creating temp file. The contents are:\nThis is the first line.\nThis is the last line.\n```\n\n显示的内容大致如上，我的ubuntu子系统有点怪怪的，不知道为毛。\n\n\n\n`-t`选项回强制`mktemp`命令在系统的临时目录来创建该文件，它会返回临时文件的全路径，而不是只有文件名。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ mktemp -t test20.XXXX\n/tmp/test20.bY3Q\nwangsx@SC-201708020022:~/tmp$ mktemp -t test20.XXXXXX\n/tmp/test20.WrkAia\n```\n\n`-d`选项告诉`mktemp`创建一个临时目录而不是临时文件。\n\n\n\n## 记录消息\n\n有时候想将消息同时发送到显示器和日志文件，用`tee`命令可以搞定。\n\n`tee`命令的功能就像一个`T`，它将从STDIN过来的数据同时发往两处。一处是STDOUT，一处是`tee`命令行所指定的文件名。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ date | tee testfile\n2017年 08月 22日 星期二 21:49:07 DST\nwangsx@SC-201708020022:~/tmp$ cat testfile\n2017年 08月 22日 星期二 21:49:07 DST\n```\n\n如果要追加文件，请使用`-a`选项。\n\n\n\n## 实例\n\n文件重定向常见于脚本需要读入文件和输出文件时。\n\n下面是一个具体的实例：shell脚本使用命令行参数指定待读取的.csv文件。.csv格式用于从电子表格中导出数据，所以我们可以把数据库数据放入电子表格，把电子表格保存成.csv格式，读取文件，然后创建INSERT语句将数据插入MySQL数据库。\n\n```shell\n#!/bin/bash\n# read file and create INSERT statements for MySQL\n\noutfile='members.sql'\nIFS=\",\"\nwhile read lname fname address city state zip # read 使用IFS字符解析读入的文本\ndo\n    cat >> $outfile << EOF\n    # >> 将cat的输出追加到$outfile指定的文件中\n    # cat的输入不再取自于标准输入，而是被重定向到脚本中存储的数据，EOF符号标记了追加到文件中的数据的起止（两个）\n    INSERT INTO members (lname,fname,address,city,state,zip) VALUES\n    ('$lname', '$fname', '$address', '$city', '$state', '$zip');\nEOF\n    # 上面是标准的SQL语句\ndone < $1 # 将命令行第一个参数指明的数据文件导入while\n```\n\n造一个符合的csv文件\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat members.csv\nBlum,Richard,123 Main St.,Chicago,IL,60601\nBlum,Barbara,123 Main St.,Chicago,IL,60601\nBresnahan,Timothy,456, Oak Ave.,Columbus,OH,43201\n```\n\n运行脚本\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test23 members.csv\nwangsx@SC-201708020022:~/tmp$ cat members.sql\n    INSERT INTO members (lname,fname,address,city,state,zip) VALUES\n    ('Blum', 'Richard', '123 Main St.', 'Chicago', 'IL', '60601');\n    INSERT INTO members (lname,fname,address,city,state,zip) VALUES\n    ('Blum', 'Barbara', '123 Main St.', 'Chicago', 'IL', '60601');\n    INSERT INTO members (lname,fname,address,city,state,zip) VALUES\n    ('Bresnahan', 'Timothy', '456', ' Oak Ave.', 'Columbus', 'OH,43201');\n```\n","source":"_posts/2017-08-22-shell-show-data.md","raw":"---\ntitle: Linux脚本编程——呈现数据\nauthor: 王诗翔\ndate: 2017-08-21\ncategories:\n- Linux杂烩\n- shell编程\ntags:\n- bash shell\n- shell笔记\n---\n\n\n\n> 本章内容：\n>\n> - 再探重定向\n> - 标准输入和输出\n> - 报告错误\n> - 丢弃数据\n> - 创建日志文件\n\n\n\n<!-- more -->\n\n## 理解输入和输出\n\n显示输出的方法有：\n\n- 在显示器屏幕上输出\n- 将输出重定向到文件中\n- 有时将一部分数据显示在显示器上；一部分保存到文件中。\n\n之前涉及的脚本都是以第一种方式输出。现在我们来具体了解下输入和输出。\n\n### 标准文件描述符\n\n**Linux系统将每个对象当作文件处理**。着包括输入和输出进程。而标识文件对象是通过**文件描述符**完成的。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多有九个文件描述符，bash shell保留勒前三个（0,1,2），见下表。\n\n| 文件描述符 | 缩写     | 描述   |\n| ----- | ------ | ---- |\n| 0     | STDIN  | 标准输入 |\n| 1     | STDOUT | 标准输出 |\n| 2     | STDERR | 标准错误 |\n\nshell用他们将shell默认的输入和输出导向到相应的位置。\n\n**STDIN**\n\n在使用输入重定向符号（<）时，Linux会用重定向指定的文件夹来替换标准输入文件描述符。它会读取文件并提取数据，就像它是从键盘上键入的。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat\nthis is a test\nthis is a test\nthis is a second test\nthis is a second test\n```\n\n输入`cat`命令时，它从STDIN接受输入。输入一行，`cat`命令会显示一行。\n\n当然也可以通过`<`符号强制`cat`命令接受来自另一个非STDIN文件的输入。\n\n```shell\nwangsx@SC-201708020022:~$ cat < testfile\nThis is the first line.\nThis is the second line.\nThis is the third line.\n```\n\n**STDOUT**\n\n标准输出就是终端显示器。我们可以使用`<`输出重定向符号来改变它。\n\n```shell\nwangsx@SC-201708020022:~$ ls -l > test2\nwangsx@SC-201708020022:~$ cat test2\n总用量 28\ndrwxrwxrwx 0 wangsx wangsx 4096 8月   2 11:48 biosoft\n-rw-rw-rw- 1 wangsx wangsx 2156 8月   4 00:12 biostar.yml\ndrwxrwxrwx 0 wangsx wangsx 4096 8月   3 22:24 miniconda2\ndrwxrwxrwx 0 wangsx wangsx 4096 8月   2 11:50 ncbi\n-rw-rw-rw- 1 wangsx wangsx 5230 8月  14 00:14 spf13-vim.sh\ndrwxrwxrwx 0 wangsx wangsx 4096 8月  13 23:51 src\n-rw-rw-rw- 1 wangsx wangsx    0 8月  21 22:43 test2\n-rw-rw-rw- 1 wangsx wangsx   73 8月  21 22:39 testfile\ndrwxrwxrwx 0 wangsx wangsx 4096 8月  19 17:15 tmp\n-rw-rw-rw- 1 wangsx wangsx 2156 8月  14 12:20 wsx_biostar.yml\n```\n\n如果文件存在，`>`符号会将导向的文件全部重写。如果想要以追加的形式，则使用`>>`。\n\n**STDERR**\n\nSTDERR文件描述符代表shell的标准错误输出。运行脚本或命令的错误信息都会发送到这个位置。\n\n默认，STDERR会和STDOUT指向同样的地方（屏幕终端）。使用脚本时，我们常常会希望将错误信息保存到日志文件中。\n\n\n\n### 重定向错误\n\n几种实现方法：\n\n1. 只重定向错误\n\n   将文件描述符值（2）放在重定向符号前。\n\n   ```shell\n   wangsx@SC-201708020022:~$ ls -al badfile 2> test4\n   wangsx@SC-201708020022:~$ cat test4\n   ls: 无法访问'badfile': 没有那个文件或目录\n   ```\n\n   命令生成的任何错误信息都会保存在输出文件中。**这个方法只重定向错误信息。**\n\n2. 重定向错误和数据\n\n   这必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。\n\n   ```shell\n   wangsx@SC-201708020022:~$ ls -al test test2 test3 bad test 2> test6 1> test7\n   wangsx@SC-201708020022:~$ cat test6\n   ls: 无法访问'test': 没有那个文件或目录\n   ls: 无法访问'test3': 没有那个文件或目录\n   ls: 无法访问'bad': 没有那个文件或目录\n   ls: 无法访问'test': 没有那个文件或目录\n   wangsx@SC-201708020022:~$ cat test7\n   -rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2\n   ```\n\n   可以看到正常输出重定向到了test7，错误重定向到了test6。另外，也可以将STDERR和STDOUT的输出重定向到同一个输出文件，bash shell提供了符号`&>`。\n\n   ```shell\n   wangsx@SC-201708020022:~$ ls -al test test2 test3 bad &> test7\n   wangsx@SC-201708020022:~$ cat test7\n   ls: 无法访问'test': 没有那个文件或目录\n   ls: 无法访问'test3': 没有那个文件或目录\n   ls: 无法访问'bad': 没有那个文件或目录\n   -rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2\n   ```\n\n   使用这个符号的话，bash shell会自动赋予错误消息更高的优先级。这样能够集中浏览错误信息。\n\n   ​\n\n## 在脚本中重定向输出\n\n两种方法在脚本中重定向输出：\n\n- 临时重定向输出\n- 永久重定向脚本中的所有命令\n\n### 临时重定向\n\n如果**有意**在脚本中生成错误信息，可以将单独的一行输出重定向到STDERR。\n\n使用时需要在文件描述符数字前加`&`:\n\n```shell\necho \"This is an error message\" >&2\n```\n\n下面看个例子：\n\n```shell\nwangsx@SC-201708020022:~$ cat test8\n#!/bin/bash\n# testing STDERR message\n\necho \"This is an error\" >&2\necho \"This is normal output\"\n```\n\n像平常一样运行的话，看出不会有什么差别。\n\n```shell\nwangsx@SC-201708020022:~$ sh test8\nThis is an error\nThis is normal output\n```\n\n但是如果重定向STDERR的话，所有导向STDERR的文本都会被重定向\n\n```shell\nwangsx@SC-201708020022:~$ sh test8 2> test9\nThis is normal output\nwangsx@SC-201708020022:~$ cat test9\nThis is an error\n```\n\n**这个方法非常适合在脚本中生成错误信息**。\n\n### 永久重定向\n\n如果脚本中涉及大量重定向，上述的方法就会非常繁琐。我们可以用`exec`命令告诉shell在脚本执行期间重定向某个特定文件描述符。\n\n```shell\nwangsx@SC-201708020022:~$ cat test10\n#!/bin/bash\n# redirecting all output to a file\nexec 1>testout\n\necho \"This is a test of redirecting all output\"\necho \"from a script to another file\"\necho \"without having to redirect every individual line\"\nwangsx@SC-201708020022:~$ sh test10\nwangsx@SC-201708020022:~$ cat testout\nThis is a test of redirecting all output\nfrom a script to another file\nwithout having to redirect every individual line\n```\n\n再结合STDERR看看\n\n```shell\nwangsx@SC-201708020022:~$ cat test11\n#!/bin/bash\n# redirecting output to different locations\n\nexec 2>testerror\n\necho \"This is the start of the script\"\necho \"now redirecting all output to another location\"\n\nexec 1>testout\necho \"This output should go to the testout file\"\necho \"but this should go to the testerror file\" >&2\nwangsx@SC-201708020022:~$ sh test11\nThis is the start of the script\nnow redirecting all output to another location\nwangsx@SC-201708020022:~$ cat testout\nThis output should go to the testout file\nwangsx@SC-201708020022:~$ cat testerror\nbut this should go to the testerror file\n```\n\n**这个脚本用`exec`命令将STDERR的输出重定向到文件testerror。接着echo语句向STDOUT显示几行文本。随后使用`exec`命令将STDOUT重定向到testout文件。**最后，虽然STDOUT被重定向了，但依然可以将echo语句发给STDERR。\n\n这里存在一个问题，一旦重定向了STDOUT或STDERR，就很难将他们重定向回原来的位置。\n\n这个问题可以用以下方式解决。\n\n前面提到shell只用了3个文件描述符，而总共有9个，我们可以利用其他6个来操作。\n\n这里只需要另外使用一个，就可以重定向文件描述符：\n\n```shell\nwangsx@SC-201708020022:~$ cat test14\n#!/bin/bash\n# storing STDOUT, the coming back to it\n\nexec 3>&1\nexec 1>test14out\n\necho \"This should store in the output file\"\necho \"along with this line\"\n\nexec 1>&3\necho \"Now things should be back to normal\"\nwangsx@SC-201708020022:~$ sh test14\nNow things should be back to normal\nwangsx@SC-201708020022:~$ cat test14out\nThis should store in the output file\nalong with this line\n```\n\n这里有意思的是把重定向当程序变量在玩，类似\n\n```shell\na=b # 把b的内容存到a\nb=c # 修改b的内容\n# 使用完后\nb=a # 将b原来的内容还原\n```\n\n输入文件描述符也可以进行类似的操作。\n\n\n\n## 阻止命令输出\n\n有时候不想显示脚本的输出就要这么干。\n\n一种通用的方法是将STDERR重定向到`null`的特殊文件（里面什么都没有）。shell输出到null文件的任何数据都不会保存，全部被丢掉了。\n\nnull文件在Linux中的标准位置是`/dev/null`。\n\n```shell\nwangsx@SC-201708020022:~$ ls -al > /dev/null\nwangsx@SC-201708020022:~$ cat /dev/null\nwangsx@SC-201708020022:~$\n```\n\n这是避免出现错误消息，也无需保存它们的一个常用方法。\n\n```shell\nwangsx@SC-201708020022:~$ ls -al badfile test2 2> /dev/null\n-rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2\n```\n\n由于null文件不含有任何内容，程序员通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建。\n\n```shell\nwangsx@SC-201708020022:~$ cat testfile\nThis is the first line.\nThis is the second line.\nThis is the third line.\nwangsx@SC-201708020022:~$ cat /dev/null > testfile\nwangsx@SC-201708020022:~$ cat testfile\nwangsx@SC-201708020022:~$\n```\n\n\n\n## 创建临时文件\n\nLinux使用/tmp目录来存放不需要永久保留的文件。大多数Linux发行版配置了在启动时删除/tmp目录的所有文件。\n\n### 创建本地临时文件\n\n默认`mktemp`会在本地目录创建一个文件。你只需要指定文件名模板，可以是任意文本名，后面加六个`X`即可。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ mktemp testing.XXXXXX\nwangsx@SC-201708020022:~/tmp$ mktemp testing.XXXXXX\nwangsx@SC-201708020022:~/tmp$ ll\n总用量 12\ndrwxrwxrwx 0 wangsx wangsx 4096 8月  22 21:34 ./\ndrwxr-xr-x 0 wangsx wangsx 4096 8月  22 21:31 ../\n-rw------- 1 wangsx wangsx    0 8月  22 21:33 testing.R6dAku\n-rw------- 1 wangsx wangsx    0 8月  22 21:32 testing.V5psXP\n```\n\n`mktemp`命令会用6个字符码替换这6个`X`，从而保证文件名在目录中是唯一的。\n\n在脚本中使用`mktemp`命令时，可能要将文件名保存到变量中，这样就可以在脚本后面引用了。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test19\n#!/bin/bash t nomore\" \\\n# creating and using a temp file\ntempfile=$(mktemp test19.XXXXXX)\n\nexec 3>$tempfile\necho \"This script writes to temp file $tempfile\necho \"This is the first line.\" >&3\necho \"This is the last line.\" >&3\nexec 3>&-\n\necho \"Done creating temp file. The contents are:\"\ncat $tempfile\nrm -f $tempfile 2> /dev/null\nwangsx@SC-201708020022:~/tmp$ sh test19\nThis script writes to temp file test19.fVVEwn\nDone creating temp file. The contents are:\nThis is the first line.\nThis is the last line.\n```\n\n显示的内容大致如上，我的ubuntu子系统有点怪怪的，不知道为毛。\n\n\n\n`-t`选项回强制`mktemp`命令在系统的临时目录来创建该文件，它会返回临时文件的全路径，而不是只有文件名。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ mktemp -t test20.XXXX\n/tmp/test20.bY3Q\nwangsx@SC-201708020022:~/tmp$ mktemp -t test20.XXXXXX\n/tmp/test20.WrkAia\n```\n\n`-d`选项告诉`mktemp`创建一个临时目录而不是临时文件。\n\n\n\n## 记录消息\n\n有时候想将消息同时发送到显示器和日志文件，用`tee`命令可以搞定。\n\n`tee`命令的功能就像一个`T`，它将从STDIN过来的数据同时发往两处。一处是STDOUT，一处是`tee`命令行所指定的文件名。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ date | tee testfile\n2017年 08月 22日 星期二 21:49:07 DST\nwangsx@SC-201708020022:~/tmp$ cat testfile\n2017年 08月 22日 星期二 21:49:07 DST\n```\n\n如果要追加文件，请使用`-a`选项。\n\n\n\n## 实例\n\n文件重定向常见于脚本需要读入文件和输出文件时。\n\n下面是一个具体的实例：shell脚本使用命令行参数指定待读取的.csv文件。.csv格式用于从电子表格中导出数据，所以我们可以把数据库数据放入电子表格，把电子表格保存成.csv格式，读取文件，然后创建INSERT语句将数据插入MySQL数据库。\n\n```shell\n#!/bin/bash\n# read file and create INSERT statements for MySQL\n\noutfile='members.sql'\nIFS=\",\"\nwhile read lname fname address city state zip # read 使用IFS字符解析读入的文本\ndo\n    cat >> $outfile << EOF\n    # >> 将cat的输出追加到$outfile指定的文件中\n    # cat的输入不再取自于标准输入，而是被重定向到脚本中存储的数据，EOF符号标记了追加到文件中的数据的起止（两个）\n    INSERT INTO members (lname,fname,address,city,state,zip) VALUES\n    ('$lname', '$fname', '$address', '$city', '$state', '$zip');\nEOF\n    # 上面是标准的SQL语句\ndone < $1 # 将命令行第一个参数指明的数据文件导入while\n```\n\n造一个符合的csv文件\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat members.csv\nBlum,Richard,123 Main St.,Chicago,IL,60601\nBlum,Barbara,123 Main St.,Chicago,IL,60601\nBresnahan,Timothy,456, Oak Ave.,Columbus,OH,43201\n```\n\n运行脚本\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test23 members.csv\nwangsx@SC-201708020022:~/tmp$ cat members.sql\n    INSERT INTO members (lname,fname,address,city,state,zip) VALUES\n    ('Blum', 'Richard', '123 Main St.', 'Chicago', 'IL', '60601');\n    INSERT INTO members (lname,fname,address,city,state,zip) VALUES\n    ('Blum', 'Barbara', '123 Main St.', 'Chicago', 'IL', '60601');\n    INSERT INTO members (lname,fname,address,city,state,zip) VALUES\n    ('Bresnahan', 'Timothy', '456', ' Oak Ave.', 'Columbus', 'OH,43201');\n```\n","slug":"shell-show-data","published":1,"updated":"2018-01-27T04:08:16.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwu600069taxrntd4cmt","content":"<blockquote>\n<p>本章内容：</p>\n<ul>\n<li>再探重定向</li>\n<li>标准输入和输出</li>\n<li>报告错误</li>\n<li>丢弃数据</li>\n<li>创建日志文件</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"理解输入和输出\"><a href=\"#理解输入和输出\" class=\"headerlink\" title=\"理解输入和输出\"></a>理解输入和输出</h2><p>显示输出的方法有：</p>\n<ul>\n<li>在显示器屏幕上输出</li>\n<li>将输出重定向到文件中</li>\n<li>有时将一部分数据显示在显示器上；一部分保存到文件中。</li>\n</ul>\n<p>之前涉及的脚本都是以第一种方式输出。现在我们来具体了解下输入和输出。</p>\n<h3 id=\"标准文件描述符\"><a href=\"#标准文件描述符\" class=\"headerlink\" title=\"标准文件描述符\"></a>标准文件描述符</h3><p><strong>Linux系统将每个对象当作文件处理</strong>。着包括输入和输出进程。而标识文件对象是通过<strong>文件描述符</strong>完成的。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多有九个文件描述符，bash shell保留勒前三个（0,1,2），见下表。</p>\n<table>\n<thead>\n<tr>\n<th>文件描述符</th>\n<th>缩写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>STDIN</td>\n<td>标准输入</td>\n</tr>\n<tr>\n<td>1</td>\n<td>STDOUT</td>\n<td>标准输出</td>\n</tr>\n<tr>\n<td>2</td>\n<td>STDERR</td>\n<td>标准错误</td>\n</tr>\n</tbody>\n</table>\n<p>shell用他们将shell默认的输入和输出导向到相应的位置。</p>\n<p><strong>STDIN</strong></p>\n<p>在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件夹来替换标准输入文件描述符。它会读取文件并提取数据，就像它是从键盘上键入的。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat</span><br><span class=\"line\">this is a test</span><br><span class=\"line\">this is a test</span><br><span class=\"line\">this is a second test</span><br><span class=\"line\">this is a second test</span><br></pre></td></tr></table></figure>\n<p>输入<code>cat</code>命令时，它从STDIN接受输入。输入一行，<code>cat</code>命令会显示一行。</p>\n<p>当然也可以通过<code>&lt;</code>符号强制<code>cat</code>命令接受来自另一个非STDIN文件的输入。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat &lt; testfile</span><br><span class=\"line\">This is the first line.</span><br><span class=\"line\">This is the second line.</span><br><span class=\"line\">This is the third line.</span><br></pre></td></tr></table></figure>\n<p><strong>STDOUT</strong></p>\n<p>标准输出就是终端显示器。我们可以使用<code>&lt;</code>输出重定向符号来改变它。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -l &gt; test2</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test2</span><br><span class=\"line\">总用量 28</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月   2 11:48 biosoft</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 2156 8月   4 00:12 biostar.yml</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月   3 22:24 miniconda2</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月   2 11:50 ncbi</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 5230 8月  14 00:14 spf13-vim.sh</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月  13 23:51 src</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx    0 8月  21 22:43 test2</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx   73 8月  21 22:39 testfile</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月  19 17:15 tmp</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 2156 8月  14 12:20 wsx_biostar.yml</span><br></pre></td></tr></table></figure>\n<p>如果文件存在，<code>&gt;</code>符号会将导向的文件全部重写。如果想要以追加的形式，则使用<code>&gt;&gt;</code>。</p>\n<p><strong>STDERR</strong></p>\n<p>STDERR文件描述符代表shell的标准错误输出。运行脚本或命令的错误信息都会发送到这个位置。</p>\n<p>默认，STDERR会和STDOUT指向同样的地方（屏幕终端）。使用脚本时，我们常常会希望将错误信息保存到日志文件中。</p>\n<h3 id=\"重定向错误\"><a href=\"#重定向错误\" class=\"headerlink\" title=\"重定向错误\"></a>重定向错误</h3><p>几种实现方法：</p>\n<ol>\n<li><p>只重定向错误</p>\n<p>将文件描述符值（2）放在重定向符号前。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al badfile 2&gt; test4</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test4</span><br><span class=\"line\">ls: 无法访问'badfile': 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n<p>命令生成的任何错误信息都会保存在输出文件中。<strong>这个方法只重定向错误信息。</strong></p>\n</li>\n<li><p>重定向错误和数据</p>\n<p>这必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al test test2 test3 bad test 2&gt; test6 1&gt; test7</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test6</span><br><span class=\"line\">ls: 无法访问'test': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'test3': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'bad': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'test': 没有那个文件或目录</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test7</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2</span><br></pre></td></tr></table></figure>\n<p>可以看到正常输出重定向到了test7，错误重定向到了test6。另外，也可以将STDERR和STDOUT的输出重定向到同一个输出文件，bash shell提供了符号<code>&amp;&gt;</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al test test2 test3 bad &amp;&gt; test7</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test7</span><br><span class=\"line\">ls: 无法访问'test': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'test3': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'bad': 没有那个文件或目录</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2</span><br></pre></td></tr></table></figure>\n<p>使用这个符号的话，bash shell会自动赋予错误消息更高的优先级。这样能够集中浏览错误信息。</p>\n<p>​</p>\n</li>\n</ol>\n<h2 id=\"在脚本中重定向输出\"><a href=\"#在脚本中重定向输出\" class=\"headerlink\" title=\"在脚本中重定向输出\"></a>在脚本中重定向输出</h2><p>两种方法在脚本中重定向输出：</p>\n<ul>\n<li>临时重定向输出</li>\n<li>永久重定向脚本中的所有命令</li>\n</ul>\n<h3 id=\"临时重定向\"><a href=\"#临时重定向\" class=\"headerlink\" title=\"临时重定向\"></a>临时重定向</h3><p>如果<strong>有意</strong>在脚本中生成错误信息，可以将单独的一行输出重定向到STDERR。</p>\n<p>使用时需要在文件描述符数字前加<code>&amp;</code>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"This is an error message\" &gt;&amp;2</span><br></pre></td></tr></table></figure>\n<p>下面看个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test8</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing STDERR message</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This is an error\" &gt;&amp;2</span><br><span class=\"line\">echo \"This is normal output\"</span><br></pre></td></tr></table></figure>\n<p>像平常一样运行的话，看出不会有什么差别。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ sh test8</span><br><span class=\"line\">This is an error</span><br><span class=\"line\">This is normal output</span><br></pre></td></tr></table></figure>\n<p>但是如果重定向STDERR的话，所有导向STDERR的文本都会被重定向</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ sh test8 2&gt; test9</span><br><span class=\"line\">This is normal output</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test9</span><br><span class=\"line\">This is an error</span><br></pre></td></tr></table></figure>\n<p><strong>这个方法非常适合在脚本中生成错误信息</strong>。</p>\n<h3 id=\"永久重定向\"><a href=\"#永久重定向\" class=\"headerlink\" title=\"永久重定向\"></a>永久重定向</h3><p>如果脚本中涉及大量重定向，上述的方法就会非常繁琐。我们可以用<code>exec</code>命令告诉shell在脚本执行期间重定向某个特定文件描述符。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test10</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> redirecting all output to a file</span></span><br><span class=\"line\">exec 1&gt;testout</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This is a test of redirecting all output\"</span><br><span class=\"line\">echo \"from a script to another file\"</span><br><span class=\"line\">echo \"without having to redirect every individual line\"</span><br><span class=\"line\">wangsx@SC-201708020022:~$ sh test10</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat testout</span><br><span class=\"line\">This is a test of redirecting all output</span><br><span class=\"line\">from a script to another file</span><br><span class=\"line\">without having to redirect every individual line</span><br></pre></td></tr></table></figure>\n<p>再结合STDERR看看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test11</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> redirecting output to different locations</span></span><br><span class=\"line\"></span><br><span class=\"line\">exec 2&gt;testerror</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This is the start of the script\"</span><br><span class=\"line\">echo \"now redirecting all output to another location\"</span><br><span class=\"line\"></span><br><span class=\"line\">exec 1&gt;testout</span><br><span class=\"line\">echo \"This output should go to the testout file\"</span><br><span class=\"line\">echo \"but this should go to the testerror file\" &gt;&amp;2</span><br><span class=\"line\">wangsx@SC-201708020022:~$ sh test11</span><br><span class=\"line\">This is the start of the script</span><br><span class=\"line\">now redirecting all output to another location</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat testout</span><br><span class=\"line\">This output should go to the testout file</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat testerror</span><br><span class=\"line\">but this should go to the testerror file</span><br></pre></td></tr></table></figure>\n<p><strong>这个脚本用<code>exec</code>命令将STDERR的输出重定向到文件testerror。接着echo语句向STDOUT显示几行文本。随后使用<code>exec</code>命令将STDOUT重定向到testout文件。</strong>最后，虽然STDOUT被重定向了，但依然可以将echo语句发给STDERR。</p>\n<p>这里存在一个问题，一旦重定向了STDOUT或STDERR，就很难将他们重定向回原来的位置。</p>\n<p>这个问题可以用以下方式解决。</p>\n<p>前面提到shell只用了3个文件描述符，而总共有9个，我们可以利用其他6个来操作。</p>\n<p>这里只需要另外使用一个，就可以重定向文件描述符：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test14</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> storing STDOUT, the coming back to it</span></span><br><span class=\"line\"></span><br><span class=\"line\">exec 3&gt;&amp;1</span><br><span class=\"line\">exec 1&gt;test14out</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This should store in the output file\"</span><br><span class=\"line\">echo \"along with this line\"</span><br><span class=\"line\"></span><br><span class=\"line\">exec 1&gt;&amp;3</span><br><span class=\"line\">echo \"Now things should be back to normal\"</span><br><span class=\"line\">wangsx@SC-201708020022:~$ sh test14</span><br><span class=\"line\">Now things should be back to normal</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test14out</span><br><span class=\"line\">This should store in the output file</span><br><span class=\"line\">along with this line</span><br></pre></td></tr></table></figure>\n<p>这里有意思的是把重定向当程序变量在玩，类似</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=b # 把b的内容存到a</span><br><span class=\"line\">b=c # 修改b的内容</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用完后</span></span><br><span class=\"line\">b=a # 将b原来的内容还原</span><br></pre></td></tr></table></figure>\n<p>输入文件描述符也可以进行类似的操作。</p>\n<h2 id=\"阻止命令输出\"><a href=\"#阻止命令输出\" class=\"headerlink\" title=\"阻止命令输出\"></a>阻止命令输出</h2><p>有时候不想显示脚本的输出就要这么干。</p>\n<p>一种通用的方法是将STDERR重定向到<code>null</code>的特殊文件（里面什么都没有）。shell输出到null文件的任何数据都不会保存，全部被丢掉了。</p>\n<p>null文件在Linux中的标准位置是<code>/dev/null</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al &gt; /dev/null</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat /dev/null</span><br><span class=\"line\">wangsx@SC-201708020022:~$</span><br></pre></td></tr></table></figure>\n<p>这是避免出现错误消息，也无需保存它们的一个常用方法。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al badfile test2 2&gt; /dev/null</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2</span><br></pre></td></tr></table></figure>\n<p>由于null文件不含有任何内容，程序员通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat testfile</span><br><span class=\"line\">This is the first line.</span><br><span class=\"line\">This is the second line.</span><br><span class=\"line\">This is the third line.</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat /dev/null &gt; testfile</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat testfile</span><br><span class=\"line\">wangsx@SC-201708020022:~$</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建临时文件\"><a href=\"#创建临时文件\" class=\"headerlink\" title=\"创建临时文件\"></a>创建临时文件</h2><p>Linux使用/tmp目录来存放不需要永久保留的文件。大多数Linux发行版配置了在启动时删除/tmp目录的所有文件。</p>\n<h3 id=\"创建本地临时文件\"><a href=\"#创建本地临时文件\" class=\"headerlink\" title=\"创建本地临时文件\"></a>创建本地临时文件</h3><p>默认<code>mktemp</code>会在本地目录创建一个文件。你只需要指定文件名模板，可以是任意文本名，后面加六个<code>X</code>即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ mktemp testing.XXXXXX</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ mktemp testing.XXXXXX</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ll</span><br><span class=\"line\">总用量 12</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月  22 21:34 ./</span><br><span class=\"line\">drwxr-xr-x 0 wangsx wangsx 4096 8月  22 21:31 ../</span><br><span class=\"line\">-rw------- 1 wangsx wangsx    0 8月  22 21:33 testing.R6dAku</span><br><span class=\"line\">-rw------- 1 wangsx wangsx    0 8月  22 21:32 testing.V5psXP</span><br></pre></td></tr></table></figure>\n<p><code>mktemp</code>命令会用6个字符码替换这6个<code>X</code>，从而保证文件名在目录中是唯一的。</p>\n<p>在脚本中使用<code>mktemp</code>命令时，可能要将文件名保存到变量中，这样就可以在脚本后面引用了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test19</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash t nomore<span class=\"string\">\" \\</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> creating and using a temp file</span></span><br><span class=\"line\">tempfile=$(mktemp test19.XXXXXX)</span><br><span class=\"line\"></span><br><span class=\"line\">exec 3&gt;$tempfile</span><br><span class=\"line\">echo \"This script writes to temp file $tempfile</span><br><span class=\"line\">echo \"This is the first line.\" &gt;&amp;3</span><br><span class=\"line\">echo \"This is the last line.\" &gt;&amp;3</span><br><span class=\"line\">exec 3&gt;&amp;-</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"Done creating temp file. The contents are:\"</span><br><span class=\"line\">cat $tempfile</span><br><span class=\"line\">rm -f $tempfile 2&gt; /dev/null</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ sh test19</span><br><span class=\"line\">This script writes to temp file test19.fVVEwn</span><br><span class=\"line\">Done creating temp file. The contents are:</span><br><span class=\"line\">This is the first line.</span><br><span class=\"line\">This is the last line.</span><br></pre></td></tr></table></figure>\n<p>显示的内容大致如上，我的ubuntu子系统有点怪怪的，不知道为毛。</p>\n<p><code>-t</code>选项回强制<code>mktemp</code>命令在系统的临时目录来创建该文件，它会返回临时文件的全路径，而不是只有文件名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ mktemp -t test20.XXXX</span><br><span class=\"line\">/tmp/test20.bY3Q</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ mktemp -t test20.XXXXXX</span><br><span class=\"line\">/tmp/test20.WrkAia</span><br></pre></td></tr></table></figure>\n<p><code>-d</code>选项告诉<code>mktemp</code>创建一个临时目录而不是临时文件。</p>\n<h2 id=\"记录消息\"><a href=\"#记录消息\" class=\"headerlink\" title=\"记录消息\"></a>记录消息</h2><p>有时候想将消息同时发送到显示器和日志文件，用<code>tee</code>命令可以搞定。</p>\n<p><code>tee</code>命令的功能就像一个<code>T</code>，它将从STDIN过来的数据同时发往两处。一处是STDOUT，一处是<code>tee</code>命令行所指定的文件名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ date | tee testfile</span><br><span class=\"line\">2017年 08月 22日 星期二 21:49:07 DST</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat testfile</span><br><span class=\"line\">2017年 08月 22日 星期二 21:49:07 DST</span><br></pre></td></tr></table></figure>\n<p>如果要追加文件，请使用<code>-a</code>选项。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>文件重定向常见于脚本需要读入文件和输出文件时。</p>\n<p>下面是一个具体的实例：shell脚本使用命令行参数指定待读取的.csv文件。.csv格式用于从电子表格中导出数据，所以我们可以把数据库数据放入电子表格，把电子表格保存成.csv格式，读取文件，然后创建INSERT语句将数据插入MySQL数据库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">read</span> file and create INSERT statements <span class=\"keyword\">for</span> MySQL</span></span><br><span class=\"line\"></span><br><span class=\"line\">outfile='members.sql'</span><br><span class=\"line\">IFS=\",\"</span><br><span class=\"line\">while read lname fname address city state zip # read 使用IFS字符解析读入的文本</span><br><span class=\"line\">do</span><br><span class=\"line\">    cat &gt;&gt; $outfile &lt;&lt; EOF</span><br><span class=\"line\">    # &gt;&gt; 将cat的输出追加到$outfile指定的文件中</span><br><span class=\"line\">    # cat的输入不再取自于标准输入，而是被重定向到脚本中存储的数据，EOF符号标记了追加到文件中的数据的起止（两个）</span><br><span class=\"line\">    INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class=\"line\">    ('$lname', '$fname', '$address', '$city', '$state', '$zip');</span><br><span class=\"line\">EOF</span><br><span class=\"line\">    # 上面是标准的SQL语句</span><br><span class=\"line\">done &lt; $1 # 将命令行第一个参数指明的数据文件导入while</span><br></pre></td></tr></table></figure>\n<p>造一个符合的csv文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat members.csv</span><br><span class=\"line\">Blum,Richard,123 Main St.,Chicago,IL,60601</span><br><span class=\"line\">Blum,Barbara,123 Main St.,Chicago,IL,60601</span><br><span class=\"line\">Bresnahan,Timothy,456, Oak Ave.,Columbus,OH,43201</span><br></pre></td></tr></table></figure>\n<p>运行脚本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test23 members.csv</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat members.sql</span><br><span class=\"line\">    INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class=\"line\">    ('Blum', 'Richard', '123 Main St.', 'Chicago', 'IL', '60601');</span><br><span class=\"line\">    INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class=\"line\">    ('Blum', 'Barbara', '123 Main St.', 'Chicago', 'IL', '60601');</span><br><span class=\"line\">    INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class=\"line\">    ('Bresnahan', 'Timothy', '456', ' Oak Ave.', 'Columbus', 'OH,43201');</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本章内容：</p>\n<ul>\n<li>再探重定向</li>\n<li>标准输入和输出</li>\n<li>报告错误</li>\n<li>丢弃数据</li>\n<li>创建日志文件</li>\n</ul>\n</blockquote>","more":"<h2 id=\"理解输入和输出\"><a href=\"#理解输入和输出\" class=\"headerlink\" title=\"理解输入和输出\"></a>理解输入和输出</h2><p>显示输出的方法有：</p>\n<ul>\n<li>在显示器屏幕上输出</li>\n<li>将输出重定向到文件中</li>\n<li>有时将一部分数据显示在显示器上；一部分保存到文件中。</li>\n</ul>\n<p>之前涉及的脚本都是以第一种方式输出。现在我们来具体了解下输入和输出。</p>\n<h3 id=\"标准文件描述符\"><a href=\"#标准文件描述符\" class=\"headerlink\" title=\"标准文件描述符\"></a>标准文件描述符</h3><p><strong>Linux系统将每个对象当作文件处理</strong>。着包括输入和输出进程。而标识文件对象是通过<strong>文件描述符</strong>完成的。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次最多有九个文件描述符，bash shell保留勒前三个（0,1,2），见下表。</p>\n<table>\n<thead>\n<tr>\n<th>文件描述符</th>\n<th>缩写</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>STDIN</td>\n<td>标准输入</td>\n</tr>\n<tr>\n<td>1</td>\n<td>STDOUT</td>\n<td>标准输出</td>\n</tr>\n<tr>\n<td>2</td>\n<td>STDERR</td>\n<td>标准错误</td>\n</tr>\n</tbody>\n</table>\n<p>shell用他们将shell默认的输入和输出导向到相应的位置。</p>\n<p><strong>STDIN</strong></p>\n<p>在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件夹来替换标准输入文件描述符。它会读取文件并提取数据，就像它是从键盘上键入的。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat</span><br><span class=\"line\">this is a test</span><br><span class=\"line\">this is a test</span><br><span class=\"line\">this is a second test</span><br><span class=\"line\">this is a second test</span><br></pre></td></tr></table></figure>\n<p>输入<code>cat</code>命令时，它从STDIN接受输入。输入一行，<code>cat</code>命令会显示一行。</p>\n<p>当然也可以通过<code>&lt;</code>符号强制<code>cat</code>命令接受来自另一个非STDIN文件的输入。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat &lt; testfile</span><br><span class=\"line\">This is the first line.</span><br><span class=\"line\">This is the second line.</span><br><span class=\"line\">This is the third line.</span><br></pre></td></tr></table></figure>\n<p><strong>STDOUT</strong></p>\n<p>标准输出就是终端显示器。我们可以使用<code>&lt;</code>输出重定向符号来改变它。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -l &gt; test2</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test2</span><br><span class=\"line\">总用量 28</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月   2 11:48 biosoft</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 2156 8月   4 00:12 biostar.yml</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月   3 22:24 miniconda2</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月   2 11:50 ncbi</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 5230 8月  14 00:14 spf13-vim.sh</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月  13 23:51 src</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx    0 8月  21 22:43 test2</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx   73 8月  21 22:39 testfile</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月  19 17:15 tmp</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 2156 8月  14 12:20 wsx_biostar.yml</span><br></pre></td></tr></table></figure>\n<p>如果文件存在，<code>&gt;</code>符号会将导向的文件全部重写。如果想要以追加的形式，则使用<code>&gt;&gt;</code>。</p>\n<p><strong>STDERR</strong></p>\n<p>STDERR文件描述符代表shell的标准错误输出。运行脚本或命令的错误信息都会发送到这个位置。</p>\n<p>默认，STDERR会和STDOUT指向同样的地方（屏幕终端）。使用脚本时，我们常常会希望将错误信息保存到日志文件中。</p>\n<h3 id=\"重定向错误\"><a href=\"#重定向错误\" class=\"headerlink\" title=\"重定向错误\"></a>重定向错误</h3><p>几种实现方法：</p>\n<ol>\n<li><p>只重定向错误</p>\n<p>将文件描述符值（2）放在重定向符号前。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al badfile 2&gt; test4</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test4</span><br><span class=\"line\">ls: 无法访问'badfile': 没有那个文件或目录</span><br></pre></td></tr></table></figure>\n<p>命令生成的任何错误信息都会保存在输出文件中。<strong>这个方法只重定向错误信息。</strong></p>\n</li>\n<li><p>重定向错误和数据</p>\n<p>这必须用两个重定向符号。需要在符号前面放上待重定向数据所对应的文件描述符，然后指向用于保存数据的输出文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al test test2 test3 bad test 2&gt; test6 1&gt; test7</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test6</span><br><span class=\"line\">ls: 无法访问'test': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'test3': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'bad': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'test': 没有那个文件或目录</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test7</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2</span><br></pre></td></tr></table></figure>\n<p>可以看到正常输出重定向到了test7，错误重定向到了test6。另外，也可以将STDERR和STDOUT的输出重定向到同一个输出文件，bash shell提供了符号<code>&amp;&gt;</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al test test2 test3 bad &amp;&gt; test7</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test7</span><br><span class=\"line\">ls: 无法访问'test': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'test3': 没有那个文件或目录</span><br><span class=\"line\">ls: 无法访问'bad': 没有那个文件或目录</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2</span><br></pre></td></tr></table></figure>\n<p>使用这个符号的话，bash shell会自动赋予错误消息更高的优先级。这样能够集中浏览错误信息。</p>\n<p>​</p>\n</li>\n</ol>\n<h2 id=\"在脚本中重定向输出\"><a href=\"#在脚本中重定向输出\" class=\"headerlink\" title=\"在脚本中重定向输出\"></a>在脚本中重定向输出</h2><p>两种方法在脚本中重定向输出：</p>\n<ul>\n<li>临时重定向输出</li>\n<li>永久重定向脚本中的所有命令</li>\n</ul>\n<h3 id=\"临时重定向\"><a href=\"#临时重定向\" class=\"headerlink\" title=\"临时重定向\"></a>临时重定向</h3><p>如果<strong>有意</strong>在脚本中生成错误信息，可以将单独的一行输出重定向到STDERR。</p>\n<p>使用时需要在文件描述符数字前加<code>&amp;</code>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"This is an error message\" &gt;&amp;2</span><br></pre></td></tr></table></figure>\n<p>下面看个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test8</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing STDERR message</span></span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This is an error\" &gt;&amp;2</span><br><span class=\"line\">echo \"This is normal output\"</span><br></pre></td></tr></table></figure>\n<p>像平常一样运行的话，看出不会有什么差别。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ sh test8</span><br><span class=\"line\">This is an error</span><br><span class=\"line\">This is normal output</span><br></pre></td></tr></table></figure>\n<p>但是如果重定向STDERR的话，所有导向STDERR的文本都会被重定向</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ sh test8 2&gt; test9</span><br><span class=\"line\">This is normal output</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test9</span><br><span class=\"line\">This is an error</span><br></pre></td></tr></table></figure>\n<p><strong>这个方法非常适合在脚本中生成错误信息</strong>。</p>\n<h3 id=\"永久重定向\"><a href=\"#永久重定向\" class=\"headerlink\" title=\"永久重定向\"></a>永久重定向</h3><p>如果脚本中涉及大量重定向，上述的方法就会非常繁琐。我们可以用<code>exec</code>命令告诉shell在脚本执行期间重定向某个特定文件描述符。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test10</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> redirecting all output to a file</span></span><br><span class=\"line\">exec 1&gt;testout</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This is a test of redirecting all output\"</span><br><span class=\"line\">echo \"from a script to another file\"</span><br><span class=\"line\">echo \"without having to redirect every individual line\"</span><br><span class=\"line\">wangsx@SC-201708020022:~$ sh test10</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat testout</span><br><span class=\"line\">This is a test of redirecting all output</span><br><span class=\"line\">from a script to another file</span><br><span class=\"line\">without having to redirect every individual line</span><br></pre></td></tr></table></figure>\n<p>再结合STDERR看看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test11</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> redirecting output to different locations</span></span><br><span class=\"line\"></span><br><span class=\"line\">exec 2&gt;testerror</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This is the start of the script\"</span><br><span class=\"line\">echo \"now redirecting all output to another location\"</span><br><span class=\"line\"></span><br><span class=\"line\">exec 1&gt;testout</span><br><span class=\"line\">echo \"This output should go to the testout file\"</span><br><span class=\"line\">echo \"but this should go to the testerror file\" &gt;&amp;2</span><br><span class=\"line\">wangsx@SC-201708020022:~$ sh test11</span><br><span class=\"line\">This is the start of the script</span><br><span class=\"line\">now redirecting all output to another location</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat testout</span><br><span class=\"line\">This output should go to the testout file</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat testerror</span><br><span class=\"line\">but this should go to the testerror file</span><br></pre></td></tr></table></figure>\n<p><strong>这个脚本用<code>exec</code>命令将STDERR的输出重定向到文件testerror。接着echo语句向STDOUT显示几行文本。随后使用<code>exec</code>命令将STDOUT重定向到testout文件。</strong>最后，虽然STDOUT被重定向了，但依然可以将echo语句发给STDERR。</p>\n<p>这里存在一个问题，一旦重定向了STDOUT或STDERR，就很难将他们重定向回原来的位置。</p>\n<p>这个问题可以用以下方式解决。</p>\n<p>前面提到shell只用了3个文件描述符，而总共有9个，我们可以利用其他6个来操作。</p>\n<p>这里只需要另外使用一个，就可以重定向文件描述符：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test14</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> storing STDOUT, the coming back to it</span></span><br><span class=\"line\"></span><br><span class=\"line\">exec 3&gt;&amp;1</span><br><span class=\"line\">exec 1&gt;test14out</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This should store in the output file\"</span><br><span class=\"line\">echo \"along with this line\"</span><br><span class=\"line\"></span><br><span class=\"line\">exec 1&gt;&amp;3</span><br><span class=\"line\">echo \"Now things should be back to normal\"</span><br><span class=\"line\">wangsx@SC-201708020022:~$ sh test14</span><br><span class=\"line\">Now things should be back to normal</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat test14out</span><br><span class=\"line\">This should store in the output file</span><br><span class=\"line\">along with this line</span><br></pre></td></tr></table></figure>\n<p>这里有意思的是把重定向当程序变量在玩，类似</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=b # 把b的内容存到a</span><br><span class=\"line\">b=c # 修改b的内容</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用完后</span></span><br><span class=\"line\">b=a # 将b原来的内容还原</span><br></pre></td></tr></table></figure>\n<p>输入文件描述符也可以进行类似的操作。</p>\n<h2 id=\"阻止命令输出\"><a href=\"#阻止命令输出\" class=\"headerlink\" title=\"阻止命令输出\"></a>阻止命令输出</h2><p>有时候不想显示脚本的输出就要这么干。</p>\n<p>一种通用的方法是将STDERR重定向到<code>null</code>的特殊文件（里面什么都没有）。shell输出到null文件的任何数据都不会保存，全部被丢掉了。</p>\n<p>null文件在Linux中的标准位置是<code>/dev/null</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al &gt; /dev/null</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat /dev/null</span><br><span class=\"line\">wangsx@SC-201708020022:~$</span><br></pre></td></tr></table></figure>\n<p>这是避免出现错误消息，也无需保存它们的一个常用方法。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ls -al badfile test2 2&gt; /dev/null</span><br><span class=\"line\">-rw-rw-rw- 1 wangsx wangsx 571 8月  21 22:43 test2</span><br></pre></td></tr></table></figure>\n<p>由于null文件不含有任何内容，程序员通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat testfile</span><br><span class=\"line\">This is the first line.</span><br><span class=\"line\">This is the second line.</span><br><span class=\"line\">This is the third line.</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat /dev/null &gt; testfile</span><br><span class=\"line\">wangsx@SC-201708020022:~$ cat testfile</span><br><span class=\"line\">wangsx@SC-201708020022:~$</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建临时文件\"><a href=\"#创建临时文件\" class=\"headerlink\" title=\"创建临时文件\"></a>创建临时文件</h2><p>Linux使用/tmp目录来存放不需要永久保留的文件。大多数Linux发行版配置了在启动时删除/tmp目录的所有文件。</p>\n<h3 id=\"创建本地临时文件\"><a href=\"#创建本地临时文件\" class=\"headerlink\" title=\"创建本地临时文件\"></a>创建本地临时文件</h3><p>默认<code>mktemp</code>会在本地目录创建一个文件。你只需要指定文件名模板，可以是任意文本名，后面加六个<code>X</code>即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ mktemp testing.XXXXXX</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ mktemp testing.XXXXXX</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ll</span><br><span class=\"line\">总用量 12</span><br><span class=\"line\">drwxrwxrwx 0 wangsx wangsx 4096 8月  22 21:34 ./</span><br><span class=\"line\">drwxr-xr-x 0 wangsx wangsx 4096 8月  22 21:31 ../</span><br><span class=\"line\">-rw------- 1 wangsx wangsx    0 8月  22 21:33 testing.R6dAku</span><br><span class=\"line\">-rw------- 1 wangsx wangsx    0 8月  22 21:32 testing.V5psXP</span><br></pre></td></tr></table></figure>\n<p><code>mktemp</code>命令会用6个字符码替换这6个<code>X</code>，从而保证文件名在目录中是唯一的。</p>\n<p>在脚本中使用<code>mktemp</code>命令时，可能要将文件名保存到变量中，这样就可以在脚本后面引用了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test19</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash t nomore<span class=\"string\">\" \\</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> creating and using a temp file</span></span><br><span class=\"line\">tempfile=$(mktemp test19.XXXXXX)</span><br><span class=\"line\"></span><br><span class=\"line\">exec 3&gt;$tempfile</span><br><span class=\"line\">echo \"This script writes to temp file $tempfile</span><br><span class=\"line\">echo \"This is the first line.\" &gt;&amp;3</span><br><span class=\"line\">echo \"This is the last line.\" &gt;&amp;3</span><br><span class=\"line\">exec 3&gt;&amp;-</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"Done creating temp file. The contents are:\"</span><br><span class=\"line\">cat $tempfile</span><br><span class=\"line\">rm -f $tempfile 2&gt; /dev/null</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ sh test19</span><br><span class=\"line\">This script writes to temp file test19.fVVEwn</span><br><span class=\"line\">Done creating temp file. The contents are:</span><br><span class=\"line\">This is the first line.</span><br><span class=\"line\">This is the last line.</span><br></pre></td></tr></table></figure>\n<p>显示的内容大致如上，我的ubuntu子系统有点怪怪的，不知道为毛。</p>\n<p><code>-t</code>选项回强制<code>mktemp</code>命令在系统的临时目录来创建该文件，它会返回临时文件的全路径，而不是只有文件名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ mktemp -t test20.XXXX</span><br><span class=\"line\">/tmp/test20.bY3Q</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ mktemp -t test20.XXXXXX</span><br><span class=\"line\">/tmp/test20.WrkAia</span><br></pre></td></tr></table></figure>\n<p><code>-d</code>选项告诉<code>mktemp</code>创建一个临时目录而不是临时文件。</p>\n<h2 id=\"记录消息\"><a href=\"#记录消息\" class=\"headerlink\" title=\"记录消息\"></a>记录消息</h2><p>有时候想将消息同时发送到显示器和日志文件，用<code>tee</code>命令可以搞定。</p>\n<p><code>tee</code>命令的功能就像一个<code>T</code>，它将从STDIN过来的数据同时发往两处。一处是STDOUT，一处是<code>tee</code>命令行所指定的文件名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ date | tee testfile</span><br><span class=\"line\">2017年 08月 22日 星期二 21:49:07 DST</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat testfile</span><br><span class=\"line\">2017年 08月 22日 星期二 21:49:07 DST</span><br></pre></td></tr></table></figure>\n<p>如果要追加文件，请使用<code>-a</code>选项。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>文件重定向常见于脚本需要读入文件和输出文件时。</p>\n<p>下面是一个具体的实例：shell脚本使用命令行参数指定待读取的.csv文件。.csv格式用于从电子表格中导出数据，所以我们可以把数据库数据放入电子表格，把电子表格保存成.csv格式，读取文件，然后创建INSERT语句将数据插入MySQL数据库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"built_in\">read</span> file and create INSERT statements <span class=\"keyword\">for</span> MySQL</span></span><br><span class=\"line\"></span><br><span class=\"line\">outfile='members.sql'</span><br><span class=\"line\">IFS=\",\"</span><br><span class=\"line\">while read lname fname address city state zip # read 使用IFS字符解析读入的文本</span><br><span class=\"line\">do</span><br><span class=\"line\">    cat &gt;&gt; $outfile &lt;&lt; EOF</span><br><span class=\"line\">    # &gt;&gt; 将cat的输出追加到$outfile指定的文件中</span><br><span class=\"line\">    # cat的输入不再取自于标准输入，而是被重定向到脚本中存储的数据，EOF符号标记了追加到文件中的数据的起止（两个）</span><br><span class=\"line\">    INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class=\"line\">    ('$lname', '$fname', '$address', '$city', '$state', '$zip');</span><br><span class=\"line\">EOF</span><br><span class=\"line\">    # 上面是标准的SQL语句</span><br><span class=\"line\">done &lt; $1 # 将命令行第一个参数指明的数据文件导入while</span><br></pre></td></tr></table></figure>\n<p>造一个符合的csv文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat members.csv</span><br><span class=\"line\">Blum,Richard,123 Main St.,Chicago,IL,60601</span><br><span class=\"line\">Blum,Barbara,123 Main St.,Chicago,IL,60601</span><br><span class=\"line\">Bresnahan,Timothy,456, Oak Ave.,Columbus,OH,43201</span><br></pre></td></tr></table></figure>\n<p>运行脚本</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test23 members.csv</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat members.sql</span><br><span class=\"line\">    INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class=\"line\">    ('Blum', 'Richard', '123 Main St.', 'Chicago', 'IL', '60601');</span><br><span class=\"line\">    INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class=\"line\">    ('Blum', 'Barbara', '123 Main St.', 'Chicago', 'IL', '60601');</span><br><span class=\"line\">    INSERT INTO members (lname,fname,address,city,state,zip) VALUES</span><br><span class=\"line\">    ('Bresnahan', 'Timothy', '456', ' Oak Ave.', 'Columbus', 'OH,43201');</span><br></pre></td></tr></table></figure>"},{"title":"构建基本shell脚本","author":"王诗翔","date":"2017-08-10T16:00:00.000Z","_content":"\n<!-- more -->\n\n> **内容**\n>\n> - 使用多个命令\n> - 创建脚本文件\n> - 显示消息\n> - 使用变量\n> - 输入输出重定向\n> - 管道\n> - 数学运算\n> - 退出脚本\n\n### 使用多个命令\n\n如果多个命令一起使用，可以放在一行并用分号分隔。\n\n```shell\nwsx@wsx-ubuntu:~$ date; who\n2017年 07月 26日 星期三 09:53:43 CST\nwsx      tty7         2017-07-26 09:48 (:0)\n```\n\n### 创建脚本文件\n\n在创建脚本文件时，必须在文件的第一行指定要使用的shell，格式为：\n\n```\n#!/bin/bash\n```\n\n脚本文件的第一行中`#`后的惊叹号会告诉shell使用哪个shell来运行脚本（如果是其他编码语言脚本，像python，第一行类似）。\n\n其他地方的`#`用作注释行。\n\n添加名为`test1`的脚本文件，内容为：\n\n```\n#!/bin/bash\n# This script displays the date and who's logged on\ndate\nwho\n```\n\n现在运行脚本，结果会是：\n\n```\nwsx@wsx-ubuntu:~/script_learn$ test1\n未找到 'test1' 命令，您要输入的是否是：\n 命令 'testr' 来自于包 'python3-testrepository' (main)\n 命令 'testr' 来自于包 'python-testrepository' (universe)\n 命令 'test' 来自于包 'coreutils' (main)\ntest1：未找到命令\n```\n\n我们现在需要做的是让bash shell能够找到我们的脚本文件。shell会通过`PATH`环境变量来查找命令，我们可以看看：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ echo $PATH\n/home/wsx/Anaconda/bin:/home/wsx/Anoconda/ENTER/bin:/usr/lib/jvm/default-java/bin:/home/wsx/bin:/home/wsx/Anaconda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\n```\n\n很显然，我们的文件没有在这些目录范围内。要让shell找到test1脚本，我们可以采取以下两种做法之一：\n\n- 将shell脚本文件所处的目录添加到`PATH`环境变量中；\n- 在提示符中用绝对路径或相对路径来引用shell脚本文件。\n\n第二种方法比较简单，我们在这里试试：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ ./test1\nbash: ./test1: 权限不够\nwsx@wsx-ubuntu:~/script_learn$ ll test1 # 发现权限不够，查看文件的权限\n-rw-rw-r-- 1 wsx wsx 73 7月  26 10:03 test1\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test1 # 修改权限，添加可执行属性\nwsx@wsx-ubuntu:~/script_learn$ ./test1 # 成功运行脚本\n2017年 07月 26日 星期三 10:09:23 CST\nwsx      tty7         2017-07-26 09:48 (:0)\n\n```\n\n### 显示消息\n\n在`echo`命令后面加上一个字符串，就能显示出这个文本字符串。这种方式可以添加自己的文本消息来告诉脚本用户脚本正在做什么。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ echo This is a test\nThis is a test\n```\n\n如果文本本身带有字符串，我们需要**用单引号或双引号来划定文本字符串**。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ echo \"Let's see if this'll work\"\nLet's see if this'll work\n```\n\n我们修改下之前的test1文件，增加消息显示：\n\n```shell\n#!/bin/bash\n# This script displays the date and who's logged on\necho The time and date are:\ndate\necho \"Let's see who's logged into the system\"\nwho\n```\n\n运行：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ ./test1\nThe time and date are:\n2017年 07月 26日 星期三 10:17:59 CST\nLet's see who's logged into the system\nwsx      tty7         2017-07-26 09:48 (:0)\n```\n\n**如果想把文本字符串和命令输出显示在同一行中**，可以用`echo`语句的`-n`参数。需要在字符串的两侧加上引号，并且保证字符串尾部有一个空格（不然字符串和命令输出就粘连到一起了）。\n\n```shell\n#!/bin/bash\n# This script displays the date and who's logged on\necho -n \"The time and date are: \"\ndate\necho  \"Let's see who's logged into the system: \"\nwho\n\n# 运行结果输出\nwsx@wsx-ubuntu:~/script_learn$ ./test1\nThe time and date are: 2017年 07月 26日 星期三 10:24:04 CST\nLet's see who's logged into the system:\nwsx      tty7         2017-07-26 09:48 (:0)\n\n```\n\n### 使用变量\n\n变量允许我们临时性地将信息存储在shell脚本中，以便和脚本中的其他命令一起使用。\n\n**环境变量**\n\nshell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统ID(也称为UID)、用户默认主目录以及shell查找程序的搜索路径。\n\n使用`set`命令显示一份完整的当前环境变量列表。`env`与`printenv`命令都可以显示全局变量。（这些命令输出结果比较多，不展示了。之前关于环境变量的笔记有比较详细的描述。）\n\n在环境变量名称之前加上美元符可以使用这些环境变量。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test2\n#! /bin/bash\n# display user information from the system\necho \"User info for userid: $USER\"\necho UID: $UID\necho HOME: $HOME\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test2\nwsx@wsx-ubuntu:~/script_learn$ ./test2\nUser info for userid: wsx\nUID: 1000\nHOME: /home/wsx\n```\n\n可以想象的到，如果我们想要使用实际的美元符而不是引用变量，肯定会出问题。这时候我们需要在美元符前面加上`\\`进行转义，以显示美元符本身。\n\n**用户变量**\n\n使用等号将值赋给用户变量。**注意，在变量、等号和值之间不能出现空格！**这个是初学者常见的一个问题，本人也非常不太适应这个。因为在其他语言中不区分等号两边的空格，相信接触过其他脚本的朋友们肯定有习惯打空格使代码美观的，这在bash shell中是万万行不通滴。\n\n一个使用的例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test3\n#!/bin/bash\n# testing variables\ndays=10\nguest=\"Katie\"\necho \"$guest checked in $days days ago\"\ndays=5\nguest=\"Jessica\"\necho \"$guest checked in $days days ago\"\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test3\nwsx@wsx-ubuntu:~/script_learn$ ./test3\nKatie checked in 10 days ago\nJessica checked in 5 days ago\n```\n\n变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不需要使用美元符。\n\n### 命令替换\n\nshell脚本最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。\n\n有两种方法可以将命令输出赋给变量：\n\n- 反引号字符(`)\n- $()格式\n\n```\n要么用一对反引号把整个命令行命令围起来：\ntesting=`date`\n要么使用$()格式\ntesting=$(date)\n```\n\n下面是一个例子，在脚本中通过命令替换获得当前日期并用它来生成唯一文件名：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test4\n#!/bin/bash\n# copy the /usr/bin directory listing to a log file\ntoday=$(date +%y%m%d)\nls /usr/bin -al > log.$today\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test4\nwsx@wsx-ubuntu:~/script_learn$ ./test4\n```\n\n### 重定向输入和输出\n\n通过几个操作符进行重定向，我们可以将命令的结果输出到另外的位置（文件）。当然，重定向可以用于输入。\n\n**输出重定向**\n\n最基本的操作符是`>`。比如我们想要输出命令结果到一个指定文件：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ date > test6\nwsx@wsx-ubuntu:~/script_learn$ ls -l test6\n-rw-rw-r-- 1 wsx wsx 43 7月  26 16:42 test6\nwsx@wsx-ubuntu:~/script_learn$ cat test6\n2017年 07月 26日 星期三 16:42:34 CST\n```\n\n如果想要将命令的输出追加到已有文件中，需要用双大于号（>>）来追加数据。\n\n**输入重定向**\n\n输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。\n\n使用的符号是小于号（<）。\n\n> 一种简单的记忆方法是：在命令行上，命令总是在左侧，而重定向符号“指向”数据流动的方向。小于号说明数据正在从输入文件流向命令。\n\n比如用wc命令检查文本的行数、词数和字节数。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ wc < test6\n 1  6 43\n```\n\n另一种输入重定向的方法是**内联输入重定向**。它无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据即可。它使用的符号是远小于号（<<），除了这个符号，我们还需要指定一个文本标记用来划分输入数据的开始和结尾。任何字符串都可以作为文本标记，但在数据的开始和结尾文本标记必须一致。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ wc << EOF\n> test string1\n> test string2\n> test string3\n> EOF\n 3  6 39\n```\n\n它的形式为：\n\n```\ncommand << marker\ndata\nmarker\n```\n\n### 管道\n\n有时候需要将一个命令的输出作为另一个命令的输入。通过`|`符号分隔命令即可实现管道。\n\n比如我想查看某个文件（test1）的前两行并进行排序，操作如下：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test1\n#!/bin/bash\n# This script displays the date and who's logged on\necho -n \"The time and date are: \"\ndate\necho  \"Let's see who's logged into the system: \"\nwho\nwsx@wsx-ubuntu:~/script_learn$ cat test1 | head -2 | sort\n#!/bin/bash\n# This script displays the date and who's logged on\n```\n\n管道的强大之处在于可以根据自己的需求灵活地组合和使用各种linux命令工具。这里只是一个简单的例子，要熟练掌握少不了平时多多研究和练习。\n\n### 执行数学运算\n\n对shell脚本来说，执行数学运算非常麻烦。有两种实现方式。\n\n**expr**命令\n\n`expr`命令允许在命令行上处理数学表达式，但是特别笨拙。（Bourne shell中）\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ exrpr 1 + 5\n未找到 'exrpr' 命令，您要输入的是否是：\n 命令 'expr' 来自于包 'coreutils' (main)\nexrpr：未找到命令\n\n```\n\n看到没有，那算了。它基本涉及的操作跟我们使用的其他语言是一致的。但是有些问题需要处理，像`*`是通配符，在运算是是做乘号处理的，需要进行转义。\n\n**使用方括号**\n\nbash shell提供了一种更简单的方法来执行数学表达式。在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（$[operator]）将数学表达式围起来。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ var1=$[1+5]\nwsx@wsx-ubuntu:~/script_learn$ echo $var1\n6\nwsx@wsx-ubuntu:~/script_learn$ var2=$[$var1+2]\nwsx@wsx-ubuntu:~/script_learn$ echo $var2\n8\n```\n\n这种方式不仅方便，而且因为在方括号内，不会让shell误解乘号或其他符号。\n\n但bash shell计算有一个主要限制：**它只支持整数运算！**\n\n**浮点解决方案**\n\n最常见的方案是用内建的bash计算器。它实际上是一门编程语言，它允许在命令行中输入浮点表达式，然后解释并计算该表达式，最后返回结果。bash计算器能够识别：\n\n- 数字（整数和浮点数）\n- 变量（简单变量和数组）\n- 注释（/* */开始的行）\n- 表达式\n- 编程语句\n- 函数\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ bc\nbc 1.06.95\nCopyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.\nThis is free software with ABSOLUTELY NO WARRANTY.\nFor details type `warranty'.\n12 * 5.4\n64.8\n3.156 * (3 + 5)\n25.248\nquit\n```\n\n在脚本中使用bc\n\n可以用命令替换运行bc命令，并将输出赋给一个变量。基本格式如下：\n\n```\nvariable=$(echo \"options; expression\" | bc)\n```\n\noptions设置变量，expression参数定义了通过bc执行的数学表达式。\n\n看一个简单实例：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test9\n#!/bin/bash\nvar1=$(echo \"scale=4; 3.44/5\" | bc)\necho The answer is $var1\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test9\nwsx@wsx-ubuntu:~/script_learn$ ./test9\nThe answer is .6880\n```\n\n这个例子将`scale`变量设置为四位小数，并在`expression`部分指定了特定的运算。\n\n这个方法适用于较短的运算，但有时我们会涉及更多的数字。如果需要进行大量运算，在一个命令行中列出多个表达式就会有点麻烦。\n\n这里有一个解决方法：使用内联输入重定向，将一个文件重定向到bc命令来处理。格式为：\n\n```\nvariable=$(bc << EOF\noptions\nstatements\nexpressions\nEOF)\n```\n\n`EOF`文本字符串标识了内联重定向数据的起始。注意，仍然需要命令替换符号将bc命令的输出赋给变量。\n\n下面是一个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test10\n#!/bin/bash\n\nvar1=10.46\nvar2=43.67\nvar3=33.2\nvar4=71\n\nvar5=$(bc <<EOF\nscale=4\na1 = ( $var1 * $var2)\nb1 = ( $var3 * $var4)\na1 + b1\nEOF\n)\n\necho The final answer for this mess is $var5\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test10\nwsx@wsx-ubuntu:~/script_learn$ ./test10\nThe final answer for this mess is 2813.9882\n```\n\n在普通的shell脚本中，数字默认当做字符串处理。这也是为什么我们脚本处理计算麻烦和我们需要特定的工具和方法来进行处理。一定要注意区分。\n\n### 退出脚本\n\n前面运行的脚本都是命令执行完成，脚本自动结束。其实我们可以用更为优雅的方式告诉shell命令运行完成，因为每个命令都使用**退出状态码（exit status）**，它是一个0-255的整数值，我们可以捕获这个值并在脚本中使用。\n\nLinux提供了一个专门的变量`$?`来保存上个已执行命令的退出状态码。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ date\n2017年 07月 27日 星期四 10:44:18 CST\nwsx@wsx-ubuntu:~/script_learn$ echo $?\n0\n```\n\n按照惯例，一个成功结束的命令的退出状态码是0。如果有错误，则显示一个正数值。\n\nLinux错误退出状态码没有什么标准，但有一些参考：\n\n| 状态码   | 描述               |\n| ----- | ---------------- |\n| 0     | 命令成功结束           |\n| 1     | 一般性未知错误          |\n| 2     | 不适合的shell命令      |\n| 126   | 命令不可执行           |\n| 127   | 没找到命令            |\n| 128   | 无效的退出参数          |\n| 128+x | 与Linux信号x相关的严重错误 |\n| 130   | 通过Ctrl+C终止的命令    |\n| 255   | 正常范围之外的退出状态码     |\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ asfg\n未找到 'asfg' 命令，您要输入的是否是：\n 命令 'asdfg' 来自于包 'aoeui' (universe)\nasfg：未找到命令\nwsx@wsx-ubuntu:~/script_learn$ echo $?\n127\n```\n\n**exit命令**\n\n默认，shell脚本会以脚本最后的一个命令的退出状态码退出。\n\n但是我们可以改变这种默认行为，返回自己的退出状态码。exit命令允许在脚本结束时指定一个状态退出码。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test13\n#!/bin/bash\n# testing the exit status\nvar1=10\nvar2=30\nvar3=$[$var1 + $var2]\necho The answer is $var3\nexit 5\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test13\nwsx@wsx-ubuntu:~/script_learn$ ./test13\nThe answer is 40\nwsx@wsx-ubuntu:~/script_learn$ echo $?\n5\n```\n\n注意最大255，如果大于它，得到的是求模的结果（余数）。\n","source":"_posts/2017-08-11-basic-shell.md","raw":"---\ntitle: 构建基本shell脚本\nauthor: 王诗翔\ndate: 2017-08-11\ncategories:\n- Linux杂烩\n- shell编程\ntags:\n- bash shell\n- shell笔记\n---\n\n<!-- more -->\n\n> **内容**\n>\n> - 使用多个命令\n> - 创建脚本文件\n> - 显示消息\n> - 使用变量\n> - 输入输出重定向\n> - 管道\n> - 数学运算\n> - 退出脚本\n\n### 使用多个命令\n\n如果多个命令一起使用，可以放在一行并用分号分隔。\n\n```shell\nwsx@wsx-ubuntu:~$ date; who\n2017年 07月 26日 星期三 09:53:43 CST\nwsx      tty7         2017-07-26 09:48 (:0)\n```\n\n### 创建脚本文件\n\n在创建脚本文件时，必须在文件的第一行指定要使用的shell，格式为：\n\n```\n#!/bin/bash\n```\n\n脚本文件的第一行中`#`后的惊叹号会告诉shell使用哪个shell来运行脚本（如果是其他编码语言脚本，像python，第一行类似）。\n\n其他地方的`#`用作注释行。\n\n添加名为`test1`的脚本文件，内容为：\n\n```\n#!/bin/bash\n# This script displays the date and who's logged on\ndate\nwho\n```\n\n现在运行脚本，结果会是：\n\n```\nwsx@wsx-ubuntu:~/script_learn$ test1\n未找到 'test1' 命令，您要输入的是否是：\n 命令 'testr' 来自于包 'python3-testrepository' (main)\n 命令 'testr' 来自于包 'python-testrepository' (universe)\n 命令 'test' 来自于包 'coreutils' (main)\ntest1：未找到命令\n```\n\n我们现在需要做的是让bash shell能够找到我们的脚本文件。shell会通过`PATH`环境变量来查找命令，我们可以看看：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ echo $PATH\n/home/wsx/Anaconda/bin:/home/wsx/Anoconda/ENTER/bin:/usr/lib/jvm/default-java/bin:/home/wsx/bin:/home/wsx/Anaconda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\n```\n\n很显然，我们的文件没有在这些目录范围内。要让shell找到test1脚本，我们可以采取以下两种做法之一：\n\n- 将shell脚本文件所处的目录添加到`PATH`环境变量中；\n- 在提示符中用绝对路径或相对路径来引用shell脚本文件。\n\n第二种方法比较简单，我们在这里试试：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ ./test1\nbash: ./test1: 权限不够\nwsx@wsx-ubuntu:~/script_learn$ ll test1 # 发现权限不够，查看文件的权限\n-rw-rw-r-- 1 wsx wsx 73 7月  26 10:03 test1\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test1 # 修改权限，添加可执行属性\nwsx@wsx-ubuntu:~/script_learn$ ./test1 # 成功运行脚本\n2017年 07月 26日 星期三 10:09:23 CST\nwsx      tty7         2017-07-26 09:48 (:0)\n\n```\n\n### 显示消息\n\n在`echo`命令后面加上一个字符串，就能显示出这个文本字符串。这种方式可以添加自己的文本消息来告诉脚本用户脚本正在做什么。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ echo This is a test\nThis is a test\n```\n\n如果文本本身带有字符串，我们需要**用单引号或双引号来划定文本字符串**。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ echo \"Let's see if this'll work\"\nLet's see if this'll work\n```\n\n我们修改下之前的test1文件，增加消息显示：\n\n```shell\n#!/bin/bash\n# This script displays the date and who's logged on\necho The time and date are:\ndate\necho \"Let's see who's logged into the system\"\nwho\n```\n\n运行：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ ./test1\nThe time and date are:\n2017年 07月 26日 星期三 10:17:59 CST\nLet's see who's logged into the system\nwsx      tty7         2017-07-26 09:48 (:0)\n```\n\n**如果想把文本字符串和命令输出显示在同一行中**，可以用`echo`语句的`-n`参数。需要在字符串的两侧加上引号，并且保证字符串尾部有一个空格（不然字符串和命令输出就粘连到一起了）。\n\n```shell\n#!/bin/bash\n# This script displays the date and who's logged on\necho -n \"The time and date are: \"\ndate\necho  \"Let's see who's logged into the system: \"\nwho\n\n# 运行结果输出\nwsx@wsx-ubuntu:~/script_learn$ ./test1\nThe time and date are: 2017年 07月 26日 星期三 10:24:04 CST\nLet's see who's logged into the system:\nwsx      tty7         2017-07-26 09:48 (:0)\n\n```\n\n### 使用变量\n\n变量允许我们临时性地将信息存储在shell脚本中，以便和脚本中的其他命令一起使用。\n\n**环境变量**\n\nshell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统ID(也称为UID)、用户默认主目录以及shell查找程序的搜索路径。\n\n使用`set`命令显示一份完整的当前环境变量列表。`env`与`printenv`命令都可以显示全局变量。（这些命令输出结果比较多，不展示了。之前关于环境变量的笔记有比较详细的描述。）\n\n在环境变量名称之前加上美元符可以使用这些环境变量。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test2\n#! /bin/bash\n# display user information from the system\necho \"User info for userid: $USER\"\necho UID: $UID\necho HOME: $HOME\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test2\nwsx@wsx-ubuntu:~/script_learn$ ./test2\nUser info for userid: wsx\nUID: 1000\nHOME: /home/wsx\n```\n\n可以想象的到，如果我们想要使用实际的美元符而不是引用变量，肯定会出问题。这时候我们需要在美元符前面加上`\\`进行转义，以显示美元符本身。\n\n**用户变量**\n\n使用等号将值赋给用户变量。**注意，在变量、等号和值之间不能出现空格！**这个是初学者常见的一个问题，本人也非常不太适应这个。因为在其他语言中不区分等号两边的空格，相信接触过其他脚本的朋友们肯定有习惯打空格使代码美观的，这在bash shell中是万万行不通滴。\n\n一个使用的例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test3\n#!/bin/bash\n# testing variables\ndays=10\nguest=\"Katie\"\necho \"$guest checked in $days days ago\"\ndays=5\nguest=\"Jessica\"\necho \"$guest checked in $days days ago\"\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test3\nwsx@wsx-ubuntu:~/script_learn$ ./test3\nKatie checked in 10 days ago\nJessica checked in 5 days ago\n```\n\n变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不需要使用美元符。\n\n### 命令替换\n\nshell脚本最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。\n\n有两种方法可以将命令输出赋给变量：\n\n- 反引号字符(`)\n- $()格式\n\n```\n要么用一对反引号把整个命令行命令围起来：\ntesting=`date`\n要么使用$()格式\ntesting=$(date)\n```\n\n下面是一个例子，在脚本中通过命令替换获得当前日期并用它来生成唯一文件名：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test4\n#!/bin/bash\n# copy the /usr/bin directory listing to a log file\ntoday=$(date +%y%m%d)\nls /usr/bin -al > log.$today\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test4\nwsx@wsx-ubuntu:~/script_learn$ ./test4\n```\n\n### 重定向输入和输出\n\n通过几个操作符进行重定向，我们可以将命令的结果输出到另外的位置（文件）。当然，重定向可以用于输入。\n\n**输出重定向**\n\n最基本的操作符是`>`。比如我们想要输出命令结果到一个指定文件：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ date > test6\nwsx@wsx-ubuntu:~/script_learn$ ls -l test6\n-rw-rw-r-- 1 wsx wsx 43 7月  26 16:42 test6\nwsx@wsx-ubuntu:~/script_learn$ cat test6\n2017年 07月 26日 星期三 16:42:34 CST\n```\n\n如果想要将命令的输出追加到已有文件中，需要用双大于号（>>）来追加数据。\n\n**输入重定向**\n\n输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。\n\n使用的符号是小于号（<）。\n\n> 一种简单的记忆方法是：在命令行上，命令总是在左侧，而重定向符号“指向”数据流动的方向。小于号说明数据正在从输入文件流向命令。\n\n比如用wc命令检查文本的行数、词数和字节数。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ wc < test6\n 1  6 43\n```\n\n另一种输入重定向的方法是**内联输入重定向**。它无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据即可。它使用的符号是远小于号（<<），除了这个符号，我们还需要指定一个文本标记用来划分输入数据的开始和结尾。任何字符串都可以作为文本标记，但在数据的开始和结尾文本标记必须一致。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ wc << EOF\n> test string1\n> test string2\n> test string3\n> EOF\n 3  6 39\n```\n\n它的形式为：\n\n```\ncommand << marker\ndata\nmarker\n```\n\n### 管道\n\n有时候需要将一个命令的输出作为另一个命令的输入。通过`|`符号分隔命令即可实现管道。\n\n比如我想查看某个文件（test1）的前两行并进行排序，操作如下：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test1\n#!/bin/bash\n# This script displays the date and who's logged on\necho -n \"The time and date are: \"\ndate\necho  \"Let's see who's logged into the system: \"\nwho\nwsx@wsx-ubuntu:~/script_learn$ cat test1 | head -2 | sort\n#!/bin/bash\n# This script displays the date and who's logged on\n```\n\n管道的强大之处在于可以根据自己的需求灵活地组合和使用各种linux命令工具。这里只是一个简单的例子，要熟练掌握少不了平时多多研究和练习。\n\n### 执行数学运算\n\n对shell脚本来说，执行数学运算非常麻烦。有两种实现方式。\n\n**expr**命令\n\n`expr`命令允许在命令行上处理数学表达式，但是特别笨拙。（Bourne shell中）\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ exrpr 1 + 5\n未找到 'exrpr' 命令，您要输入的是否是：\n 命令 'expr' 来自于包 'coreutils' (main)\nexrpr：未找到命令\n\n```\n\n看到没有，那算了。它基本涉及的操作跟我们使用的其他语言是一致的。但是有些问题需要处理，像`*`是通配符，在运算是是做乘号处理的，需要进行转义。\n\n**使用方括号**\n\nbash shell提供了一种更简单的方法来执行数学表达式。在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（$[operator]）将数学表达式围起来。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ var1=$[1+5]\nwsx@wsx-ubuntu:~/script_learn$ echo $var1\n6\nwsx@wsx-ubuntu:~/script_learn$ var2=$[$var1+2]\nwsx@wsx-ubuntu:~/script_learn$ echo $var2\n8\n```\n\n这种方式不仅方便，而且因为在方括号内，不会让shell误解乘号或其他符号。\n\n但bash shell计算有一个主要限制：**它只支持整数运算！**\n\n**浮点解决方案**\n\n最常见的方案是用内建的bash计算器。它实际上是一门编程语言，它允许在命令行中输入浮点表达式，然后解释并计算该表达式，最后返回结果。bash计算器能够识别：\n\n- 数字（整数和浮点数）\n- 变量（简单变量和数组）\n- 注释（/* */开始的行）\n- 表达式\n- 编程语句\n- 函数\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ bc\nbc 1.06.95\nCopyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.\nThis is free software with ABSOLUTELY NO WARRANTY.\nFor details type `warranty'.\n12 * 5.4\n64.8\n3.156 * (3 + 5)\n25.248\nquit\n```\n\n在脚本中使用bc\n\n可以用命令替换运行bc命令，并将输出赋给一个变量。基本格式如下：\n\n```\nvariable=$(echo \"options; expression\" | bc)\n```\n\noptions设置变量，expression参数定义了通过bc执行的数学表达式。\n\n看一个简单实例：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test9\n#!/bin/bash\nvar1=$(echo \"scale=4; 3.44/5\" | bc)\necho The answer is $var1\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test9\nwsx@wsx-ubuntu:~/script_learn$ ./test9\nThe answer is .6880\n```\n\n这个例子将`scale`变量设置为四位小数，并在`expression`部分指定了特定的运算。\n\n这个方法适用于较短的运算，但有时我们会涉及更多的数字。如果需要进行大量运算，在一个命令行中列出多个表达式就会有点麻烦。\n\n这里有一个解决方法：使用内联输入重定向，将一个文件重定向到bc命令来处理。格式为：\n\n```\nvariable=$(bc << EOF\noptions\nstatements\nexpressions\nEOF)\n```\n\n`EOF`文本字符串标识了内联重定向数据的起始。注意，仍然需要命令替换符号将bc命令的输出赋给变量。\n\n下面是一个例子：\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test10\n#!/bin/bash\n\nvar1=10.46\nvar2=43.67\nvar3=33.2\nvar4=71\n\nvar5=$(bc <<EOF\nscale=4\na1 = ( $var1 * $var2)\nb1 = ( $var3 * $var4)\na1 + b1\nEOF\n)\n\necho The final answer for this mess is $var5\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test10\nwsx@wsx-ubuntu:~/script_learn$ ./test10\nThe final answer for this mess is 2813.9882\n```\n\n在普通的shell脚本中，数字默认当做字符串处理。这也是为什么我们脚本处理计算麻烦和我们需要特定的工具和方法来进行处理。一定要注意区分。\n\n### 退出脚本\n\n前面运行的脚本都是命令执行完成，脚本自动结束。其实我们可以用更为优雅的方式告诉shell命令运行完成，因为每个命令都使用**退出状态码（exit status）**，它是一个0-255的整数值，我们可以捕获这个值并在脚本中使用。\n\nLinux提供了一个专门的变量`$?`来保存上个已执行命令的退出状态码。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ date\n2017年 07月 27日 星期四 10:44:18 CST\nwsx@wsx-ubuntu:~/script_learn$ echo $?\n0\n```\n\n按照惯例，一个成功结束的命令的退出状态码是0。如果有错误，则显示一个正数值。\n\nLinux错误退出状态码没有什么标准，但有一些参考：\n\n| 状态码   | 描述               |\n| ----- | ---------------- |\n| 0     | 命令成功结束           |\n| 1     | 一般性未知错误          |\n| 2     | 不适合的shell命令      |\n| 126   | 命令不可执行           |\n| 127   | 没找到命令            |\n| 128   | 无效的退出参数          |\n| 128+x | 与Linux信号x相关的严重错误 |\n| 130   | 通过Ctrl+C终止的命令    |\n| 255   | 正常范围之外的退出状态码     |\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ asfg\n未找到 'asfg' 命令，您要输入的是否是：\n 命令 'asdfg' 来自于包 'aoeui' (universe)\nasfg：未找到命令\nwsx@wsx-ubuntu:~/script_learn$ echo $?\n127\n```\n\n**exit命令**\n\n默认，shell脚本会以脚本最后的一个命令的退出状态码退出。\n\n但是我们可以改变这种默认行为，返回自己的退出状态码。exit命令允许在脚本结束时指定一个状态退出码。\n\n```shell\nwsx@wsx-ubuntu:~/script_learn$ cat test13\n#!/bin/bash\n# testing the exit status\nvar1=10\nvar2=30\nvar3=$[$var1 + $var2]\necho The answer is $var3\nexit 5\n\nwsx@wsx-ubuntu:~/script_learn$ chmod u+x test13\nwsx@wsx-ubuntu:~/script_learn$ ./test13\nThe answer is 40\nwsx@wsx-ubuntu:~/script_learn$ echo $?\n5\n```\n\n注意最大255，如果大于它，得到的是求模的结果（余数）。\n","slug":"basic-shell","published":1,"updated":"2018-01-27T04:07:39.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwu900079tax6a3exgys","content":"<a id=\"more\"></a>\n<blockquote>\n<p><strong>内容</strong></p>\n<ul>\n<li>使用多个命令</li>\n<li>创建脚本文件</li>\n<li>显示消息</li>\n<li>使用变量</li>\n<li>输入输出重定向</li>\n<li>管道</li>\n<li>数学运算</li>\n<li>退出脚本</li>\n</ul>\n</blockquote>\n<h3 id=\"使用多个命令\"><a href=\"#使用多个命令\" class=\"headerlink\" title=\"使用多个命令\"></a>使用多个命令</h3><p>如果多个命令一起使用，可以放在一行并用分号分隔。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ date; who</span><br><span class=\"line\">2017年 07月 26日 星期三 09:53:43 CST</span><br><span class=\"line\">wsx      tty7         2017-07-26 09:48 (:0)</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建脚本文件\"><a href=\"#创建脚本文件\" class=\"headerlink\" title=\"创建脚本文件\"></a>创建脚本文件</h3><p>在创建脚本文件时，必须在文件的第一行指定要使用的shell，格式为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br></pre></td></tr></table></figure>\n<p>脚本文件的第一行中<code>#</code>后的惊叹号会告诉shell使用哪个shell来运行脚本（如果是其他编码语言脚本，像python，第一行类似）。</p>\n<p>其他地方的<code>#</code>用作注释行。</p>\n<p>添加名为<code>test1</code>的脚本文件，内容为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># This script displays the date and who's logged on</span></span><br><span class=\"line\">date</span><br><span class=\"line\">who</span><br></pre></td></tr></table></figure>\n<p>现在运行脚本，结果会是：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx<span class=\"meta\">@wsx</span>-<span class=\"string\">ubuntu:</span>~/script_learn$ test1</span><br><span class=\"line\">未找到 <span class=\"string\">'test1'</span> 命令，您要输入的是否是：</span><br><span class=\"line\"> 命令 <span class=\"string\">'testr'</span> 来自于包 <span class=\"string\">'python3-testrepository'</span> (main)</span><br><span class=\"line\"> 命令 <span class=\"string\">'testr'</span> 来自于包 <span class=\"string\">'python-testrepository'</span> (universe)</span><br><span class=\"line\"> 命令 <span class=\"string\">'test'</span> 来自于包 <span class=\"string\">'coreutils'</span> (main)</span><br><span class=\"line\">test1：未找到命令</span><br></pre></td></tr></table></figure>\n<p>我们现在需要做的是让bash shell能够找到我们的脚本文件。shell会通过<code>PATH</code>环境变量来查找命令，我们可以看看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $PATH</span><br><span class=\"line\">/home/wsx/Anaconda/bin:/home/wsx/Anoconda/ENTER/bin:/usr/lib/jvm/default-java/bin:/home/wsx/bin:/home/wsx/Anaconda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>\n<p>很显然，我们的文件没有在这些目录范围内。要让shell找到test1脚本，我们可以采取以下两种做法之一：</p>\n<ul>\n<li>将shell脚本文件所处的目录添加到<code>PATH</code>环境变量中；</li>\n<li>在提示符中用绝对路径或相对路径来引用shell脚本文件。</li>\n</ul>\n<p>第二种方法比较简单，我们在这里试试：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1</span><br><span class=\"line\">bash: ./test1: 权限不够</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ll test1 # 发现权限不够，查看文件的权限</span><br><span class=\"line\">-rw-rw-r-- 1 wsx wsx 73 7月  26 10:03 test1</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test1 # 修改权限，添加可执行属性</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1 # 成功运行脚本</span><br><span class=\"line\">2017年 07月 26日 星期三 10:09:23 CST</span><br><span class=\"line\">wsx      tty7         2017-07-26 09:48 (:0)</span><br></pre></td></tr></table></figure>\n<h3 id=\"显示消息\"><a href=\"#显示消息\" class=\"headerlink\" title=\"显示消息\"></a>显示消息</h3><p>在<code>echo</code>命令后面加上一个字符串，就能显示出这个文本字符串。这种方式可以添加自己的文本消息来告诉脚本用户脚本正在做什么。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo This is a test</span><br><span class=\"line\">This is a test</span><br></pre></td></tr></table></figure>\n<p>如果文本本身带有字符串，我们需要<strong>用单引号或双引号来划定文本字符串</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo \"Let's see if this'll work\"</span><br><span class=\"line\">Let's see if this'll work</span><br></pre></td></tr></table></figure>\n<p>我们修改下之前的test1文件，增加消息显示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This script displays the date and who<span class=\"string\">'s logged on</span></span></span><br><span class=\"line\">echo The time and date are:</span><br><span class=\"line\">date</span><br><span class=\"line\">echo \"Let's see who's logged into the system\"</span><br><span class=\"line\">who</span><br></pre></td></tr></table></figure>\n<p>运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1</span><br><span class=\"line\">The time and date are:</span><br><span class=\"line\">2017年 07月 26日 星期三 10:17:59 CST</span><br><span class=\"line\">Let's see who's logged into the system</span><br><span class=\"line\">wsx      tty7         2017-07-26 09:48 (:0)</span><br></pre></td></tr></table></figure>\n<p><strong>如果想把文本字符串和命令输出显示在同一行中</strong>，可以用<code>echo</code>语句的<code>-n</code>参数。需要在字符串的两侧加上引号，并且保证字符串尾部有一个空格（不然字符串和命令输出就粘连到一起了）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This script displays the date and who<span class=\"string\">'s logged on</span></span></span><br><span class=\"line\">echo -n \"The time and date are: \"</span><br><span class=\"line\">date</span><br><span class=\"line\">echo  \"Let's see who's logged into the system: \"</span><br><span class=\"line\">who</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 运行结果输出</span></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1</span><br><span class=\"line\">The time and date are: 2017年 07月 26日 星期三 10:24:04 CST</span><br><span class=\"line\">Let's see who's logged into the system:</span><br><span class=\"line\">wsx      tty7         2017-07-26 09:48 (:0)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h3><p>变量允许我们临时性地将信息存储在shell脚本中，以便和脚本中的其他命令一起使用。</p>\n<p><strong>环境变量</strong></p>\n<p>shell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统ID(也称为UID)、用户默认主目录以及shell查找程序的搜索路径。</p>\n<p>使用<code>set</code>命令显示一份完整的当前环境变量列表。<code>env</code>与<code>printenv</code>命令都可以显示全局变量。（这些命令输出结果比较多，不展示了。之前关于环境变量的笔记有比较详细的描述。）</p>\n<p>在环境变量名称之前加上美元符可以使用这些环境变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> display user information from the system</span></span><br><span class=\"line\">echo \"User info for userid: $USER\"</span><br><span class=\"line\">echo UID: $UID</span><br><span class=\"line\">echo HOME: $HOME</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test2</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test2</span><br><span class=\"line\">User info for userid: wsx</span><br><span class=\"line\">UID: 1000</span><br><span class=\"line\">HOME: /home/wsx</span><br></pre></td></tr></table></figure>\n<p>可以想象的到，如果我们想要使用实际的美元符而不是引用变量，肯定会出问题。这时候我们需要在美元符前面加上<code>\\</code>进行转义，以显示美元符本身。</p>\n<p><strong>用户变量</strong></p>\n<p>使用等号将值赋给用户变量。<strong>注意，在变量、等号和值之间不能出现空格！</strong>这个是初学者常见的一个问题，本人也非常不太适应这个。因为在其他语言中不区分等号两边的空格，相信接触过其他脚本的朋友们肯定有习惯打空格使代码美观的，这在bash shell中是万万行不通滴。</p>\n<p>一个使用的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing variables</span></span><br><span class=\"line\">days=10</span><br><span class=\"line\">guest=\"Katie\"</span><br><span class=\"line\">echo \"$guest checked in $days days ago\"</span><br><span class=\"line\">days=5</span><br><span class=\"line\">guest=\"Jessica\"</span><br><span class=\"line\">echo \"$guest checked in $days days ago\"</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test3</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3</span><br><span class=\"line\">Katie checked in 10 days ago</span><br><span class=\"line\">Jessica checked in 5 days ago</span><br></pre></td></tr></table></figure>\n<p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不需要使用美元符。</p>\n<h3 id=\"命令替换\"><a href=\"#命令替换\" class=\"headerlink\" title=\"命令替换\"></a>命令替换</h3><p>shell脚本最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。</p>\n<p>有两种方法可以将命令输出赋给变量：</p>\n<ul>\n<li>反引号字符(`)</li>\n<li>$()格式</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要么用一对反引号把整个命令行命令围起来：</span><br><span class=\"line\">testing=`date`</span><br><span class=\"line\">要么使用$()格式</span><br><span class=\"line\">testing=<span class=\"variable\">$(date)</span></span><br></pre></td></tr></table></figure>\n<p>下面是一个例子，在脚本中通过命令替换获得当前日期并用它来生成唯一文件名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> copy the /usr/bin directory listing to a <span class=\"built_in\">log</span> file</span></span><br><span class=\"line\">today=$(date +%y%m%d)</span><br><span class=\"line\">ls /usr/bin -al &gt; log.$today</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test4</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test4</span><br></pre></td></tr></table></figure>\n<h3 id=\"重定向输入和输出\"><a href=\"#重定向输入和输出\" class=\"headerlink\" title=\"重定向输入和输出\"></a>重定向输入和输出</h3><p>通过几个操作符进行重定向，我们可以将命令的结果输出到另外的位置（文件）。当然，重定向可以用于输入。</p>\n<p><strong>输出重定向</strong></p>\n<p>最基本的操作符是<code>&gt;</code>。比如我们想要输出命令结果到一个指定文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ date &gt; test6</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ls -l test6</span><br><span class=\"line\">-rw-rw-r-- 1 wsx wsx 43 7月  26 16:42 test6</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test6</span><br><span class=\"line\">2017年 07月 26日 星期三 16:42:34 CST</span><br></pre></td></tr></table></figure>\n<p>如果想要将命令的输出追加到已有文件中，需要用双大于号（&gt;&gt;）来追加数据。</p>\n<p><strong>输入重定向</strong></p>\n<p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。</p>\n<p>使用的符号是小于号（&lt;）。</p>\n<blockquote>\n<p>一种简单的记忆方法是：在命令行上，命令总是在左侧，而重定向符号“指向”数据流动的方向。小于号说明数据正在从输入文件流向命令。</p>\n</blockquote>\n<p>比如用wc命令检查文本的行数、词数和字节数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ wc &lt; test6</span><br><span class=\"line\"> 1  6 43</span><br></pre></td></tr></table></figure>\n<p>另一种输入重定向的方法是<strong>内联输入重定向</strong>。它无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据即可。它使用的符号是远小于号（&lt;&lt;），除了这个符号，我们还需要指定一个文本标记用来划分输入数据的开始和结尾。任何字符串都可以作为文本标记，但在数据的开始和结尾文本标记必须一致。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ wc &lt;&lt; EOF</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">test</span> string1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">test</span> string2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">test</span> string3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> EOF</span></span><br><span class=\"line\"> 3  6 39</span><br></pre></td></tr></table></figure>\n<p>它的形式为：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">command</span> &lt;&lt; marker</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span></span></span><br><span class=\"line\"><span class=\"title\">marker</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h3><p>有时候需要将一个命令的输出作为另一个命令的输入。通过<code>|</code>符号分隔命令即可实现管道。</p>\n<p>比如我想查看某个文件（test1）的前两行并进行排序，操作如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This script displays the date and who<span class=\"string\">'s logged on</span></span></span><br><span class=\"line\">echo -n \"The time and date are: \"</span><br><span class=\"line\">date</span><br><span class=\"line\">echo  \"Let's see who's logged into the system: \"</span><br><span class=\"line\">who</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1 | head -2 | sort</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This script displays the date and who<span class=\"string\">'s logged on</span></span></span><br></pre></td></tr></table></figure>\n<p>管道的强大之处在于可以根据自己的需求灵活地组合和使用各种linux命令工具。这里只是一个简单的例子，要熟练掌握少不了平时多多研究和练习。</p>\n<h3 id=\"执行数学运算\"><a href=\"#执行数学运算\" class=\"headerlink\" title=\"执行数学运算\"></a>执行数学运算</h3><p>对shell脚本来说，执行数学运算非常麻烦。有两种实现方式。</p>\n<p><strong>expr</strong>命令</p>\n<p><code>expr</code>命令允许在命令行上处理数学表达式，但是特别笨拙。（Bourne shell中）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ exrpr 1 + 5</span><br><span class=\"line\">未找到 'exrpr' 命令，您要输入的是否是：</span><br><span class=\"line\"> 命令 'expr' 来自于包 'coreutils' (main)</span><br><span class=\"line\">exrpr：未找到命令</span><br></pre></td></tr></table></figure>\n<p>看到没有，那算了。它基本涉及的操作跟我们使用的其他语言是一致的。但是有些问题需要处理，像<code>*</code>是通配符，在运算是是做乘号处理的，需要进行转义。</p>\n<p><strong>使用方括号</strong></p>\n<p>bash shell提供了一种更简单的方法来执行数学表达式。在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（$[operator]）将数学表达式围起来。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ var1=$[1+5]</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $var1</span><br><span class=\"line\">6</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ var2=$[$var1+2]</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $var2</span><br><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n<p>这种方式不仅方便，而且因为在方括号内，不会让shell误解乘号或其他符号。</p>\n<p>但bash shell计算有一个主要限制：<strong>它只支持整数运算！</strong></p>\n<p><strong>浮点解决方案</strong></p>\n<p>最常见的方案是用内建的bash计算器。它实际上是一门编程语言，它允许在命令行中输入浮点表达式，然后解释并计算该表达式，最后返回结果。bash计算器能够识别：</p>\n<ul>\n<li>数字（整数和浮点数）</li>\n<li>变量（简单变量和数组）</li>\n<li>注释（/<em> </em>/开始的行）</li>\n<li>表达式</li>\n<li>编程语句</li>\n<li>函数</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ bc</span><br><span class=\"line\">bc 1.06.95</span><br><span class=\"line\">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class=\"line\">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class=\"line\">For details type `warranty'.</span><br><span class=\"line\">12 * 5.4</span><br><span class=\"line\">64.8</span><br><span class=\"line\">3.156 * (3 + 5)</span><br><span class=\"line\">25.248</span><br><span class=\"line\">quit</span><br></pre></td></tr></table></figure>\n<p>在脚本中使用bc</p>\n<p>可以用命令替换运行bc命令，并将输出赋给一个变量。基本格式如下：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">variable</span>=$(echo <span class=\"comment\">\"options; expression\"</span> |<span class=\"comment\"> bc)</span></span><br></pre></td></tr></table></figure>\n<p>options设置变量，expression参数定义了通过bc执行的数学表达式。</p>\n<p>看一个简单实例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test9</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">var1=$(echo \"scale=4; 3.44/5\" | bc)</span><br><span class=\"line\">echo The answer is $var1</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test9</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test9</span><br><span class=\"line\">The answer is .6880</span><br></pre></td></tr></table></figure>\n<p>这个例子将<code>scale</code>变量设置为四位小数，并在<code>expression</code>部分指定了特定的运算。</p>\n<p>这个方法适用于较短的运算，但有时我们会涉及更多的数字。如果需要进行大量运算，在一个命令行中列出多个表达式就会有点麻烦。</p>\n<p>这里有一个解决方法：使用内联输入重定向，将一个文件重定向到bc命令来处理。格式为：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable=$(bc &lt;&lt; <span class=\"built_in\">EOF</span></span><br><span class=\"line\">options</span><br><span class=\"line\"><span class=\"built_in\">statements</span></span><br><span class=\"line\">expressions</span><br><span class=\"line\"><span class=\"built_in\">EOF</span>)</span><br></pre></td></tr></table></figure>\n<p><code>EOF</code>文本字符串标识了内联重定向数据的起始。注意，仍然需要命令替换符号将bc命令的输出赋给变量。</p>\n<p>下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test10</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=10.46</span><br><span class=\"line\">var2=43.67</span><br><span class=\"line\">var3=33.2</span><br><span class=\"line\">var4=71</span><br><span class=\"line\"></span><br><span class=\"line\">var5=$(bc &lt;&lt;EOF</span><br><span class=\"line\">scale=4</span><br><span class=\"line\">a1 = ( $var1 * $var2)</span><br><span class=\"line\">b1 = ( $var3 * $var4)</span><br><span class=\"line\">a1 + b1</span><br><span class=\"line\">EOF</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">echo The final answer for this mess is $var5</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test10</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test10</span><br><span class=\"line\">The final answer for this mess is 2813.9882</span><br></pre></td></tr></table></figure>\n<p>在普通的shell脚本中，数字默认当做字符串处理。这也是为什么我们脚本处理计算麻烦和我们需要特定的工具和方法来进行处理。一定要注意区分。</p>\n<h3 id=\"退出脚本\"><a href=\"#退出脚本\" class=\"headerlink\" title=\"退出脚本\"></a>退出脚本</h3><p>前面运行的脚本都是命令执行完成，脚本自动结束。其实我们可以用更为优雅的方式告诉shell命令运行完成，因为每个命令都使用<strong>退出状态码（exit status）</strong>，它是一个0-255的整数值，我们可以捕获这个值并在脚本中使用。</p>\n<p>Linux提供了一个专门的变量<code>$?</code>来保存上个已执行命令的退出状态码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ date</span><br><span class=\"line\">2017年 07月 27日 星期四 10:44:18 CST</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $?</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p>按照惯例，一个成功结束的命令的退出状态码是0。如果有错误，则显示一个正数值。</p>\n<p>Linux错误退出状态码没有什么标准，但有一些参考：</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>命令成功结束</td>\n</tr>\n<tr>\n<td>1</td>\n<td>一般性未知错误</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不适合的shell命令</td>\n</tr>\n<tr>\n<td>126</td>\n<td>命令不可执行</td>\n</tr>\n<tr>\n<td>127</td>\n<td>没找到命令</td>\n</tr>\n<tr>\n<td>128</td>\n<td>无效的退出参数</td>\n</tr>\n<tr>\n<td>128+x</td>\n<td>与Linux信号x相关的严重错误</td>\n</tr>\n<tr>\n<td>130</td>\n<td>通过Ctrl+C终止的命令</td>\n</tr>\n<tr>\n<td>255</td>\n<td>正常范围之外的退出状态码</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ asfg</span><br><span class=\"line\">未找到 'asfg' 命令，您要输入的是否是：</span><br><span class=\"line\"> 命令 'asdfg' 来自于包 'aoeui' (universe)</span><br><span class=\"line\">asfg：未找到命令</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $?</span><br><span class=\"line\">127</span><br></pre></td></tr></table></figure>\n<p><strong>exit命令</strong></p>\n<p>默认，shell脚本会以脚本最后的一个命令的退出状态码退出。</p>\n<p>但是我们可以改变这种默认行为，返回自己的退出状态码。exit命令允许在脚本结束时指定一个状态退出码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test13</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the <span class=\"built_in\">exit</span> status</span></span><br><span class=\"line\">var1=10</span><br><span class=\"line\">var2=30</span><br><span class=\"line\">var3=$[$var1 + $var2]</span><br><span class=\"line\">echo The answer is $var3</span><br><span class=\"line\">exit 5</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test13</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test13</span><br><span class=\"line\">The answer is 40</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $?</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n<p>注意最大255，如果大于它，得到的是求模的结果（余数）。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>内容</strong></p>\n<ul>\n<li>使用多个命令</li>\n<li>创建脚本文件</li>\n<li>显示消息</li>\n<li>使用变量</li>\n<li>输入输出重定向</li>\n<li>管道</li>\n<li>数学运算</li>\n<li>退出脚本</li>\n</ul>\n</blockquote>\n<h3 id=\"使用多个命令\"><a href=\"#使用多个命令\" class=\"headerlink\" title=\"使用多个命令\"></a>使用多个命令</h3><p>如果多个命令一起使用，可以放在一行并用分号分隔。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ date; who</span><br><span class=\"line\">2017年 07月 26日 星期三 09:53:43 CST</span><br><span class=\"line\">wsx      tty7         2017-07-26 09:48 (:0)</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建脚本文件\"><a href=\"#创建脚本文件\" class=\"headerlink\" title=\"创建脚本文件\"></a>创建脚本文件</h3><p>在创建脚本文件时，必须在文件的第一行指定要使用的shell，格式为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br></pre></td></tr></table></figure>\n<p>脚本文件的第一行中<code>#</code>后的惊叹号会告诉shell使用哪个shell来运行脚本（如果是其他编码语言脚本，像python，第一行类似）。</p>\n<p>其他地方的<code>#</code>用作注释行。</p>\n<p>添加名为<code>test1</code>的脚本文件，内容为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># This script displays the date and who's logged on</span></span><br><span class=\"line\">date</span><br><span class=\"line\">who</span><br></pre></td></tr></table></figure>\n<p>现在运行脚本，结果会是：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx<span class=\"meta\">@wsx</span>-<span class=\"string\">ubuntu:</span>~/script_learn$ test1</span><br><span class=\"line\">未找到 <span class=\"string\">'test1'</span> 命令，您要输入的是否是：</span><br><span class=\"line\"> 命令 <span class=\"string\">'testr'</span> 来自于包 <span class=\"string\">'python3-testrepository'</span> (main)</span><br><span class=\"line\"> 命令 <span class=\"string\">'testr'</span> 来自于包 <span class=\"string\">'python-testrepository'</span> (universe)</span><br><span class=\"line\"> 命令 <span class=\"string\">'test'</span> 来自于包 <span class=\"string\">'coreutils'</span> (main)</span><br><span class=\"line\">test1：未找到命令</span><br></pre></td></tr></table></figure>\n<p>我们现在需要做的是让bash shell能够找到我们的脚本文件。shell会通过<code>PATH</code>环境变量来查找命令，我们可以看看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $PATH</span><br><span class=\"line\">/home/wsx/Anaconda/bin:/home/wsx/Anoconda/ENTER/bin:/usr/lib/jvm/default-java/bin:/home/wsx/bin:/home/wsx/Anaconda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>\n<p>很显然，我们的文件没有在这些目录范围内。要让shell找到test1脚本，我们可以采取以下两种做法之一：</p>\n<ul>\n<li>将shell脚本文件所处的目录添加到<code>PATH</code>环境变量中；</li>\n<li>在提示符中用绝对路径或相对路径来引用shell脚本文件。</li>\n</ul>\n<p>第二种方法比较简单，我们在这里试试：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1</span><br><span class=\"line\">bash: ./test1: 权限不够</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ll test1 # 发现权限不够，查看文件的权限</span><br><span class=\"line\">-rw-rw-r-- 1 wsx wsx 73 7月  26 10:03 test1</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test1 # 修改权限，添加可执行属性</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1 # 成功运行脚本</span><br><span class=\"line\">2017年 07月 26日 星期三 10:09:23 CST</span><br><span class=\"line\">wsx      tty7         2017-07-26 09:48 (:0)</span><br></pre></td></tr></table></figure>\n<h3 id=\"显示消息\"><a href=\"#显示消息\" class=\"headerlink\" title=\"显示消息\"></a>显示消息</h3><p>在<code>echo</code>命令后面加上一个字符串，就能显示出这个文本字符串。这种方式可以添加自己的文本消息来告诉脚本用户脚本正在做什么。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo This is a test</span><br><span class=\"line\">This is a test</span><br></pre></td></tr></table></figure>\n<p>如果文本本身带有字符串，我们需要<strong>用单引号或双引号来划定文本字符串</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo \"Let's see if this'll work\"</span><br><span class=\"line\">Let's see if this'll work</span><br></pre></td></tr></table></figure>\n<p>我们修改下之前的test1文件，增加消息显示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This script displays the date and who<span class=\"string\">'s logged on</span></span></span><br><span class=\"line\">echo The time and date are:</span><br><span class=\"line\">date</span><br><span class=\"line\">echo \"Let's see who's logged into the system\"</span><br><span class=\"line\">who</span><br></pre></td></tr></table></figure>\n<p>运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1</span><br><span class=\"line\">The time and date are:</span><br><span class=\"line\">2017年 07月 26日 星期三 10:17:59 CST</span><br><span class=\"line\">Let's see who's logged into the system</span><br><span class=\"line\">wsx      tty7         2017-07-26 09:48 (:0)</span><br></pre></td></tr></table></figure>\n<p><strong>如果想把文本字符串和命令输出显示在同一行中</strong>，可以用<code>echo</code>语句的<code>-n</code>参数。需要在字符串的两侧加上引号，并且保证字符串尾部有一个空格（不然字符串和命令输出就粘连到一起了）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This script displays the date and who<span class=\"string\">'s logged on</span></span></span><br><span class=\"line\">echo -n \"The time and date are: \"</span><br><span class=\"line\">date</span><br><span class=\"line\">echo  \"Let's see who's logged into the system: \"</span><br><span class=\"line\">who</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 运行结果输出</span></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test1</span><br><span class=\"line\">The time and date are: 2017年 07月 26日 星期三 10:24:04 CST</span><br><span class=\"line\">Let's see who's logged into the system:</span><br><span class=\"line\">wsx      tty7         2017-07-26 09:48 (:0)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h3><p>变量允许我们临时性地将信息存储在shell脚本中，以便和脚本中的其他命令一起使用。</p>\n<p><strong>环境变量</strong></p>\n<p>shell维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用户名、用户的系统ID(也称为UID)、用户默认主目录以及shell查找程序的搜索路径。</p>\n<p>使用<code>set</code>命令显示一份完整的当前环境变量列表。<code>env</code>与<code>printenv</code>命令都可以显示全局变量。（这些命令输出结果比较多，不展示了。之前关于环境变量的笔记有比较详细的描述。）</p>\n<p>在环境变量名称之前加上美元符可以使用这些环境变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">! /bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> display user information from the system</span></span><br><span class=\"line\">echo \"User info for userid: $USER\"</span><br><span class=\"line\">echo UID: $UID</span><br><span class=\"line\">echo HOME: $HOME</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test2</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test2</span><br><span class=\"line\">User info for userid: wsx</span><br><span class=\"line\">UID: 1000</span><br><span class=\"line\">HOME: /home/wsx</span><br></pre></td></tr></table></figure>\n<p>可以想象的到，如果我们想要使用实际的美元符而不是引用变量，肯定会出问题。这时候我们需要在美元符前面加上<code>\\</code>进行转义，以显示美元符本身。</p>\n<p><strong>用户变量</strong></p>\n<p>使用等号将值赋给用户变量。<strong>注意，在变量、等号和值之间不能出现空格！</strong>这个是初学者常见的一个问题，本人也非常不太适应这个。因为在其他语言中不区分等号两边的空格，相信接触过其他脚本的朋友们肯定有习惯打空格使代码美观的，这在bash shell中是万万行不通滴。</p>\n<p>一个使用的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing variables</span></span><br><span class=\"line\">days=10</span><br><span class=\"line\">guest=\"Katie\"</span><br><span class=\"line\">echo \"$guest checked in $days days ago\"</span><br><span class=\"line\">days=5</span><br><span class=\"line\">guest=\"Jessica\"</span><br><span class=\"line\">echo \"$guest checked in $days days ago\"</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test3</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test3</span><br><span class=\"line\">Katie checked in 10 days ago</span><br><span class=\"line\">Jessica checked in 5 days ago</span><br></pre></td></tr></table></figure>\n<p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不需要使用美元符。</p>\n<h3 id=\"命令替换\"><a href=\"#命令替换\" class=\"headerlink\" title=\"命令替换\"></a>命令替换</h3><p>shell脚本最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。</p>\n<p>有两种方法可以将命令输出赋给变量：</p>\n<ul>\n<li>反引号字符(`)</li>\n<li>$()格式</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要么用一对反引号把整个命令行命令围起来：</span><br><span class=\"line\">testing=`date`</span><br><span class=\"line\">要么使用$()格式</span><br><span class=\"line\">testing=<span class=\"variable\">$(date)</span></span><br></pre></td></tr></table></figure>\n<p>下面是一个例子，在脚本中通过命令替换获得当前日期并用它来生成唯一文件名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> copy the /usr/bin directory listing to a <span class=\"built_in\">log</span> file</span></span><br><span class=\"line\">today=$(date +%y%m%d)</span><br><span class=\"line\">ls /usr/bin -al &gt; log.$today</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test4</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test4</span><br></pre></td></tr></table></figure>\n<h3 id=\"重定向输入和输出\"><a href=\"#重定向输入和输出\" class=\"headerlink\" title=\"重定向输入和输出\"></a>重定向输入和输出</h3><p>通过几个操作符进行重定向，我们可以将命令的结果输出到另外的位置（文件）。当然，重定向可以用于输入。</p>\n<p><strong>输出重定向</strong></p>\n<p>最基本的操作符是<code>&gt;</code>。比如我们想要输出命令结果到一个指定文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ date &gt; test6</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ls -l test6</span><br><span class=\"line\">-rw-rw-r-- 1 wsx wsx 43 7月  26 16:42 test6</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test6</span><br><span class=\"line\">2017年 07月 26日 星期三 16:42:34 CST</span><br></pre></td></tr></table></figure>\n<p>如果想要将命令的输出追加到已有文件中，需要用双大于号（&gt;&gt;）来追加数据。</p>\n<p><strong>输入重定向</strong></p>\n<p>输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的输出重定向到文件。</p>\n<p>使用的符号是小于号（&lt;）。</p>\n<blockquote>\n<p>一种简单的记忆方法是：在命令行上，命令总是在左侧，而重定向符号“指向”数据流动的方向。小于号说明数据正在从输入文件流向命令。</p>\n</blockquote>\n<p>比如用wc命令检查文本的行数、词数和字节数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ wc &lt; test6</span><br><span class=\"line\"> 1  6 43</span><br></pre></td></tr></table></figure>\n<p>另一种输入重定向的方法是<strong>内联输入重定向</strong>。它无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据即可。它使用的符号是远小于号（&lt;&lt;），除了这个符号，我们还需要指定一个文本标记用来划分输入数据的开始和结尾。任何字符串都可以作为文本标记，但在数据的开始和结尾文本标记必须一致。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ wc &lt;&lt; EOF</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">test</span> string1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">test</span> string2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">test</span> string3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> EOF</span></span><br><span class=\"line\"> 3  6 39</span><br></pre></td></tr></table></figure>\n<p>它的形式为：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">command</span> &lt;&lt; marker</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">data</span></span></span><br><span class=\"line\"><span class=\"title\">marker</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h3><p>有时候需要将一个命令的输出作为另一个命令的输入。通过<code>|</code>符号分隔命令即可实现管道。</p>\n<p>比如我想查看某个文件（test1）的前两行并进行排序，操作如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This script displays the date and who<span class=\"string\">'s logged on</span></span></span><br><span class=\"line\">echo -n \"The time and date are: \"</span><br><span class=\"line\">date</span><br><span class=\"line\">echo  \"Let's see who's logged into the system: \"</span><br><span class=\"line\">who</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test1 | head -2 | sort</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This script displays the date and who<span class=\"string\">'s logged on</span></span></span><br></pre></td></tr></table></figure>\n<p>管道的强大之处在于可以根据自己的需求灵活地组合和使用各种linux命令工具。这里只是一个简单的例子，要熟练掌握少不了平时多多研究和练习。</p>\n<h3 id=\"执行数学运算\"><a href=\"#执行数学运算\" class=\"headerlink\" title=\"执行数学运算\"></a>执行数学运算</h3><p>对shell脚本来说，执行数学运算非常麻烦。有两种实现方式。</p>\n<p><strong>expr</strong>命令</p>\n<p><code>expr</code>命令允许在命令行上处理数学表达式，但是特别笨拙。（Bourne shell中）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ exrpr 1 + 5</span><br><span class=\"line\">未找到 'exrpr' 命令，您要输入的是否是：</span><br><span class=\"line\"> 命令 'expr' 来自于包 'coreutils' (main)</span><br><span class=\"line\">exrpr：未找到命令</span><br></pre></td></tr></table></figure>\n<p>看到没有，那算了。它基本涉及的操作跟我们使用的其他语言是一致的。但是有些问题需要处理，像<code>*</code>是通配符，在运算是是做乘号处理的，需要进行转义。</p>\n<p><strong>使用方括号</strong></p>\n<p>bash shell提供了一种更简单的方法来执行数学表达式。在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（$[operator]）将数学表达式围起来。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ var1=$[1+5]</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $var1</span><br><span class=\"line\">6</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ var2=$[$var1+2]</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $var2</span><br><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n<p>这种方式不仅方便，而且因为在方括号内，不会让shell误解乘号或其他符号。</p>\n<p>但bash shell计算有一个主要限制：<strong>它只支持整数运算！</strong></p>\n<p><strong>浮点解决方案</strong></p>\n<p>最常见的方案是用内建的bash计算器。它实际上是一门编程语言，它允许在命令行中输入浮点表达式，然后解释并计算该表达式，最后返回结果。bash计算器能够识别：</p>\n<ul>\n<li>数字（整数和浮点数）</li>\n<li>变量（简单变量和数组）</li>\n<li>注释（/<em> </em>/开始的行）</li>\n<li>表达式</li>\n<li>编程语句</li>\n<li>函数</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ bc</span><br><span class=\"line\">bc 1.06.95</span><br><span class=\"line\">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class=\"line\">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class=\"line\">For details type `warranty'.</span><br><span class=\"line\">12 * 5.4</span><br><span class=\"line\">64.8</span><br><span class=\"line\">3.156 * (3 + 5)</span><br><span class=\"line\">25.248</span><br><span class=\"line\">quit</span><br></pre></td></tr></table></figure>\n<p>在脚本中使用bc</p>\n<p>可以用命令替换运行bc命令，并将输出赋给一个变量。基本格式如下：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">variable</span>=$(echo <span class=\"comment\">\"options; expression\"</span> |<span class=\"comment\"> bc)</span></span><br></pre></td></tr></table></figure>\n<p>options设置变量，expression参数定义了通过bc执行的数学表达式。</p>\n<p>看一个简单实例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test9</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">var1=$(echo \"scale=4; 3.44/5\" | bc)</span><br><span class=\"line\">echo The answer is $var1</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test9</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test9</span><br><span class=\"line\">The answer is .6880</span><br></pre></td></tr></table></figure>\n<p>这个例子将<code>scale</code>变量设置为四位小数，并在<code>expression</code>部分指定了特定的运算。</p>\n<p>这个方法适用于较短的运算，但有时我们会涉及更多的数字。如果需要进行大量运算，在一个命令行中列出多个表达式就会有点麻烦。</p>\n<p>这里有一个解决方法：使用内联输入重定向，将一个文件重定向到bc命令来处理。格式为：</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable=$(bc &lt;&lt; <span class=\"built_in\">EOF</span></span><br><span class=\"line\">options</span><br><span class=\"line\"><span class=\"built_in\">statements</span></span><br><span class=\"line\">expressions</span><br><span class=\"line\"><span class=\"built_in\">EOF</span>)</span><br></pre></td></tr></table></figure>\n<p><code>EOF</code>文本字符串标识了内联重定向数据的起始。注意，仍然需要命令替换符号将bc命令的输出赋给变量。</p>\n<p>下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test10</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">var1=10.46</span><br><span class=\"line\">var2=43.67</span><br><span class=\"line\">var3=33.2</span><br><span class=\"line\">var4=71</span><br><span class=\"line\"></span><br><span class=\"line\">var5=$(bc &lt;&lt;EOF</span><br><span class=\"line\">scale=4</span><br><span class=\"line\">a1 = ( $var1 * $var2)</span><br><span class=\"line\">b1 = ( $var3 * $var4)</span><br><span class=\"line\">a1 + b1</span><br><span class=\"line\">EOF</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">echo The final answer for this mess is $var5</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test10</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test10</span><br><span class=\"line\">The final answer for this mess is 2813.9882</span><br></pre></td></tr></table></figure>\n<p>在普通的shell脚本中，数字默认当做字符串处理。这也是为什么我们脚本处理计算麻烦和我们需要特定的工具和方法来进行处理。一定要注意区分。</p>\n<h3 id=\"退出脚本\"><a href=\"#退出脚本\" class=\"headerlink\" title=\"退出脚本\"></a>退出脚本</h3><p>前面运行的脚本都是命令执行完成，脚本自动结束。其实我们可以用更为优雅的方式告诉shell命令运行完成，因为每个命令都使用<strong>退出状态码（exit status）</strong>，它是一个0-255的整数值，我们可以捕获这个值并在脚本中使用。</p>\n<p>Linux提供了一个专门的变量<code>$?</code>来保存上个已执行命令的退出状态码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ date</span><br><span class=\"line\">2017年 07月 27日 星期四 10:44:18 CST</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $?</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p>按照惯例，一个成功结束的命令的退出状态码是0。如果有错误，则显示一个正数值。</p>\n<p>Linux错误退出状态码没有什么标准，但有一些参考：</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>命令成功结束</td>\n</tr>\n<tr>\n<td>1</td>\n<td>一般性未知错误</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不适合的shell命令</td>\n</tr>\n<tr>\n<td>126</td>\n<td>命令不可执行</td>\n</tr>\n<tr>\n<td>127</td>\n<td>没找到命令</td>\n</tr>\n<tr>\n<td>128</td>\n<td>无效的退出参数</td>\n</tr>\n<tr>\n<td>128+x</td>\n<td>与Linux信号x相关的严重错误</td>\n</tr>\n<tr>\n<td>130</td>\n<td>通过Ctrl+C终止的命令</td>\n</tr>\n<tr>\n<td>255</td>\n<td>正常范围之外的退出状态码</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ asfg</span><br><span class=\"line\">未找到 'asfg' 命令，您要输入的是否是：</span><br><span class=\"line\"> 命令 'asdfg' 来自于包 'aoeui' (universe)</span><br><span class=\"line\">asfg：未找到命令</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $?</span><br><span class=\"line\">127</span><br></pre></td></tr></table></figure>\n<p><strong>exit命令</strong></p>\n<p>默认，shell脚本会以脚本最后的一个命令的退出状态码退出。</p>\n<p>但是我们可以改变这种默认行为，返回自己的退出状态码。exit命令允许在脚本结束时指定一个状态退出码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ cat test13</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the <span class=\"built_in\">exit</span> status</span></span><br><span class=\"line\">var1=10</span><br><span class=\"line\">var2=30</span><br><span class=\"line\">var3=$[$var1 + $var2]</span><br><span class=\"line\">echo The answer is $var3</span><br><span class=\"line\">exit 5</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ chmod u+x test13</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ ./test13</span><br><span class=\"line\">The answer is 40</span><br><span class=\"line\">wsx@wsx-ubuntu:~/script_learn$ echo $?</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n<p>注意最大255，如果大于它，得到的是求模的结果（余数）。</p>"},{"title":"Linux数据处理命令工具","author":"王诗翔","date":"2017-09-02T16:00:00.000Z","_content":"\n\n\n参考学习《Bioinformatics. Data. Skills》，这里简要地整理下Linux用来处理数据文本的工具。具体命令详情请在[Linux命令大全](http://man.linuxde.net/)中搜索或者查阅其他相关资料。\n\n<!-- more -->\n\n`head`,`tail`查看文档头尾。`-n`选项可以指定行数。\n\n`less`用来查阅文档，`q`退出，`space bar`翻页，`g`第一行，`G`最后一行，`j`下，`k`上,`/<pattern>`往下搜索模式，`?<pattern>`往上搜索模式，`n`前一个匹配字符，`N`后一个匹配字符。\n\n`less`可以用于debug，查看中间输出结果。比如\n```shell\nstep1 input.txt | step2 | step3 > output.txt\n# step1,2,3为程序或命令名\n```\n可以写为\n```shell\nstep1 input.txt | less\nstep1 input.txt | step2 | less\nstep1 input.txt | step2 | step3 | less\n```\n\n## 纯文本信息汇总\n\n`wc`命令默认依次输出单词数、行数、总字符数。查看行数使用`wc -l`。\n如果存在空行，空行会被计数。可以使用`grep`命令实现非空行计数\n`grep -c \"[^ \\\\n\\\\t]\" some_data.bed`\n\n`ls -lh`以易读形式查看文件大小。\n\n输出文件列数：\n```shell\n# -F指定分隔符，此处假定是table键分隔，默认空格键\nawk -F \"\\t\" '{print NF; exit}' some_data.bed\n```\n\n### 怎么去除注释的元数据行呢？怎么计数非注释行行数呢？\n\n可以使用`tail`结合`awk`，试试gtf(基因组注释文件)\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ head -n 6 Homo_sapiens.GRCh37.75.gtf\n#!genome-build GRCh37.p13\n#!genome-version GRCh37\n#!genome-date 2009-02\n#!genome-build-accession NCBI:GCA_000001405.14\n#!genebuild-last-updated 2013-09\n1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";\n```\n可以看到注释行是5行，我们利用`tail`试试去掉它\n```shell\n# 注意此处 -n后接的\"+\"号\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ tail -n +5 Homo_sapiens.GRCh37.75.gtf | head -n 1\n#!genebuild-last-updated 2013-09\n```\n发现还有一行没去掉\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ tail -n +6 Homo_sapiens.GRCh37.75.gtf | head -n 1\n1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";\n```\n成功搞定，然后结合前面提到的`awk`命令即可计算行数。\n\n上面方法鲁棒性不够（人为地确定行数），一种更为通用的方法是`grep`结合`awk`命令\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 1\n1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";\n```\n推荐使用这种。\n\n## Cut\n\n\n`cut`可以处理列数据，`-f`选项指定列，可以是一个范围（比如2-8），注意不能用它给列排序。\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3\ngene\ntranscript\nexon\nexon\nexon\ntranscript\nexon\nexon\nexon\ntranscript\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5\ngene\t11869\t14412\ntranscript\t11869\t14409\nexon\t11869\t12227\nexon\t12613\t12721\nexon\t13221\t14409\ntranscript\t11872\t14412\nexon\t11872\t12227\nexon\t12613\t12721\nexon\t13225\t14412\ntranscript\t11874\t14409\n```\n`-d`选项可以指定分隔符，比如`-d,`指定`,`为分隔符。\n\n使用`column`命令来格式化输出，上次的命令结果输出明显没对齐，我们把它对齐看看：\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 | column -t\ngene        11869  14412\ntranscript  11869  14409\nexon        11869  12227\nexon        12613  12721\nexon        13221  14409\ntranscript  11872  14412\nexon        11872  12227\nexon        12613  12721\nexon        13225  14412\ntranscript  11874  14409\n```\n注意，使用这个命令是为了好观察，不要把用它处理然后把结果传入文本（会导致程序处理文件效率降低，因为文本解析速度会下降）。\n\n`cut`和`column`默认以`\\t`为分隔符，这里也能够用`-s`选项指定。\n\n先把之前的tab分隔文件弄成逗号分隔文件，然后使用`-s`选项看看：\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 |  awk '{FS=\"\\t\";OFS=\",\";}{print $1,$2,$3}'\ngene,11869,14412\ntranscript,11869,14409\nexon,11869,12227\nexon,12613,12721\nexon,13221,14409\ntranscript,11872,14412\nexon,11872,12227\nexon,12613,12721\nexon,13225,14412\ntranscript,11874,14409\n\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 |  awk '{FS=\"\\t\";OFS=\",\";}{print $1,$2,$3}'| column -s \",\" -t\ngene        11869  14412\ntranscript  11869  14409\nexon        11869  12227\nexon        12613  12721\nexon        13221  14409\ntranscript  11872  14412\nexon        11872  12227\nexon        12613  12721\nexon        13225  14412\ntranscript  11874  14409\n```\n\n## grep\n\n`grep`处理速度非常之快，能用它尽量用它。`--color=auto`可以激活颜色（标记匹配文字），更方便查看。\n\n`-v`选项排除匹配到的，`-w`进行完全匹配。这样可以防止，你想排除`abc`结果把`abc1`，`abcd`也排除掉了。\n\n`-B`指定输出包括匹配到的前多少行，比如`-B1`就是前一行；`-A`指定输出包括匹配到的后多少行，比如`-A2`就是包括了后两行。`-C`指定输出包括匹配到的前后多少行。\n`grep`支持基本正则表达式，`-E`指定支持扩展表达式，或者用`egrep`命令。\n`-c`选项对匹配的行计数；`-o`选项只抽离输出匹配的部分\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -E -o 'gene_id \"\\w+\"' Homo_sapiens.GRCh37.75.gtf | head -n 5\ngene_id \"ENSG00000223972\"\ngene_id \"ENSG00000223972\"\ngene_id \"ENSG00000223972\"\ngene_id \"ENSG00000223972\"\ngene_id \"ENSG00000223972\"\n```\n发现冗余项非常多，如果我们只要唯一的呢，怎么办？\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -E -o 'gene_id \"(\\w+)\"' Homo_sapiens.GRCh37.75.gtf | cut -f2 -d\" \"| sed 's/\"//g' | sort | uniq | head -n 10\nENSG00000000003\nENSG00000000005\nENSG00000000419\nENSG00000000457\nENSG00000000460\nENSG00000000938\nENSG00000000971\nENSG00000001036\nENSG00000001084\nENSG00000001167\n```\n虽然我的笔记本呼啦啦作响，但是还是非常快就跑完了。\n\n\n\n## file查看文件编码\n\n```shell\nwsx@wsx-ubuntu:~$ file regular_express.txt\nregular_express.txt: ASCII text, with CRLF, LF line terminators\n```\n常用的大型数据文件一般存为ASCII码形式（像几大基因bank的数据文件），而我们自己认为创建的常为UTF-8，所以有时候认为处理文件需要会碰到把UTF-8编码的字符插入到ASCII码文件里去了。遇到这种问题，我们可以用`hexdump -c`命令查看出错的地方（手边没有这样的文件，就不举例了）。\n\n## 用sort对文本排序\n\n我们先创建一个bed格式文件来试试这个命令：\n```shell\nwsx@wsx-ubuntu:~$ cat test.bed\nchr1\t26\t39\nchr3\t32\t47\nchr1\t40\t50\nchr1\t9\t28\nchr2\t35\t54\nchr1\t10\t19\nwsx@wsx-ubuntu:~$ sort test.bed\nchr1\t10\t19\nchr1\t26\t39\nchr1\t40\t50\nchr1\t9\t28\nchr2\t35\t54\nchr3\t32\t47\n\n```\n可以明显看到文本按照第一列进行了排序。\n默认，`sort`用空格或tab键作为域（列）分隔符。如果我们用其他形式的分隔符，需要用`-t`选项指定。\n\n\n下面是对`bed`文件最通用的排序命令：\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed\nchr1\t9\t28\nchr1\t10\t19\nchr1\t26\t39\nchr1\t40\t50\nchr2\t35\t54\nchr3\t32\t47\n```\n基本操作`bedtools`软件都会先用这个命令对`bedtools`文件排序。\n现在略加解释一下，`sort`用`-k`选项指定某列的排序方式。而每次使用`-k`选项都要带上指定列的范围(start, end)。如果只指定一列，就为(start,start)了，像上面命令的`-k1,1`就是。也许你会觉得`-k2,2n`很奇怪，这里的`n`指定程序把第二列当做数值对待。如果不做设定，都是当做字符对待（shell都是这么对待数值数据的）。所以总结其他这一行命令就是对第一列按照字符排序，第二列按照数值排序。\n\n我们可以用`-c`选项检查一个文件是不是已经按照过某种方式排过序了。\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed | sort -k1,1 -k2,2 -c\nsort：-:2：无序： chr1\t10\t19\nwsx@wsx-ubuntu:~$ echo $?\n1\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed | sort -k1,1 -k2,2n -c\nwsx@wsx-ubuntu:~$ echo $?\n0\n\n```\n上面可以清楚地看到`sort`是怎么对待文件的（一般shell返回0表示成功执行）。\n```shell\nwsx@wsx-ubuntu:~$ tsfds\ntsfds：未找到命令\nwsx@wsx-ubuntu:~$ echo $?\n127\nwsx@wsx-ubuntu:~$ echo test\ntest\nwsx@wsx-ubuntu:~$ echo $?\n0\n```\nshell的命令退出状态码表示了该命令执行的完成的某种情况。不同的状态码有不同的含义，具体可以百度查阅（我之前整理的shell笔记应该讲过，可以看看）。\n\n反向排序用`-r`选项。如果你只想反转一列，可以把它加在`-k`选项后。\n\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2nr test.bed\nchr1\t40\t50\nchr1\t26\t39\nchr1\t10\t19\nchr1\t9\t28\nchr2\t35\t54\nchr3\t32\t47\n```\n现在我给`test.bed`加一行：\n```shell\nwsx@wsx-ubuntu:~$ cat test.bed\nchr1\t26\t39\nchr3\t32\t47\nchr1\t40\t50\nchr1\t9\t28\nchr2\t35\t54\nchr1\t10\t19\nchr11\t22\t56\n```\n你会发现有点奇怪\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed\nchr1\t9\t28\nchr1\t10\t19\nchr1\t26\t39\nchr1\t40\t50\nchr11\t22\t56\nchr2\t35\t54\nchr3\t32\t47\n```\n怎么`chr11`在`chr2`前面？其实`sort`排序的方式有点像查字典。例子中，命令先比较`c`，然后比较`h`，然后比较`r`，接着比较`1`，自然`11`会在`2`前面了。这里可以添加`V`选项修改。\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1V -k2,2n test.bed\nchr1\t9\t28\nchr1\t10\t19\nchr1\t26\t39\nchr1\t40\t50\nchr2\t35\t54\nchr3\t32\t47\nchr11\t22\t56\n```\n是不是觉得这样更可观一些？不过通常在处理数据时不做此处理，符合 规范的数据可以让后续处理程序效率更高。\n\n基本掌握`sort`这些也够用了，它主要为后续处理服务。如果想知道其他的用法，查查吧，同时欢迎发文来交流。\n\n## 用uniq寻找唯一值\n\n首先创建样例文本\n```shell\nwsx@wsx-ubuntu:~$ cat test.letter\nA\nA\nB\nC\nB\nC\nC\nC\nD\nF\nD\n```\n使用`uniq`看看\n```shell\nwsx@wsx-ubuntu:~$ uniq test.letter\nA\nB\nC\nB\nC\nD\nF\nD\n```\n尼玛，怎么不对。它好像只去掉了连续的同一字符。怎么办？想想我们刚学了什么命令？`sort`不是刚好可以把同样的字符弄到一起去吗，然后再使用`uniq`，嘿嘿：\n```shell\nwsx@wsx-ubuntu:~$ sort test.letter | uniq\nA\nB\nC\nD\nF\n```\n哟呵，got you。\n\n加`-c`选项计数：\n```shell\nwsx@wsx-ubuntu:~$ sort test.letter | uniq -c\n      2 A\n      2 B\n      4 C\n      2 D\n      1 F\n```\n把结果再排序\n```shell\nwsx@wsx-ubuntu:~$ sort test.letter | uniq -c | sort -rn\n      4 C\n      2 D\n      2 B\n      2 A\n      1 F\n```\n`-d`选项只输出重复行\n```shell\nwsx@wsx-ubuntu:~$ cat test.letter\nA\nA\nB\nC\nB\nC\nC\nC\nD\nF\nD\nwsx@wsx-ubuntu:~$ uniq -d test.letter\nA\nC\nwsx@wsx-ubuntu:~$ sort test.letter | uniq -d\nA\nB\nC\nD\n\n```\n使用时需要注意处理不同导致的结果差异。\n\n## Join 命令\n\n用来连接文件。\n假设现在我们有两个文件：\n\n```shell\nwsx@wsx-ubuntu:/tmp$ cat example.bed\nchr1\t26\t39\nchr1\t32\t47\nchr3\t11\t28\nchr1\t40\t49\nchr3\t16\t27\nchr1\t9\t28\nchr2\t35\t53\nwsx@wsx-ubuntu:/tmp$ cat example_length.txt\nchr1\t53453\nchr2\t34356\nchr3\t24356\n```\n我想把第二个文件说明染色体长度添加到第一个文件对应染色体的第三列。\n我们首先要给文件排序（使用`join`前必须做），然后使用`join`命令。\n```shell\nwsx@wsx-ubuntu:/tmp$ sort -k1,1 example.bed > example_sorted.bed\nwsx@wsx-ubuntu:/tmp$ sort -c -k1,1 example_length.txt\nwsx@wsx-ubuntu:/tmp$ cat example_sorted.bed\nchr1\t26\t39\nchr1\t32\t47\nchr1\t40\t49\nchr1\t9\t28\nchr2\t35\t53\nchr3\t11\t28\nchr3\t16\t27\nwsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 example_sorted.bed  example_length.txt > example_with_length.txt\nwsx@wsx-ubuntu:/tmp$ cat example_with_length.txt\nchr1 26 39 53453\nchr1 32 47 53453\nchr1 40 49 53453\nchr1 9 28 53453\nchr2 35 53 34356\nchr3 11 28 24356\nchr3 16 27 24356\n```\n命令基本语法是\n```\njoin -1 <file_1_field> -2 <file_2_field> <file_1> <file_2>\n```\n既然名字叫`join`，就是两者必须有共同之处，通过共同的支点将两者连为一体。\n`-1`和`-2`选项后接参数分别指定了这个支点，也就是连接的域（列）。比如例子中，都是两个文件的第一列。\n\n两个文件中，第一列都共有`chr1(2)(3)`。 如果不一致会出现什么情况呢？\n\n```shell\nwsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 example_sorted.bed  example_length_alt.txt chr1 26 39 53453\nchr1 32 47 53453\nchr1 40 49 53453\nchr1 9 28 53453\nchr2 35 53 34356\n```\n如果第二个文件没有`chr3`，`join`之后也没了！！\n\n我们可以通过`-a`选项指定哪一个文件可以不遵循配对\n```shell\nwsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 -a 1 example_sorted.bed  example_length_alt.txt\nchr1 26 39 53453\nchr1 32 47 53453\nchr1 40 49 53453\nchr1 9 28 53453\nchr2 35 53 34356\nchr3 11 28\nchr3 16 27\n```\n\n## awk\n\n`awk`是文本处理的一把好手，虽然它不能像`python`，`R`干一些高级复杂的主题工作，但是它具备完整的命令操作和编程体系。\n\n`awk`是一门语言，我不可能在学习的时候能够逻辑清晰详细地介绍给大家。主要是还通过实例来了解用法，加深认识。手册可以参考http://man.linuxde.net/awk。\n\n首先要明白的是，`awk`按行处理数据。在shell知识里，如果把一个文档看做一张表。那么一行就是一个**记录**，一列就是一个**域**。可以看出，`awk`就是按记录处理文本的。\n\n其次是`awk`的程序结构是\n```\npattern {action}\n```\npattern可以是表达式或者正则表达式。pattern有点像`if`语句，当它满足时就会执行相应的动作。\n\n另一个`awk`核心是它用`$0`表示所有列，`$1`，`$2`...等等表示对应的列。我们可以很方便地用它进行操作。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk '{print $0}' example.bed\nchr1\t26\t39\nchr1\t32\t47\nchr3\t11\t28\nchr1\t40\t49\nchr3\t16\t27\nchr1\t9\t28\nchr2\t35\t53\nwsx@wsx-ubuntu:/tmp$ awk '{print $1}' example.bed\nchr1\nchr1\nchr3\nchr1\nchr3\nchr1\nchr2\nwsx@wsx-ubuntu:/tmp$ awk '{print $2}' example.bed\n26\n32\n11\n40\n16\n9\n```\n\n`print`语句就像动作一样输出你操作的结果。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk '{ print $2 \"\\t\" $3}' example.bed\n26\t39\n32\t47\n11\t28\n40\t49\n16\t27\n9\t28\n35\t53\nwsx@wsx-ubuntu:/tmp$ awk '{ print $2  $3}' example.bed\n2639\n3247\n1128\n4049\n1627\n928\n3553\nwsx@wsx-ubuntu:/tmp$ awk '{ print $2 , $3}' example.bed\n26 39\n32 47\n11 28\n40 49\n16 27\n9 28\n35 53\n\n```\n了解上述几个语句的不同。\n\n表示染色体名一般用带`chr`或者不带`chr`标志两种方式。当我们要用到这两种时，肯定要让它们能够对应起来，也就是转换。`awk`命令可以非常方便地添加`chr`标记。\n\n下面我先把例子文件的`chr`去掉，然后加上试试。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk '{ print $1}' example.bed\nchr1\nchr1\nchr3\nchr1\nchr3\nchr1\nchr2\nwsx@wsx-ubuntu:/tmp$ awk '{ print $1}' example.bed | cut -c4\n1\n1\n3\n1\n3\n1\n2\nwsx@wsx-ubuntu:/tmp$ awk '{ print $1}' example.bed | cut -c4 | awk '{print \"chr\"$1}'\nchr1\nchr1\nchr3\nchr1\nchr3\nchr1\nchr2\n```\n\n`awk`作为一门编程语言，它支持各种操作符（运算，逻辑，判断）喔。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk '$3 - $2 >18' example.bed\nchr1\t9\t28\nwsx@wsx-ubuntu:/tmp$ awk '$1 ~/chr1/ && $3 - $2 > 10' example.bed\nchr1\t26\t39\nchr1\t32\t47\nchr1\t9\t28\n\n# 这里 ~ 符号用来匹配正则表达式\n```\n还有`awk`存在一些变量，像`NR`表示行号，`OFS`表示输出分隔符等。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk 'NR >= 3 && NR <= 5' example.bed\nchr3\t11\t28\nchr1\t40\t49\nchr3\t16\t27\n```\n\n如果我们想把`gtf`文件转换成为`bed`格式，可以使用\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ head -n1000 Homo_sapiens.GRCh37.75.gtf | awk '!/^#/{ print $1 \"\\t\" $4-1 \"\\t\" $5} ' | head -n 3\n1\t11868\t14412\n1\t11868\t14409\n1\t11868\t12227\n```\n因为篇幅有限，我不可能输出所有结果，所以只取部分数据做了运算。\n\n\n\n## 用Sed进行流编辑\n\n`sed`命令从文本或者标准输入中每次读入一行数据。\n\n我们先从简单的实例出发，看下该命令怎么将一列中的`chrm12`,`chrom2`等转换成`chr12`，`chr2`的格式。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat chrms.txt\nchrom1    3214482    3216968\nchrom1    3214234    3216968\nchrom1    3213425    3210653\n\nwangsx@SC-201708020022:~/tmp$ sed 's/chrom/chr/' chrms.txt\nchr1    3214482    3216968\nchr1    3214234    3216968\nchr1    3213425    3210653\n```\n\n虽然示例文件处理仅仅只有三行，但我们可以将这种处理方式运用到上G甚至更大的数据文件中，而不用打开整个文件进行处理。并且，可以借助重导向实现对数据处理结果的输出。\n\n`sed`替换命令采用的格式是\n\n```shell\ns/pattern/replacement/\n```\n\n`sed`会自动搜索符合`pattern`的字符串，然后修改为`replacement`（我们想要修改后的样子）。一般默认`sed`只替换第一个匹配的`pattern`，我们可以通过添加全局标识`g`将其应用到数据的所有行中。\n\n```shell\ns/pattern/replacement/g\n```\n\n如果我们想要忽略匹配的大小写，使用`i`标识\n\n```shell\ns/pattern/replacement/i\n```\n\n默认`sed`命令支持基本的POSIX正则表达式（BRE），可以通过`-E`选项进行拓展（ERE）。很多的Linux命令都这种方式，像常用的`grep`命令。\n\n\n\n再看一个实例，如果我们想把`chr1:28647389-28659480`这样格式的文字转换为三列，可以使用：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" | \\\n>  sed -E 's/^(chr[^:]+):([0-9]+)-([0-9]+)/\\1\\t\\2\\t\\3/'\nchr1    28647389        28659480\n```\n\n我们聚焦在第二个命令`sed`上。初看杂乱无章，但是从最大的结构看依旧是\n\n```shell\ns/pattern/replacement/\n```\n\n先看`pattern`部分，这是由几个简单正则表达式组成的复合体，几个`()`括起来的字符串可以单独看。第一个匹配`chr`加上一个非冒号的字符，第二个和第三个都是匹配多个数字。最开始的`^`表示以`chr`起始（前面没有字符），各个括号中间的是对应的字符。整体的`pattern`的目的就是为了找到文本中符合这种模式的字符串，如果只是想把这个模式找出来的话，几个括号可以不用加。显然这几个括号的作用就是将它们划分成多个域，帮助`sed`进行处理。可以看到`replacement`部分存在`\\1`,`\\2`,`\\3`，它恰好对应`()`的顺序。这样我们在中间插入`\\t`制表符，就可以完成我们想要的功能：将原字符串转换为三列。\n\n我本身对字符串并不是非常熟悉，懂一些元字符，可能讲解的不是很到位。不熟悉正则表达式的朋友，可以学习和参考下[学习正则表达式](http://www.jianshu.com/p/7c50954651fa)，是我从Github上Copy到的非常好的学习资料，有兴趣也可以Fork学习。\n\n上山的路总是有很多条，我们下面看下其他实现该功能的办法：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/[:-]/\\t/g'\nchr1    28647389        28659480\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/:/\\t/' | sed 's/-/\\t/'\nchr1    28647389        28659480\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  tr ':-' '\\t'\nchr1    28647389        28659480\n```\n\n这三种方式看起来都非常简单有效。它处理字符串的思路不是从匹配pattern然后替换入手，不对，应该说是不是从匹配所有pattern然后替换入手。处理的关键是只处理字符串中看似无用的连字符`:`与`-`，将其替换成制表符从而轻松完成分割。\n\n` sed 's/:/\\t/' | sed 's/-/\\t/'`可以通过`-e`选项写为` sed -e 's/:/\\t/' -e 's/-/\\t/'`，效果等价。\n\n\n默认`sed`命令支持基本的POSIX正则表达式（BRE），可以通过`-E`选项进行拓展（ERE）。很多的Linux命令都这种方式，像常用的`grep`命令。\n\n\n\n再看一个实例，如果我们想把`chr1:28647389-28659480`这样格式的文字转换为三列，可以使用：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" | \\\n>  sed -E 's/^(chr[^:]+):([0-9]+)-([0-9]+)/\\1\\t\\2\\t\\3/'\nchr1    28647389        28659480\n```\n\n我们聚焦在第二个命令`sed`上。初看杂乱无章，但是从最大的结构看依旧是\n\n```shell\ns/pattern/replacement/\n```\n\n先看`pattern`部分，这是由几个简单正则表达式组成的复合体，几个`()`括起来的字符串可以单独看。第一个匹配`chr`加上一个非冒号的字符，第二个和第三个都是匹配多个数字。最开始的`^`表示以`chr`起始（前面没有字符），各个括号中间的是对应的字符。整体的`pattern`的目的就是为了找到文本中符合这种模式的字符串，如果只是想把这个模式找出来的话，几个括号可以不用加。显然这几个括号的作用就是将它们划分成多个域，帮助`sed`进行处理。可以看到`replacement`部分存在`\\1`,`\\2`,`\\3`，它恰好对应`()`的顺序。这样我们在中间插入`\\t`制表符，就可以完成我们想要的功能：将原字符串转换为三列。\n\n我本身对字符串并不是非常熟悉，懂一些元字符，可能讲解的不是很到位。不熟悉正则表达式的朋友，可以学习和参考下[学习正则表达式](http://www.jianshu.com/p/7c50954651fa)，是我从Github上Copy到的非常好的学习资料，有兴趣也可以Fork学习。\n\n上山的路总是有很多条，我们下面看下其他实现该功能的办法：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/[:-]/\\t/g'\nchr1    28647389        28659480\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/:/\\t/' | sed 's/-/\\t/'\nchr1    28647389        28659480\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  tr ':-' '\\t'\nchr1    28647389        28659480\n```\n\n这三种方式看起来都非常简单有效。它处理字符串的思路不是从匹配pattern然后替换入手，不对，应该说是不是从匹配所有pattern然后替换入手。处理的关键是只处理字符串中看似无用的连字符`:`与`-`，将其替换成制表符从而轻松完成分割。\n\n` sed 's/:/\\t/' | sed 's/-/\\t/'`可以通过`-e`选项写为` sed -e 's/:/\\t/' -e 's/-/\\t/'`，效果等价。\n\n\n\n默认，`sed`会输出每一行的结果，用`replacement`替换`pattern`，但实际中我们可能会因此得到不想要的结果。比如下面的这个例子。\n\n如果我们想要抓出`gtf`文件第九列的转录名，可能会使用以下命令\n\n```shell\nwangsx@SC-201708020022:~/database$ zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | head -n 3 | \\\n> sed -E 's/.*transcript_id \"([^\"]+)\".*/\\1/'\nchr1    HAVANA  gene    11869   14409   .       +       .       gene_id \"ENSG00000223972.5_2\"; gene_type \"transcribed_unprocessed_pseudogene\"; gene_name \"DDX11L1\"; level 2; havana_gene \"OTTHUMG00000000961.2_2\"; remap_status \"full_contig\"; remap_num_mappings 1; remap_target_status \"overlap\";\nENST00000456328.2_1\nENST00000456328.2_1\n```\n\n我们可以发现一些没有转录名行的结果是输出整行，这可不是我们想要的。一种解决办法是在使用`sed`之前先抓出有`transcript_id`的行。其实`sed`命令本身也可以通过选项和参数设定解决这个问题，这里我们可以用`-n`选项关闭`sed`输出所有行，在最末的`/`后加`p`只输出匹配项。\n\n```shell\nwangsx@SC-201708020022:~/database$ zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | head -n 3 | sed -E -n 's/.*transc\nript_id \"([^\"]+)\".*/\\1/p'\nENST00000456328.2_1\nENST00000456328.2_1\n```\n\n注意方括号内`^`是非（取反）的意思。\n\n解释如下：\n\n1. 首先，匹配字符串\"transcript_id\"之前0或多个任意字符（`.`表示除换行键的任意字符）。\n2. 然后，匹配和捕获一个或多个不是引号的字符，用的是`[^\"]`\n\n`+`号的使用是一种非贪婪的方法。很多新手会用`*`，这是贪婪操作，往往会得不偿失，需要注意喔。\n\n```shell\nwangsx@SC-201708020022:~/database$ sed -E 's/transcript_id \"([^\"]+)\".*/\\1/' greedy_example.txt\nENSMUST00000160944\nwangsx@SC-201708020022:~/database$ sed -E 's/transcript_id \"(.*)\".*/\\1/' greedy_example.txt\nENSMUST00000160944\"; gene_name \"Gm16088\n```\n\n使用`*`时它会尽量多地去匹配符合要求的模式。\n\n\n\n我们也可以用`sed`命令来获取特定范围的行，比如说我要取出头10行，可以使用\n\n```shell\nsed -n '1,10p' filename\n```\n\n20到50行\n\n```shell\nsed -n '20,50p' filename\n```\n\n当然`sed`的功能特性远远不止这些，有待于大家更多地挖掘。不过需要注意的是，尽量让工具干它最擅长的事情。如果是复杂地大规模计算，还是最好写个Python脚本。\n\n> **KISS原则**:\n>\n> Keep Incredible Sed Simple\n\n\n\n## 高级Shell用法\n\n### 子shell\n\n首先需要记住**连续**命令和**管道**命令的区别：前者是简单地一个一个按顺序运行程序（一般用`&&`或者`;`）；后者前一个程序的输出结果会直接传到下一个命令程序的输入中（这不就是流程化操作么，用`|`分隔）。\n\n子shell可以让我们在一个独立的shell进程中执行连续命令。\n\n首先看个例子\n\n```shell\nwangsx@SC-201708020022:~/database$ echo \"this command\"; echo \"that command\" | sed 's/command/step/'\nthis command\nthat step\nwangsx@SC-201708020022:~/database$ (echo \"this command\"; echo \"that command\") | sed 's/command/step/'\nthis step\nthat step\n```\n\n发现仅仅加了个括号，结果就不同了。第二个命令就用了子shell，它把两个`echo`命令放进单独的空间执行后将结果传给下游。\n\n子shell在对`gtf`文件进行操作时有个非常有意思有用的用处。我们如果想对`gtf`文件排序，但是又想要保留文件头部注释信息，我们就能够用两次`grep`操作分别抓出注释和非注释信息，然后又把它结合在一起。下面看看效果，用`less`进行检查：\n\n```shell\nwangsx@SC-201708020022:~/database$ (zgrep \"^#\" gencode.v27lift37.annotation.gtf.gz; \\\n>  zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | \\\n>  sort -k1,1 -k4,4n) | less\n```\n\n\n\n可以看到，子shell确实能够给我们提供非常有用的操作去组合命令实现想要的功能。\n\n\n\n### 命令管道及进程替换\n\n很多生信命令行工具需要提供多个输入和输出参数，这用在管道命令里可能会导致非常低效的情形（管道只接受一个标准输入和输出）。幸好，我们可以使用命令管道来解决此类问题。\n\n**命名管道**，也成为FIFO（先入先出，额，这不是队列么:smile:）。它是一个特殊的排序文件，命名管道有点像文件，它可以永久保留在你的文件系统上（估计本质就是文件吧~）。\n\n我们用`mkfifo`来生成它\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ls -l fqin\nprw-rw-rw- 1 wangsx wangsx 0 9月   3 20:45 fqin\n```\n\n可以它看它权限的第一个字符是p，指代是pipe。说明是个特殊文件。\n\n我们像文件一样对它进行一些操作\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat fqin\nhello, named pipes\n[1]+  已完成               echo \"hello, named pipes\" > fqin\nwangsx@SC-201708020022:~/tmp$ rm fqin\n```\n\n比如当使用一个生信命令行工具\n\n```\nprocessing_tool --in1 in1.fq --in2 in2.fq --out1 out1.fq --out2 out2.fq\n```\n\n`in1.fq in2.fq`就可以上游输出数据到`processing_tool`的命名管道；同理`out1.fq out2.fq`可以是命名管道用来写进输出数据。\n\n但这样我们每次都得不停地创建和删除这些文件，解决办法是使用匿名管道，也叫进程替换。\n\n不能光说，看看例子就知道和理解了。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat <(echo \"hello, process substitution\")\nhello, process substitution\n```\n\n`echo`命令运行后使用了进程替换，产生匿名文件，然后匿名文件被重导向`cat`命令。\n\n把它用到工具上，就变成了(假定上游zcat下游执行grep命令)\n\n```shell\nprocessing_tool --in1 < (zcat file1) --in2 < (zcat file2) --out1 (gzip > outfile1) --out2 (gzip > outfile2)\n```\n","source":"_posts/2017-09-03-Linux-data-analysis-tools.md","raw":"---\ntitle:  Linux数据处理命令工具\nauthor: 王诗翔\ndate:  2017-09-03\ncategories:\n- Linux杂烩\n- 文本处理\ntags:\n- Linux shell\n- 数据处理\n---\n\n\n\n参考学习《Bioinformatics. Data. Skills》，这里简要地整理下Linux用来处理数据文本的工具。具体命令详情请在[Linux命令大全](http://man.linuxde.net/)中搜索或者查阅其他相关资料。\n\n<!-- more -->\n\n`head`,`tail`查看文档头尾。`-n`选项可以指定行数。\n\n`less`用来查阅文档，`q`退出，`space bar`翻页，`g`第一行，`G`最后一行，`j`下，`k`上,`/<pattern>`往下搜索模式，`?<pattern>`往上搜索模式，`n`前一个匹配字符，`N`后一个匹配字符。\n\n`less`可以用于debug，查看中间输出结果。比如\n```shell\nstep1 input.txt | step2 | step3 > output.txt\n# step1,2,3为程序或命令名\n```\n可以写为\n```shell\nstep1 input.txt | less\nstep1 input.txt | step2 | less\nstep1 input.txt | step2 | step3 | less\n```\n\n## 纯文本信息汇总\n\n`wc`命令默认依次输出单词数、行数、总字符数。查看行数使用`wc -l`。\n如果存在空行，空行会被计数。可以使用`grep`命令实现非空行计数\n`grep -c \"[^ \\\\n\\\\t]\" some_data.bed`\n\n`ls -lh`以易读形式查看文件大小。\n\n输出文件列数：\n```shell\n# -F指定分隔符，此处假定是table键分隔，默认空格键\nawk -F \"\\t\" '{print NF; exit}' some_data.bed\n```\n\n### 怎么去除注释的元数据行呢？怎么计数非注释行行数呢？\n\n可以使用`tail`结合`awk`，试试gtf(基因组注释文件)\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ head -n 6 Homo_sapiens.GRCh37.75.gtf\n#!genome-build GRCh37.p13\n#!genome-version GRCh37\n#!genome-date 2009-02\n#!genome-build-accession NCBI:GCA_000001405.14\n#!genebuild-last-updated 2013-09\n1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";\n```\n可以看到注释行是5行，我们利用`tail`试试去掉它\n```shell\n# 注意此处 -n后接的\"+\"号\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ tail -n +5 Homo_sapiens.GRCh37.75.gtf | head -n 1\n#!genebuild-last-updated 2013-09\n```\n发现还有一行没去掉\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ tail -n +6 Homo_sapiens.GRCh37.75.gtf | head -n 1\n1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";\n```\n成功搞定，然后结合前面提到的`awk`命令即可计算行数。\n\n上面方法鲁棒性不够（人为地确定行数），一种更为通用的方法是`grep`结合`awk`命令\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 1\n1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";\n```\n推荐使用这种。\n\n## Cut\n\n\n`cut`可以处理列数据，`-f`选项指定列，可以是一个范围（比如2-8），注意不能用它给列排序。\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3\ngene\ntranscript\nexon\nexon\nexon\ntranscript\nexon\nexon\nexon\ntranscript\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5\ngene\t11869\t14412\ntranscript\t11869\t14409\nexon\t11869\t12227\nexon\t12613\t12721\nexon\t13221\t14409\ntranscript\t11872\t14412\nexon\t11872\t12227\nexon\t12613\t12721\nexon\t13225\t14412\ntranscript\t11874\t14409\n```\n`-d`选项可以指定分隔符，比如`-d,`指定`,`为分隔符。\n\n使用`column`命令来格式化输出，上次的命令结果输出明显没对齐，我们把它对齐看看：\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 | column -t\ngene        11869  14412\ntranscript  11869  14409\nexon        11869  12227\nexon        12613  12721\nexon        13221  14409\ntranscript  11872  14412\nexon        11872  12227\nexon        12613  12721\nexon        13225  14412\ntranscript  11874  14409\n```\n注意，使用这个命令是为了好观察，不要把用它处理然后把结果传入文本（会导致程序处理文件效率降低，因为文本解析速度会下降）。\n\n`cut`和`column`默认以`\\t`为分隔符，这里也能够用`-s`选项指定。\n\n先把之前的tab分隔文件弄成逗号分隔文件，然后使用`-s`选项看看：\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 |  awk '{FS=\"\\t\";OFS=\",\";}{print $1,$2,$3}'\ngene,11869,14412\ntranscript,11869,14409\nexon,11869,12227\nexon,12613,12721\nexon,13221,14409\ntranscript,11872,14412\nexon,11872,12227\nexon,12613,12721\nexon,13225,14412\ntranscript,11874,14409\n\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 |  awk '{FS=\"\\t\";OFS=\",\";}{print $1,$2,$3}'| column -s \",\" -t\ngene        11869  14412\ntranscript  11869  14409\nexon        11869  12227\nexon        12613  12721\nexon        13221  14409\ntranscript  11872  14412\nexon        11872  12227\nexon        12613  12721\nexon        13225  14412\ntranscript  11874  14409\n```\n\n## grep\n\n`grep`处理速度非常之快，能用它尽量用它。`--color=auto`可以激活颜色（标记匹配文字），更方便查看。\n\n`-v`选项排除匹配到的，`-w`进行完全匹配。这样可以防止，你想排除`abc`结果把`abc1`，`abcd`也排除掉了。\n\n`-B`指定输出包括匹配到的前多少行，比如`-B1`就是前一行；`-A`指定输出包括匹配到的后多少行，比如`-A2`就是包括了后两行。`-C`指定输出包括匹配到的前后多少行。\n`grep`支持基本正则表达式，`-E`指定支持扩展表达式，或者用`egrep`命令。\n`-c`选项对匹配的行计数；`-o`选项只抽离输出匹配的部分\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -E -o 'gene_id \"\\w+\"' Homo_sapiens.GRCh37.75.gtf | head -n 5\ngene_id \"ENSG00000223972\"\ngene_id \"ENSG00000223972\"\ngene_id \"ENSG00000223972\"\ngene_id \"ENSG00000223972\"\ngene_id \"ENSG00000223972\"\n```\n发现冗余项非常多，如果我们只要唯一的呢，怎么办？\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -E -o 'gene_id \"(\\w+)\"' Homo_sapiens.GRCh37.75.gtf | cut -f2 -d\" \"| sed 's/\"//g' | sort | uniq | head -n 10\nENSG00000000003\nENSG00000000005\nENSG00000000419\nENSG00000000457\nENSG00000000460\nENSG00000000938\nENSG00000000971\nENSG00000001036\nENSG00000001084\nENSG00000001167\n```\n虽然我的笔记本呼啦啦作响，但是还是非常快就跑完了。\n\n\n\n## file查看文件编码\n\n```shell\nwsx@wsx-ubuntu:~$ file regular_express.txt\nregular_express.txt: ASCII text, with CRLF, LF line terminators\n```\n常用的大型数据文件一般存为ASCII码形式（像几大基因bank的数据文件），而我们自己认为创建的常为UTF-8，所以有时候认为处理文件需要会碰到把UTF-8编码的字符插入到ASCII码文件里去了。遇到这种问题，我们可以用`hexdump -c`命令查看出错的地方（手边没有这样的文件，就不举例了）。\n\n## 用sort对文本排序\n\n我们先创建一个bed格式文件来试试这个命令：\n```shell\nwsx@wsx-ubuntu:~$ cat test.bed\nchr1\t26\t39\nchr3\t32\t47\nchr1\t40\t50\nchr1\t9\t28\nchr2\t35\t54\nchr1\t10\t19\nwsx@wsx-ubuntu:~$ sort test.bed\nchr1\t10\t19\nchr1\t26\t39\nchr1\t40\t50\nchr1\t9\t28\nchr2\t35\t54\nchr3\t32\t47\n\n```\n可以明显看到文本按照第一列进行了排序。\n默认，`sort`用空格或tab键作为域（列）分隔符。如果我们用其他形式的分隔符，需要用`-t`选项指定。\n\n\n下面是对`bed`文件最通用的排序命令：\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed\nchr1\t9\t28\nchr1\t10\t19\nchr1\t26\t39\nchr1\t40\t50\nchr2\t35\t54\nchr3\t32\t47\n```\n基本操作`bedtools`软件都会先用这个命令对`bedtools`文件排序。\n现在略加解释一下，`sort`用`-k`选项指定某列的排序方式。而每次使用`-k`选项都要带上指定列的范围(start, end)。如果只指定一列，就为(start,start)了，像上面命令的`-k1,1`就是。也许你会觉得`-k2,2n`很奇怪，这里的`n`指定程序把第二列当做数值对待。如果不做设定，都是当做字符对待（shell都是这么对待数值数据的）。所以总结其他这一行命令就是对第一列按照字符排序，第二列按照数值排序。\n\n我们可以用`-c`选项检查一个文件是不是已经按照过某种方式排过序了。\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed | sort -k1,1 -k2,2 -c\nsort：-:2：无序： chr1\t10\t19\nwsx@wsx-ubuntu:~$ echo $?\n1\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed | sort -k1,1 -k2,2n -c\nwsx@wsx-ubuntu:~$ echo $?\n0\n\n```\n上面可以清楚地看到`sort`是怎么对待文件的（一般shell返回0表示成功执行）。\n```shell\nwsx@wsx-ubuntu:~$ tsfds\ntsfds：未找到命令\nwsx@wsx-ubuntu:~$ echo $?\n127\nwsx@wsx-ubuntu:~$ echo test\ntest\nwsx@wsx-ubuntu:~$ echo $?\n0\n```\nshell的命令退出状态码表示了该命令执行的完成的某种情况。不同的状态码有不同的含义，具体可以百度查阅（我之前整理的shell笔记应该讲过，可以看看）。\n\n反向排序用`-r`选项。如果你只想反转一列，可以把它加在`-k`选项后。\n\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2nr test.bed\nchr1\t40\t50\nchr1\t26\t39\nchr1\t10\t19\nchr1\t9\t28\nchr2\t35\t54\nchr3\t32\t47\n```\n现在我给`test.bed`加一行：\n```shell\nwsx@wsx-ubuntu:~$ cat test.bed\nchr1\t26\t39\nchr3\t32\t47\nchr1\t40\t50\nchr1\t9\t28\nchr2\t35\t54\nchr1\t10\t19\nchr11\t22\t56\n```\n你会发现有点奇怪\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed\nchr1\t9\t28\nchr1\t10\t19\nchr1\t26\t39\nchr1\t40\t50\nchr11\t22\t56\nchr2\t35\t54\nchr3\t32\t47\n```\n怎么`chr11`在`chr2`前面？其实`sort`排序的方式有点像查字典。例子中，命令先比较`c`，然后比较`h`，然后比较`r`，接着比较`1`，自然`11`会在`2`前面了。这里可以添加`V`选项修改。\n```shell\nwsx@wsx-ubuntu:~$ sort -k1,1V -k2,2n test.bed\nchr1\t9\t28\nchr1\t10\t19\nchr1\t26\t39\nchr1\t40\t50\nchr2\t35\t54\nchr3\t32\t47\nchr11\t22\t56\n```\n是不是觉得这样更可观一些？不过通常在处理数据时不做此处理，符合 规范的数据可以让后续处理程序效率更高。\n\n基本掌握`sort`这些也够用了，它主要为后续处理服务。如果想知道其他的用法，查查吧，同时欢迎发文来交流。\n\n## 用uniq寻找唯一值\n\n首先创建样例文本\n```shell\nwsx@wsx-ubuntu:~$ cat test.letter\nA\nA\nB\nC\nB\nC\nC\nC\nD\nF\nD\n```\n使用`uniq`看看\n```shell\nwsx@wsx-ubuntu:~$ uniq test.letter\nA\nB\nC\nB\nC\nD\nF\nD\n```\n尼玛，怎么不对。它好像只去掉了连续的同一字符。怎么办？想想我们刚学了什么命令？`sort`不是刚好可以把同样的字符弄到一起去吗，然后再使用`uniq`，嘿嘿：\n```shell\nwsx@wsx-ubuntu:~$ sort test.letter | uniq\nA\nB\nC\nD\nF\n```\n哟呵，got you。\n\n加`-c`选项计数：\n```shell\nwsx@wsx-ubuntu:~$ sort test.letter | uniq -c\n      2 A\n      2 B\n      4 C\n      2 D\n      1 F\n```\n把结果再排序\n```shell\nwsx@wsx-ubuntu:~$ sort test.letter | uniq -c | sort -rn\n      4 C\n      2 D\n      2 B\n      2 A\n      1 F\n```\n`-d`选项只输出重复行\n```shell\nwsx@wsx-ubuntu:~$ cat test.letter\nA\nA\nB\nC\nB\nC\nC\nC\nD\nF\nD\nwsx@wsx-ubuntu:~$ uniq -d test.letter\nA\nC\nwsx@wsx-ubuntu:~$ sort test.letter | uniq -d\nA\nB\nC\nD\n\n```\n使用时需要注意处理不同导致的结果差异。\n\n## Join 命令\n\n用来连接文件。\n假设现在我们有两个文件：\n\n```shell\nwsx@wsx-ubuntu:/tmp$ cat example.bed\nchr1\t26\t39\nchr1\t32\t47\nchr3\t11\t28\nchr1\t40\t49\nchr3\t16\t27\nchr1\t9\t28\nchr2\t35\t53\nwsx@wsx-ubuntu:/tmp$ cat example_length.txt\nchr1\t53453\nchr2\t34356\nchr3\t24356\n```\n我想把第二个文件说明染色体长度添加到第一个文件对应染色体的第三列。\n我们首先要给文件排序（使用`join`前必须做），然后使用`join`命令。\n```shell\nwsx@wsx-ubuntu:/tmp$ sort -k1,1 example.bed > example_sorted.bed\nwsx@wsx-ubuntu:/tmp$ sort -c -k1,1 example_length.txt\nwsx@wsx-ubuntu:/tmp$ cat example_sorted.bed\nchr1\t26\t39\nchr1\t32\t47\nchr1\t40\t49\nchr1\t9\t28\nchr2\t35\t53\nchr3\t11\t28\nchr3\t16\t27\nwsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 example_sorted.bed  example_length.txt > example_with_length.txt\nwsx@wsx-ubuntu:/tmp$ cat example_with_length.txt\nchr1 26 39 53453\nchr1 32 47 53453\nchr1 40 49 53453\nchr1 9 28 53453\nchr2 35 53 34356\nchr3 11 28 24356\nchr3 16 27 24356\n```\n命令基本语法是\n```\njoin -1 <file_1_field> -2 <file_2_field> <file_1> <file_2>\n```\n既然名字叫`join`，就是两者必须有共同之处，通过共同的支点将两者连为一体。\n`-1`和`-2`选项后接参数分别指定了这个支点，也就是连接的域（列）。比如例子中，都是两个文件的第一列。\n\n两个文件中，第一列都共有`chr1(2)(3)`。 如果不一致会出现什么情况呢？\n\n```shell\nwsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 example_sorted.bed  example_length_alt.txt chr1 26 39 53453\nchr1 32 47 53453\nchr1 40 49 53453\nchr1 9 28 53453\nchr2 35 53 34356\n```\n如果第二个文件没有`chr3`，`join`之后也没了！！\n\n我们可以通过`-a`选项指定哪一个文件可以不遵循配对\n```shell\nwsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 -a 1 example_sorted.bed  example_length_alt.txt\nchr1 26 39 53453\nchr1 32 47 53453\nchr1 40 49 53453\nchr1 9 28 53453\nchr2 35 53 34356\nchr3 11 28\nchr3 16 27\n```\n\n## awk\n\n`awk`是文本处理的一把好手，虽然它不能像`python`，`R`干一些高级复杂的主题工作，但是它具备完整的命令操作和编程体系。\n\n`awk`是一门语言，我不可能在学习的时候能够逻辑清晰详细地介绍给大家。主要是还通过实例来了解用法，加深认识。手册可以参考http://man.linuxde.net/awk。\n\n首先要明白的是，`awk`按行处理数据。在shell知识里，如果把一个文档看做一张表。那么一行就是一个**记录**，一列就是一个**域**。可以看出，`awk`就是按记录处理文本的。\n\n其次是`awk`的程序结构是\n```\npattern {action}\n```\npattern可以是表达式或者正则表达式。pattern有点像`if`语句，当它满足时就会执行相应的动作。\n\n另一个`awk`核心是它用`$0`表示所有列，`$1`，`$2`...等等表示对应的列。我们可以很方便地用它进行操作。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk '{print $0}' example.bed\nchr1\t26\t39\nchr1\t32\t47\nchr3\t11\t28\nchr1\t40\t49\nchr3\t16\t27\nchr1\t9\t28\nchr2\t35\t53\nwsx@wsx-ubuntu:/tmp$ awk '{print $1}' example.bed\nchr1\nchr1\nchr3\nchr1\nchr3\nchr1\nchr2\nwsx@wsx-ubuntu:/tmp$ awk '{print $2}' example.bed\n26\n32\n11\n40\n16\n9\n```\n\n`print`语句就像动作一样输出你操作的结果。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk '{ print $2 \"\\t\" $3}' example.bed\n26\t39\n32\t47\n11\t28\n40\t49\n16\t27\n9\t28\n35\t53\nwsx@wsx-ubuntu:/tmp$ awk '{ print $2  $3}' example.bed\n2639\n3247\n1128\n4049\n1627\n928\n3553\nwsx@wsx-ubuntu:/tmp$ awk '{ print $2 , $3}' example.bed\n26 39\n32 47\n11 28\n40 49\n16 27\n9 28\n35 53\n\n```\n了解上述几个语句的不同。\n\n表示染色体名一般用带`chr`或者不带`chr`标志两种方式。当我们要用到这两种时，肯定要让它们能够对应起来，也就是转换。`awk`命令可以非常方便地添加`chr`标记。\n\n下面我先把例子文件的`chr`去掉，然后加上试试。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk '{ print $1}' example.bed\nchr1\nchr1\nchr3\nchr1\nchr3\nchr1\nchr2\nwsx@wsx-ubuntu:/tmp$ awk '{ print $1}' example.bed | cut -c4\n1\n1\n3\n1\n3\n1\n2\nwsx@wsx-ubuntu:/tmp$ awk '{ print $1}' example.bed | cut -c4 | awk '{print \"chr\"$1}'\nchr1\nchr1\nchr3\nchr1\nchr3\nchr1\nchr2\n```\n\n`awk`作为一门编程语言，它支持各种操作符（运算，逻辑，判断）喔。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk '$3 - $2 >18' example.bed\nchr1\t9\t28\nwsx@wsx-ubuntu:/tmp$ awk '$1 ~/chr1/ && $3 - $2 > 10' example.bed\nchr1\t26\t39\nchr1\t32\t47\nchr1\t9\t28\n\n# 这里 ~ 符号用来匹配正则表达式\n```\n还有`awk`存在一些变量，像`NR`表示行号，`OFS`表示输出分隔符等。\n```shell\nwsx@wsx-ubuntu:/tmp$ awk 'NR >= 3 && NR <= 5' example.bed\nchr3\t11\t28\nchr1\t40\t49\nchr3\t16\t27\n```\n\n如果我们想把`gtf`文件转换成为`bed`格式，可以使用\n```shell\nwsx@wsx-ubuntu:~/Work/research/Promoter_Research$ head -n1000 Homo_sapiens.GRCh37.75.gtf | awk '!/^#/{ print $1 \"\\t\" $4-1 \"\\t\" $5} ' | head -n 3\n1\t11868\t14412\n1\t11868\t14409\n1\t11868\t12227\n```\n因为篇幅有限，我不可能输出所有结果，所以只取部分数据做了运算。\n\n\n\n## 用Sed进行流编辑\n\n`sed`命令从文本或者标准输入中每次读入一行数据。\n\n我们先从简单的实例出发，看下该命令怎么将一列中的`chrm12`,`chrom2`等转换成`chr12`，`chr2`的格式。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat chrms.txt\nchrom1    3214482    3216968\nchrom1    3214234    3216968\nchrom1    3213425    3210653\n\nwangsx@SC-201708020022:~/tmp$ sed 's/chrom/chr/' chrms.txt\nchr1    3214482    3216968\nchr1    3214234    3216968\nchr1    3213425    3210653\n```\n\n虽然示例文件处理仅仅只有三行，但我们可以将这种处理方式运用到上G甚至更大的数据文件中，而不用打开整个文件进行处理。并且，可以借助重导向实现对数据处理结果的输出。\n\n`sed`替换命令采用的格式是\n\n```shell\ns/pattern/replacement/\n```\n\n`sed`会自动搜索符合`pattern`的字符串，然后修改为`replacement`（我们想要修改后的样子）。一般默认`sed`只替换第一个匹配的`pattern`，我们可以通过添加全局标识`g`将其应用到数据的所有行中。\n\n```shell\ns/pattern/replacement/g\n```\n\n如果我们想要忽略匹配的大小写，使用`i`标识\n\n```shell\ns/pattern/replacement/i\n```\n\n默认`sed`命令支持基本的POSIX正则表达式（BRE），可以通过`-E`选项进行拓展（ERE）。很多的Linux命令都这种方式，像常用的`grep`命令。\n\n\n\n再看一个实例，如果我们想把`chr1:28647389-28659480`这样格式的文字转换为三列，可以使用：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" | \\\n>  sed -E 's/^(chr[^:]+):([0-9]+)-([0-9]+)/\\1\\t\\2\\t\\3/'\nchr1    28647389        28659480\n```\n\n我们聚焦在第二个命令`sed`上。初看杂乱无章，但是从最大的结构看依旧是\n\n```shell\ns/pattern/replacement/\n```\n\n先看`pattern`部分，这是由几个简单正则表达式组成的复合体，几个`()`括起来的字符串可以单独看。第一个匹配`chr`加上一个非冒号的字符，第二个和第三个都是匹配多个数字。最开始的`^`表示以`chr`起始（前面没有字符），各个括号中间的是对应的字符。整体的`pattern`的目的就是为了找到文本中符合这种模式的字符串，如果只是想把这个模式找出来的话，几个括号可以不用加。显然这几个括号的作用就是将它们划分成多个域，帮助`sed`进行处理。可以看到`replacement`部分存在`\\1`,`\\2`,`\\3`，它恰好对应`()`的顺序。这样我们在中间插入`\\t`制表符，就可以完成我们想要的功能：将原字符串转换为三列。\n\n我本身对字符串并不是非常熟悉，懂一些元字符，可能讲解的不是很到位。不熟悉正则表达式的朋友，可以学习和参考下[学习正则表达式](http://www.jianshu.com/p/7c50954651fa)，是我从Github上Copy到的非常好的学习资料，有兴趣也可以Fork学习。\n\n上山的路总是有很多条，我们下面看下其他实现该功能的办法：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/[:-]/\\t/g'\nchr1    28647389        28659480\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/:/\\t/' | sed 's/-/\\t/'\nchr1    28647389        28659480\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  tr ':-' '\\t'\nchr1    28647389        28659480\n```\n\n这三种方式看起来都非常简单有效。它处理字符串的思路不是从匹配pattern然后替换入手，不对，应该说是不是从匹配所有pattern然后替换入手。处理的关键是只处理字符串中看似无用的连字符`:`与`-`，将其替换成制表符从而轻松完成分割。\n\n` sed 's/:/\\t/' | sed 's/-/\\t/'`可以通过`-e`选项写为` sed -e 's/:/\\t/' -e 's/-/\\t/'`，效果等价。\n\n\n默认`sed`命令支持基本的POSIX正则表达式（BRE），可以通过`-E`选项进行拓展（ERE）。很多的Linux命令都这种方式，像常用的`grep`命令。\n\n\n\n再看一个实例，如果我们想把`chr1:28647389-28659480`这样格式的文字转换为三列，可以使用：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" | \\\n>  sed -E 's/^(chr[^:]+):([0-9]+)-([0-9]+)/\\1\\t\\2\\t\\3/'\nchr1    28647389        28659480\n```\n\n我们聚焦在第二个命令`sed`上。初看杂乱无章，但是从最大的结构看依旧是\n\n```shell\ns/pattern/replacement/\n```\n\n先看`pattern`部分，这是由几个简单正则表达式组成的复合体，几个`()`括起来的字符串可以单独看。第一个匹配`chr`加上一个非冒号的字符，第二个和第三个都是匹配多个数字。最开始的`^`表示以`chr`起始（前面没有字符），各个括号中间的是对应的字符。整体的`pattern`的目的就是为了找到文本中符合这种模式的字符串，如果只是想把这个模式找出来的话，几个括号可以不用加。显然这几个括号的作用就是将它们划分成多个域，帮助`sed`进行处理。可以看到`replacement`部分存在`\\1`,`\\2`,`\\3`，它恰好对应`()`的顺序。这样我们在中间插入`\\t`制表符，就可以完成我们想要的功能：将原字符串转换为三列。\n\n我本身对字符串并不是非常熟悉，懂一些元字符，可能讲解的不是很到位。不熟悉正则表达式的朋友，可以学习和参考下[学习正则表达式](http://www.jianshu.com/p/7c50954651fa)，是我从Github上Copy到的非常好的学习资料，有兴趣也可以Fork学习。\n\n上山的路总是有很多条，我们下面看下其他实现该功能的办法：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/[:-]/\\t/g'\nchr1    28647389        28659480\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/:/\\t/' | sed 's/-/\\t/'\nchr1    28647389        28659480\nwangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  tr ':-' '\\t'\nchr1    28647389        28659480\n```\n\n这三种方式看起来都非常简单有效。它处理字符串的思路不是从匹配pattern然后替换入手，不对，应该说是不是从匹配所有pattern然后替换入手。处理的关键是只处理字符串中看似无用的连字符`:`与`-`，将其替换成制表符从而轻松完成分割。\n\n` sed 's/:/\\t/' | sed 's/-/\\t/'`可以通过`-e`选项写为` sed -e 's/:/\\t/' -e 's/-/\\t/'`，效果等价。\n\n\n\n默认，`sed`会输出每一行的结果，用`replacement`替换`pattern`，但实际中我们可能会因此得到不想要的结果。比如下面的这个例子。\n\n如果我们想要抓出`gtf`文件第九列的转录名，可能会使用以下命令\n\n```shell\nwangsx@SC-201708020022:~/database$ zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | head -n 3 | \\\n> sed -E 's/.*transcript_id \"([^\"]+)\".*/\\1/'\nchr1    HAVANA  gene    11869   14409   .       +       .       gene_id \"ENSG00000223972.5_2\"; gene_type \"transcribed_unprocessed_pseudogene\"; gene_name \"DDX11L1\"; level 2; havana_gene \"OTTHUMG00000000961.2_2\"; remap_status \"full_contig\"; remap_num_mappings 1; remap_target_status \"overlap\";\nENST00000456328.2_1\nENST00000456328.2_1\n```\n\n我们可以发现一些没有转录名行的结果是输出整行，这可不是我们想要的。一种解决办法是在使用`sed`之前先抓出有`transcript_id`的行。其实`sed`命令本身也可以通过选项和参数设定解决这个问题，这里我们可以用`-n`选项关闭`sed`输出所有行，在最末的`/`后加`p`只输出匹配项。\n\n```shell\nwangsx@SC-201708020022:~/database$ zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | head -n 3 | sed -E -n 's/.*transc\nript_id \"([^\"]+)\".*/\\1/p'\nENST00000456328.2_1\nENST00000456328.2_1\n```\n\n注意方括号内`^`是非（取反）的意思。\n\n解释如下：\n\n1. 首先，匹配字符串\"transcript_id\"之前0或多个任意字符（`.`表示除换行键的任意字符）。\n2. 然后，匹配和捕获一个或多个不是引号的字符，用的是`[^\"]`\n\n`+`号的使用是一种非贪婪的方法。很多新手会用`*`，这是贪婪操作，往往会得不偿失，需要注意喔。\n\n```shell\nwangsx@SC-201708020022:~/database$ sed -E 's/transcript_id \"([^\"]+)\".*/\\1/' greedy_example.txt\nENSMUST00000160944\nwangsx@SC-201708020022:~/database$ sed -E 's/transcript_id \"(.*)\".*/\\1/' greedy_example.txt\nENSMUST00000160944\"; gene_name \"Gm16088\n```\n\n使用`*`时它会尽量多地去匹配符合要求的模式。\n\n\n\n我们也可以用`sed`命令来获取特定范围的行，比如说我要取出头10行，可以使用\n\n```shell\nsed -n '1,10p' filename\n```\n\n20到50行\n\n```shell\nsed -n '20,50p' filename\n```\n\n当然`sed`的功能特性远远不止这些，有待于大家更多地挖掘。不过需要注意的是，尽量让工具干它最擅长的事情。如果是复杂地大规模计算，还是最好写个Python脚本。\n\n> **KISS原则**:\n>\n> Keep Incredible Sed Simple\n\n\n\n## 高级Shell用法\n\n### 子shell\n\n首先需要记住**连续**命令和**管道**命令的区别：前者是简单地一个一个按顺序运行程序（一般用`&&`或者`;`）；后者前一个程序的输出结果会直接传到下一个命令程序的输入中（这不就是流程化操作么，用`|`分隔）。\n\n子shell可以让我们在一个独立的shell进程中执行连续命令。\n\n首先看个例子\n\n```shell\nwangsx@SC-201708020022:~/database$ echo \"this command\"; echo \"that command\" | sed 's/command/step/'\nthis command\nthat step\nwangsx@SC-201708020022:~/database$ (echo \"this command\"; echo \"that command\") | sed 's/command/step/'\nthis step\nthat step\n```\n\n发现仅仅加了个括号，结果就不同了。第二个命令就用了子shell，它把两个`echo`命令放进单独的空间执行后将结果传给下游。\n\n子shell在对`gtf`文件进行操作时有个非常有意思有用的用处。我们如果想对`gtf`文件排序，但是又想要保留文件头部注释信息，我们就能够用两次`grep`操作分别抓出注释和非注释信息，然后又把它结合在一起。下面看看效果，用`less`进行检查：\n\n```shell\nwangsx@SC-201708020022:~/database$ (zgrep \"^#\" gencode.v27lift37.annotation.gtf.gz; \\\n>  zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | \\\n>  sort -k1,1 -k4,4n) | less\n```\n\n\n\n可以看到，子shell确实能够给我们提供非常有用的操作去组合命令实现想要的功能。\n\n\n\n### 命令管道及进程替换\n\n很多生信命令行工具需要提供多个输入和输出参数，这用在管道命令里可能会导致非常低效的情形（管道只接受一个标准输入和输出）。幸好，我们可以使用命令管道来解决此类问题。\n\n**命名管道**，也成为FIFO（先入先出，额，这不是队列么:smile:）。它是一个特殊的排序文件，命名管道有点像文件，它可以永久保留在你的文件系统上（估计本质就是文件吧~）。\n\n我们用`mkfifo`来生成它\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ls -l fqin\nprw-rw-rw- 1 wangsx wangsx 0 9月   3 20:45 fqin\n```\n\n可以它看它权限的第一个字符是p，指代是pipe。说明是个特殊文件。\n\n我们像文件一样对它进行一些操作\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat fqin\nhello, named pipes\n[1]+  已完成               echo \"hello, named pipes\" > fqin\nwangsx@SC-201708020022:~/tmp$ rm fqin\n```\n\n比如当使用一个生信命令行工具\n\n```\nprocessing_tool --in1 in1.fq --in2 in2.fq --out1 out1.fq --out2 out2.fq\n```\n\n`in1.fq in2.fq`就可以上游输出数据到`processing_tool`的命名管道；同理`out1.fq out2.fq`可以是命名管道用来写进输出数据。\n\n但这样我们每次都得不停地创建和删除这些文件，解决办法是使用匿名管道，也叫进程替换。\n\n不能光说，看看例子就知道和理解了。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat <(echo \"hello, process substitution\")\nhello, process substitution\n```\n\n`echo`命令运行后使用了进程替换，产生匿名文件，然后匿名文件被重导向`cat`命令。\n\n把它用到工具上，就变成了(假定上游zcat下游执行grep命令)\n\n```shell\nprocessing_tool --in1 < (zcat file1) --in2 < (zcat file2) --out1 (gzip > outfile1) --out2 (gzip > outfile2)\n```\n","slug":"Linux-data-analysis-tools","published":1,"updated":"2018-01-27T04:08:22.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwuc00089taxfwifgjbf","content":"<p>参考学习《Bioinformatics. Data. Skills》，这里简要地整理下Linux用来处理数据文本的工具。具体命令详情请在<a href=\"http://man.linuxde.net/\" target=\"_blank\" rel=\"noopener\">Linux命令大全</a>中搜索或者查阅其他相关资料。</p>\n<a id=\"more\"></a>\n<p><code>head</code>,<code>tail</code>查看文档头尾。<code>-n</code>选项可以指定行数。</p>\n<p><code>less</code>用来查阅文档，<code>q</code>退出，<code>space bar</code>翻页，<code>g</code>第一行，<code>G</code>最后一行，<code>j</code>下，<code>k</code>上,<code>/&lt;pattern&gt;</code>往下搜索模式，<code>?&lt;pattern&gt;</code>往上搜索模式，<code>n</code>前一个匹配字符，<code>N</code>后一个匹配字符。</p>\n<p><code>less</code>可以用于debug，查看中间输出结果。比如<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1 input.txt | step2 | step3 &gt; output.txt</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> step1,2,3为程序或命令名</span></span><br></pre></td></tr></table></figure></p>\n<p>可以写为<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1 input.txt | less</span><br><span class=\"line\">step1 input.txt | step2 | less</span><br><span class=\"line\">step1 input.txt | step2 | step3 | less</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"纯文本信息汇总\"><a href=\"#纯文本信息汇总\" class=\"headerlink\" title=\"纯文本信息汇总\"></a>纯文本信息汇总</h2><p><code>wc</code>命令默认依次输出单词数、行数、总字符数。查看行数使用<code>wc -l</code>。<br>如果存在空行，空行会被计数。可以使用<code>grep</code>命令实现非空行计数<br><code>grep -c &quot;[^ \\\\n\\\\t]&quot; some_data.bed</code></p>\n<p><code>ls -lh</code>以易读形式查看文件大小。</p>\n<p>输出文件列数：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> -F指定分隔符，此处假定是table键分隔，默认空格键</span></span><br><span class=\"line\">awk -F \"\\t\" '&#123;print NF; exit&#125;' some_data.bed</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"怎么去除注释的元数据行呢？怎么计数非注释行行数呢？\"><a href=\"#怎么去除注释的元数据行呢？怎么计数非注释行行数呢？\" class=\"headerlink\" title=\"怎么去除注释的元数据行呢？怎么计数非注释行行数呢？\"></a>怎么去除注释的元数据行呢？怎么计数非注释行行数呢？</h3><p>可以使用<code>tail</code>结合<code>awk</code>，试试gtf(基因组注释文件)<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ head -n 6 Homo_sapiens.GRCh37.75.gtf</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genome-build GRCh37.p13</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genome-version GRCh37</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genome-date 2009-02</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genome-build-accession NCBI:GCA_000001405.14</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genebuild-last-updated 2013-09</span></span><br><span class=\"line\">1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";</span><br></pre></td></tr></table></figure></p>\n<p>可以看到注释行是5行，我们利用<code>tail</code>试试去掉它<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意此处 -n后接的<span class=\"string\">\"+\"</span>号</span></span><br><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ tail -n +5 Homo_sapiens.GRCh37.75.gtf | head -n 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genebuild-last-updated 2013-09</span></span><br></pre></td></tr></table></figure></p>\n<p>发现还有一行没去掉<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ tail -n +6 Homo_sapiens.GRCh37.75.gtf | head -n 1</span><br><span class=\"line\">1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";</span><br></pre></td></tr></table></figure></p>\n<p>成功搞定，然后结合前面提到的<code>awk</code>命令即可计算行数。</p>\n<p>上面方法鲁棒性不够（人为地确定行数），一种更为通用的方法是<code>grep</code>结合<code>awk</code>命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 1</span><br><span class=\"line\">1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";</span><br></pre></td></tr></table></figure></p>\n<p>推荐使用这种。</p>\n<h2 id=\"Cut\"><a href=\"#Cut\" class=\"headerlink\" title=\"Cut\"></a>Cut</h2><p><code>cut</code>可以处理列数据，<code>-f</code>选项指定列，可以是一个范围（比如2-8），注意不能用它给列排序。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3</span><br><span class=\"line\">gene</span><br><span class=\"line\">transcript</span><br><span class=\"line\">exon</span><br><span class=\"line\">exon</span><br><span class=\"line\">exon</span><br><span class=\"line\">transcript</span><br><span class=\"line\">exon</span><br><span class=\"line\">exon</span><br><span class=\"line\">exon</span><br><span class=\"line\">transcript</span><br><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5</span><br><span class=\"line\">gene\t11869\t14412</span><br><span class=\"line\">transcript\t11869\t14409</span><br><span class=\"line\">exon\t11869\t12227</span><br><span class=\"line\">exon\t12613\t12721</span><br><span class=\"line\">exon\t13221\t14409</span><br><span class=\"line\">transcript\t11872\t14412</span><br><span class=\"line\">exon\t11872\t12227</span><br><span class=\"line\">exon\t12613\t12721</span><br><span class=\"line\">exon\t13225\t14412</span><br><span class=\"line\">transcript\t11874\t14409</span><br></pre></td></tr></table></figure></p>\n<p><code>-d</code>选项可以指定分隔符，比如<code>-d,</code>指定<code>,</code>为分隔符。</p>\n<p>使用<code>column</code>命令来格式化输出，上次的命令结果输出明显没对齐，我们把它对齐看看：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 | column -t</span><br><span class=\"line\">gene        11869  14412</span><br><span class=\"line\">transcript  11869  14409</span><br><span class=\"line\">exon        11869  12227</span><br><span class=\"line\">exon        12613  12721</span><br><span class=\"line\">exon        13221  14409</span><br><span class=\"line\">transcript  11872  14412</span><br><span class=\"line\">exon        11872  12227</span><br><span class=\"line\">exon        12613  12721</span><br><span class=\"line\">exon        13225  14412</span><br><span class=\"line\">transcript  11874  14409</span><br></pre></td></tr></table></figure></p>\n<p>注意，使用这个命令是为了好观察，不要把用它处理然后把结果传入文本（会导致程序处理文件效率降低，因为文本解析速度会下降）。</p>\n<p><code>cut</code>和<code>column</code>默认以<code>\\t</code>为分隔符，这里也能够用<code>-s</code>选项指定。</p>\n<p>先把之前的tab分隔文件弄成逗号分隔文件，然后使用<code>-s</code>选项看看：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 |  awk '&#123;FS=\"\\t\";OFS=\",\";&#125;&#123;print $1,$2,$3&#125;'</span><br><span class=\"line\">gene,11869,14412</span><br><span class=\"line\">transcript,11869,14409</span><br><span class=\"line\">exon,11869,12227</span><br><span class=\"line\">exon,12613,12721</span><br><span class=\"line\">exon,13221,14409</span><br><span class=\"line\">transcript,11872,14412</span><br><span class=\"line\">exon,11872,12227</span><br><span class=\"line\">exon,12613,12721</span><br><span class=\"line\">exon,13225,14412</span><br><span class=\"line\">transcript,11874,14409</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 |  awk '&#123;FS=\"\\t\";OFS=\",\";&#125;&#123;print $1,$2,$3&#125;'| column -s \",\" -t</span><br><span class=\"line\">gene        11869  14412</span><br><span class=\"line\">transcript  11869  14409</span><br><span class=\"line\">exon        11869  12227</span><br><span class=\"line\">exon        12613  12721</span><br><span class=\"line\">exon        13221  14409</span><br><span class=\"line\">transcript  11872  14412</span><br><span class=\"line\">exon        11872  12227</span><br><span class=\"line\">exon        12613  12721</span><br><span class=\"line\">exon        13225  14412</span><br><span class=\"line\">transcript  11874  14409</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h2><p><code>grep</code>处理速度非常之快，能用它尽量用它。<code>--color=auto</code>可以激活颜色（标记匹配文字），更方便查看。</p>\n<p><code>-v</code>选项排除匹配到的，<code>-w</code>进行完全匹配。这样可以防止，你想排除<code>abc</code>结果把<code>abc1</code>，<code>abcd</code>也排除掉了。</p>\n<p><code>-B</code>指定输出包括匹配到的前多少行，比如<code>-B1</code>就是前一行；<code>-A</code>指定输出包括匹配到的后多少行，比如<code>-A2</code>就是包括了后两行。<code>-C</code>指定输出包括匹配到的前后多少行。<br><code>grep</code>支持基本正则表达式，<code>-E</code>指定支持扩展表达式，或者用<code>egrep</code>命令。<br><code>-c</code>选项对匹配的行计数；<code>-o</code>选项只抽离输出匹配的部分<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -E -o 'gene_id \"\\w+\"' Homo_sapiens.GRCh37.75.gtf | head -n 5</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br></pre></td></tr></table></figure></p>\n<p>发现冗余项非常多，如果我们只要唯一的呢，怎么办？<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -E -o 'gene_id \"(\\w+)\"' Homo_sapiens.GRCh37.75.gtf | cut -f2 -d\" \"| sed 's/\"//g' | sort | uniq | head -n 10</span><br><span class=\"line\">ENSG00000000003</span><br><span class=\"line\">ENSG00000000005</span><br><span class=\"line\">ENSG00000000419</span><br><span class=\"line\">ENSG00000000457</span><br><span class=\"line\">ENSG00000000460</span><br><span class=\"line\">ENSG00000000938</span><br><span class=\"line\">ENSG00000000971</span><br><span class=\"line\">ENSG00000001036</span><br><span class=\"line\">ENSG00000001084</span><br><span class=\"line\">ENSG00000001167</span><br></pre></td></tr></table></figure></p>\n<p>虽然我的笔记本呼啦啦作响，但是还是非常快就跑完了。</p>\n<h2 id=\"file查看文件编码\"><a href=\"#file查看文件编码\" class=\"headerlink\" title=\"file查看文件编码\"></a>file查看文件编码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ file regular_express.txt</span><br><span class=\"line\">regular_express.txt: ASCII text, with CRLF, LF line terminators</span><br></pre></td></tr></table></figure>\n<p>常用的大型数据文件一般存为ASCII码形式（像几大基因bank的数据文件），而我们自己认为创建的常为UTF-8，所以有时候认为处理文件需要会碰到把UTF-8编码的字符插入到ASCII码文件里去了。遇到这种问题，我们可以用<code>hexdump -c</code>命令查看出错的地方（手边没有这样的文件，就不举例了）。</p>\n<h2 id=\"用sort对文本排序\"><a href=\"#用sort对文本排序\" class=\"headerlink\" title=\"用sort对文本排序\"></a>用sort对文本排序</h2><p>我们先创建一个bed格式文件来试试这个命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ cat test.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr3\t32\t47</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.bed</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br></pre></td></tr></table></figure></p>\n<p>可以明显看到文本按照第一列进行了排序。<br>默认，<code>sort</code>用空格或tab键作为域（列）分隔符。如果我们用其他形式的分隔符，需要用<code>-t</code>选项指定。</p>\n<p>下面是对<code>bed</code>文件最通用的排序命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br></pre></td></tr></table></figure></p>\n<p>基本操作<code>bedtools</code>软件都会先用这个命令对<code>bedtools</code>文件排序。<br>现在略加解释一下，<code>sort</code>用<code>-k</code>选项指定某列的排序方式。而每次使用<code>-k</code>选项都要带上指定列的范围(start, end)。如果只指定一列，就为(start,start)了，像上面命令的<code>-k1,1</code>就是。也许你会觉得<code>-k2,2n</code>很奇怪，这里的<code>n</code>指定程序把第二列当做数值对待。如果不做设定，都是当做字符对待（shell都是这么对待数值数据的）。所以总结其他这一行命令就是对第一列按照字符排序，第二列按照数值排序。</p>\n<p>我们可以用<code>-c</code>选项检查一个文件是不是已经按照过某种方式排过序了。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed | sort -k1,1 -k2,2 -c</span><br><span class=\"line\">sort：-:2：无序： chr1\t10\t19</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo $?</span><br><span class=\"line\">1</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed | sort -k1,1 -k2,2n -c</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo $?</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure></p>\n<p>上面可以清楚地看到<code>sort</code>是怎么对待文件的（一般shell返回0表示成功执行）。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ tsfds</span><br><span class=\"line\">tsfds：未找到命令</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo $?</span><br><span class=\"line\">127</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo test</span><br><span class=\"line\">test</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo $?</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure></p>\n<p>shell的命令退出状态码表示了该命令执行的完成的某种情况。不同的状态码有不同的含义，具体可以百度查阅（我之前整理的shell笔记应该讲过，可以看看）。</p>\n<p>反向排序用<code>-r</code>选项。如果你只想反转一列，可以把它加在<code>-k</code>选项后。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2nr test.bed</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br></pre></td></tr></table></figure>\n<p>现在我给<code>test.bed</code>加一行：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ cat test.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr3\t32\t47</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr11\t22\t56</span><br></pre></td></tr></table></figure></p>\n<p>你会发现有点奇怪<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr11\t22\t56</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br></pre></td></tr></table></figure></p>\n<p>怎么<code>chr11</code>在<code>chr2</code>前面？其实<code>sort</code>排序的方式有点像查字典。例子中，命令先比较<code>c</code>，然后比较<code>h</code>，然后比较<code>r</code>，接着比较<code>1</code>，自然<code>11</code>会在<code>2</code>前面了。这里可以添加<code>V</code>选项修改。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1V -k2,2n test.bed</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br><span class=\"line\">chr11\t22\t56</span><br></pre></td></tr></table></figure></p>\n<p>是不是觉得这样更可观一些？不过通常在处理数据时不做此处理，符合 规范的数据可以让后续处理程序效率更高。</p>\n<p>基本掌握<code>sort</code>这些也够用了，它主要为后续处理服务。如果想知道其他的用法，查查吧，同时欢迎发文来交流。</p>\n<h2 id=\"用uniq寻找唯一值\"><a href=\"#用uniq寻找唯一值\" class=\"headerlink\" title=\"用uniq寻找唯一值\"></a>用uniq寻找唯一值</h2><p>首先创建样例文本<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ cat test.letter</span><br><span class=\"line\">A</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">C</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">F</span><br><span class=\"line\">D</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>uniq</code>看看<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ uniq test.letter</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">F</span><br><span class=\"line\">D</span><br></pre></td></tr></table></figure></p>\n<p>尼玛，怎么不对。它好像只去掉了连续的同一字符。怎么办？想想我们刚学了什么命令？<code>sort</code>不是刚好可以把同样的字符弄到一起去吗，然后再使用<code>uniq</code>，嘿嘿：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.letter | uniq</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">F</span><br></pre></td></tr></table></figure></p>\n<p>哟呵，got you。</p>\n<p>加<code>-c</code>选项计数：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.letter | uniq -c</span><br><span class=\"line\">      2 A</span><br><span class=\"line\">      2 B</span><br><span class=\"line\">      4 C</span><br><span class=\"line\">      2 D</span><br><span class=\"line\">      1 F</span><br></pre></td></tr></table></figure></p>\n<p>把结果再排序<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.letter | uniq -c | sort -rn</span><br><span class=\"line\">      4 C</span><br><span class=\"line\">      2 D</span><br><span class=\"line\">      2 B</span><br><span class=\"line\">      2 A</span><br><span class=\"line\">      1 F</span><br></pre></td></tr></table></figure></p>\n<p><code>-d</code>选项只输出重复行<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ cat test.letter</span><br><span class=\"line\">A</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">C</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">F</span><br><span class=\"line\">D</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ uniq -d test.letter</span><br><span class=\"line\">A</span><br><span class=\"line\">C</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.letter | uniq -d</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br></pre></td></tr></table></figure></p>\n<p>使用时需要注意处理不同导致的结果差异。</p>\n<h2 id=\"Join-命令\"><a href=\"#Join-命令\" class=\"headerlink\" title=\"Join 命令\"></a>Join 命令</h2><p>用来连接文件。<br>假设现在我们有两个文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ cat example.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t32\t47</span><br><span class=\"line\">chr3\t11\t28</span><br><span class=\"line\">chr1\t40\t49</span><br><span class=\"line\">chr3\t16\t27</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t53</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ cat example_length.txt</span><br><span class=\"line\">chr1\t53453</span><br><span class=\"line\">chr2\t34356</span><br><span class=\"line\">chr3\t24356</span><br></pre></td></tr></table></figure>\n<p>我想把第二个文件说明染色体长度添加到第一个文件对应染色体的第三列。<br>我们首先要给文件排序（使用<code>join</code>前必须做），然后使用<code>join</code>命令。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ sort -k1,1 example.bed &gt; example_sorted.bed</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ sort -c -k1,1 example_length.txt</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ cat example_sorted.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t32\t47</span><br><span class=\"line\">chr1\t40\t49</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t53</span><br><span class=\"line\">chr3\t11\t28</span><br><span class=\"line\">chr3\t16\t27</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 example_sorted.bed  example_length.txt &gt; example_with_length.txt</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ cat example_with_length.txt</span><br><span class=\"line\">chr1 26 39 53453</span><br><span class=\"line\">chr1 32 47 53453</span><br><span class=\"line\">chr1 40 49 53453</span><br><span class=\"line\">chr1 9 28 53453</span><br><span class=\"line\">chr2 35 53 34356</span><br><span class=\"line\">chr3 11 28 24356</span><br><span class=\"line\">chr3 16 27 24356</span><br></pre></td></tr></table></figure></p>\n<p>命令基本语法是<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">join</span> -<span class=\"number\">1</span> <span class=\"symbol\">&lt;file_1_field&gt;</span> -<span class=\"number\">2</span> <span class=\"symbol\">&lt;file_2_field&gt;</span> <span class=\"symbol\">&lt;file_1&gt;</span> <span class=\"symbol\">&lt;file_2&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>既然名字叫<code>join</code>，就是两者必须有共同之处，通过共同的支点将两者连为一体。<br><code>-1</code>和<code>-2</code>选项后接参数分别指定了这个支点，也就是连接的域（列）。比如例子中，都是两个文件的第一列。</p>\n<p>两个文件中，第一列都共有<code>chr1(2)(3)</code>。 如果不一致会出现什么情况呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 example_sorted.bed  example_length_alt.txt chr1 26 39 53453</span><br><span class=\"line\">chr1 32 47 53453</span><br><span class=\"line\">chr1 40 49 53453</span><br><span class=\"line\">chr1 9 28 53453</span><br><span class=\"line\">chr2 35 53 34356</span><br></pre></td></tr></table></figure>\n<p>如果第二个文件没有<code>chr3</code>，<code>join</code>之后也没了！！</p>\n<p>我们可以通过<code>-a</code>选项指定哪一个文件可以不遵循配对<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 -a 1 example_sorted.bed  example_length_alt.txt</span><br><span class=\"line\">chr1 26 39 53453</span><br><span class=\"line\">chr1 32 47 53453</span><br><span class=\"line\">chr1 40 49 53453</span><br><span class=\"line\">chr1 9 28 53453</span><br><span class=\"line\">chr2 35 53 34356</span><br><span class=\"line\">chr3 11 28</span><br><span class=\"line\">chr3 16 27</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"awk\"><a href=\"#awk\" class=\"headerlink\" title=\"awk\"></a>awk</h2><p><code>awk</code>是文本处理的一把好手，虽然它不能像<code>python</code>，<code>R</code>干一些高级复杂的主题工作，但是它具备完整的命令操作和编程体系。</p>\n<p><code>awk</code>是一门语言，我不可能在学习的时候能够逻辑清晰详细地介绍给大家。主要是还通过实例来了解用法，加深认识。手册可以参考<a href=\"http://man.linuxde.net/awk。\" target=\"_blank\" rel=\"noopener\">http://man.linuxde.net/awk。</a></p>\n<p>首先要明白的是，<code>awk</code>按行处理数据。在shell知识里，如果把一个文档看做一张表。那么一行就是一个<strong>记录</strong>，一列就是一个<strong>域</strong>。可以看出，<code>awk</code>就是按记录处理文本的。</p>\n<p>其次是<code>awk</code>的程序结构是<br><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">pattern</span> &#123;action&#125;</span><br></pre></td></tr></table></figure></p>\n<p>pattern可以是表达式或者正则表达式。pattern有点像<code>if</code>语句，当它满足时就会执行相应的动作。</p>\n<p>另一个<code>awk</code>核心是它用<code>$0</code>表示所有列，<code>$1</code>，<code>$2</code>…等等表示对应的列。我们可以很方便地用它进行操作。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123;print $0&#125;' example.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t32\t47</span><br><span class=\"line\">chr3\t11\t28</span><br><span class=\"line\">chr1\t40\t49</span><br><span class=\"line\">chr3\t16\t27</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t53</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123;print $1&#125;' example.bed</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr2</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123;print $2&#125;' example.bed</span><br><span class=\"line\">26</span><br><span class=\"line\">32</span><br><span class=\"line\">11</span><br><span class=\"line\">40</span><br><span class=\"line\">16</span><br><span class=\"line\">9</span><br></pre></td></tr></table></figure></p>\n<p><code>print</code>语句就像动作一样输出你操作的结果。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $2 \"\\t\" $3&#125;' example.bed</span><br><span class=\"line\">26\t39</span><br><span class=\"line\">32\t47</span><br><span class=\"line\">11\t28</span><br><span class=\"line\">40\t49</span><br><span class=\"line\">16\t27</span><br><span class=\"line\">9\t28</span><br><span class=\"line\">35\t53</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $2  $3&#125;' example.bed</span><br><span class=\"line\">2639</span><br><span class=\"line\">3247</span><br><span class=\"line\">1128</span><br><span class=\"line\">4049</span><br><span class=\"line\">1627</span><br><span class=\"line\">928</span><br><span class=\"line\">3553</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $2 , $3&#125;' example.bed</span><br><span class=\"line\">26 39</span><br><span class=\"line\">32 47</span><br><span class=\"line\">11 28</span><br><span class=\"line\">40 49</span><br><span class=\"line\">16 27</span><br><span class=\"line\">9 28</span><br><span class=\"line\">35 53</span><br></pre></td></tr></table></figure></p>\n<p>了解上述几个语句的不同。</p>\n<p>表示染色体名一般用带<code>chr</code>或者不带<code>chr</code>标志两种方式。当我们要用到这两种时，肯定要让它们能够对应起来，也就是转换。<code>awk</code>命令可以非常方便地添加<code>chr</code>标记。</p>\n<p>下面我先把例子文件的<code>chr</code>去掉，然后加上试试。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $1&#125;' example.bed</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr2</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $1&#125;' example.bed | cut -c4</span><br><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $1&#125;' example.bed | cut -c4 | awk '&#123;print \"chr\"$1&#125;'</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr2</span><br></pre></td></tr></table></figure></p>\n<p><code>awk</code>作为一门编程语言，它支持各种操作符（运算，逻辑，判断）喔。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '$3 - $2 &gt;18' example.bed</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '$1 ~/chr1/ &amp;&amp; $3 - $2 &gt; 10' example.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t32\t47</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这里 ~ 符号用来匹配正则表达式</span></span><br></pre></td></tr></table></figure></p>\n<p>还有<code>awk</code>存在一些变量，像<code>NR</code>表示行号，<code>OFS</code>表示输出分隔符等。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk 'NR &gt;= 3 &amp;&amp; NR &lt;= 5' example.bed</span><br><span class=\"line\">chr3\t11\t28</span><br><span class=\"line\">chr1\t40\t49</span><br><span class=\"line\">chr3\t16\t27</span><br></pre></td></tr></table></figure></p>\n<p>如果我们想把<code>gtf</code>文件转换成为<code>bed</code>格式，可以使用<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ head -n1000 Homo_sapiens.GRCh37.75.gtf | awk '!/^#/&#123; print $1 \"\\t\" $4-1 \"\\t\" $5&#125; ' | head -n 3</span><br><span class=\"line\">1\t11868\t14412</span><br><span class=\"line\">1\t11868\t14409</span><br><span class=\"line\">1\t11868\t12227</span><br></pre></td></tr></table></figure></p>\n<p>因为篇幅有限，我不可能输出所有结果，所以只取部分数据做了运算。</p>\n<h2 id=\"用Sed进行流编辑\"><a href=\"#用Sed进行流编辑\" class=\"headerlink\" title=\"用Sed进行流编辑\"></a>用Sed进行流编辑</h2><p><code>sed</code>命令从文本或者标准输入中每次读入一行数据。</p>\n<p>我们先从简单的实例出发，看下该命令怎么将一列中的<code>chrm12</code>,<code>chrom2</code>等转换成<code>chr12</code>，<code>chr2</code>的格式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat chrms.txt</span><br><span class=\"line\">chrom1    3214482    3216968</span><br><span class=\"line\">chrom1    3214234    3216968</span><br><span class=\"line\">chrom1    3213425    3210653</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ sed 's/chrom/chr/' chrms.txt</span><br><span class=\"line\">chr1    3214482    3216968</span><br><span class=\"line\">chr1    3214234    3216968</span><br><span class=\"line\">chr1    3213425    3210653</span><br></pre></td></tr></table></figure>\n<p>虽然示例文件处理仅仅只有三行，但我们可以将这种处理方式运用到上G甚至更大的数据文件中，而不用打开整个文件进行处理。并且，可以借助重导向实现对数据处理结果的输出。</p>\n<p><code>sed</code>替换命令采用的格式是</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/</span><br></pre></td></tr></table></figure>\n<p><code>sed</code>会自动搜索符合<code>pattern</code>的字符串，然后修改为<code>replacement</code>（我们想要修改后的样子）。一般默认<code>sed</code>只替换第一个匹配的<code>pattern</code>，我们可以通过添加全局标识<code>g</code>将其应用到数据的所有行中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/g</span><br></pre></td></tr></table></figure>\n<p>如果我们想要忽略匹配的大小写，使用<code>i</code>标识</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/i</span><br></pre></td></tr></table></figure>\n<p>默认<code>sed</code>命令支持基本的POSIX正则表达式（BRE），可以通过<code>-E</code>选项进行拓展（ERE）。很多的Linux命令都这种方式，像常用的<code>grep</code>命令。</p>\n<p>再看一个实例，如果我们想把<code>chr1:28647389-28659480</code>这样格式的文字转换为三列，可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" | \\</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">  sed -E <span class=\"string\">'s/^(chr[^:]+):([0-9]+)-([0-9]+)/\\1\\t\\2\\t\\3/'</span></span></span><br><span class=\"line\">chr1    28647389        28659480</span><br></pre></td></tr></table></figure>\n<p>我们聚焦在第二个命令<code>sed</code>上。初看杂乱无章，但是从最大的结构看依旧是</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/</span><br></pre></td></tr></table></figure>\n<p>先看<code>pattern</code>部分，这是由几个简单正则表达式组成的复合体，几个<code>()</code>括起来的字符串可以单独看。第一个匹配<code>chr</code>加上一个非冒号的字符，第二个和第三个都是匹配多个数字。最开始的<code>^</code>表示以<code>chr</code>起始（前面没有字符），各个括号中间的是对应的字符。整体的<code>pattern</code>的目的就是为了找到文本中符合这种模式的字符串，如果只是想把这个模式找出来的话，几个括号可以不用加。显然这几个括号的作用就是将它们划分成多个域，帮助<code>sed</code>进行处理。可以看到<code>replacement</code>部分存在<code>\\1</code>,<code>\\2</code>,<code>\\3</code>，它恰好对应<code>()</code>的顺序。这样我们在中间插入<code>\\t</code>制表符，就可以完成我们想要的功能：将原字符串转换为三列。</p>\n<p>我本身对字符串并不是非常熟悉，懂一些元字符，可能讲解的不是很到位。不熟悉正则表达式的朋友，可以学习和参考下<a href=\"http://www.jianshu.com/p/7c50954651fa\" target=\"_blank\" rel=\"noopener\">学习正则表达式</a>，是我从Github上Copy到的非常好的学习资料，有兴趣也可以Fork学习。</p>\n<p>上山的路总是有很多条，我们下面看下其他实现该功能的办法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/[:-]/\\t/g'</span><br><span class=\"line\">chr1    28647389        28659480</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/:/\\t/' | sed 's/-/\\t/'</span><br><span class=\"line\">chr1    28647389        28659480</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  tr ':-' '\\t'</span><br><span class=\"line\">chr1    28647389        28659480</span><br></pre></td></tr></table></figure>\n<p>这三种方式看起来都非常简单有效。它处理字符串的思路不是从匹配pattern然后替换入手，不对，应该说是不是从匹配所有pattern然后替换入手。处理的关键是只处理字符串中看似无用的连字符<code>:</code>与<code>-</code>，将其替换成制表符从而轻松完成分割。</p>\n<p><code>sed &#39;s/:/\\t/&#39; | sed &#39;s/-/\\t/&#39;</code>可以通过<code>-e</code>选项写为<code>sed -e &#39;s/:/\\t/&#39; -e &#39;s/-/\\t/&#39;</code>，效果等价。</p>\n<p>默认<code>sed</code>命令支持基本的POSIX正则表达式（BRE），可以通过<code>-E</code>选项进行拓展（ERE）。很多的Linux命令都这种方式，像常用的<code>grep</code>命令。</p>\n<p>再看一个实例，如果我们想把<code>chr1:28647389-28659480</code>这样格式的文字转换为三列，可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" | \\</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">  sed -E <span class=\"string\">'s/^(chr[^:]+):([0-9]+)-([0-9]+)/\\1\\t\\2\\t\\3/'</span></span></span><br><span class=\"line\">chr1    28647389        28659480</span><br></pre></td></tr></table></figure>\n<p>我们聚焦在第二个命令<code>sed</code>上。初看杂乱无章，但是从最大的结构看依旧是</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/</span><br></pre></td></tr></table></figure>\n<p>先看<code>pattern</code>部分，这是由几个简单正则表达式组成的复合体，几个<code>()</code>括起来的字符串可以单独看。第一个匹配<code>chr</code>加上一个非冒号的字符，第二个和第三个都是匹配多个数字。最开始的<code>^</code>表示以<code>chr</code>起始（前面没有字符），各个括号中间的是对应的字符。整体的<code>pattern</code>的目的就是为了找到文本中符合这种模式的字符串，如果只是想把这个模式找出来的话，几个括号可以不用加。显然这几个括号的作用就是将它们划分成多个域，帮助<code>sed</code>进行处理。可以看到<code>replacement</code>部分存在<code>\\1</code>,<code>\\2</code>,<code>\\3</code>，它恰好对应<code>()</code>的顺序。这样我们在中间插入<code>\\t</code>制表符，就可以完成我们想要的功能：将原字符串转换为三列。</p>\n<p>我本身对字符串并不是非常熟悉，懂一些元字符，可能讲解的不是很到位。不熟悉正则表达式的朋友，可以学习和参考下<a href=\"http://www.jianshu.com/p/7c50954651fa\" target=\"_blank\" rel=\"noopener\">学习正则表达式</a>，是我从Github上Copy到的非常好的学习资料，有兴趣也可以Fork学习。</p>\n<p>上山的路总是有很多条，我们下面看下其他实现该功能的办法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/[:-]/\\t/g'</span><br><span class=\"line\">chr1    28647389        28659480</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/:/\\t/' | sed 's/-/\\t/'</span><br><span class=\"line\">chr1    28647389        28659480</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  tr ':-' '\\t'</span><br><span class=\"line\">chr1    28647389        28659480</span><br></pre></td></tr></table></figure>\n<p>这三种方式看起来都非常简单有效。它处理字符串的思路不是从匹配pattern然后替换入手，不对，应该说是不是从匹配所有pattern然后替换入手。处理的关键是只处理字符串中看似无用的连字符<code>:</code>与<code>-</code>，将其替换成制表符从而轻松完成分割。</p>\n<p><code>sed &#39;s/:/\\t/&#39; | sed &#39;s/-/\\t/&#39;</code>可以通过<code>-e</code>选项写为<code>sed -e &#39;s/:/\\t/&#39; -e &#39;s/-/\\t/&#39;</code>，效果等价。</p>\n<p>默认，<code>sed</code>会输出每一行的结果，用<code>replacement</code>替换<code>pattern</code>，但实际中我们可能会因此得到不想要的结果。比如下面的这个例子。</p>\n<p>如果我们想要抓出<code>gtf</code>文件第九列的转录名，可能会使用以下命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | head -n 3 | \\</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> sed -E <span class=\"string\">'s/.*transcript_id \"([^\"]+)\".*/\\1/'</span></span></span><br><span class=\"line\">chr1    HAVANA  gene    11869   14409   .       +       .       gene_id \"ENSG00000223972.5_2\"; gene_type \"transcribed_unprocessed_pseudogene\"; gene_name \"DDX11L1\"; level 2; havana_gene \"OTTHUMG00000000961.2_2\"; remap_status \"full_contig\"; remap_num_mappings 1; remap_target_status \"overlap\";</span><br><span class=\"line\">ENST00000456328.2_1</span><br><span class=\"line\">ENST00000456328.2_1</span><br></pre></td></tr></table></figure>\n<p>我们可以发现一些没有转录名行的结果是输出整行，这可不是我们想要的。一种解决办法是在使用<code>sed</code>之前先抓出有<code>transcript_id</code>的行。其实<code>sed</code>命令本身也可以通过选项和参数设定解决这个问题，这里我们可以用<code>-n</code>选项关闭<code>sed</code>输出所有行，在最末的<code>/</code>后加<code>p</code>只输出匹配项。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | head -n 3 | sed -E -n 's/.*transc</span><br><span class=\"line\">ript_id \"([^\"]+)\".*/\\1/p'</span><br><span class=\"line\">ENST00000456328.2_1</span><br><span class=\"line\">ENST00000456328.2_1</span><br></pre></td></tr></table></figure>\n<p>注意方括号内<code>^</code>是非（取反）的意思。</p>\n<p>解释如下：</p>\n<ol>\n<li>首先，匹配字符串”transcript_id”之前0或多个任意字符（<code>.</code>表示除换行键的任意字符）。</li>\n<li>然后，匹配和捕获一个或多个不是引号的字符，用的是<code>[^&quot;]</code></li>\n</ol>\n<p><code>+</code>号的使用是一种非贪婪的方法。很多新手会用<code>*</code>，这是贪婪操作，往往会得不偿失，需要注意喔。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ sed -E 's/transcript_id \"([^\"]+)\".*/\\1/' greedy_example.txt</span><br><span class=\"line\">ENSMUST00000160944</span><br><span class=\"line\">wangsx@SC-201708020022:~/database$ sed -E 's/transcript_id \"(.*)\".*/\\1/' greedy_example.txt</span><br><span class=\"line\">ENSMUST00000160944\"; gene_name \"Gm16088</span><br></pre></td></tr></table></figure>\n<p>使用<code>*</code>时它会尽量多地去匹配符合要求的模式。</p>\n<p>我们也可以用<code>sed</code>命令来获取特定范围的行，比如说我要取出头10行，可以使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -n '1,10p' filename</span><br></pre></td></tr></table></figure>\n<p>20到50行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -n '20,50p' filename</span><br></pre></td></tr></table></figure>\n<p>当然<code>sed</code>的功能特性远远不止这些，有待于大家更多地挖掘。不过需要注意的是，尽量让工具干它最擅长的事情。如果是复杂地大规模计算，还是最好写个Python脚本。</p>\n<blockquote>\n<p><strong>KISS原则</strong>:</p>\n<p>Keep Incredible Sed Simple</p>\n</blockquote>\n<h2 id=\"高级Shell用法\"><a href=\"#高级Shell用法\" class=\"headerlink\" title=\"高级Shell用法\"></a>高级Shell用法</h2><h3 id=\"子shell\"><a href=\"#子shell\" class=\"headerlink\" title=\"子shell\"></a>子shell</h3><p>首先需要记住<strong>连续</strong>命令和<strong>管道</strong>命令的区别：前者是简单地一个一个按顺序运行程序（一般用<code>&amp;&amp;</code>或者<code>;</code>）；后者前一个程序的输出结果会直接传到下一个命令程序的输入中（这不就是流程化操作么，用<code>|</code>分隔）。</p>\n<p>子shell可以让我们在一个独立的shell进程中执行连续命令。</p>\n<p>首先看个例子</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ echo \"this command\"; echo \"that command\" | sed 's/command/step/'</span><br><span class=\"line\">this command</span><br><span class=\"line\">that step</span><br><span class=\"line\">wangsx@SC-201708020022:~/database$ (echo \"this command\"; echo \"that command\") | sed 's/command/step/'</span><br><span class=\"line\">this step</span><br><span class=\"line\">that step</span><br></pre></td></tr></table></figure>\n<p>发现仅仅加了个括号，结果就不同了。第二个命令就用了子shell，它把两个<code>echo</code>命令放进单独的空间执行后将结果传给下游。</p>\n<p>子shell在对<code>gtf</code>文件进行操作时有个非常有意思有用的用处。我们如果想对<code>gtf</code>文件排序，但是又想要保留文件头部注释信息，我们就能够用两次<code>grep</code>操作分别抓出注释和非注释信息，然后又把它结合在一起。下面看看效果，用<code>less</code>进行检查：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ (zgrep \"^#\" gencode.v27lift37.annotation.gtf.gz; \\</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">  zgrep -v <span class=\"string\">\"^#\"</span> gencode.v27lift37.annotation.gtf.gz | \\</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">  sort -k1,1 -k4,4n) | less</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，子shell确实能够给我们提供非常有用的操作去组合命令实现想要的功能。</p>\n<h3 id=\"命令管道及进程替换\"><a href=\"#命令管道及进程替换\" class=\"headerlink\" title=\"命令管道及进程替换\"></a>命令管道及进程替换</h3><p>很多生信命令行工具需要提供多个输入和输出参数，这用在管道命令里可能会导致非常低效的情形（管道只接受一个标准输入和输出）。幸好，我们可以使用命令管道来解决此类问题。</p>\n<p><strong>命名管道</strong>，也成为FIFO（先入先出，额，这不是队列么:smile:）。它是一个特殊的排序文件，命名管道有点像文件，它可以永久保留在你的文件系统上（估计本质就是文件吧~）。</p>\n<p>我们用<code>mkfifo</code>来生成它</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ls -l fqin</span><br><span class=\"line\">prw-rw-rw- 1 wangsx wangsx 0 9月   3 20:45 fqin</span><br></pre></td></tr></table></figure>\n<p>可以它看它权限的第一个字符是p，指代是pipe。说明是个特殊文件。</p>\n<p>我们像文件一样对它进行一些操作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat fqin</span><br><span class=\"line\">hello, named pipes</span><br><span class=\"line\">[1]+  已完成               echo \"hello, named pipes\" &gt; fqin</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ rm fqin</span><br></pre></td></tr></table></figure>\n<p>比如当使用一个生信命令行工具</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">processing<span class=\"number\">_</span>tool --<span class=\"keyword\">in</span><span class=\"number\">1</span> <span class=\"keyword\">in</span><span class=\"number\">1</span>.fq --<span class=\"keyword\">in</span><span class=\"number\">2</span> <span class=\"keyword\">in</span><span class=\"number\">2</span>.fq --<span class=\"keyword\">out</span><span class=\"number\">1</span> <span class=\"keyword\">out</span><span class=\"number\">1</span>.fq --<span class=\"keyword\">out</span><span class=\"number\">2</span> <span class=\"keyword\">out</span><span class=\"number\">2</span>.fq</span><br></pre></td></tr></table></figure>\n<p><code>in1.fq in2.fq</code>就可以上游输出数据到<code>processing_tool</code>的命名管道；同理<code>out1.fq out2.fq</code>可以是命名管道用来写进输出数据。</p>\n<p>但这样我们每次都得不停地创建和删除这些文件，解决办法是使用匿名管道，也叫进程替换。</p>\n<p>不能光说，看看例子就知道和理解了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat &lt;(echo \"hello, process substitution\")</span><br><span class=\"line\">hello, process substitution</span><br></pre></td></tr></table></figure>\n<p><code>echo</code>命令运行后使用了进程替换，产生匿名文件，然后匿名文件被重导向<code>cat</code>命令。</p>\n<p>把它用到工具上，就变成了(假定上游zcat下游执行grep命令)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">processing_tool --in1 &lt; (zcat file1) --in2 &lt; (zcat file2) --out1 (gzip &gt; outfile1) --out2 (gzip &gt; outfile2)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>参考学习《Bioinformatics. Data. Skills》，这里简要地整理下Linux用来处理数据文本的工具。具体命令详情请在<a href=\"http://man.linuxde.net/\" target=\"_blank\" rel=\"noopener\">Linux命令大全</a>中搜索或者查阅其他相关资料。</p>","more":"<p><code>head</code>,<code>tail</code>查看文档头尾。<code>-n</code>选项可以指定行数。</p>\n<p><code>less</code>用来查阅文档，<code>q</code>退出，<code>space bar</code>翻页，<code>g</code>第一行，<code>G</code>最后一行，<code>j</code>下，<code>k</code>上,<code>/&lt;pattern&gt;</code>往下搜索模式，<code>?&lt;pattern&gt;</code>往上搜索模式，<code>n</code>前一个匹配字符，<code>N</code>后一个匹配字符。</p>\n<p><code>less</code>可以用于debug，查看中间输出结果。比如<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1 input.txt | step2 | step3 &gt; output.txt</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> step1,2,3为程序或命令名</span></span><br></pre></td></tr></table></figure></p>\n<p>可以写为<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">step1 input.txt | less</span><br><span class=\"line\">step1 input.txt | step2 | less</span><br><span class=\"line\">step1 input.txt | step2 | step3 | less</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"纯文本信息汇总\"><a href=\"#纯文本信息汇总\" class=\"headerlink\" title=\"纯文本信息汇总\"></a>纯文本信息汇总</h2><p><code>wc</code>命令默认依次输出单词数、行数、总字符数。查看行数使用<code>wc -l</code>。<br>如果存在空行，空行会被计数。可以使用<code>grep</code>命令实现非空行计数<br><code>grep -c &quot;[^ \\\\n\\\\t]&quot; some_data.bed</code></p>\n<p><code>ls -lh</code>以易读形式查看文件大小。</p>\n<p>输出文件列数：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> -F指定分隔符，此处假定是table键分隔，默认空格键</span></span><br><span class=\"line\">awk -F \"\\t\" '&#123;print NF; exit&#125;' some_data.bed</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"怎么去除注释的元数据行呢？怎么计数非注释行行数呢？\"><a href=\"#怎么去除注释的元数据行呢？怎么计数非注释行行数呢？\" class=\"headerlink\" title=\"怎么去除注释的元数据行呢？怎么计数非注释行行数呢？\"></a>怎么去除注释的元数据行呢？怎么计数非注释行行数呢？</h3><p>可以使用<code>tail</code>结合<code>awk</code>，试试gtf(基因组注释文件)<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ head -n 6 Homo_sapiens.GRCh37.75.gtf</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genome-build GRCh37.p13</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genome-version GRCh37</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genome-date 2009-02</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genome-build-accession NCBI:GCA_000001405.14</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genebuild-last-updated 2013-09</span></span><br><span class=\"line\">1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";</span><br></pre></td></tr></table></figure></p>\n<p>可以看到注释行是5行，我们利用<code>tail</code>试试去掉它<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意此处 -n后接的<span class=\"string\">\"+\"</span>号</span></span><br><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ tail -n +5 Homo_sapiens.GRCh37.75.gtf | head -n 1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!genebuild-last-updated 2013-09</span></span><br></pre></td></tr></table></figure></p>\n<p>发现还有一行没去掉<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ tail -n +6 Homo_sapiens.GRCh37.75.gtf | head -n 1</span><br><span class=\"line\">1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";</span><br></pre></td></tr></table></figure></p>\n<p>成功搞定，然后结合前面提到的<code>awk</code>命令即可计算行数。</p>\n<p>上面方法鲁棒性不够（人为地确定行数），一种更为通用的方法是<code>grep</code>结合<code>awk</code>命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 1</span><br><span class=\"line\">1\tpseudogene\tgene\t11869\t14412\t.\t+\t.\tgene_id \"ENSG00000223972\"; gene_name \"DDX11L1\"; gene_source \"ensembl_havana\"; gene_biotype \"pseudogene\";</span><br></pre></td></tr></table></figure></p>\n<p>推荐使用这种。</p>\n<h2 id=\"Cut\"><a href=\"#Cut\" class=\"headerlink\" title=\"Cut\"></a>Cut</h2><p><code>cut</code>可以处理列数据，<code>-f</code>选项指定列，可以是一个范围（比如2-8），注意不能用它给列排序。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3</span><br><span class=\"line\">gene</span><br><span class=\"line\">transcript</span><br><span class=\"line\">exon</span><br><span class=\"line\">exon</span><br><span class=\"line\">exon</span><br><span class=\"line\">transcript</span><br><span class=\"line\">exon</span><br><span class=\"line\">exon</span><br><span class=\"line\">exon</span><br><span class=\"line\">transcript</span><br><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5</span><br><span class=\"line\">gene\t11869\t14412</span><br><span class=\"line\">transcript\t11869\t14409</span><br><span class=\"line\">exon\t11869\t12227</span><br><span class=\"line\">exon\t12613\t12721</span><br><span class=\"line\">exon\t13221\t14409</span><br><span class=\"line\">transcript\t11872\t14412</span><br><span class=\"line\">exon\t11872\t12227</span><br><span class=\"line\">exon\t12613\t12721</span><br><span class=\"line\">exon\t13225\t14412</span><br><span class=\"line\">transcript\t11874\t14409</span><br></pre></td></tr></table></figure></p>\n<p><code>-d</code>选项可以指定分隔符，比如<code>-d,</code>指定<code>,</code>为分隔符。</p>\n<p>使用<code>column</code>命令来格式化输出，上次的命令结果输出明显没对齐，我们把它对齐看看：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 | column -t</span><br><span class=\"line\">gene        11869  14412</span><br><span class=\"line\">transcript  11869  14409</span><br><span class=\"line\">exon        11869  12227</span><br><span class=\"line\">exon        12613  12721</span><br><span class=\"line\">exon        13221  14409</span><br><span class=\"line\">transcript  11872  14412</span><br><span class=\"line\">exon        11872  12227</span><br><span class=\"line\">exon        12613  12721</span><br><span class=\"line\">exon        13225  14412</span><br><span class=\"line\">transcript  11874  14409</span><br></pre></td></tr></table></figure></p>\n<p>注意，使用这个命令是为了好观察，不要把用它处理然后把结果传入文本（会导致程序处理文件效率降低，因为文本解析速度会下降）。</p>\n<p><code>cut</code>和<code>column</code>默认以<code>\\t</code>为分隔符，这里也能够用<code>-s</code>选项指定。</p>\n<p>先把之前的tab分隔文件弄成逗号分隔文件，然后使用<code>-s</code>选项看看：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 |  awk '&#123;FS=\"\\t\";OFS=\",\";&#125;&#123;print $1,$2,$3&#125;'</span><br><span class=\"line\">gene,11869,14412</span><br><span class=\"line\">transcript,11869,14409</span><br><span class=\"line\">exon,11869,12227</span><br><span class=\"line\">exon,12613,12721</span><br><span class=\"line\">exon,13221,14409</span><br><span class=\"line\">transcript,11872,14412</span><br><span class=\"line\">exon,11872,12227</span><br><span class=\"line\">exon,12613,12721</span><br><span class=\"line\">exon,13225,14412</span><br><span class=\"line\">transcript,11874,14409</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -v \"^#\" Homo_sapiens.GRCh37.75.gtf | head -n 10 | cut -f 3-5 |  awk '&#123;FS=\"\\t\";OFS=\",\";&#125;&#123;print $1,$2,$3&#125;'| column -s \",\" -t</span><br><span class=\"line\">gene        11869  14412</span><br><span class=\"line\">transcript  11869  14409</span><br><span class=\"line\">exon        11869  12227</span><br><span class=\"line\">exon        12613  12721</span><br><span class=\"line\">exon        13221  14409</span><br><span class=\"line\">transcript  11872  14412</span><br><span class=\"line\">exon        11872  12227</span><br><span class=\"line\">exon        12613  12721</span><br><span class=\"line\">exon        13225  14412</span><br><span class=\"line\">transcript  11874  14409</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h2><p><code>grep</code>处理速度非常之快，能用它尽量用它。<code>--color=auto</code>可以激活颜色（标记匹配文字），更方便查看。</p>\n<p><code>-v</code>选项排除匹配到的，<code>-w</code>进行完全匹配。这样可以防止，你想排除<code>abc</code>结果把<code>abc1</code>，<code>abcd</code>也排除掉了。</p>\n<p><code>-B</code>指定输出包括匹配到的前多少行，比如<code>-B1</code>就是前一行；<code>-A</code>指定输出包括匹配到的后多少行，比如<code>-A2</code>就是包括了后两行。<code>-C</code>指定输出包括匹配到的前后多少行。<br><code>grep</code>支持基本正则表达式，<code>-E</code>指定支持扩展表达式，或者用<code>egrep</code>命令。<br><code>-c</code>选项对匹配的行计数；<code>-o</code>选项只抽离输出匹配的部分<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -E -o 'gene_id \"\\w+\"' Homo_sapiens.GRCh37.75.gtf | head -n 5</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br><span class=\"line\">gene_id \"ENSG00000223972\"</span><br></pre></td></tr></table></figure></p>\n<p>发现冗余项非常多，如果我们只要唯一的呢，怎么办？<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ grep -E -o 'gene_id \"(\\w+)\"' Homo_sapiens.GRCh37.75.gtf | cut -f2 -d\" \"| sed 's/\"//g' | sort | uniq | head -n 10</span><br><span class=\"line\">ENSG00000000003</span><br><span class=\"line\">ENSG00000000005</span><br><span class=\"line\">ENSG00000000419</span><br><span class=\"line\">ENSG00000000457</span><br><span class=\"line\">ENSG00000000460</span><br><span class=\"line\">ENSG00000000938</span><br><span class=\"line\">ENSG00000000971</span><br><span class=\"line\">ENSG00000001036</span><br><span class=\"line\">ENSG00000001084</span><br><span class=\"line\">ENSG00000001167</span><br></pre></td></tr></table></figure></p>\n<p>虽然我的笔记本呼啦啦作响，但是还是非常快就跑完了。</p>\n<h2 id=\"file查看文件编码\"><a href=\"#file查看文件编码\" class=\"headerlink\" title=\"file查看文件编码\"></a>file查看文件编码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ file regular_express.txt</span><br><span class=\"line\">regular_express.txt: ASCII text, with CRLF, LF line terminators</span><br></pre></td></tr></table></figure>\n<p>常用的大型数据文件一般存为ASCII码形式（像几大基因bank的数据文件），而我们自己认为创建的常为UTF-8，所以有时候认为处理文件需要会碰到把UTF-8编码的字符插入到ASCII码文件里去了。遇到这种问题，我们可以用<code>hexdump -c</code>命令查看出错的地方（手边没有这样的文件，就不举例了）。</p>\n<h2 id=\"用sort对文本排序\"><a href=\"#用sort对文本排序\" class=\"headerlink\" title=\"用sort对文本排序\"></a>用sort对文本排序</h2><p>我们先创建一个bed格式文件来试试这个命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ cat test.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr3\t32\t47</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.bed</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br></pre></td></tr></table></figure></p>\n<p>可以明显看到文本按照第一列进行了排序。<br>默认，<code>sort</code>用空格或tab键作为域（列）分隔符。如果我们用其他形式的分隔符，需要用<code>-t</code>选项指定。</p>\n<p>下面是对<code>bed</code>文件最通用的排序命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br></pre></td></tr></table></figure></p>\n<p>基本操作<code>bedtools</code>软件都会先用这个命令对<code>bedtools</code>文件排序。<br>现在略加解释一下，<code>sort</code>用<code>-k</code>选项指定某列的排序方式。而每次使用<code>-k</code>选项都要带上指定列的范围(start, end)。如果只指定一列，就为(start,start)了，像上面命令的<code>-k1,1</code>就是。也许你会觉得<code>-k2,2n</code>很奇怪，这里的<code>n</code>指定程序把第二列当做数值对待。如果不做设定，都是当做字符对待（shell都是这么对待数值数据的）。所以总结其他这一行命令就是对第一列按照字符排序，第二列按照数值排序。</p>\n<p>我们可以用<code>-c</code>选项检查一个文件是不是已经按照过某种方式排过序了。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed | sort -k1,1 -k2,2 -c</span><br><span class=\"line\">sort：-:2：无序： chr1\t10\t19</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo $?</span><br><span class=\"line\">1</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed | sort -k1,1 -k2,2n -c</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo $?</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure></p>\n<p>上面可以清楚地看到<code>sort</code>是怎么对待文件的（一般shell返回0表示成功执行）。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ tsfds</span><br><span class=\"line\">tsfds：未找到命令</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo $?</span><br><span class=\"line\">127</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo test</span><br><span class=\"line\">test</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ echo $?</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure></p>\n<p>shell的命令退出状态码表示了该命令执行的完成的某种情况。不同的状态码有不同的含义，具体可以百度查阅（我之前整理的shell笔记应该讲过，可以看看）。</p>\n<p>反向排序用<code>-r</code>选项。如果你只想反转一列，可以把它加在<code>-k</code>选项后。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2nr test.bed</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br></pre></td></tr></table></figure>\n<p>现在我给<code>test.bed</code>加一行：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ cat test.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr3\t32\t47</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr11\t22\t56</span><br></pre></td></tr></table></figure></p>\n<p>你会发现有点奇怪<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1 -k2,2n test.bed</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr11\t22\t56</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br></pre></td></tr></table></figure></p>\n<p>怎么<code>chr11</code>在<code>chr2</code>前面？其实<code>sort</code>排序的方式有点像查字典。例子中，命令先比较<code>c</code>，然后比较<code>h</code>，然后比较<code>r</code>，接着比较<code>1</code>，自然<code>11</code>会在<code>2</code>前面了。这里可以添加<code>V</code>选项修改。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort -k1,1V -k2,2n test.bed</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr1\t10\t19</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t40\t50</span><br><span class=\"line\">chr2\t35\t54</span><br><span class=\"line\">chr3\t32\t47</span><br><span class=\"line\">chr11\t22\t56</span><br></pre></td></tr></table></figure></p>\n<p>是不是觉得这样更可观一些？不过通常在处理数据时不做此处理，符合 规范的数据可以让后续处理程序效率更高。</p>\n<p>基本掌握<code>sort</code>这些也够用了，它主要为后续处理服务。如果想知道其他的用法，查查吧，同时欢迎发文来交流。</p>\n<h2 id=\"用uniq寻找唯一值\"><a href=\"#用uniq寻找唯一值\" class=\"headerlink\" title=\"用uniq寻找唯一值\"></a>用uniq寻找唯一值</h2><p>首先创建样例文本<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ cat test.letter</span><br><span class=\"line\">A</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">C</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">F</span><br><span class=\"line\">D</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>uniq</code>看看<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ uniq test.letter</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">F</span><br><span class=\"line\">D</span><br></pre></td></tr></table></figure></p>\n<p>尼玛，怎么不对。它好像只去掉了连续的同一字符。怎么办？想想我们刚学了什么命令？<code>sort</code>不是刚好可以把同样的字符弄到一起去吗，然后再使用<code>uniq</code>，嘿嘿：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.letter | uniq</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">F</span><br></pre></td></tr></table></figure></p>\n<p>哟呵，got you。</p>\n<p>加<code>-c</code>选项计数：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.letter | uniq -c</span><br><span class=\"line\">      2 A</span><br><span class=\"line\">      2 B</span><br><span class=\"line\">      4 C</span><br><span class=\"line\">      2 D</span><br><span class=\"line\">      1 F</span><br></pre></td></tr></table></figure></p>\n<p>把结果再排序<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.letter | uniq -c | sort -rn</span><br><span class=\"line\">      4 C</span><br><span class=\"line\">      2 D</span><br><span class=\"line\">      2 B</span><br><span class=\"line\">      2 A</span><br><span class=\"line\">      1 F</span><br></pre></td></tr></table></figure></p>\n<p><code>-d</code>选项只输出重复行<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ cat test.letter</span><br><span class=\"line\">A</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">C</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">F</span><br><span class=\"line\">D</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ uniq -d test.letter</span><br><span class=\"line\">A</span><br><span class=\"line\">C</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ sort test.letter | uniq -d</span><br><span class=\"line\">A</span><br><span class=\"line\">B</span><br><span class=\"line\">C</span><br><span class=\"line\">D</span><br></pre></td></tr></table></figure></p>\n<p>使用时需要注意处理不同导致的结果差异。</p>\n<h2 id=\"Join-命令\"><a href=\"#Join-命令\" class=\"headerlink\" title=\"Join 命令\"></a>Join 命令</h2><p>用来连接文件。<br>假设现在我们有两个文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ cat example.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t32\t47</span><br><span class=\"line\">chr3\t11\t28</span><br><span class=\"line\">chr1\t40\t49</span><br><span class=\"line\">chr3\t16\t27</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t53</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ cat example_length.txt</span><br><span class=\"line\">chr1\t53453</span><br><span class=\"line\">chr2\t34356</span><br><span class=\"line\">chr3\t24356</span><br></pre></td></tr></table></figure>\n<p>我想把第二个文件说明染色体长度添加到第一个文件对应染色体的第三列。<br>我们首先要给文件排序（使用<code>join</code>前必须做），然后使用<code>join</code>命令。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ sort -k1,1 example.bed &gt; example_sorted.bed</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ sort -c -k1,1 example_length.txt</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ cat example_sorted.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t32\t47</span><br><span class=\"line\">chr1\t40\t49</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t53</span><br><span class=\"line\">chr3\t11\t28</span><br><span class=\"line\">chr3\t16\t27</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 example_sorted.bed  example_length.txt &gt; example_with_length.txt</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ cat example_with_length.txt</span><br><span class=\"line\">chr1 26 39 53453</span><br><span class=\"line\">chr1 32 47 53453</span><br><span class=\"line\">chr1 40 49 53453</span><br><span class=\"line\">chr1 9 28 53453</span><br><span class=\"line\">chr2 35 53 34356</span><br><span class=\"line\">chr3 11 28 24356</span><br><span class=\"line\">chr3 16 27 24356</span><br></pre></td></tr></table></figure></p>\n<p>命令基本语法是<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">join</span> -<span class=\"number\">1</span> <span class=\"symbol\">&lt;file_1_field&gt;</span> -<span class=\"number\">2</span> <span class=\"symbol\">&lt;file_2_field&gt;</span> <span class=\"symbol\">&lt;file_1&gt;</span> <span class=\"symbol\">&lt;file_2&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>既然名字叫<code>join</code>，就是两者必须有共同之处，通过共同的支点将两者连为一体。<br><code>-1</code>和<code>-2</code>选项后接参数分别指定了这个支点，也就是连接的域（列）。比如例子中，都是两个文件的第一列。</p>\n<p>两个文件中，第一列都共有<code>chr1(2)(3)</code>。 如果不一致会出现什么情况呢？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 example_sorted.bed  example_length_alt.txt chr1 26 39 53453</span><br><span class=\"line\">chr1 32 47 53453</span><br><span class=\"line\">chr1 40 49 53453</span><br><span class=\"line\">chr1 9 28 53453</span><br><span class=\"line\">chr2 35 53 34356</span><br></pre></td></tr></table></figure>\n<p>如果第二个文件没有<code>chr3</code>，<code>join</code>之后也没了！！</p>\n<p>我们可以通过<code>-a</code>选项指定哪一个文件可以不遵循配对<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ join -1 1 -2 1 -a 1 example_sorted.bed  example_length_alt.txt</span><br><span class=\"line\">chr1 26 39 53453</span><br><span class=\"line\">chr1 32 47 53453</span><br><span class=\"line\">chr1 40 49 53453</span><br><span class=\"line\">chr1 9 28 53453</span><br><span class=\"line\">chr2 35 53 34356</span><br><span class=\"line\">chr3 11 28</span><br><span class=\"line\">chr3 16 27</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"awk\"><a href=\"#awk\" class=\"headerlink\" title=\"awk\"></a>awk</h2><p><code>awk</code>是文本处理的一把好手，虽然它不能像<code>python</code>，<code>R</code>干一些高级复杂的主题工作，但是它具备完整的命令操作和编程体系。</p>\n<p><code>awk</code>是一门语言，我不可能在学习的时候能够逻辑清晰详细地介绍给大家。主要是还通过实例来了解用法，加深认识。手册可以参考<a href=\"http://man.linuxde.net/awk。\" target=\"_blank\" rel=\"noopener\">http://man.linuxde.net/awk。</a></p>\n<p>首先要明白的是，<code>awk</code>按行处理数据。在shell知识里，如果把一个文档看做一张表。那么一行就是一个<strong>记录</strong>，一列就是一个<strong>域</strong>。可以看出，<code>awk</code>就是按记录处理文本的。</p>\n<p>其次是<code>awk</code>的程序结构是<br><figure class=\"highlight coq\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">pattern</span> &#123;action&#125;</span><br></pre></td></tr></table></figure></p>\n<p>pattern可以是表达式或者正则表达式。pattern有点像<code>if</code>语句，当它满足时就会执行相应的动作。</p>\n<p>另一个<code>awk</code>核心是它用<code>$0</code>表示所有列，<code>$1</code>，<code>$2</code>…等等表示对应的列。我们可以很方便地用它进行操作。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123;print $0&#125;' example.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t32\t47</span><br><span class=\"line\">chr3\t11\t28</span><br><span class=\"line\">chr1\t40\t49</span><br><span class=\"line\">chr3\t16\t27</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">chr2\t35\t53</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123;print $1&#125;' example.bed</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr2</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123;print $2&#125;' example.bed</span><br><span class=\"line\">26</span><br><span class=\"line\">32</span><br><span class=\"line\">11</span><br><span class=\"line\">40</span><br><span class=\"line\">16</span><br><span class=\"line\">9</span><br></pre></td></tr></table></figure></p>\n<p><code>print</code>语句就像动作一样输出你操作的结果。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $2 \"\\t\" $3&#125;' example.bed</span><br><span class=\"line\">26\t39</span><br><span class=\"line\">32\t47</span><br><span class=\"line\">11\t28</span><br><span class=\"line\">40\t49</span><br><span class=\"line\">16\t27</span><br><span class=\"line\">9\t28</span><br><span class=\"line\">35\t53</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $2  $3&#125;' example.bed</span><br><span class=\"line\">2639</span><br><span class=\"line\">3247</span><br><span class=\"line\">1128</span><br><span class=\"line\">4049</span><br><span class=\"line\">1627</span><br><span class=\"line\">928</span><br><span class=\"line\">3553</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $2 , $3&#125;' example.bed</span><br><span class=\"line\">26 39</span><br><span class=\"line\">32 47</span><br><span class=\"line\">11 28</span><br><span class=\"line\">40 49</span><br><span class=\"line\">16 27</span><br><span class=\"line\">9 28</span><br><span class=\"line\">35 53</span><br></pre></td></tr></table></figure></p>\n<p>了解上述几个语句的不同。</p>\n<p>表示染色体名一般用带<code>chr</code>或者不带<code>chr</code>标志两种方式。当我们要用到这两种时，肯定要让它们能够对应起来，也就是转换。<code>awk</code>命令可以非常方便地添加<code>chr</code>标记。</p>\n<p>下面我先把例子文件的<code>chr</code>去掉，然后加上试试。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $1&#125;' example.bed</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr2</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $1&#125;' example.bed | cut -c4</span><br><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '&#123; print $1&#125;' example.bed | cut -c4 | awk '&#123;print \"chr\"$1&#125;'</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr3</span><br><span class=\"line\">chr1</span><br><span class=\"line\">chr2</span><br></pre></td></tr></table></figure></p>\n<p><code>awk</code>作为一门编程语言，它支持各种操作符（运算，逻辑，判断）喔。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '$3 - $2 &gt;18' example.bed</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk '$1 ~/chr1/ &amp;&amp; $3 - $2 &gt; 10' example.bed</span><br><span class=\"line\">chr1\t26\t39</span><br><span class=\"line\">chr1\t32\t47</span><br><span class=\"line\">chr1\t9\t28</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这里 ~ 符号用来匹配正则表达式</span></span><br></pre></td></tr></table></figure></p>\n<p>还有<code>awk</code>存在一些变量，像<code>NR</code>表示行号，<code>OFS</code>表示输出分隔符等。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:/tmp$ awk 'NR &gt;= 3 &amp;&amp; NR &lt;= 5' example.bed</span><br><span class=\"line\">chr3\t11\t28</span><br><span class=\"line\">chr1\t40\t49</span><br><span class=\"line\">chr3\t16\t27</span><br></pre></td></tr></table></figure></p>\n<p>如果我们想把<code>gtf</code>文件转换成为<code>bed</code>格式，可以使用<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~/Work/research/Promoter_Research$ head -n1000 Homo_sapiens.GRCh37.75.gtf | awk '!/^#/&#123; print $1 \"\\t\" $4-1 \"\\t\" $5&#125; ' | head -n 3</span><br><span class=\"line\">1\t11868\t14412</span><br><span class=\"line\">1\t11868\t14409</span><br><span class=\"line\">1\t11868\t12227</span><br></pre></td></tr></table></figure></p>\n<p>因为篇幅有限，我不可能输出所有结果，所以只取部分数据做了运算。</p>\n<h2 id=\"用Sed进行流编辑\"><a href=\"#用Sed进行流编辑\" class=\"headerlink\" title=\"用Sed进行流编辑\"></a>用Sed进行流编辑</h2><p><code>sed</code>命令从文本或者标准输入中每次读入一行数据。</p>\n<p>我们先从简单的实例出发，看下该命令怎么将一列中的<code>chrm12</code>,<code>chrom2</code>等转换成<code>chr12</code>，<code>chr2</code>的格式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat chrms.txt</span><br><span class=\"line\">chrom1    3214482    3216968</span><br><span class=\"line\">chrom1    3214234    3216968</span><br><span class=\"line\">chrom1    3213425    3210653</span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ sed 's/chrom/chr/' chrms.txt</span><br><span class=\"line\">chr1    3214482    3216968</span><br><span class=\"line\">chr1    3214234    3216968</span><br><span class=\"line\">chr1    3213425    3210653</span><br></pre></td></tr></table></figure>\n<p>虽然示例文件处理仅仅只有三行，但我们可以将这种处理方式运用到上G甚至更大的数据文件中，而不用打开整个文件进行处理。并且，可以借助重导向实现对数据处理结果的输出。</p>\n<p><code>sed</code>替换命令采用的格式是</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/</span><br></pre></td></tr></table></figure>\n<p><code>sed</code>会自动搜索符合<code>pattern</code>的字符串，然后修改为<code>replacement</code>（我们想要修改后的样子）。一般默认<code>sed</code>只替换第一个匹配的<code>pattern</code>，我们可以通过添加全局标识<code>g</code>将其应用到数据的所有行中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/g</span><br></pre></td></tr></table></figure>\n<p>如果我们想要忽略匹配的大小写，使用<code>i</code>标识</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/i</span><br></pre></td></tr></table></figure>\n<p>默认<code>sed</code>命令支持基本的POSIX正则表达式（BRE），可以通过<code>-E</code>选项进行拓展（ERE）。很多的Linux命令都这种方式，像常用的<code>grep</code>命令。</p>\n<p>再看一个实例，如果我们想把<code>chr1:28647389-28659480</code>这样格式的文字转换为三列，可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" | \\</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">  sed -E <span class=\"string\">'s/^(chr[^:]+):([0-9]+)-([0-9]+)/\\1\\t\\2\\t\\3/'</span></span></span><br><span class=\"line\">chr1    28647389        28659480</span><br></pre></td></tr></table></figure>\n<p>我们聚焦在第二个命令<code>sed</code>上。初看杂乱无章，但是从最大的结构看依旧是</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/</span><br></pre></td></tr></table></figure>\n<p>先看<code>pattern</code>部分，这是由几个简单正则表达式组成的复合体，几个<code>()</code>括起来的字符串可以单独看。第一个匹配<code>chr</code>加上一个非冒号的字符，第二个和第三个都是匹配多个数字。最开始的<code>^</code>表示以<code>chr</code>起始（前面没有字符），各个括号中间的是对应的字符。整体的<code>pattern</code>的目的就是为了找到文本中符合这种模式的字符串，如果只是想把这个模式找出来的话，几个括号可以不用加。显然这几个括号的作用就是将它们划分成多个域，帮助<code>sed</code>进行处理。可以看到<code>replacement</code>部分存在<code>\\1</code>,<code>\\2</code>,<code>\\3</code>，它恰好对应<code>()</code>的顺序。这样我们在中间插入<code>\\t</code>制表符，就可以完成我们想要的功能：将原字符串转换为三列。</p>\n<p>我本身对字符串并不是非常熟悉，懂一些元字符，可能讲解的不是很到位。不熟悉正则表达式的朋友，可以学习和参考下<a href=\"http://www.jianshu.com/p/7c50954651fa\" target=\"_blank\" rel=\"noopener\">学习正则表达式</a>，是我从Github上Copy到的非常好的学习资料，有兴趣也可以Fork学习。</p>\n<p>上山的路总是有很多条，我们下面看下其他实现该功能的办法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/[:-]/\\t/g'</span><br><span class=\"line\">chr1    28647389        28659480</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/:/\\t/' | sed 's/-/\\t/'</span><br><span class=\"line\">chr1    28647389        28659480</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  tr ':-' '\\t'</span><br><span class=\"line\">chr1    28647389        28659480</span><br></pre></td></tr></table></figure>\n<p>这三种方式看起来都非常简单有效。它处理字符串的思路不是从匹配pattern然后替换入手，不对，应该说是不是从匹配所有pattern然后替换入手。处理的关键是只处理字符串中看似无用的连字符<code>:</code>与<code>-</code>，将其替换成制表符从而轻松完成分割。</p>\n<p><code>sed &#39;s/:/\\t/&#39; | sed &#39;s/-/\\t/&#39;</code>可以通过<code>-e</code>选项写为<code>sed -e &#39;s/:/\\t/&#39; -e &#39;s/-/\\t/&#39;</code>，效果等价。</p>\n<p>默认<code>sed</code>命令支持基本的POSIX正则表达式（BRE），可以通过<code>-E</code>选项进行拓展（ERE）。很多的Linux命令都这种方式，像常用的<code>grep</code>命令。</p>\n<p>再看一个实例，如果我们想把<code>chr1:28647389-28659480</code>这样格式的文字转换为三列，可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" | \\</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">  sed -E <span class=\"string\">'s/^(chr[^:]+):([0-9]+)-([0-9]+)/\\1\\t\\2\\t\\3/'</span></span></span><br><span class=\"line\">chr1    28647389        28659480</span><br></pre></td></tr></table></figure>\n<p>我们聚焦在第二个命令<code>sed</code>上。初看杂乱无章，但是从最大的结构看依旧是</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/</span><br></pre></td></tr></table></figure>\n<p>先看<code>pattern</code>部分，这是由几个简单正则表达式组成的复合体，几个<code>()</code>括起来的字符串可以单独看。第一个匹配<code>chr</code>加上一个非冒号的字符，第二个和第三个都是匹配多个数字。最开始的<code>^</code>表示以<code>chr</code>起始（前面没有字符），各个括号中间的是对应的字符。整体的<code>pattern</code>的目的就是为了找到文本中符合这种模式的字符串，如果只是想把这个模式找出来的话，几个括号可以不用加。显然这几个括号的作用就是将它们划分成多个域，帮助<code>sed</code>进行处理。可以看到<code>replacement</code>部分存在<code>\\1</code>,<code>\\2</code>,<code>\\3</code>，它恰好对应<code>()</code>的顺序。这样我们在中间插入<code>\\t</code>制表符，就可以完成我们想要的功能：将原字符串转换为三列。</p>\n<p>我本身对字符串并不是非常熟悉，懂一些元字符，可能讲解的不是很到位。不熟悉正则表达式的朋友，可以学习和参考下<a href=\"http://www.jianshu.com/p/7c50954651fa\" target=\"_blank\" rel=\"noopener\">学习正则表达式</a>，是我从Github上Copy到的非常好的学习资料，有兴趣也可以Fork学习。</p>\n<p>上山的路总是有很多条，我们下面看下其他实现该功能的办法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/[:-]/\\t/g'</span><br><span class=\"line\">chr1    28647389        28659480</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  sed 's/:/\\t/' | sed 's/-/\\t/'</span><br><span class=\"line\">chr1    28647389        28659480</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ echo \"chr1:28647389-28659480\" |  tr ':-' '\\t'</span><br><span class=\"line\">chr1    28647389        28659480</span><br></pre></td></tr></table></figure>\n<p>这三种方式看起来都非常简单有效。它处理字符串的思路不是从匹配pattern然后替换入手，不对，应该说是不是从匹配所有pattern然后替换入手。处理的关键是只处理字符串中看似无用的连字符<code>:</code>与<code>-</code>，将其替换成制表符从而轻松完成分割。</p>\n<p><code>sed &#39;s/:/\\t/&#39; | sed &#39;s/-/\\t/&#39;</code>可以通过<code>-e</code>选项写为<code>sed -e &#39;s/:/\\t/&#39; -e &#39;s/-/\\t/&#39;</code>，效果等价。</p>\n<p>默认，<code>sed</code>会输出每一行的结果，用<code>replacement</code>替换<code>pattern</code>，但实际中我们可能会因此得到不想要的结果。比如下面的这个例子。</p>\n<p>如果我们想要抓出<code>gtf</code>文件第九列的转录名，可能会使用以下命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | head -n 3 | \\</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> sed -E <span class=\"string\">'s/.*transcript_id \"([^\"]+)\".*/\\1/'</span></span></span><br><span class=\"line\">chr1    HAVANA  gene    11869   14409   .       +       .       gene_id \"ENSG00000223972.5_2\"; gene_type \"transcribed_unprocessed_pseudogene\"; gene_name \"DDX11L1\"; level 2; havana_gene \"OTTHUMG00000000961.2_2\"; remap_status \"full_contig\"; remap_num_mappings 1; remap_target_status \"overlap\";</span><br><span class=\"line\">ENST00000456328.2_1</span><br><span class=\"line\">ENST00000456328.2_1</span><br></pre></td></tr></table></figure>\n<p>我们可以发现一些没有转录名行的结果是输出整行，这可不是我们想要的。一种解决办法是在使用<code>sed</code>之前先抓出有<code>transcript_id</code>的行。其实<code>sed</code>命令本身也可以通过选项和参数设定解决这个问题，这里我们可以用<code>-n</code>选项关闭<code>sed</code>输出所有行，在最末的<code>/</code>后加<code>p</code>只输出匹配项。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ zgrep -v \"^#\" gencode.v27lift37.annotation.gtf.gz | head -n 3 | sed -E -n 's/.*transc</span><br><span class=\"line\">ript_id \"([^\"]+)\".*/\\1/p'</span><br><span class=\"line\">ENST00000456328.2_1</span><br><span class=\"line\">ENST00000456328.2_1</span><br></pre></td></tr></table></figure>\n<p>注意方括号内<code>^</code>是非（取反）的意思。</p>\n<p>解释如下：</p>\n<ol>\n<li>首先，匹配字符串”transcript_id”之前0或多个任意字符（<code>.</code>表示除换行键的任意字符）。</li>\n<li>然后，匹配和捕获一个或多个不是引号的字符，用的是<code>[^&quot;]</code></li>\n</ol>\n<p><code>+</code>号的使用是一种非贪婪的方法。很多新手会用<code>*</code>，这是贪婪操作，往往会得不偿失，需要注意喔。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ sed -E 's/transcript_id \"([^\"]+)\".*/\\1/' greedy_example.txt</span><br><span class=\"line\">ENSMUST00000160944</span><br><span class=\"line\">wangsx@SC-201708020022:~/database$ sed -E 's/transcript_id \"(.*)\".*/\\1/' greedy_example.txt</span><br><span class=\"line\">ENSMUST00000160944\"; gene_name \"Gm16088</span><br></pre></td></tr></table></figure>\n<p>使用<code>*</code>时它会尽量多地去匹配符合要求的模式。</p>\n<p>我们也可以用<code>sed</code>命令来获取特定范围的行，比如说我要取出头10行，可以使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -n '1,10p' filename</span><br></pre></td></tr></table></figure>\n<p>20到50行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -n '20,50p' filename</span><br></pre></td></tr></table></figure>\n<p>当然<code>sed</code>的功能特性远远不止这些，有待于大家更多地挖掘。不过需要注意的是，尽量让工具干它最擅长的事情。如果是复杂地大规模计算，还是最好写个Python脚本。</p>\n<blockquote>\n<p><strong>KISS原则</strong>:</p>\n<p>Keep Incredible Sed Simple</p>\n</blockquote>\n<h2 id=\"高级Shell用法\"><a href=\"#高级Shell用法\" class=\"headerlink\" title=\"高级Shell用法\"></a>高级Shell用法</h2><h3 id=\"子shell\"><a href=\"#子shell\" class=\"headerlink\" title=\"子shell\"></a>子shell</h3><p>首先需要记住<strong>连续</strong>命令和<strong>管道</strong>命令的区别：前者是简单地一个一个按顺序运行程序（一般用<code>&amp;&amp;</code>或者<code>;</code>）；后者前一个程序的输出结果会直接传到下一个命令程序的输入中（这不就是流程化操作么，用<code>|</code>分隔）。</p>\n<p>子shell可以让我们在一个独立的shell进程中执行连续命令。</p>\n<p>首先看个例子</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ echo \"this command\"; echo \"that command\" | sed 's/command/step/'</span><br><span class=\"line\">this command</span><br><span class=\"line\">that step</span><br><span class=\"line\">wangsx@SC-201708020022:~/database$ (echo \"this command\"; echo \"that command\") | sed 's/command/step/'</span><br><span class=\"line\">this step</span><br><span class=\"line\">that step</span><br></pre></td></tr></table></figure>\n<p>发现仅仅加了个括号，结果就不同了。第二个命令就用了子shell，它把两个<code>echo</code>命令放进单独的空间执行后将结果传给下游。</p>\n<p>子shell在对<code>gtf</code>文件进行操作时有个非常有意思有用的用处。我们如果想对<code>gtf</code>文件排序，但是又想要保留文件头部注释信息，我们就能够用两次<code>grep</code>操作分别抓出注释和非注释信息，然后又把它结合在一起。下面看看效果，用<code>less</code>进行检查：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/database$ (zgrep \"^#\" gencode.v27lift37.annotation.gtf.gz; \\</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">  zgrep -v <span class=\"string\">\"^#\"</span> gencode.v27lift37.annotation.gtf.gz | \\</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">  sort -k1,1 -k4,4n) | less</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，子shell确实能够给我们提供非常有用的操作去组合命令实现想要的功能。</p>\n<h3 id=\"命令管道及进程替换\"><a href=\"#命令管道及进程替换\" class=\"headerlink\" title=\"命令管道及进程替换\"></a>命令管道及进程替换</h3><p>很多生信命令行工具需要提供多个输入和输出参数，这用在管道命令里可能会导致非常低效的情形（管道只接受一个标准输入和输出）。幸好，我们可以使用命令管道来解决此类问题。</p>\n<p><strong>命名管道</strong>，也成为FIFO（先入先出，额，这不是队列么:smile:）。它是一个特殊的排序文件，命名管道有点像文件，它可以永久保留在你的文件系统上（估计本质就是文件吧~）。</p>\n<p>我们用<code>mkfifo</code>来生成它</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ls -l fqin</span><br><span class=\"line\">prw-rw-rw- 1 wangsx wangsx 0 9月   3 20:45 fqin</span><br></pre></td></tr></table></figure>\n<p>可以它看它权限的第一个字符是p，指代是pipe。说明是个特殊文件。</p>\n<p>我们像文件一样对它进行一些操作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat fqin</span><br><span class=\"line\">hello, named pipes</span><br><span class=\"line\">[1]+  已完成               echo \"hello, named pipes\" &gt; fqin</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ rm fqin</span><br></pre></td></tr></table></figure>\n<p>比如当使用一个生信命令行工具</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">processing<span class=\"number\">_</span>tool --<span class=\"keyword\">in</span><span class=\"number\">1</span> <span class=\"keyword\">in</span><span class=\"number\">1</span>.fq --<span class=\"keyword\">in</span><span class=\"number\">2</span> <span class=\"keyword\">in</span><span class=\"number\">2</span>.fq --<span class=\"keyword\">out</span><span class=\"number\">1</span> <span class=\"keyword\">out</span><span class=\"number\">1</span>.fq --<span class=\"keyword\">out</span><span class=\"number\">2</span> <span class=\"keyword\">out</span><span class=\"number\">2</span>.fq</span><br></pre></td></tr></table></figure>\n<p><code>in1.fq in2.fq</code>就可以上游输出数据到<code>processing_tool</code>的命名管道；同理<code>out1.fq out2.fq</code>可以是命名管道用来写进输出数据。</p>\n<p>但这样我们每次都得不停地创建和删除这些文件，解决办法是使用匿名管道，也叫进程替换。</p>\n<p>不能光说，看看例子就知道和理解了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat &lt;(echo \"hello, process substitution\")</span><br><span class=\"line\">hello, process substitution</span><br></pre></td></tr></table></figure>\n<p><code>echo</code>命令运行后使用了进程替换，产生匿名文件，然后匿名文件被重导向<code>cat</code>命令。</p>\n<p>把它用到工具上，就变成了(假定上游zcat下游执行grep命令)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">processing_tool --in1 &lt; (zcat file1) --in2 &lt; (zcat file2) --out1 (gzip &gt; outfile1) --out2 (gzip &gt; outfile2)</span><br></pre></td></tr></table></figure>"},{"title":"R中的属性与类","author":"王诗翔","date":"2017-09-14T16:00:00.000Z","_content":"\n## 属性\n\n属性描述了对象所代表的内容以及R解释该对象的方式。**很多时候两个对象之间的唯一差别就在于它们的属性不同**。下表展示了一些重要的属性。很多常见的属性都是针对常见的数值型数据对象而言的：像数组、矩阵和数据框。\n\n<!-- more -->\n\n| 属性        | 描述                                       |\n| --------- | ---------------------------------------- |\n| class     | 对象的类                                     |\n| comment   | 对象的注解；一般用于描述对象的含义                        |\n| dim       | 对象的维度                                    |\n| dimnames  | 与对象的每个维度相关的名字                            |\n| names     | 返回对象的名字属性。返回结果取决于对象的类型，对于数据框对象会返回数据框的列名，对于数组会返回数组中被命名元素的名字 |\n| row.names | 对象的行名                                    |\n| tsp       | 对象的起始点。对时间序列对象很有用                        |\n| levels    | 因子型变量的水平                                 |\n\n**标准使用方法**：对于对象x和属性a,一般用a(x)来查询x的a属性。\n\n这个操作也可以改变对象的属性。\n\n我们可以通过`attributes`函数获得一个包含对象所有属性的列表。\n\n```\n> m <- matrix(data=1:12, nrow=4, ncol=3,\n+              dimnames=list(c(\"r1\",\"r2\",\"r3\",\"r4\"),c(\"c1\",\"c2\",\"c3\")))\n> m\n   c1 c2 c3\nr1  1  5  9\nr2  2  6 10\nr3  3  7 11\nr4  4  8 12\n> attributes(m)\n$dim\n[1] 4 3\n\n$dimnames\n$dimnames[[1]]\n[1] \"r1\" \"r2\" \"r3\" \"r4\"\n\n$dimnames[[2]]\n[1] \"c1\" \"c2\" \"c3\"\n\n\n```\n\n用`dim`和`dimnames`函数可以直接获取对应属性的信息。\n\n```\n> dim(m)\n[1] 4 3\n> dimnames(m)\n[[1]]\n[1] \"r1\" \"r2\" \"r3\" \"r4\"\n\n[[2]]\n[1] \"c1\" \"c2\" \"c3\"\n\n\n```\n\n存在简便的函数获取行名和列名：\n\n```\n> colnames(m)\n[1] \"c1\" \"c2\" \"c3\"\n> rownames(m)\n[1] \"r1\" \"r2\" \"r3\" \"r4\"\n\n\n```\n\n有意思的是，我们可以通过简单地改变属性将矩阵转化为其他类的对象。例如我们通过移除对象的维度属性，达到改变类型和类的目的。\n\n```\n> dim(m) <- NULL\n> m\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n> class(m)\n[1] \"integer\"\n> typeof(m)\n[1] \"integer\"\n\n```\n\n下面我们来比较一下普通一维数组和二维数组的异同。\n\n先创建一个数组a：\n\n```\n> a <- array(1:12, dim=c(3,4))\n> a\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n\n```\n\n然后，定义一个包含相同对象的向量：\n\n```\n> b <- 1:12\n> b\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\n\n```\n\n我们可以用方括号来操作a中的元素，但对b不能用同样的方式（因为对象b没有任何维度）。\n\n```\n> a[2,2]\n[1] 5\n> b[2,2]\nError in b[2, 2] : 量度数目不对\n\n\n```\n\n咦，这连个对象在R里面是不是相同的啊？下面用`==`看下：\n\n```\n> a == b\n     [,1] [,2] [,3] [,4]\n[1,] TRUE TRUE TRUE TRUE\n[2,] TRUE TRUE TRUE TRUE\n[3,] TRUE TRUE TRUE TRUE\n\n\n```\n\n结果表明对象的所有元素都是相同的。但这不意味着这两者完全一样的，我们自己也能很明显感觉它们的差异。\n\nR中有一个`all.equal`函数可以用来比较两个对象的数据和维度以甄别两个对象是否近乎相同，若不同则会返回其原因。\n\n```\n> all.equal(a,b)\n[1] \"Attributes: < Modes: list, NULL >\"\n[2] \"Attributes: < Lengths: 1, 0 >\"\n[3] \"Attributes: < names for target but not for current >\"\n[4] \"Attributes: < current is not list-like >\"\n[5] \"target is matrix, current is numeric\"\n\n```\n\n如果我们只care两个对象是不是完全一致，而不关心不一致的原因，可以使用`identical`函数。\n\n```\n> identical(a, b)\n[1] FALSE\n\n```\n\n通过赋予对象b一个维度属性，可以将b转化为一个与a相同的数组。\n\n```\n> dim(b) <- c(3, 4)\n> b[2,2]\n[1] 5\n> all.equal(a,b)\n[1] TRUE\n> identical(a,b)\n[1] TRUE\n\n```\n\n## 类\n\n对象的类是对象的属性之一。对于简单的对象而言，其类和类型是有紧密联系的。然而，对于复合型对象，两者则可能不同（最常见的是数据框，你创建一个然后用`class`与`typeof`函数看看就知道了）。\n\n下面是一个简单数值型向量的类型和类：\n\n```\n> x <- c(1,2,3)\n> typeof(x)\n[1] \"double\"\n> class(x)\n[1] \"numeric\"\n\n```\n\n与改变其他属性的操作一样，我们可以改变R对象所属的类。**例如，在计算机内部，因子是通过整型数据以及整型数据到因子水平的映射来实现的**（整型数据占的存储空间较少且固定，因此比字符向量更高效）。\n\n在调用`class`函数或者`typeof`函数时，对于有些对象，我们需要对其进行引用以防止其在调用时被执行。比如，我们想查询符号x而不是x所指向的对象的类型时，用如下操作：\n\n```\n> x = 1\n> class(quote(x))\n[1] \"name\"\n> typeof(quote(x))\n[1] \"symbol\"\n\n# 观察区别\n> class(x)\n[1] \"numeric\"\n> typeof(x)\n[1] \"double\"\n\n```\n\n------\n\n学习整理自《R核心技术手册》\n","source":"_posts/2017-09-15-Class-in-R.md","raw":"---\ntitle: \"R中的属性与类\"\nauthor: 王诗翔\ndate: 2017-09-15\ncategories:\n- 极客R\n- 基本理论\ntags:\n- R\n- 类\n---\n\n## 属性\n\n属性描述了对象所代表的内容以及R解释该对象的方式。**很多时候两个对象之间的唯一差别就在于它们的属性不同**。下表展示了一些重要的属性。很多常见的属性都是针对常见的数值型数据对象而言的：像数组、矩阵和数据框。\n\n<!-- more -->\n\n| 属性        | 描述                                       |\n| --------- | ---------------------------------------- |\n| class     | 对象的类                                     |\n| comment   | 对象的注解；一般用于描述对象的含义                        |\n| dim       | 对象的维度                                    |\n| dimnames  | 与对象的每个维度相关的名字                            |\n| names     | 返回对象的名字属性。返回结果取决于对象的类型，对于数据框对象会返回数据框的列名，对于数组会返回数组中被命名元素的名字 |\n| row.names | 对象的行名                                    |\n| tsp       | 对象的起始点。对时间序列对象很有用                        |\n| levels    | 因子型变量的水平                                 |\n\n**标准使用方法**：对于对象x和属性a,一般用a(x)来查询x的a属性。\n\n这个操作也可以改变对象的属性。\n\n我们可以通过`attributes`函数获得一个包含对象所有属性的列表。\n\n```\n> m <- matrix(data=1:12, nrow=4, ncol=3,\n+              dimnames=list(c(\"r1\",\"r2\",\"r3\",\"r4\"),c(\"c1\",\"c2\",\"c3\")))\n> m\n   c1 c2 c3\nr1  1  5  9\nr2  2  6 10\nr3  3  7 11\nr4  4  8 12\n> attributes(m)\n$dim\n[1] 4 3\n\n$dimnames\n$dimnames[[1]]\n[1] \"r1\" \"r2\" \"r3\" \"r4\"\n\n$dimnames[[2]]\n[1] \"c1\" \"c2\" \"c3\"\n\n\n```\n\n用`dim`和`dimnames`函数可以直接获取对应属性的信息。\n\n```\n> dim(m)\n[1] 4 3\n> dimnames(m)\n[[1]]\n[1] \"r1\" \"r2\" \"r3\" \"r4\"\n\n[[2]]\n[1] \"c1\" \"c2\" \"c3\"\n\n\n```\n\n存在简便的函数获取行名和列名：\n\n```\n> colnames(m)\n[1] \"c1\" \"c2\" \"c3\"\n> rownames(m)\n[1] \"r1\" \"r2\" \"r3\" \"r4\"\n\n\n```\n\n有意思的是，我们可以通过简单地改变属性将矩阵转化为其他类的对象。例如我们通过移除对象的维度属性，达到改变类型和类的目的。\n\n```\n> dim(m) <- NULL\n> m\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n> class(m)\n[1] \"integer\"\n> typeof(m)\n[1] \"integer\"\n\n```\n\n下面我们来比较一下普通一维数组和二维数组的异同。\n\n先创建一个数组a：\n\n```\n> a <- array(1:12, dim=c(3,4))\n> a\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n\n```\n\n然后，定义一个包含相同对象的向量：\n\n```\n> b <- 1:12\n> b\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\n\n```\n\n我们可以用方括号来操作a中的元素，但对b不能用同样的方式（因为对象b没有任何维度）。\n\n```\n> a[2,2]\n[1] 5\n> b[2,2]\nError in b[2, 2] : 量度数目不对\n\n\n```\n\n咦，这连个对象在R里面是不是相同的啊？下面用`==`看下：\n\n```\n> a == b\n     [,1] [,2] [,3] [,4]\n[1,] TRUE TRUE TRUE TRUE\n[2,] TRUE TRUE TRUE TRUE\n[3,] TRUE TRUE TRUE TRUE\n\n\n```\n\n结果表明对象的所有元素都是相同的。但这不意味着这两者完全一样的，我们自己也能很明显感觉它们的差异。\n\nR中有一个`all.equal`函数可以用来比较两个对象的数据和维度以甄别两个对象是否近乎相同，若不同则会返回其原因。\n\n```\n> all.equal(a,b)\n[1] \"Attributes: < Modes: list, NULL >\"\n[2] \"Attributes: < Lengths: 1, 0 >\"\n[3] \"Attributes: < names for target but not for current >\"\n[4] \"Attributes: < current is not list-like >\"\n[5] \"target is matrix, current is numeric\"\n\n```\n\n如果我们只care两个对象是不是完全一致，而不关心不一致的原因，可以使用`identical`函数。\n\n```\n> identical(a, b)\n[1] FALSE\n\n```\n\n通过赋予对象b一个维度属性，可以将b转化为一个与a相同的数组。\n\n```\n> dim(b) <- c(3, 4)\n> b[2,2]\n[1] 5\n> all.equal(a,b)\n[1] TRUE\n> identical(a,b)\n[1] TRUE\n\n```\n\n## 类\n\n对象的类是对象的属性之一。对于简单的对象而言，其类和类型是有紧密联系的。然而，对于复合型对象，两者则可能不同（最常见的是数据框，你创建一个然后用`class`与`typeof`函数看看就知道了）。\n\n下面是一个简单数值型向量的类型和类：\n\n```\n> x <- c(1,2,3)\n> typeof(x)\n[1] \"double\"\n> class(x)\n[1] \"numeric\"\n\n```\n\n与改变其他属性的操作一样，我们可以改变R对象所属的类。**例如，在计算机内部，因子是通过整型数据以及整型数据到因子水平的映射来实现的**（整型数据占的存储空间较少且固定，因此比字符向量更高效）。\n\n在调用`class`函数或者`typeof`函数时，对于有些对象，我们需要对其进行引用以防止其在调用时被执行。比如，我们想查询符号x而不是x所指向的对象的类型时，用如下操作：\n\n```\n> x = 1\n> class(quote(x))\n[1] \"name\"\n> typeof(quote(x))\n[1] \"symbol\"\n\n# 观察区别\n> class(x)\n[1] \"numeric\"\n> typeof(x)\n[1] \"double\"\n\n```\n\n------\n\n学习整理自《R核心技术手册》\n","slug":"Class-in-R","published":1,"updated":"2018-01-27T04:08:33.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwuf000b9taxwb5w0q4z","content":"<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>属性描述了对象所代表的内容以及R解释该对象的方式。<strong>很多时候两个对象之间的唯一差别就在于它们的属性不同</strong>。下表展示了一些重要的属性。很多常见的属性都是针对常见的数值型数据对象而言的：像数组、矩阵和数据框。</p>\n<a id=\"more\"></a>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>class</td>\n<td>对象的类</td>\n</tr>\n<tr>\n<td>comment</td>\n<td>对象的注解；一般用于描述对象的含义</td>\n</tr>\n<tr>\n<td>dim</td>\n<td>对象的维度</td>\n</tr>\n<tr>\n<td>dimnames</td>\n<td>与对象的每个维度相关的名字</td>\n</tr>\n<tr>\n<td>names</td>\n<td>返回对象的名字属性。返回结果取决于对象的类型，对于数据框对象会返回数据框的列名，对于数组会返回数组中被命名元素的名字</td>\n</tr>\n<tr>\n<td>row.names</td>\n<td>对象的行名</td>\n</tr>\n<tr>\n<td>tsp</td>\n<td>对象的起始点。对时间序列对象很有用</td>\n</tr>\n<tr>\n<td>levels</td>\n<td>因子型变量的水平</td>\n</tr>\n</tbody>\n</table>\n<p><strong>标准使用方法</strong>：对于对象x和属性a,一般用a(x)来查询x的a属性。</p>\n<p>这个操作也可以改变对象的属性。</p>\n<p>我们可以通过<code>attributes</code>函数获得一个包含对象所有属性的列表。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; m &lt;- matrix(data=<span class=\"number\">1</span>:<span class=\"number\">12</span>, nrow=<span class=\"number\">4</span>, ncol=<span class=\"number\">3</span>,</span><br><span class=\"line\">+              dimnames=list(c(<span class=\"string\">\"r1\"</span>,<span class=\"string\">\"r2\"</span>,<span class=\"string\">\"r3\"</span>,<span class=\"string\">\"r4\"</span>),c(<span class=\"string\">\"c1\"</span>,<span class=\"string\">\"c2\"</span>,<span class=\"string\">\"c3\"</span>)))</span><br><span class=\"line\">&gt; m</span><br><span class=\"line\">   c1 c2 c3</span><br><span class=\"line\">r1  <span class=\"number\">1</span>  <span class=\"number\">5</span>  <span class=\"number\">9</span></span><br><span class=\"line\">r2  <span class=\"number\">2</span>  <span class=\"number\">6</span> <span class=\"number\">10</span></span><br><span class=\"line\">r3  <span class=\"number\">3</span>  <span class=\"number\">7</span> <span class=\"number\">11</span></span><br><span class=\"line\">r4  <span class=\"number\">4</span>  <span class=\"number\">8</span> <span class=\"number\">12</span></span><br><span class=\"line\">&gt; attributes(m)</span><br><span class=\"line\">$dim</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">4</span> <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">$dimnames</span><br><span class=\"line\">$dimnames<span class=\"string\">[[1]]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"r1\"</span> <span class=\"string\">\"r2\"</span> <span class=\"string\">\"r3\"</span> <span class=\"string\">\"r4\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">$dimnames<span class=\"string\">[[2]]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"c1\"</span> <span class=\"string\">\"c2\"</span> <span class=\"string\">\"c3\"</span></span><br></pre></td></tr></table></figure>\n<p>用<code>dim</code>和<code>dimnames</code>函数可以直接获取对应属性的信息。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dim(m)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">4</span> <span class=\"number\">3</span></span><br><span class=\"line\">&gt; dimnames(m)</span><br><span class=\"line\"><span class=\"string\">[[1]]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"r1\"</span> <span class=\"string\">\"r2\"</span> <span class=\"string\">\"r3\"</span> <span class=\"string\">\"r4\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">[[2]]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"c1\"</span> <span class=\"string\">\"c2\"</span> <span class=\"string\">\"c3\"</span></span><br></pre></td></tr></table></figure>\n<p>存在简便的函数获取行名和列名：</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; colnames(m)</span><br><span class=\"line\"><span class=\"string\">[1]</span> <span class=\"string\">\"c1\"</span> <span class=\"string\">\"c2\"</span> <span class=\"string\">\"c3\"</span></span><br><span class=\"line\">&gt; rownames(m)</span><br><span class=\"line\"><span class=\"string\">[1]</span> <span class=\"string\">\"r1\"</span> <span class=\"string\">\"r2\"</span> <span class=\"string\">\"r3\"</span> <span class=\"string\">\"r4\"</span></span><br></pre></td></tr></table></figure>\n<p>有意思的是，我们可以通过简单地改变属性将矩阵转化为其他类的对象。例如我们通过移除对象的维度属性，达到改变类型和类的目的。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dim(m) &lt;- NULL</span><br><span class=\"line\">&gt; m</span><br><span class=\"line\"> [<span class=\"number\">1</span>]  <span class=\"number\">1</span>  <span class=\"number\">2</span>  <span class=\"number\">3</span>  <span class=\"number\">4</span>  <span class=\"number\">5</span>  <span class=\"number\">6</span>  <span class=\"number\">7</span>  <span class=\"number\">8</span>  <span class=\"number\">9</span> <span class=\"number\">10</span> <span class=\"number\">11</span> <span class=\"number\">12</span></span><br><span class=\"line\">&gt; class(m)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"integer\"</span></span><br><span class=\"line\">&gt; typeof(m)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"integer\"</span></span><br></pre></td></tr></table></figure>\n<p>下面我们来比较一下普通一维数组和二维数组的异同。</p>\n<p>先创建一个数组a：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; a &lt;- array(1:12, dim=c(3,4))</span><br><span class=\"line\">&gt; a</span><br><span class=\"line\">     [,1] [,2] [,3] [,4]</span><br><span class=\"line\">[1,]   <span class=\"number\"> 1 </span>  <span class=\"number\"> 4 </span>  <span class=\"number\"> 7 </span>  10</span><br><span class=\"line\">[2,]   <span class=\"number\"> 2 </span>  <span class=\"number\"> 5 </span>  <span class=\"number\"> 8 </span>  11</span><br><span class=\"line\">[3,]   <span class=\"number\"> 3 </span>  <span class=\"number\"> 6 </span>  <span class=\"number\"> 9 </span>  12</span><br></pre></td></tr></table></figure>\n<p>然后，定义一个包含相同对象的向量：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; b &lt;- 1:12</span><br><span class=\"line\">&gt; b</span><br><span class=\"line\"> [1] <span class=\"number\"> 1 </span><span class=\"number\"> 2 </span><span class=\"number\"> 3 </span><span class=\"number\"> 4 </span><span class=\"number\"> 5 </span><span class=\"number\"> 6 </span><span class=\"number\"> 7 </span><span class=\"number\"> 8 </span><span class=\"number\"> 9 </span>10<span class=\"number\"> 11 </span>12</span><br></pre></td></tr></table></figure>\n<p>我们可以用方括号来操作a中的元素，但对b不能用同样的方式（因为对象b没有任何维度）。</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; a[2,2]</span><br><span class=\"line\">[1] 5</span><br><span class=\"line\">&gt; b[2,2]</span><br><span class=\"line\"><span class=\"keyword\">Error </span>in b[2, 2] : 量度数目不对</span><br></pre></td></tr></table></figure>\n<p>咦，这连个对象在R里面是不是相同的啊？下面用<code>==</code>看下：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; a == b</span><br><span class=\"line\">     [,<span class=\"number\">1</span>] [,<span class=\"number\">2</span>] [,<span class=\"number\">3</span>] [,<span class=\"number\">4</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>,] <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span></span><br><span class=\"line\">[<span class=\"number\">2</span>,] <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span></span><br><span class=\"line\">[<span class=\"number\">3</span>,] <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span></span><br></pre></td></tr></table></figure>\n<p>结果表明对象的所有元素都是相同的。但这不意味着这两者完全一样的，我们自己也能很明显感觉它们的差异。</p>\n<p>R中有一个<code>all.equal</code>函数可以用来比较两个对象的数据和维度以甄别两个对象是否近乎相同，若不同则会返回其原因。</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; all.equal(a,b)</span><br><span class=\"line\"><span class=\"string\">[1]</span> <span class=\"string\">\"Attributes: &lt; Modes: list, NULL &gt;\"</span></span><br><span class=\"line\"><span class=\"string\">[2]</span> <span class=\"string\">\"Attributes: &lt; Lengths: 1, 0 &gt;\"</span></span><br><span class=\"line\"><span class=\"string\">[3]</span> <span class=\"string\">\"Attributes: &lt; names for target but not for current &gt;\"</span></span><br><span class=\"line\"><span class=\"string\">[4]</span> <span class=\"string\">\"Attributes: &lt; current is not list-like &gt;\"</span></span><br><span class=\"line\"><span class=\"string\">[5]</span> <span class=\"string\">\"target is matrix, current is numeric\"</span></span><br></pre></td></tr></table></figure>\n<p>如果我们只care两个对象是不是完全一致，而不关心不一致的原因，可以使用<code>identical</code>函数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> identical(a, b)</span></span><br><span class=\"line\">[1] FALSE</span><br></pre></td></tr></table></figure>\n<p>通过赋予对象b一个维度属性，可以将b转化为一个与a相同的数组。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dim(b) &lt;- c(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&gt; b[<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">5</span></span><br><span class=\"line\">&gt; all.equal(a,b)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"literal\">TRUE</span></span><br><span class=\"line\">&gt; identical(a,b)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"literal\">TRUE</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>对象的类是对象的属性之一。对于简单的对象而言，其类和类型是有紧密联系的。然而，对于复合型对象，两者则可能不同（最常见的是数据框，你创建一个然后用<code>class</code>与<code>typeof</code>函数看看就知道了）。</p>\n<p>下面是一个简单数值型向量的类型和类：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; x &lt;- c(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">&gt; typeof(x)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"double\"</span></span><br><span class=\"line\">&gt; class(x)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"numeric\"</span></span><br></pre></td></tr></table></figure>\n<p>与改变其他属性的操作一样，我们可以改变R对象所属的类。<strong>例如，在计算机内部，因子是通过整型数据以及整型数据到因子水平的映射来实现的</strong>（整型数据占的存储空间较少且固定，因此比字符向量更高效）。</p>\n<p>在调用<code>class</code>函数或者<code>typeof</code>函数时，对于有些对象，我们需要对其进行引用以防止其在调用时被执行。比如，我们想查询符号x而不是x所指向的对象的类型时，用如下操作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> x = 1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> class(quote(x))</span></span><br><span class=\"line\">[1] \"name\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> typeof(quote(x))</span></span><br><span class=\"line\">[1] \"symbol\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 观察区别</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> class(x)</span></span><br><span class=\"line\">[1] \"numeric\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> typeof(x)</span></span><br><span class=\"line\">[1] \"double\"</span><br></pre></td></tr></table></figure>\n<hr>\n<p>学习整理自《R核心技术手册》</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>属性描述了对象所代表的内容以及R解释该对象的方式。<strong>很多时候两个对象之间的唯一差别就在于它们的属性不同</strong>。下表展示了一些重要的属性。很多常见的属性都是针对常见的数值型数据对象而言的：像数组、矩阵和数据框。</p>","more":"<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>class</td>\n<td>对象的类</td>\n</tr>\n<tr>\n<td>comment</td>\n<td>对象的注解；一般用于描述对象的含义</td>\n</tr>\n<tr>\n<td>dim</td>\n<td>对象的维度</td>\n</tr>\n<tr>\n<td>dimnames</td>\n<td>与对象的每个维度相关的名字</td>\n</tr>\n<tr>\n<td>names</td>\n<td>返回对象的名字属性。返回结果取决于对象的类型，对于数据框对象会返回数据框的列名，对于数组会返回数组中被命名元素的名字</td>\n</tr>\n<tr>\n<td>row.names</td>\n<td>对象的行名</td>\n</tr>\n<tr>\n<td>tsp</td>\n<td>对象的起始点。对时间序列对象很有用</td>\n</tr>\n<tr>\n<td>levels</td>\n<td>因子型变量的水平</td>\n</tr>\n</tbody>\n</table>\n<p><strong>标准使用方法</strong>：对于对象x和属性a,一般用a(x)来查询x的a属性。</p>\n<p>这个操作也可以改变对象的属性。</p>\n<p>我们可以通过<code>attributes</code>函数获得一个包含对象所有属性的列表。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; m &lt;- matrix(data=<span class=\"number\">1</span>:<span class=\"number\">12</span>, nrow=<span class=\"number\">4</span>, ncol=<span class=\"number\">3</span>,</span><br><span class=\"line\">+              dimnames=list(c(<span class=\"string\">\"r1\"</span>,<span class=\"string\">\"r2\"</span>,<span class=\"string\">\"r3\"</span>,<span class=\"string\">\"r4\"</span>),c(<span class=\"string\">\"c1\"</span>,<span class=\"string\">\"c2\"</span>,<span class=\"string\">\"c3\"</span>)))</span><br><span class=\"line\">&gt; m</span><br><span class=\"line\">   c1 c2 c3</span><br><span class=\"line\">r1  <span class=\"number\">1</span>  <span class=\"number\">5</span>  <span class=\"number\">9</span></span><br><span class=\"line\">r2  <span class=\"number\">2</span>  <span class=\"number\">6</span> <span class=\"number\">10</span></span><br><span class=\"line\">r3  <span class=\"number\">3</span>  <span class=\"number\">7</span> <span class=\"number\">11</span></span><br><span class=\"line\">r4  <span class=\"number\">4</span>  <span class=\"number\">8</span> <span class=\"number\">12</span></span><br><span class=\"line\">&gt; attributes(m)</span><br><span class=\"line\">$dim</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">4</span> <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">$dimnames</span><br><span class=\"line\">$dimnames<span class=\"string\">[[1]]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"r1\"</span> <span class=\"string\">\"r2\"</span> <span class=\"string\">\"r3\"</span> <span class=\"string\">\"r4\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">$dimnames<span class=\"string\">[[2]]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"c1\"</span> <span class=\"string\">\"c2\"</span> <span class=\"string\">\"c3\"</span></span><br></pre></td></tr></table></figure>\n<p>用<code>dim</code>和<code>dimnames</code>函数可以直接获取对应属性的信息。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dim(m)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">4</span> <span class=\"number\">3</span></span><br><span class=\"line\">&gt; dimnames(m)</span><br><span class=\"line\"><span class=\"string\">[[1]]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"r1\"</span> <span class=\"string\">\"r2\"</span> <span class=\"string\">\"r3\"</span> <span class=\"string\">\"r4\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">[[2]]</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"c1\"</span> <span class=\"string\">\"c2\"</span> <span class=\"string\">\"c3\"</span></span><br></pre></td></tr></table></figure>\n<p>存在简便的函数获取行名和列名：</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; colnames(m)</span><br><span class=\"line\"><span class=\"string\">[1]</span> <span class=\"string\">\"c1\"</span> <span class=\"string\">\"c2\"</span> <span class=\"string\">\"c3\"</span></span><br><span class=\"line\">&gt; rownames(m)</span><br><span class=\"line\"><span class=\"string\">[1]</span> <span class=\"string\">\"r1\"</span> <span class=\"string\">\"r2\"</span> <span class=\"string\">\"r3\"</span> <span class=\"string\">\"r4\"</span></span><br></pre></td></tr></table></figure>\n<p>有意思的是，我们可以通过简单地改变属性将矩阵转化为其他类的对象。例如我们通过移除对象的维度属性，达到改变类型和类的目的。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dim(m) &lt;- NULL</span><br><span class=\"line\">&gt; m</span><br><span class=\"line\"> [<span class=\"number\">1</span>]  <span class=\"number\">1</span>  <span class=\"number\">2</span>  <span class=\"number\">3</span>  <span class=\"number\">4</span>  <span class=\"number\">5</span>  <span class=\"number\">6</span>  <span class=\"number\">7</span>  <span class=\"number\">8</span>  <span class=\"number\">9</span> <span class=\"number\">10</span> <span class=\"number\">11</span> <span class=\"number\">12</span></span><br><span class=\"line\">&gt; class(m)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"integer\"</span></span><br><span class=\"line\">&gt; typeof(m)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"integer\"</span></span><br></pre></td></tr></table></figure>\n<p>下面我们来比较一下普通一维数组和二维数组的异同。</p>\n<p>先创建一个数组a：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; a &lt;- array(1:12, dim=c(3,4))</span><br><span class=\"line\">&gt; a</span><br><span class=\"line\">     [,1] [,2] [,3] [,4]</span><br><span class=\"line\">[1,]   <span class=\"number\"> 1 </span>  <span class=\"number\"> 4 </span>  <span class=\"number\"> 7 </span>  10</span><br><span class=\"line\">[2,]   <span class=\"number\"> 2 </span>  <span class=\"number\"> 5 </span>  <span class=\"number\"> 8 </span>  11</span><br><span class=\"line\">[3,]   <span class=\"number\"> 3 </span>  <span class=\"number\"> 6 </span>  <span class=\"number\"> 9 </span>  12</span><br></pre></td></tr></table></figure>\n<p>然后，定义一个包含相同对象的向量：</p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; b &lt;- 1:12</span><br><span class=\"line\">&gt; b</span><br><span class=\"line\"> [1] <span class=\"number\"> 1 </span><span class=\"number\"> 2 </span><span class=\"number\"> 3 </span><span class=\"number\"> 4 </span><span class=\"number\"> 5 </span><span class=\"number\"> 6 </span><span class=\"number\"> 7 </span><span class=\"number\"> 8 </span><span class=\"number\"> 9 </span>10<span class=\"number\"> 11 </span>12</span><br></pre></td></tr></table></figure>\n<p>我们可以用方括号来操作a中的元素，但对b不能用同样的方式（因为对象b没有任何维度）。</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; a[2,2]</span><br><span class=\"line\">[1] 5</span><br><span class=\"line\">&gt; b[2,2]</span><br><span class=\"line\"><span class=\"keyword\">Error </span>in b[2, 2] : 量度数目不对</span><br></pre></td></tr></table></figure>\n<p>咦，这连个对象在R里面是不是相同的啊？下面用<code>==</code>看下：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; a == b</span><br><span class=\"line\">     [,<span class=\"number\">1</span>] [,<span class=\"number\">2</span>] [,<span class=\"number\">3</span>] [,<span class=\"number\">4</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>,] <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span></span><br><span class=\"line\">[<span class=\"number\">2</span>,] <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span></span><br><span class=\"line\">[<span class=\"number\">3</span>,] <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span> <span class=\"literal\">TRUE</span></span><br></pre></td></tr></table></figure>\n<p>结果表明对象的所有元素都是相同的。但这不意味着这两者完全一样的，我们自己也能很明显感觉它们的差异。</p>\n<p>R中有一个<code>all.equal</code>函数可以用来比较两个对象的数据和维度以甄别两个对象是否近乎相同，若不同则会返回其原因。</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; all.equal(a,b)</span><br><span class=\"line\"><span class=\"string\">[1]</span> <span class=\"string\">\"Attributes: &lt; Modes: list, NULL &gt;\"</span></span><br><span class=\"line\"><span class=\"string\">[2]</span> <span class=\"string\">\"Attributes: &lt; Lengths: 1, 0 &gt;\"</span></span><br><span class=\"line\"><span class=\"string\">[3]</span> <span class=\"string\">\"Attributes: &lt; names for target but not for current &gt;\"</span></span><br><span class=\"line\"><span class=\"string\">[4]</span> <span class=\"string\">\"Attributes: &lt; current is not list-like &gt;\"</span></span><br><span class=\"line\"><span class=\"string\">[5]</span> <span class=\"string\">\"target is matrix, current is numeric\"</span></span><br></pre></td></tr></table></figure>\n<p>如果我们只care两个对象是不是完全一致，而不关心不一致的原因，可以使用<code>identical</code>函数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> identical(a, b)</span></span><br><span class=\"line\">[1] FALSE</span><br></pre></td></tr></table></figure>\n<p>通过赋予对象b一个维度属性，可以将b转化为一个与a相同的数组。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; dim(b) &lt;- c(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&gt; b[<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">5</span></span><br><span class=\"line\">&gt; all.equal(a,b)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"literal\">TRUE</span></span><br><span class=\"line\">&gt; identical(a,b)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"literal\">TRUE</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>对象的类是对象的属性之一。对于简单的对象而言，其类和类型是有紧密联系的。然而，对于复合型对象，两者则可能不同（最常见的是数据框，你创建一个然后用<code>class</code>与<code>typeof</code>函数看看就知道了）。</p>\n<p>下面是一个简单数值型向量的类型和类：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; x &lt;- c(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">&gt; typeof(x)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"double\"</span></span><br><span class=\"line\">&gt; class(x)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"numeric\"</span></span><br></pre></td></tr></table></figure>\n<p>与改变其他属性的操作一样，我们可以改变R对象所属的类。<strong>例如，在计算机内部，因子是通过整型数据以及整型数据到因子水平的映射来实现的</strong>（整型数据占的存储空间较少且固定，因此比字符向量更高效）。</p>\n<p>在调用<code>class</code>函数或者<code>typeof</code>函数时，对于有些对象，我们需要对其进行引用以防止其在调用时被执行。比如，我们想查询符号x而不是x所指向的对象的类型时，用如下操作：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> x = 1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> class(quote(x))</span></span><br><span class=\"line\">[1] \"name\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> typeof(quote(x))</span></span><br><span class=\"line\">[1] \"symbol\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 观察区别</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> class(x)</span></span><br><span class=\"line\">[1] \"numeric\"</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> typeof(x)</span></span><br><span class=\"line\">[1] \"double\"</span><br></pre></td></tr></table></figure>\n<hr>\n<p>学习整理自《R核心技术手册》</p>"},{"title":"使用shell创建文本菜单和窗口部件","author":"王诗翔","date":"2017-11-28T16:00:00.000Z","_content":"\n*来源： Linux命令行与shell脚本编程大全*\n\n内容：\n\n>- 创建文本菜单\n>- 创建文本窗口部件\n>- 添加X Window图形\n\n\n\n## 创建文本菜单\n\n创建交互式shell脚本最常用的方法是使用菜单，它提供了各种选项帮助脚本用户了解脚本能做到的和不能做的。\n\nshell脚本菜单的核心是`case`命令，该命令会根据用户在菜单上的选择来执行特定命令。\n\n下面我们逐步了解和创建基于菜单的shell脚本的步骤。\n\n<!-- more -->\n\n### 创建菜单布局\n\n**第一步**是决定在菜单上显示哪些元素以及想要显示的布局方式。\n\n**在创建菜单前，通常先清空显示器上已有的内容。这样能在干净的，没有干扰的环境中显示菜单了。**\n\n`clear`命令使用当前终端的`terminfo`数据来清理出现在屏幕上的文字。运行`clear`命令后可以使用`echo`命令显示菜单元素。\n\n**默认，echo命令只显示可打印的文本字符。**而在创建菜单时一些非文本字符也非常有用，比如制表符和换行符。我们需要添加`-e`选项使得`echo`命令能解析包含在其中的非文本字符。\n\n例如，\n\n```shell\nwsx@wsx:~/tmp$ echo -e \"1.\\tDisplay disk space\"\n1.\tDisplay disk space\n```\n\n这对于格式化菜单项布局非常方便，只需要几个`echo`命令就可以创建一个还不错的菜单。\n\n```shell\nclear\necho\necho -e \"\\t\\t\\tSys Admin Menu\\n\"\necho -e \"\\t1. Display disk space\"\necho -e \"\\t2. Display logged on users\"\necho -e \"\\t3. Display memory usage\"\necho -e \"\\t0. Exit menu\\n\\n\"\necho -en \"\\t\\tEnter an option: \"\n```\n\n最后一行`-en`选项去掉末尾换行符使得菜单更专业点，光标会在行尾等待用户输入。\n\n**创建菜单的最后一步是获取用户输入。**这一步用`read`命令。因为我们只期望用户使用单字符输入，在命令加`-n`选项进行限定。这样用户只需要输入一个数字，不用摁回车键。\n\n```shell\nread -n 1 option\n```\n\n\n\n### 创建菜单函数\n\nshell脚本菜单选项作为一组独立的函数实现起来更为容易。要做到这一点，你要为每个菜单项创建独立的shell函数。**第一步**是决定你希望脚本执行那些功能，然后将这些功能以函数的形式放在代码中。\n\n**通常我们会为还没有实现的函数先创建一个*桩函数*，它是一个控函数，或者只有一个echo语句，说明最终这里需要什么内容。**\n\n```shell\nfunction diskspace {\n  clear\n  echo \"This is where the diskspace commands will do\"\n}\n```\n\n这允许菜单在我实现某个函数时仍然能正常操作。不需要我们写出所有函数之后才能让菜单投入使用。函数从`clear`命令开始，这样我们就能在一个干净的屏幕上执行该函数，不会收到原先菜单的干扰。\n\n**另外，将菜单布局本身作为一个函数来创建有利于菜单制作。**\n\n```shell\nfunction menu {\n  \tclear\n\techo\n\techo -e \"\\t\\t\\tSys Admin Menu\\n\"\n\techo -e \"\\t1. Display disk space\"\n\techo -e \"\\t2. Display logged on users\"\n\techo -e \"\\t3. Display memory usage\"\n\techo -e \"\\t0. Exit menu\\n\\n\"\n\techo -en \"\\t\\tEnter an option: \"\n\tread -n 1 option\n}\n```\n\n这样我们能在任何时候调用该函数以此重现菜单。\n\n### 添加菜单逻辑\n\n下一步我们需要创建程序逻辑将菜单布局和函数结合起来。这需要使用`case`命令。\n\n`case`命令应该根据菜单中输入的字符来调用相应的函数，用case命令字符星号来处理所有不正确的菜单项。\n\n下面展示了典型菜单的`case`用法：\n\n```shell\nmenu\ncase $option in\n0)\n\tbreak ;;\n1)\n\tdiskspace ;;\n2)\n\twhoseon ;;\n3)\n\tmemusage ;;\n*)\n\tclear\n\techo \"Sorry, wrong selection\";;\nesac\n```\n\n这里首先调用`menu`函数清空屏幕并显示菜单。`menu`函数中的`read`命令会一直等待，知道用户在键盘上键入一个字符。然后`case`命令会接管余下的处理过程，基于字符调用相应的函数。\n\n### 整合shell脚本菜单\n\n现在让我们将前面的步骤全部组合起来，看看它们是如何协作的。\n\n这是一个完整的菜单脚本例子：\n\n```shell\nwsx@wsx:~/tmp$ cat test14\n#!/bin/bash\n# simple script menu\n\nfunction diskspace {\n\tclear\n\tdf -k\n}\n\nfunction whoseon {\n\tclear\n\twho\n}\n\nfunction memusage {\n\tclear\n\tcat /proc/meminfo\n}\n\nfunction menu {\n\tclear\n\techo\n\techo -e \"\\t\\t\\tSys Admin Menu\\n\"\n\techo -e \"\\t1. Display disk space\"\n\techo -e \"\\t2. Display logged on users\"\n\techo -e \"\\t3. Display memory usage\"\n\techo -e \"\\t0. Exit menu\\n\\n\"\n\techo -en \"\\t\\tEnter an option: \"\n\tread -n 1 option\n}\n\nwhile [ 1 ]\ndo\n\tmenu\n\tcase $option in\n\t0)\n\t\tbreak ;;\n\t1)\n\t\tdiskspace ;;\n\t2)\n\t\twhoseon ;;\n\t3)\n\t\tmemusage ;;\n\t*)\n\t\tclear\n\t\techo \"Sorry, wrong selection\" ;;\n\tesac\n\techo -en \"\\n\\n\\t\\t\\tHit any key to continue\"\n\tread -n 1 line\ndone\nclear\n\n```\n\n使用：\n\n```shell\n\t\t\tSys Admin Menu\n\n\t1. Display disk space\n\t2. Display logged on users\n\t3. Display memory usage\n\t0. Exit menu\n\n\n\t\tEnter an option:\n```\n\n输入1：\n\n```shell\n文件系统           1K-块     已用      可用 已用% 挂载点\nudev             4006080        0   4006080    0% /dev\ntmpfs             807220    81004    726216   11% /run\n/dev/sda4      305650672 14226064 275828680    5% /\ntmpfs            4036100     1724   4034376    1% /dev/shm\ntmpfs               5120        4      5116    1% /run/lock\ntmpfs            4036100        0   4036100    0% /sys/fs/cgroup\n/dev/sda3         524272     4684    519588    1% /boot/efi\ntmpfs             807220       52    807168    1% /run/user/1000\ntmpfs             807220       16    807204    1% /run/user/125\n/dev/sda2      421886972 23340376 398546596    6% /media/wsx/存储\n\n\n\t\t\tHit any key to continue\n```\n\n其他都可以自己测试一下，我就不赘言了。\n\n\n\n### 使用select命令\n\n`select`命令只需要一条命令就可以创建出菜单，然后获取输入的答案并自动处理。\n\n命令格式如下：\n\n```shell\nselect variable in list\ndo\n\tcommands\ndone\n```\n\n**`list`参数是由空格分隔的文本选项列表，这些列表构成了整个菜单。**`select`命令会将每个列表项显示成一个带编号的选项，然后为选项显示一个由`PS3`环境变量定义的特殊提示符。\n\n```shell\nwsx@wsx:~/tmp$ cat smenu1\n#!/bin/bash\n# using select in the menu\n\nfunction diskspace {\n\tclear\n\tdf -k\n}\n\nfunction whoseon {\n\tclear\n\twho\n}\n\nfunction memusage {\n\tclear\n\tcat /proc/meminfo\n}\n\nPS3=\"Enter an option: \"\nselect option in \"Display disk space\" \"Display logged on users\" \"Display memory usage\" \"Exit program\"\ndo\n\tcase $option in\n\t\"Exit program\")\n\t\tbreak ;;\n\t\"Display disk space\")\n\t\tdiskspace ;;\n\t\"Display logged on users\")\n\t\tmemusage ;;\n\t\"Display memory usage\"）\n\t\tmemusage ;;\n\t*)\n\t\tclear\n\t\techo \"Sorry, wrong selection\";;\n\tesac\ndone\nclear\n\n```\n\n运行会自动生成如下菜单项：\n\n```shell\nwsx@wsx:~/tmp$ ./smenu1\n1) Display disk space\t    3) Display memory usage\n2) Display logged on users  4) Exit program\nEnter an option:\n```\n\n**在使用`select`命令时，记住存储在变量中的结果值是整个文本字符串而不是跟菜单项相关联的数字。文本字符串是要在`case`语句中比较的内容。**\n\n\n\n## 制作窗口\n\n`dialog`包能够用ANSI转义控制字符在文本环境中创建标准的窗口对话框。我们可以将这些对话框融入自己的shell脚本中，借此与用户进行交互。这部分我们来学习如何使用`dialog`包。\n\n安装：\n\n```shell\nsudo apt-get install dialog\n```\n\n### dialog包\n\n`dialog`包使用命令行参数来决定生成哪种窗口部件（widget）。部件是dialog包中窗口元素的术语。\n\n| 部件           | 描述                        |\n| ------------ | ------------------------- |\n| calendar     | 提供选择日期的日历                 |\n| checklist    | 显示多个选项（其中每个选项都能打开或关闭）     |\n| form         | 构建一个带有标签以及文本字段（可以填写内容）的表单 |\n| fselect      | 提供一个文件选择窗口来浏览选择文件         |\n| gauge        | 显示完成的百分比进度条               |\n| infobox      | 显示一条消息，但不用等待回应            |\n| inputbox     | 提供一个输入文本用的文本表单            |\n| inputmenu    | 提供一个可编辑的菜单                |\n| menu         | 显示可选择的一系列选项               |\n| msgbox       | 显示一条消息，并要求用户选择OK按钮        |\n| pause        | 显示一个进度条来显示暂定期间的状态         |\n| passwordbox  | 显示一个文本框，但会隐藏输入的文本         |\n| passwordform | 显示一个带标签的隐藏文本字段的表单         |\n| radiolist    | 提供一组菜单选项，但只能选择其中一个        |\n| tailbox      | 用tail命令在滚动窗口中显示文件的内容      |\n| tailboxbg    | 跟tailbox一样，但是在后台模式中运行     |\n| textbox      | 在滚动窗口中显示文件的内容             |\n| timebox      | 提供一个选择小时、分钟和秒数的窗口         |\n| yesno        | 提供一条带有Yes和No按钮的简单消息       |\n\n如上表所见，我们可以选择很多不同的部件。只需要多花点功夫就可以让脚本看起来更专业。\n\n**要在命令行上指定某个特定的部件，需要使用双破折线格式**：\n\n```shell\ndialog --widget parameters\n```\n\n其中`widget`是上表中某个特定的部件，`parameters`定义了部件窗口的大小以及部件需要的文本。\n\n**每个dialog部件都提供了两种形式的输出：**\n\n- 使用STDERR\n- 使用退出状态码\n\n可以通过`dialog`命令的退出状态码来确定用户选择的按钮。如果选择了Yes或OK按钮，命令会返回状态码`0`。如果选择了Cancer或No按钮，命令会返回状态码`1`。可用标准的`$?`变量来确定`dialog`部件具体选择了哪个按钮。\n\n如果部件返回了数据，`dialog`命令会将数据发送到STDERR。我们可以用标准的bash shell方法将其重定向到另一个文件或文件描述符中。\n\n```shell\ndialog --inputbox \"Enter your age:\" 10 20 2>age.txt\n```\n\n这条命令将文本框输入的文本重定向到age.txt文本中。\n\n#### msgbox部件\n\n`msgbox`部件是对话框中最常见的类型。它会在窗口中显示一条简单的信息，直到用户点击OK后消失。\n\n使用格式：\n\n```shell\ndialog --msgbox text height width\n```\n\n`text`参数是要在窗口显示的字符串，`height`与`width`参数设定自动换行的窗口大小。如果想要在窗口加一个标题，可以使用`--title`参数，后接作为标题的文本。\n\n例子：\n\n```shell\ndialog --title Testing --msgbox \"This is a test\" 10 20\n```\n\n输入命令后，消息框会显示在终端上。如果你的终端仿真器支持鼠标，可以单击OK来关闭对话框，也可以按下回车键。\n\n#### yesno部件\n\n该部件在窗口底部生成两个按钮：一个是Yes，一个是No。用户可以用鼠标、制表符或者键盘方向键来切换按钮。选择按钮则使用空格或者回车键。\n\n下面是一个例子：\n\n```shell\nwsx@wsx:~$ dialog --title \"Please answer\" --yesno \"Is this thing on?\" 10 20\n# 中间终端有输出\nwsx@wsx:~$ echo $?\n0\n```\n\n`dialog`命令的退出状态码会根据用户选择的按钮来设置。选择No返回1，选择Yes就是0。\n\n#### inputbox部件\n\ninputbox部件提供了一个简单的文本框区域来输入文本字符串，dialog会将它传到STDERR，我们需要重定向获得输入。inputbox提供了两个按钮：OK和Cancel。如果选择了OK，命令退出状态码为0，否则为1。\n\n```shell\nwsx@wsx:~/tmp$ dialog --inputbox \"Enter your age:\" 10 20 2>age.txt\nwsx@wsx:~/tmp$ cat age.txt\n24\n```\n\n如果你自己运行过的话就会注意到该值后面没有换行符，这让我们能够轻松将文本内容重定向到脚本变量中，以获得用户输入的值。\n\n#### textbox部件\n\ntextbox部件是在窗口中显示大量信息的极佳办法。它会生成一个滚动窗口来显示由参数所指定的文件中的文本。\n\n```shell\nwsx@wsx:~/tmp$ dialog --textbox /etc/passwd 15 45\n```\n\n`/etc/passwd`文件内容显示在可滚动的文本窗口中，可以用方向键来左右或上下滚动显示文件的内容。窗口底部的行会显示当前查看文本处于文件中的哪个位置（百分比）。文本框只包含一个用来选择退出部件的Exit按钮。\n\n#### menu部件\n\n我们可以用这个部件来创建之前（上一篇笔记）中制作的文本菜单的窗口版本。只要为每个选项提供一个选择标号和文本就行。\n\n```shell\nwsx@wsx:~/tmp$ dialog --menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 4 \"Exit\" 2>test.txt\n```\n\n**第一个参数定义了菜单的标题，之后的两个参数定义了菜单窗口的高和宽，而第四个参数则定义了在窗口中一次显示的菜单项总数。如果存在更多选择，则有滚动条。**\n\n菜单项必须使用菜单对：第一个元素是用来选择菜单项的标号（必须唯一）；第二个元素是菜单中使用的文本。\n\ndialog命令会将选定（鼠标点击或回车键或选择OK）的菜单项文本发送到STDERR。\n\n#### fselect部件\n\n该部件在处理文件名时非常方便。不用强制用户键入文件名，我们就可以用`fselect`部件来浏览文件的位置并选择文件。\n\n使用格式：\n\n```shell\nwsx@wsx:~/tmp$ dialog --title \"Select a file\" --fselect $HOME/ 10 50 2>file.txt\n```\n\n**第一个参数是窗口使用的其实目录位置。`fselect`部件窗口由左侧的目录列表、右侧的文件列表和含有当前选定的文件或目录的简单文本框组成。可以手动在文本框键入文件名，或者用目录和文件列表来选定（使用空格键选定）**。\n\n\n\n### dialog选项\n\n除了标准部件，dialog还有大量定制的选项。前面我们使用的`title`就是一个。\n\n下面显示了命令可用的选项：\n\n| 选项                       | 描述                                |\n| ------------------------ | --------------------------------- |\n| --add-widget             | 继续下一个对话框直到按下Esc或Cancel选项          |\n| --aspect ratio           | 直到窗口宽度和高度的宽高比                     |\n| --backtitle title        | 直到显示在屏幕顶部背景上的图标                   |\n| --begin x y              | 指定窗口左上角的起始位置                      |\n| --cancel-label label     | 指定Cancel按钮的替代标签                   |\n| --clear                  | 用默认的对话背景色来清空屏幕内容                  |\n| --colors                 | 在对话文本中嵌入ANSI色彩编码                  |\n| --cr-wrap                | 在对话文本中允许使用换行符并强制换行                |\n| --create-rc file         | 将示例配置文件的内容复制到指定的file文件中           |\n| --defaultno              | 将yes/no对话框的默认答案设为no               |\n| --default-item string    | 设定复选列表、表单或菜单对话中的默认项               |\n| --exit-label label       | 指定Exit按钮的替代标签                     |\n| --extra-button           | 在OK按钮和Cancel按钮之间显示一个额外按钮          |\n| --extra-label label      | 指定额外按钮的替换标签                       |\n| --help                   | 显示dialog命令的帮助信息                   |\n| --help-button            | 在OK按钮和Cancel按钮后显示一个Help按钮         |\n| --help-label label       | 指定Help按钮的替换标签                     |\n| --help-status            | 当选定Help按钮后，在帮助信息后写入多选列表、单选列表或表单信息 |\n| --ignore                 | 忽略dialog不能识别的选项                   |\n| --input-fd fd            | 指定STDIN之外的另一个文件描述符                |\n| --insecure               | 在passwd部件中键入内容时显示星号               |\n| --item-help              | 为多选列表、单选列表或菜单中的每个标号在屏幕底部添加一个帮助栏   |\n| --keep-window            | 不要清除屏幕上显示过的部件                     |\n| --max-input size         | 指定输入的最大字符串长度。默认为2048              |\n| --nocancel               | 隐藏Cancel按钮                        |\n| --no-collapse            | 不要将对话文本中的制表符转换为空格                 |\n| --no-kill                | 将tailboxbg对话放到后台，并禁止该进程的SIGHUP信号  |\n| --no-label label         | 为No按钮指定替换标签                       |\n| --no-shadow              | 不要显示对话窗口的阴影效果                     |\n| --ok-label label         | 指定OK按钮的替换标签                       |\n| --output-fd fd           | 指定除STDERR之外的另一个输出文件描述符            |\n| --print-maxsize          | 将对话窗口的最大尺寸打印到输出中                  |\n| --print-size             | 将每个对话窗口的大小打印到输出中                  |\n| --print-version          | 将dialog的版本号打印到输出中                 |\n| --separate-output        | 一次一行地输出checklist部件的结果，不使用引号       |\n| --separator string       | 指定用于分隔部件输出的字符串                    |\n| --separate-widget string | 指定用于分隔部件输出的字符串                    |\n| --shadow                 | 在每个窗口右下角绘制阴影                      |\n| --single-quoted          | 需要时对多选列表的输出采用单引号                  |\n| --sleep sec              | 在处理完对话窗口后延迟指定的秒数                  |\n| --stderr                 | 将输出发送到STDERR（默认）                  |\n| --stdout                 | 将输出发送到STDOUT                      |\n| --tab-correct            | 将制表符转换为空格                         |\n| --tab-len n              | 指定一个制表符占用的空格数（默认为8）               |\n| --timeout sec            | 指定无用户输入时，sec秒后退出并返回错误代码           |\n| --title title            | 指定对话窗口的标题                         |\n| --trim                   | 从对话文本中删除前导空格和换行符                  |\n| --visit-tiems            | 修改对话窗口制表符的停留位置，使其包括选项列表           |\n| --yes-label label        | 为Yes按钮指定替换标签                      |\n\n **`--backtitle`选项是为脚本中的菜单创建公共标题的简便办法。**上表提供的强大特性允许我们创建任何需要的窗口。\n\n```\ndialog命令支持运行时配置。该命令会根据配置文件模板创建一份配置文件。dialog启动时会先去检查是否设置了DIALOGRC环境变量，该变量会保存配置文件名信息。如果未设置该变量或未找到该文件，它会将$HOME/.dialogrc作为配置文件。如果这个文件还不存在的话就尝试查找编译时指定的GLOBALRC文件，也就是/etc/dialogrc。如果还不存在就用编译时的默认值。\n```\n\n\n\n### 在脚本中使用dialog命令\n\n**必须记住两件事：**\n\n- 如果有Cancel或No按钮，检查dialog命令的退出状态码\n- 重定向STDERR来获得输出值\n\n接下来是一个简单的实例，使用dialog部件生成我们之前（上一篇笔记）所创建的系统管理菜单。\n\n```shell\nwsx@wsx-laptop:~$ cat menu3\n#!/bin/bash\n# using dialog to create a menu\n\ntemp=$(mktemp -t test.XXXXXX)\ntemp2=$(mktemp -t test2.XXXXXX)\n\nfunction diskspace {\n        df -k > $temp\n        dialog --textbox $temp 20 60\n}\n\nfunction whoseon {\n        who > $temp\n        dialog --textbox $temp 20 50\n}\n\nfunction menusage {\n        cat /proc/meminfo > $temp\n        dialog --textbox $temp 20 50\n}\n\nwhile [ 1 ]\ndo\ndialog --menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 0 \"Exit\" 2> $temp2\nif [ $? -eq 1 ]\nthen\n  break\nfi\n\nselection=$(cat $temp2)\n\ncase $selection in\n1)\n        diskspace ;;\n2)\n        whoseon ;;\n3)\n        memusage ;;\n0)\n        break ;;\n*)\n        dialog --msgbox \"Sorry, invalid selection\" 10 30\nesac\ndone\nrm -f $temp 2> /dev/null\nrm -f $temp 2> /dev/null\n\n```\n\n使用while循环加一个真值常量创建了一个无限循环来显示菜单对话。当执行完每个函数后，脚本会返回继续显示菜单。\n\n脚本使用了mktemp命令创建两个临时文件来保存dialog命令的数据。\n\n\n\n后面本来还有图形环境中（KDE、GNOME）使用的一些流行包介绍。以后等我使用ubuntu写笔记时再作学习和介绍吧。\n","source":"_posts/2017-11-29-shell-create-text-menu-and-window.md","raw":"---\ntitle: 使用shell创建文本菜单和窗口部件\nauthor: 王诗翔\ndate: 2017-11-29\ncategories:\n- Linux杂烩\n- shell编程\ntags:\n- linux\n- shell笔记\n---\n\n*来源： Linux命令行与shell脚本编程大全*\n\n内容：\n\n>- 创建文本菜单\n>- 创建文本窗口部件\n>- 添加X Window图形\n\n\n\n## 创建文本菜单\n\n创建交互式shell脚本最常用的方法是使用菜单，它提供了各种选项帮助脚本用户了解脚本能做到的和不能做的。\n\nshell脚本菜单的核心是`case`命令，该命令会根据用户在菜单上的选择来执行特定命令。\n\n下面我们逐步了解和创建基于菜单的shell脚本的步骤。\n\n<!-- more -->\n\n### 创建菜单布局\n\n**第一步**是决定在菜单上显示哪些元素以及想要显示的布局方式。\n\n**在创建菜单前，通常先清空显示器上已有的内容。这样能在干净的，没有干扰的环境中显示菜单了。**\n\n`clear`命令使用当前终端的`terminfo`数据来清理出现在屏幕上的文字。运行`clear`命令后可以使用`echo`命令显示菜单元素。\n\n**默认，echo命令只显示可打印的文本字符。**而在创建菜单时一些非文本字符也非常有用，比如制表符和换行符。我们需要添加`-e`选项使得`echo`命令能解析包含在其中的非文本字符。\n\n例如，\n\n```shell\nwsx@wsx:~/tmp$ echo -e \"1.\\tDisplay disk space\"\n1.\tDisplay disk space\n```\n\n这对于格式化菜单项布局非常方便，只需要几个`echo`命令就可以创建一个还不错的菜单。\n\n```shell\nclear\necho\necho -e \"\\t\\t\\tSys Admin Menu\\n\"\necho -e \"\\t1. Display disk space\"\necho -e \"\\t2. Display logged on users\"\necho -e \"\\t3. Display memory usage\"\necho -e \"\\t0. Exit menu\\n\\n\"\necho -en \"\\t\\tEnter an option: \"\n```\n\n最后一行`-en`选项去掉末尾换行符使得菜单更专业点，光标会在行尾等待用户输入。\n\n**创建菜单的最后一步是获取用户输入。**这一步用`read`命令。因为我们只期望用户使用单字符输入，在命令加`-n`选项进行限定。这样用户只需要输入一个数字，不用摁回车键。\n\n```shell\nread -n 1 option\n```\n\n\n\n### 创建菜单函数\n\nshell脚本菜单选项作为一组独立的函数实现起来更为容易。要做到这一点，你要为每个菜单项创建独立的shell函数。**第一步**是决定你希望脚本执行那些功能，然后将这些功能以函数的形式放在代码中。\n\n**通常我们会为还没有实现的函数先创建一个*桩函数*，它是一个控函数，或者只有一个echo语句，说明最终这里需要什么内容。**\n\n```shell\nfunction diskspace {\n  clear\n  echo \"This is where the diskspace commands will do\"\n}\n```\n\n这允许菜单在我实现某个函数时仍然能正常操作。不需要我们写出所有函数之后才能让菜单投入使用。函数从`clear`命令开始，这样我们就能在一个干净的屏幕上执行该函数，不会收到原先菜单的干扰。\n\n**另外，将菜单布局本身作为一个函数来创建有利于菜单制作。**\n\n```shell\nfunction menu {\n  \tclear\n\techo\n\techo -e \"\\t\\t\\tSys Admin Menu\\n\"\n\techo -e \"\\t1. Display disk space\"\n\techo -e \"\\t2. Display logged on users\"\n\techo -e \"\\t3. Display memory usage\"\n\techo -e \"\\t0. Exit menu\\n\\n\"\n\techo -en \"\\t\\tEnter an option: \"\n\tread -n 1 option\n}\n```\n\n这样我们能在任何时候调用该函数以此重现菜单。\n\n### 添加菜单逻辑\n\n下一步我们需要创建程序逻辑将菜单布局和函数结合起来。这需要使用`case`命令。\n\n`case`命令应该根据菜单中输入的字符来调用相应的函数，用case命令字符星号来处理所有不正确的菜单项。\n\n下面展示了典型菜单的`case`用法：\n\n```shell\nmenu\ncase $option in\n0)\n\tbreak ;;\n1)\n\tdiskspace ;;\n2)\n\twhoseon ;;\n3)\n\tmemusage ;;\n*)\n\tclear\n\techo \"Sorry, wrong selection\";;\nesac\n```\n\n这里首先调用`menu`函数清空屏幕并显示菜单。`menu`函数中的`read`命令会一直等待，知道用户在键盘上键入一个字符。然后`case`命令会接管余下的处理过程，基于字符调用相应的函数。\n\n### 整合shell脚本菜单\n\n现在让我们将前面的步骤全部组合起来，看看它们是如何协作的。\n\n这是一个完整的菜单脚本例子：\n\n```shell\nwsx@wsx:~/tmp$ cat test14\n#!/bin/bash\n# simple script menu\n\nfunction diskspace {\n\tclear\n\tdf -k\n}\n\nfunction whoseon {\n\tclear\n\twho\n}\n\nfunction memusage {\n\tclear\n\tcat /proc/meminfo\n}\n\nfunction menu {\n\tclear\n\techo\n\techo -e \"\\t\\t\\tSys Admin Menu\\n\"\n\techo -e \"\\t1. Display disk space\"\n\techo -e \"\\t2. Display logged on users\"\n\techo -e \"\\t3. Display memory usage\"\n\techo -e \"\\t0. Exit menu\\n\\n\"\n\techo -en \"\\t\\tEnter an option: \"\n\tread -n 1 option\n}\n\nwhile [ 1 ]\ndo\n\tmenu\n\tcase $option in\n\t0)\n\t\tbreak ;;\n\t1)\n\t\tdiskspace ;;\n\t2)\n\t\twhoseon ;;\n\t3)\n\t\tmemusage ;;\n\t*)\n\t\tclear\n\t\techo \"Sorry, wrong selection\" ;;\n\tesac\n\techo -en \"\\n\\n\\t\\t\\tHit any key to continue\"\n\tread -n 1 line\ndone\nclear\n\n```\n\n使用：\n\n```shell\n\t\t\tSys Admin Menu\n\n\t1. Display disk space\n\t2. Display logged on users\n\t3. Display memory usage\n\t0. Exit menu\n\n\n\t\tEnter an option:\n```\n\n输入1：\n\n```shell\n文件系统           1K-块     已用      可用 已用% 挂载点\nudev             4006080        0   4006080    0% /dev\ntmpfs             807220    81004    726216   11% /run\n/dev/sda4      305650672 14226064 275828680    5% /\ntmpfs            4036100     1724   4034376    1% /dev/shm\ntmpfs               5120        4      5116    1% /run/lock\ntmpfs            4036100        0   4036100    0% /sys/fs/cgroup\n/dev/sda3         524272     4684    519588    1% /boot/efi\ntmpfs             807220       52    807168    1% /run/user/1000\ntmpfs             807220       16    807204    1% /run/user/125\n/dev/sda2      421886972 23340376 398546596    6% /media/wsx/存储\n\n\n\t\t\tHit any key to continue\n```\n\n其他都可以自己测试一下，我就不赘言了。\n\n\n\n### 使用select命令\n\n`select`命令只需要一条命令就可以创建出菜单，然后获取输入的答案并自动处理。\n\n命令格式如下：\n\n```shell\nselect variable in list\ndo\n\tcommands\ndone\n```\n\n**`list`参数是由空格分隔的文本选项列表，这些列表构成了整个菜单。**`select`命令会将每个列表项显示成一个带编号的选项，然后为选项显示一个由`PS3`环境变量定义的特殊提示符。\n\n```shell\nwsx@wsx:~/tmp$ cat smenu1\n#!/bin/bash\n# using select in the menu\n\nfunction diskspace {\n\tclear\n\tdf -k\n}\n\nfunction whoseon {\n\tclear\n\twho\n}\n\nfunction memusage {\n\tclear\n\tcat /proc/meminfo\n}\n\nPS3=\"Enter an option: \"\nselect option in \"Display disk space\" \"Display logged on users\" \"Display memory usage\" \"Exit program\"\ndo\n\tcase $option in\n\t\"Exit program\")\n\t\tbreak ;;\n\t\"Display disk space\")\n\t\tdiskspace ;;\n\t\"Display logged on users\")\n\t\tmemusage ;;\n\t\"Display memory usage\"）\n\t\tmemusage ;;\n\t*)\n\t\tclear\n\t\techo \"Sorry, wrong selection\";;\n\tesac\ndone\nclear\n\n```\n\n运行会自动生成如下菜单项：\n\n```shell\nwsx@wsx:~/tmp$ ./smenu1\n1) Display disk space\t    3) Display memory usage\n2) Display logged on users  4) Exit program\nEnter an option:\n```\n\n**在使用`select`命令时，记住存储在变量中的结果值是整个文本字符串而不是跟菜单项相关联的数字。文本字符串是要在`case`语句中比较的内容。**\n\n\n\n## 制作窗口\n\n`dialog`包能够用ANSI转义控制字符在文本环境中创建标准的窗口对话框。我们可以将这些对话框融入自己的shell脚本中，借此与用户进行交互。这部分我们来学习如何使用`dialog`包。\n\n安装：\n\n```shell\nsudo apt-get install dialog\n```\n\n### dialog包\n\n`dialog`包使用命令行参数来决定生成哪种窗口部件（widget）。部件是dialog包中窗口元素的术语。\n\n| 部件           | 描述                        |\n| ------------ | ------------------------- |\n| calendar     | 提供选择日期的日历                 |\n| checklist    | 显示多个选项（其中每个选项都能打开或关闭）     |\n| form         | 构建一个带有标签以及文本字段（可以填写内容）的表单 |\n| fselect      | 提供一个文件选择窗口来浏览选择文件         |\n| gauge        | 显示完成的百分比进度条               |\n| infobox      | 显示一条消息，但不用等待回应            |\n| inputbox     | 提供一个输入文本用的文本表单            |\n| inputmenu    | 提供一个可编辑的菜单                |\n| menu         | 显示可选择的一系列选项               |\n| msgbox       | 显示一条消息，并要求用户选择OK按钮        |\n| pause        | 显示一个进度条来显示暂定期间的状态         |\n| passwordbox  | 显示一个文本框，但会隐藏输入的文本         |\n| passwordform | 显示一个带标签的隐藏文本字段的表单         |\n| radiolist    | 提供一组菜单选项，但只能选择其中一个        |\n| tailbox      | 用tail命令在滚动窗口中显示文件的内容      |\n| tailboxbg    | 跟tailbox一样，但是在后台模式中运行     |\n| textbox      | 在滚动窗口中显示文件的内容             |\n| timebox      | 提供一个选择小时、分钟和秒数的窗口         |\n| yesno        | 提供一条带有Yes和No按钮的简单消息       |\n\n如上表所见，我们可以选择很多不同的部件。只需要多花点功夫就可以让脚本看起来更专业。\n\n**要在命令行上指定某个特定的部件，需要使用双破折线格式**：\n\n```shell\ndialog --widget parameters\n```\n\n其中`widget`是上表中某个特定的部件，`parameters`定义了部件窗口的大小以及部件需要的文本。\n\n**每个dialog部件都提供了两种形式的输出：**\n\n- 使用STDERR\n- 使用退出状态码\n\n可以通过`dialog`命令的退出状态码来确定用户选择的按钮。如果选择了Yes或OK按钮，命令会返回状态码`0`。如果选择了Cancer或No按钮，命令会返回状态码`1`。可用标准的`$?`变量来确定`dialog`部件具体选择了哪个按钮。\n\n如果部件返回了数据，`dialog`命令会将数据发送到STDERR。我们可以用标准的bash shell方法将其重定向到另一个文件或文件描述符中。\n\n```shell\ndialog --inputbox \"Enter your age:\" 10 20 2>age.txt\n```\n\n这条命令将文本框输入的文本重定向到age.txt文本中。\n\n#### msgbox部件\n\n`msgbox`部件是对话框中最常见的类型。它会在窗口中显示一条简单的信息，直到用户点击OK后消失。\n\n使用格式：\n\n```shell\ndialog --msgbox text height width\n```\n\n`text`参数是要在窗口显示的字符串，`height`与`width`参数设定自动换行的窗口大小。如果想要在窗口加一个标题，可以使用`--title`参数，后接作为标题的文本。\n\n例子：\n\n```shell\ndialog --title Testing --msgbox \"This is a test\" 10 20\n```\n\n输入命令后，消息框会显示在终端上。如果你的终端仿真器支持鼠标，可以单击OK来关闭对话框，也可以按下回车键。\n\n#### yesno部件\n\n该部件在窗口底部生成两个按钮：一个是Yes，一个是No。用户可以用鼠标、制表符或者键盘方向键来切换按钮。选择按钮则使用空格或者回车键。\n\n下面是一个例子：\n\n```shell\nwsx@wsx:~$ dialog --title \"Please answer\" --yesno \"Is this thing on?\" 10 20\n# 中间终端有输出\nwsx@wsx:~$ echo $?\n0\n```\n\n`dialog`命令的退出状态码会根据用户选择的按钮来设置。选择No返回1，选择Yes就是0。\n\n#### inputbox部件\n\ninputbox部件提供了一个简单的文本框区域来输入文本字符串，dialog会将它传到STDERR，我们需要重定向获得输入。inputbox提供了两个按钮：OK和Cancel。如果选择了OK，命令退出状态码为0，否则为1。\n\n```shell\nwsx@wsx:~/tmp$ dialog --inputbox \"Enter your age:\" 10 20 2>age.txt\nwsx@wsx:~/tmp$ cat age.txt\n24\n```\n\n如果你自己运行过的话就会注意到该值后面没有换行符，这让我们能够轻松将文本内容重定向到脚本变量中，以获得用户输入的值。\n\n#### textbox部件\n\ntextbox部件是在窗口中显示大量信息的极佳办法。它会生成一个滚动窗口来显示由参数所指定的文件中的文本。\n\n```shell\nwsx@wsx:~/tmp$ dialog --textbox /etc/passwd 15 45\n```\n\n`/etc/passwd`文件内容显示在可滚动的文本窗口中，可以用方向键来左右或上下滚动显示文件的内容。窗口底部的行会显示当前查看文本处于文件中的哪个位置（百分比）。文本框只包含一个用来选择退出部件的Exit按钮。\n\n#### menu部件\n\n我们可以用这个部件来创建之前（上一篇笔记）中制作的文本菜单的窗口版本。只要为每个选项提供一个选择标号和文本就行。\n\n```shell\nwsx@wsx:~/tmp$ dialog --menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 4 \"Exit\" 2>test.txt\n```\n\n**第一个参数定义了菜单的标题，之后的两个参数定义了菜单窗口的高和宽，而第四个参数则定义了在窗口中一次显示的菜单项总数。如果存在更多选择，则有滚动条。**\n\n菜单项必须使用菜单对：第一个元素是用来选择菜单项的标号（必须唯一）；第二个元素是菜单中使用的文本。\n\ndialog命令会将选定（鼠标点击或回车键或选择OK）的菜单项文本发送到STDERR。\n\n#### fselect部件\n\n该部件在处理文件名时非常方便。不用强制用户键入文件名，我们就可以用`fselect`部件来浏览文件的位置并选择文件。\n\n使用格式：\n\n```shell\nwsx@wsx:~/tmp$ dialog --title \"Select a file\" --fselect $HOME/ 10 50 2>file.txt\n```\n\n**第一个参数是窗口使用的其实目录位置。`fselect`部件窗口由左侧的目录列表、右侧的文件列表和含有当前选定的文件或目录的简单文本框组成。可以手动在文本框键入文件名，或者用目录和文件列表来选定（使用空格键选定）**。\n\n\n\n### dialog选项\n\n除了标准部件，dialog还有大量定制的选项。前面我们使用的`title`就是一个。\n\n下面显示了命令可用的选项：\n\n| 选项                       | 描述                                |\n| ------------------------ | --------------------------------- |\n| --add-widget             | 继续下一个对话框直到按下Esc或Cancel选项          |\n| --aspect ratio           | 直到窗口宽度和高度的宽高比                     |\n| --backtitle title        | 直到显示在屏幕顶部背景上的图标                   |\n| --begin x y              | 指定窗口左上角的起始位置                      |\n| --cancel-label label     | 指定Cancel按钮的替代标签                   |\n| --clear                  | 用默认的对话背景色来清空屏幕内容                  |\n| --colors                 | 在对话文本中嵌入ANSI色彩编码                  |\n| --cr-wrap                | 在对话文本中允许使用换行符并强制换行                |\n| --create-rc file         | 将示例配置文件的内容复制到指定的file文件中           |\n| --defaultno              | 将yes/no对话框的默认答案设为no               |\n| --default-item string    | 设定复选列表、表单或菜单对话中的默认项               |\n| --exit-label label       | 指定Exit按钮的替代标签                     |\n| --extra-button           | 在OK按钮和Cancel按钮之间显示一个额外按钮          |\n| --extra-label label      | 指定额外按钮的替换标签                       |\n| --help                   | 显示dialog命令的帮助信息                   |\n| --help-button            | 在OK按钮和Cancel按钮后显示一个Help按钮         |\n| --help-label label       | 指定Help按钮的替换标签                     |\n| --help-status            | 当选定Help按钮后，在帮助信息后写入多选列表、单选列表或表单信息 |\n| --ignore                 | 忽略dialog不能识别的选项                   |\n| --input-fd fd            | 指定STDIN之外的另一个文件描述符                |\n| --insecure               | 在passwd部件中键入内容时显示星号               |\n| --item-help              | 为多选列表、单选列表或菜单中的每个标号在屏幕底部添加一个帮助栏   |\n| --keep-window            | 不要清除屏幕上显示过的部件                     |\n| --max-input size         | 指定输入的最大字符串长度。默认为2048              |\n| --nocancel               | 隐藏Cancel按钮                        |\n| --no-collapse            | 不要将对话文本中的制表符转换为空格                 |\n| --no-kill                | 将tailboxbg对话放到后台，并禁止该进程的SIGHUP信号  |\n| --no-label label         | 为No按钮指定替换标签                       |\n| --no-shadow              | 不要显示对话窗口的阴影效果                     |\n| --ok-label label         | 指定OK按钮的替换标签                       |\n| --output-fd fd           | 指定除STDERR之外的另一个输出文件描述符            |\n| --print-maxsize          | 将对话窗口的最大尺寸打印到输出中                  |\n| --print-size             | 将每个对话窗口的大小打印到输出中                  |\n| --print-version          | 将dialog的版本号打印到输出中                 |\n| --separate-output        | 一次一行地输出checklist部件的结果，不使用引号       |\n| --separator string       | 指定用于分隔部件输出的字符串                    |\n| --separate-widget string | 指定用于分隔部件输出的字符串                    |\n| --shadow                 | 在每个窗口右下角绘制阴影                      |\n| --single-quoted          | 需要时对多选列表的输出采用单引号                  |\n| --sleep sec              | 在处理完对话窗口后延迟指定的秒数                  |\n| --stderr                 | 将输出发送到STDERR（默认）                  |\n| --stdout                 | 将输出发送到STDOUT                      |\n| --tab-correct            | 将制表符转换为空格                         |\n| --tab-len n              | 指定一个制表符占用的空格数（默认为8）               |\n| --timeout sec            | 指定无用户输入时，sec秒后退出并返回错误代码           |\n| --title title            | 指定对话窗口的标题                         |\n| --trim                   | 从对话文本中删除前导空格和换行符                  |\n| --visit-tiems            | 修改对话窗口制表符的停留位置，使其包括选项列表           |\n| --yes-label label        | 为Yes按钮指定替换标签                      |\n\n **`--backtitle`选项是为脚本中的菜单创建公共标题的简便办法。**上表提供的强大特性允许我们创建任何需要的窗口。\n\n```\ndialog命令支持运行时配置。该命令会根据配置文件模板创建一份配置文件。dialog启动时会先去检查是否设置了DIALOGRC环境变量，该变量会保存配置文件名信息。如果未设置该变量或未找到该文件，它会将$HOME/.dialogrc作为配置文件。如果这个文件还不存在的话就尝试查找编译时指定的GLOBALRC文件，也就是/etc/dialogrc。如果还不存在就用编译时的默认值。\n```\n\n\n\n### 在脚本中使用dialog命令\n\n**必须记住两件事：**\n\n- 如果有Cancel或No按钮，检查dialog命令的退出状态码\n- 重定向STDERR来获得输出值\n\n接下来是一个简单的实例，使用dialog部件生成我们之前（上一篇笔记）所创建的系统管理菜单。\n\n```shell\nwsx@wsx-laptop:~$ cat menu3\n#!/bin/bash\n# using dialog to create a menu\n\ntemp=$(mktemp -t test.XXXXXX)\ntemp2=$(mktemp -t test2.XXXXXX)\n\nfunction diskspace {\n        df -k > $temp\n        dialog --textbox $temp 20 60\n}\n\nfunction whoseon {\n        who > $temp\n        dialog --textbox $temp 20 50\n}\n\nfunction menusage {\n        cat /proc/meminfo > $temp\n        dialog --textbox $temp 20 50\n}\n\nwhile [ 1 ]\ndo\ndialog --menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 0 \"Exit\" 2> $temp2\nif [ $? -eq 1 ]\nthen\n  break\nfi\n\nselection=$(cat $temp2)\n\ncase $selection in\n1)\n        diskspace ;;\n2)\n        whoseon ;;\n3)\n        memusage ;;\n0)\n        break ;;\n*)\n        dialog --msgbox \"Sorry, invalid selection\" 10 30\nesac\ndone\nrm -f $temp 2> /dev/null\nrm -f $temp 2> /dev/null\n\n```\n\n使用while循环加一个真值常量创建了一个无限循环来显示菜单对话。当执行完每个函数后，脚本会返回继续显示菜单。\n\n脚本使用了mktemp命令创建两个临时文件来保存dialog命令的数据。\n\n\n\n后面本来还有图形环境中（KDE、GNOME）使用的一些流行包介绍。以后等我使用ubuntu写笔记时再作学习和介绍吧。\n","slug":"shell-create-text-menu-and-window","published":1,"updated":"2018-01-27T04:08:47.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwuh000c9tax7uumsh2f","content":"<p><em>来源： Linux命令行与shell脚本编程大全</em></p>\n<p>内容：</p>\n<blockquote>\n<ul>\n<li>创建文本菜单</li>\n<li>创建文本窗口部件</li>\n<li>添加X Window图形</li>\n</ul>\n</blockquote>\n<h2 id=\"创建文本菜单\"><a href=\"#创建文本菜单\" class=\"headerlink\" title=\"创建文本菜单\"></a>创建文本菜单</h2><p>创建交互式shell脚本最常用的方法是使用菜单，它提供了各种选项帮助脚本用户了解脚本能做到的和不能做的。</p>\n<p>shell脚本菜单的核心是<code>case</code>命令，该命令会根据用户在菜单上的选择来执行特定命令。</p>\n<p>下面我们逐步了解和创建基于菜单的shell脚本的步骤。</p>\n<a id=\"more\"></a>\n<h3 id=\"创建菜单布局\"><a href=\"#创建菜单布局\" class=\"headerlink\" title=\"创建菜单布局\"></a>创建菜单布局</h3><p><strong>第一步</strong>是决定在菜单上显示哪些元素以及想要显示的布局方式。</p>\n<p><strong>在创建菜单前，通常先清空显示器上已有的内容。这样能在干净的，没有干扰的环境中显示菜单了。</strong></p>\n<p><code>clear</code>命令使用当前终端的<code>terminfo</code>数据来清理出现在屏幕上的文字。运行<code>clear</code>命令后可以使用<code>echo</code>命令显示菜单元素。</p>\n<p><strong>默认，echo命令只显示可打印的文本字符。</strong>而在创建菜单时一些非文本字符也非常有用，比如制表符和换行符。我们需要添加<code>-e</code>选项使得<code>echo</code>命令能解析包含在其中的非文本字符。</p>\n<p>例如，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ echo -e \"1.\\tDisplay disk space\"</span><br><span class=\"line\">1.\tDisplay disk space</span><br></pre></td></tr></table></figure>\n<p>这对于格式化菜单项布局非常方便，只需要几个<code>echo</code>命令就可以创建一个还不错的菜单。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear</span><br><span class=\"line\">echo</span><br><span class=\"line\">echo -e \"\\t\\t\\tSys Admin Menu\\n\"</span><br><span class=\"line\">echo -e \"\\t1. Display disk space\"</span><br><span class=\"line\">echo -e \"\\t2. Display logged on users\"</span><br><span class=\"line\">echo -e \"\\t3. Display memory usage\"</span><br><span class=\"line\">echo -e \"\\t0. Exit menu\\n\\n\"</span><br><span class=\"line\">echo -en \"\\t\\tEnter an option: \"</span><br></pre></td></tr></table></figure>\n<p>最后一行<code>-en</code>选项去掉末尾换行符使得菜单更专业点，光标会在行尾等待用户输入。</p>\n<p><strong>创建菜单的最后一步是获取用户输入。</strong>这一步用<code>read</code>命令。因为我们只期望用户使用单字符输入，在命令加<code>-n</code>选项进行限定。这样用户只需要输入一个数字，不用摁回车键。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read -n 1 option</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建菜单函数\"><a href=\"#创建菜单函数\" class=\"headerlink\" title=\"创建菜单函数\"></a>创建菜单函数</h3><p>shell脚本菜单选项作为一组独立的函数实现起来更为容易。要做到这一点，你要为每个菜单项创建独立的shell函数。<strong>第一步</strong>是决定你希望脚本执行那些功能，然后将这些功能以函数的形式放在代码中。</p>\n<p><strong>通常我们会为还没有实现的函数先创建一个<em>桩函数</em>，它是一个控函数，或者只有一个echo语句，说明最终这里需要什么内容。</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function diskspace &#123;</span><br><span class=\"line\">  clear</span><br><span class=\"line\">  echo \"This is where the diskspace commands will do\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这允许菜单在我实现某个函数时仍然能正常操作。不需要我们写出所有函数之后才能让菜单投入使用。函数从<code>clear</code>命令开始，这样我们就能在一个干净的屏幕上执行该函数，不会收到原先菜单的干扰。</p>\n<p><strong>另外，将菜单布局本身作为一个函数来创建有利于菜单制作。</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function menu &#123;</span><br><span class=\"line\">  \tclear</span><br><span class=\"line\">trueecho</span><br><span class=\"line\">trueecho -e \"\\t\\t\\tSys Admin Menu\\n\"</span><br><span class=\"line\">trueecho -e \"\\t1. Display disk space\"</span><br><span class=\"line\">trueecho -e \"\\t2. Display logged on users\"</span><br><span class=\"line\">trueecho -e \"\\t3. Display memory usage\"</span><br><span class=\"line\">trueecho -e \"\\t0. Exit menu\\n\\n\"</span><br><span class=\"line\">trueecho -en \"\\t\\tEnter an option: \"</span><br><span class=\"line\">trueread -n 1 option</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们能在任何时候调用该函数以此重现菜单。</p>\n<h3 id=\"添加菜单逻辑\"><a href=\"#添加菜单逻辑\" class=\"headerlink\" title=\"添加菜单逻辑\"></a>添加菜单逻辑</h3><p>下一步我们需要创建程序逻辑将菜单布局和函数结合起来。这需要使用<code>case</code>命令。</p>\n<p><code>case</code>命令应该根据菜单中输入的字符来调用相应的函数，用case命令字符星号来处理所有不正确的菜单项。</p>\n<p>下面展示了典型菜单的<code>case</code>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu</span><br><span class=\"line\">case $option in</span><br><span class=\"line\">0)</span><br><span class=\"line\">truebreak ;;</span><br><span class=\"line\">1)</span><br><span class=\"line\">truediskspace ;;</span><br><span class=\"line\">2)</span><br><span class=\"line\">truewhoseon ;;</span><br><span class=\"line\">3)</span><br><span class=\"line\">truememusage ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">trueecho \"Sorry, wrong selection\";;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<p>这里首先调用<code>menu</code>函数清空屏幕并显示菜单。<code>menu</code>函数中的<code>read</code>命令会一直等待，知道用户在键盘上键入一个字符。然后<code>case</code>命令会接管余下的处理过程，基于字符调用相应的函数。</p>\n<h3 id=\"整合shell脚本菜单\"><a href=\"#整合shell脚本菜单\" class=\"headerlink\" title=\"整合shell脚本菜单\"></a>整合shell脚本菜单</h3><p>现在让我们将前面的步骤全部组合起来，看看它们是如何协作的。</p>\n<p>这是一个完整的菜单脚本例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test14</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> simple script menu</span></span><br><span class=\"line\"></span><br><span class=\"line\">function diskspace &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truedf -k</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function whoseon &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truewho</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function memusage &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truecat /proc/meminfo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function menu &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">trueecho</span><br><span class=\"line\">trueecho -e \"\\t\\t\\tSys Admin Menu\\n\"</span><br><span class=\"line\">trueecho -e \"\\t1. Display disk space\"</span><br><span class=\"line\">trueecho -e \"\\t2. Display logged on users\"</span><br><span class=\"line\">trueecho -e \"\\t3. Display memory usage\"</span><br><span class=\"line\">trueecho -e \"\\t0. Exit menu\\n\\n\"</span><br><span class=\"line\">trueecho -en \"\\t\\tEnter an option: \"</span><br><span class=\"line\">trueread -n 1 option</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">while [ 1 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">truemenu</span><br><span class=\"line\">truecase $option in</span><br><span class=\"line\">true0)</span><br><span class=\"line\">truetruebreak ;;</span><br><span class=\"line\">true1)</span><br><span class=\"line\">truetruediskspace ;;</span><br><span class=\"line\">true2)</span><br><span class=\"line\">truetruewhoseon ;;</span><br><span class=\"line\">true3)</span><br><span class=\"line\">truetruememusage ;;</span><br><span class=\"line\">true*)</span><br><span class=\"line\">truetrueclear</span><br><span class=\"line\">truetrueecho \"Sorry, wrong selection\" ;;</span><br><span class=\"line\">trueesac</span><br><span class=\"line\">trueecho -en \"\\n\\n\\t\\t\\tHit any key to continue\"</span><br><span class=\"line\">trueread -n 1 line</span><br><span class=\"line\">done</span><br><span class=\"line\">clear</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">truetrueSys Admin Menu</span><br><span class=\"line\"></span><br><span class=\"line\">1. Display disk space</span><br><span class=\"line\">2. Display logged on users</span><br><span class=\"line\">3. Display memory usage</span><br><span class=\"line\">0. Exit menu</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">trueEnter an option:</span><br></pre></td></tr></table></figure>\n<p>输入1：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件系统           1K-块     已用      可用 已用% 挂载点</span><br><span class=\"line\">udev             4006080        0   4006080    0% /dev</span><br><span class=\"line\">tmpfs             807220    81004    726216   11% /run</span><br><span class=\"line\">/dev/sda4      305650672 14226064 275828680    5% /</span><br><span class=\"line\">tmpfs            4036100     1724   4034376    1% /dev/shm</span><br><span class=\"line\">tmpfs               5120        4      5116    1% /run/lock</span><br><span class=\"line\">tmpfs            4036100        0   4036100    0% /sys/fs/cgroup</span><br><span class=\"line\">/dev/sda3         524272     4684    519588    1% /boot/efi</span><br><span class=\"line\">tmpfs             807220       52    807168    1% /run/user/1000</span><br><span class=\"line\">tmpfs             807220       16    807204    1% /run/user/125</span><br><span class=\"line\">/dev/sda2      421886972 23340376 398546596    6% /media/wsx/存储</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">truetruetrueHit any key to continue</span><br></pre></td></tr></table></figure>\n<p>其他都可以自己测试一下，我就不赘言了。</p>\n<h3 id=\"使用select命令\"><a href=\"#使用select命令\" class=\"headerlink\" title=\"使用select命令\"></a>使用select命令</h3><p><code>select</code>命令只需要一条命令就可以创建出菜单，然后获取输入的答案并自动处理。</p>\n<p>命令格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select variable in list</span><br><span class=\"line\">do</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p><strong><code>list</code>参数是由空格分隔的文本选项列表，这些列表构成了整个菜单。</strong><code>select</code>命令会将每个列表项显示成一个带编号的选项，然后为选项显示一个由<code>PS3</code>环境变量定义的特殊提示符。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat smenu1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using select <span class=\"keyword\">in</span> the menu</span></span><br><span class=\"line\"></span><br><span class=\"line\">function diskspace &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truedf -k</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function whoseon &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truewho</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function memusage &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truecat /proc/meminfo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PS3=\"Enter an option: \"</span><br><span class=\"line\">select option in \"Display disk space\" \"Display logged on users\" \"Display memory usage\" \"Exit program\"</span><br><span class=\"line\">do</span><br><span class=\"line\">truecase $option in</span><br><span class=\"line\">true\"Exit program\")</span><br><span class=\"line\">truetruebreak ;;</span><br><span class=\"line\">true\"Display disk space\")</span><br><span class=\"line\">truetruediskspace ;;</span><br><span class=\"line\">true\"Display logged on users\")</span><br><span class=\"line\">truetruememusage ;;</span><br><span class=\"line\">true\"Display memory usage\"）</span><br><span class=\"line\">truetruememusage ;;</span><br><span class=\"line\">true*)</span><br><span class=\"line\">truetrueclear</span><br><span class=\"line\">truetrueecho \"Sorry, wrong selection\";;</span><br><span class=\"line\">trueesac</span><br><span class=\"line\">done</span><br><span class=\"line\">clear</span><br></pre></td></tr></table></figure>\n<p>运行会自动生成如下菜单项：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ ./smenu1</span><br><span class=\"line\">1) Display disk space\t    3) Display memory usage</span><br><span class=\"line\">2) Display logged on users  4) Exit program</span><br><span class=\"line\">Enter an option:</span><br></pre></td></tr></table></figure>\n<p><strong>在使用<code>select</code>命令时，记住存储在变量中的结果值是整个文本字符串而不是跟菜单项相关联的数字。文本字符串是要在<code>case</code>语句中比较的内容。</strong></p>\n<h2 id=\"制作窗口\"><a href=\"#制作窗口\" class=\"headerlink\" title=\"制作窗口\"></a>制作窗口</h2><p><code>dialog</code>包能够用ANSI转义控制字符在文本环境中创建标准的窗口对话框。我们可以将这些对话框融入自己的shell脚本中，借此与用户进行交互。这部分我们来学习如何使用<code>dialog</code>包。</p>\n<p>安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install dialog</span><br></pre></td></tr></table></figure>\n<h3 id=\"dialog包\"><a href=\"#dialog包\" class=\"headerlink\" title=\"dialog包\"></a>dialog包</h3><p><code>dialog</code>包使用命令行参数来决定生成哪种窗口部件（widget）。部件是dialog包中窗口元素的术语。</p>\n<table>\n<thead>\n<tr>\n<th>部件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>calendar</td>\n<td>提供选择日期的日历</td>\n</tr>\n<tr>\n<td>checklist</td>\n<td>显示多个选项（其中每个选项都能打开或关闭）</td>\n</tr>\n<tr>\n<td>form</td>\n<td>构建一个带有标签以及文本字段（可以填写内容）的表单</td>\n</tr>\n<tr>\n<td>fselect</td>\n<td>提供一个文件选择窗口来浏览选择文件</td>\n</tr>\n<tr>\n<td>gauge</td>\n<td>显示完成的百分比进度条</td>\n</tr>\n<tr>\n<td>infobox</td>\n<td>显示一条消息，但不用等待回应</td>\n</tr>\n<tr>\n<td>inputbox</td>\n<td>提供一个输入文本用的文本表单</td>\n</tr>\n<tr>\n<td>inputmenu</td>\n<td>提供一个可编辑的菜单</td>\n</tr>\n<tr>\n<td>menu</td>\n<td>显示可选择的一系列选项</td>\n</tr>\n<tr>\n<td>msgbox</td>\n<td>显示一条消息，并要求用户选择OK按钮</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>显示一个进度条来显示暂定期间的状态</td>\n</tr>\n<tr>\n<td>passwordbox</td>\n<td>显示一个文本框，但会隐藏输入的文本</td>\n</tr>\n<tr>\n<td>passwordform</td>\n<td>显示一个带标签的隐藏文本字段的表单</td>\n</tr>\n<tr>\n<td>radiolist</td>\n<td>提供一组菜单选项，但只能选择其中一个</td>\n</tr>\n<tr>\n<td>tailbox</td>\n<td>用tail命令在滚动窗口中显示文件的内容</td>\n</tr>\n<tr>\n<td>tailboxbg</td>\n<td>跟tailbox一样，但是在后台模式中运行</td>\n</tr>\n<tr>\n<td>textbox</td>\n<td>在滚动窗口中显示文件的内容</td>\n</tr>\n<tr>\n<td>timebox</td>\n<td>提供一个选择小时、分钟和秒数的窗口</td>\n</tr>\n<tr>\n<td>yesno</td>\n<td>提供一条带有Yes和No按钮的简单消息</td>\n</tr>\n</tbody>\n</table>\n<p>如上表所见，我们可以选择很多不同的部件。只需要多花点功夫就可以让脚本看起来更专业。</p>\n<p><strong>要在命令行上指定某个特定的部件，需要使用双破折线格式</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog --widget parameters</span><br></pre></td></tr></table></figure>\n<p>其中<code>widget</code>是上表中某个特定的部件，<code>parameters</code>定义了部件窗口的大小以及部件需要的文本。</p>\n<p><strong>每个dialog部件都提供了两种形式的输出：</strong></p>\n<ul>\n<li>使用STDERR</li>\n<li>使用退出状态码</li>\n</ul>\n<p>可以通过<code>dialog</code>命令的退出状态码来确定用户选择的按钮。如果选择了Yes或OK按钮，命令会返回状态码<code>0</code>。如果选择了Cancer或No按钮，命令会返回状态码<code>1</code>。可用标准的<code>$?</code>变量来确定<code>dialog</code>部件具体选择了哪个按钮。</p>\n<p>如果部件返回了数据，<code>dialog</code>命令会将数据发送到STDERR。我们可以用标准的bash shell方法将其重定向到另一个文件或文件描述符中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog --inputbox \"Enter your age:\" 10 20 2&gt;age.txt</span><br></pre></td></tr></table></figure>\n<p>这条命令将文本框输入的文本重定向到age.txt文本中。</p>\n<h4 id=\"msgbox部件\"><a href=\"#msgbox部件\" class=\"headerlink\" title=\"msgbox部件\"></a>msgbox部件</h4><p><code>msgbox</code>部件是对话框中最常见的类型。它会在窗口中显示一条简单的信息，直到用户点击OK后消失。</p>\n<p>使用格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog --msgbox text height width</span><br></pre></td></tr></table></figure>\n<p><code>text</code>参数是要在窗口显示的字符串，<code>height</code>与<code>width</code>参数设定自动换行的窗口大小。如果想要在窗口加一个标题，可以使用<code>--title</code>参数，后接作为标题的文本。</p>\n<p>例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog --title Testing --msgbox \"This is a test\" 10 20</span><br></pre></td></tr></table></figure>\n<p>输入命令后，消息框会显示在终端上。如果你的终端仿真器支持鼠标，可以单击OK来关闭对话框，也可以按下回车键。</p>\n<h4 id=\"yesno部件\"><a href=\"#yesno部件\" class=\"headerlink\" title=\"yesno部件\"></a>yesno部件</h4><p>该部件在窗口底部生成两个按钮：一个是Yes，一个是No。用户可以用鼠标、制表符或者键盘方向键来切换按钮。选择按钮则使用空格或者回车键。</p>\n<p>下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~$ dialog --title \"Please answer\" --yesno \"Is this thing on?\" 10 20</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 中间终端有输出</span></span><br><span class=\"line\">wsx@wsx:~$ echo $?</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p><code>dialog</code>命令的退出状态码会根据用户选择的按钮来设置。选择No返回1，选择Yes就是0。</p>\n<h4 id=\"inputbox部件\"><a href=\"#inputbox部件\" class=\"headerlink\" title=\"inputbox部件\"></a>inputbox部件</h4><p>inputbox部件提供了一个简单的文本框区域来输入文本字符串，dialog会将它传到STDERR，我们需要重定向获得输入。inputbox提供了两个按钮：OK和Cancel。如果选择了OK，命令退出状态码为0，否则为1。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ dialog --inputbox \"Enter your age:\" 10 20 2&gt;age.txt</span><br><span class=\"line\">wsx@wsx:~/tmp$ cat age.txt</span><br><span class=\"line\">24</span><br></pre></td></tr></table></figure>\n<p>如果你自己运行过的话就会注意到该值后面没有换行符，这让我们能够轻松将文本内容重定向到脚本变量中，以获得用户输入的值。</p>\n<h4 id=\"textbox部件\"><a href=\"#textbox部件\" class=\"headerlink\" title=\"textbox部件\"></a>textbox部件</h4><p>textbox部件是在窗口中显示大量信息的极佳办法。它会生成一个滚动窗口来显示由参数所指定的文件中的文本。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ dialog --textbox /etc/passwd 15 45</span><br></pre></td></tr></table></figure>\n<p><code>/etc/passwd</code>文件内容显示在可滚动的文本窗口中，可以用方向键来左右或上下滚动显示文件的内容。窗口底部的行会显示当前查看文本处于文件中的哪个位置（百分比）。文本框只包含一个用来选择退出部件的Exit按钮。</p>\n<h4 id=\"menu部件\"><a href=\"#menu部件\" class=\"headerlink\" title=\"menu部件\"></a>menu部件</h4><p>我们可以用这个部件来创建之前（上一篇笔记）中制作的文本菜单的窗口版本。只要为每个选项提供一个选择标号和文本就行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ dialog --menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 4 \"Exit\" 2&gt;test.txt</span><br></pre></td></tr></table></figure>\n<p><strong>第一个参数定义了菜单的标题，之后的两个参数定义了菜单窗口的高和宽，而第四个参数则定义了在窗口中一次显示的菜单项总数。如果存在更多选择，则有滚动条。</strong></p>\n<p>菜单项必须使用菜单对：第一个元素是用来选择菜单项的标号（必须唯一）；第二个元素是菜单中使用的文本。</p>\n<p>dialog命令会将选定（鼠标点击或回车键或选择OK）的菜单项文本发送到STDERR。</p>\n<h4 id=\"fselect部件\"><a href=\"#fselect部件\" class=\"headerlink\" title=\"fselect部件\"></a>fselect部件</h4><p>该部件在处理文件名时非常方便。不用强制用户键入文件名，我们就可以用<code>fselect</code>部件来浏览文件的位置并选择文件。</p>\n<p>使用格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ dialog --title \"Select a file\" --fselect $HOME/ 10 50 2&gt;file.txt</span><br></pre></td></tr></table></figure>\n<p><strong>第一个参数是窗口使用的其实目录位置。<code>fselect</code>部件窗口由左侧的目录列表、右侧的文件列表和含有当前选定的文件或目录的简单文本框组成。可以手动在文本框键入文件名，或者用目录和文件列表来选定（使用空格键选定）</strong>。</p>\n<h3 id=\"dialog选项\"><a href=\"#dialog选项\" class=\"headerlink\" title=\"dialog选项\"></a>dialog选项</h3><p>除了标准部件，dialog还有大量定制的选项。前面我们使用的<code>title</code>就是一个。</p>\n<p>下面显示了命令可用的选项：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–add-widget</td>\n<td>继续下一个对话框直到按下Esc或Cancel选项</td>\n</tr>\n<tr>\n<td>–aspect ratio</td>\n<td>直到窗口宽度和高度的宽高比</td>\n</tr>\n<tr>\n<td>–backtitle title</td>\n<td>直到显示在屏幕顶部背景上的图标</td>\n</tr>\n<tr>\n<td>–begin x y</td>\n<td>指定窗口左上角的起始位置</td>\n</tr>\n<tr>\n<td>–cancel-label label</td>\n<td>指定Cancel按钮的替代标签</td>\n</tr>\n<tr>\n<td>–clear</td>\n<td>用默认的对话背景色来清空屏幕内容</td>\n</tr>\n<tr>\n<td>–colors</td>\n<td>在对话文本中嵌入ANSI色彩编码</td>\n</tr>\n<tr>\n<td>–cr-wrap</td>\n<td>在对话文本中允许使用换行符并强制换行</td>\n</tr>\n<tr>\n<td>–create-rc file</td>\n<td>将示例配置文件的内容复制到指定的file文件中</td>\n</tr>\n<tr>\n<td>–defaultno</td>\n<td>将yes/no对话框的默认答案设为no</td>\n</tr>\n<tr>\n<td>–default-item string</td>\n<td>设定复选列表、表单或菜单对话中的默认项</td>\n</tr>\n<tr>\n<td>–exit-label label</td>\n<td>指定Exit按钮的替代标签</td>\n</tr>\n<tr>\n<td>–extra-button</td>\n<td>在OK按钮和Cancel按钮之间显示一个额外按钮</td>\n</tr>\n<tr>\n<td>–extra-label label</td>\n<td>指定额外按钮的替换标签</td>\n</tr>\n<tr>\n<td>–help</td>\n<td>显示dialog命令的帮助信息</td>\n</tr>\n<tr>\n<td>–help-button</td>\n<td>在OK按钮和Cancel按钮后显示一个Help按钮</td>\n</tr>\n<tr>\n<td>–help-label label</td>\n<td>指定Help按钮的替换标签</td>\n</tr>\n<tr>\n<td>–help-status</td>\n<td>当选定Help按钮后，在帮助信息后写入多选列表、单选列表或表单信息</td>\n</tr>\n<tr>\n<td>–ignore</td>\n<td>忽略dialog不能识别的选项</td>\n</tr>\n<tr>\n<td>–input-fd fd</td>\n<td>指定STDIN之外的另一个文件描述符</td>\n</tr>\n<tr>\n<td>–insecure</td>\n<td>在passwd部件中键入内容时显示星号</td>\n</tr>\n<tr>\n<td>–item-help</td>\n<td>为多选列表、单选列表或菜单中的每个标号在屏幕底部添加一个帮助栏</td>\n</tr>\n<tr>\n<td>–keep-window</td>\n<td>不要清除屏幕上显示过的部件</td>\n</tr>\n<tr>\n<td>–max-input size</td>\n<td>指定输入的最大字符串长度。默认为2048</td>\n</tr>\n<tr>\n<td>–nocancel</td>\n<td>隐藏Cancel按钮</td>\n</tr>\n<tr>\n<td>–no-collapse</td>\n<td>不要将对话文本中的制表符转换为空格</td>\n</tr>\n<tr>\n<td>–no-kill</td>\n<td>将tailboxbg对话放到后台，并禁止该进程的SIGHUP信号</td>\n</tr>\n<tr>\n<td>–no-label label</td>\n<td>为No按钮指定替换标签</td>\n</tr>\n<tr>\n<td>–no-shadow</td>\n<td>不要显示对话窗口的阴影效果</td>\n</tr>\n<tr>\n<td>–ok-label label</td>\n<td>指定OK按钮的替换标签</td>\n</tr>\n<tr>\n<td>–output-fd fd</td>\n<td>指定除STDERR之外的另一个输出文件描述符</td>\n</tr>\n<tr>\n<td>–print-maxsize</td>\n<td>将对话窗口的最大尺寸打印到输出中</td>\n</tr>\n<tr>\n<td>–print-size</td>\n<td>将每个对话窗口的大小打印到输出中</td>\n</tr>\n<tr>\n<td>–print-version</td>\n<td>将dialog的版本号打印到输出中</td>\n</tr>\n<tr>\n<td>–separate-output</td>\n<td>一次一行地输出checklist部件的结果，不使用引号</td>\n</tr>\n<tr>\n<td>–separator string</td>\n<td>指定用于分隔部件输出的字符串</td>\n</tr>\n<tr>\n<td>–separate-widget string</td>\n<td>指定用于分隔部件输出的字符串</td>\n</tr>\n<tr>\n<td>–shadow</td>\n<td>在每个窗口右下角绘制阴影</td>\n</tr>\n<tr>\n<td>–single-quoted</td>\n<td>需要时对多选列表的输出采用单引号</td>\n</tr>\n<tr>\n<td>–sleep sec</td>\n<td>在处理完对话窗口后延迟指定的秒数</td>\n</tr>\n<tr>\n<td>–stderr</td>\n<td>将输出发送到STDERR（默认）</td>\n</tr>\n<tr>\n<td>–stdout</td>\n<td>将输出发送到STDOUT</td>\n</tr>\n<tr>\n<td>–tab-correct</td>\n<td>将制表符转换为空格</td>\n</tr>\n<tr>\n<td>–tab-len n</td>\n<td>指定一个制表符占用的空格数（默认为8）</td>\n</tr>\n<tr>\n<td>–timeout sec</td>\n<td>指定无用户输入时，sec秒后退出并返回错误代码</td>\n</tr>\n<tr>\n<td>–title title</td>\n<td>指定对话窗口的标题</td>\n</tr>\n<tr>\n<td>–trim</td>\n<td>从对话文本中删除前导空格和换行符</td>\n</tr>\n<tr>\n<td>–visit-tiems</td>\n<td>修改对话窗口制表符的停留位置，使其包括选项列表</td>\n</tr>\n<tr>\n<td>–yes-label label</td>\n<td>为Yes按钮指定替换标签</td>\n</tr>\n</tbody>\n</table>\n<p> <strong><code>--backtitle</code>选项是为脚本中的菜单创建公共标题的简便办法。</strong>上表提供的强大特性允许我们创建任何需要的窗口。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog命令支持运行时配置。该命令会根据配置文件模板创建一份配置文件。dialog启动时会先去检查是否设置了DIALOGRC环境变量，该变量会保存配置文件名信息。如果未设置该变量或未找到该文件，它会将<span class=\"variable\">$HOME</span><span class=\"regexp\">/.dialogrc作为配置文件。如果这个文件还不存在的话就尝试查找编译时指定的GLOBALRC文件，也就是/</span>etc<span class=\"regexp\">/dialogrc。如果还不存在就用编译时的默认值。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"在脚本中使用dialog命令\"><a href=\"#在脚本中使用dialog命令\" class=\"headerlink\" title=\"在脚本中使用dialog命令\"></a>在脚本中使用dialog命令</h3><p><strong>必须记住两件事：</strong></p>\n<ul>\n<li>如果有Cancel或No按钮，检查dialog命令的退出状态码</li>\n<li>重定向STDERR来获得输出值</li>\n</ul>\n<p>接下来是一个简单的实例，使用dialog部件生成我们之前（上一篇笔记）所创建的系统管理菜单。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~$ cat menu3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using dialog to create a menu</span></span><br><span class=\"line\"></span><br><span class=\"line\">temp=$(mktemp -t test.XXXXXX)</span><br><span class=\"line\">temp2=$(mktemp -t test2.XXXXXX)</span><br><span class=\"line\"></span><br><span class=\"line\">function diskspace &#123;</span><br><span class=\"line\">        df -k &gt; $temp</span><br><span class=\"line\">        dialog --textbox $temp 20 60</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function whoseon &#123;</span><br><span class=\"line\">        who &gt; $temp</span><br><span class=\"line\">        dialog --textbox $temp 20 50</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function menusage &#123;</span><br><span class=\"line\">        cat /proc/meminfo &gt; $temp</span><br><span class=\"line\">        dialog --textbox $temp 20 50</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">while [ 1 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">dialog --menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 0 \"Exit\" 2&gt; $temp2</span><br><span class=\"line\">if [ $? -eq 1 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  break</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">selection=$(cat $temp2)</span><br><span class=\"line\"></span><br><span class=\"line\">case $selection in</span><br><span class=\"line\">1)</span><br><span class=\"line\">        diskspace ;;</span><br><span class=\"line\">2)</span><br><span class=\"line\">        whoseon ;;</span><br><span class=\"line\">3)</span><br><span class=\"line\">        memusage ;;</span><br><span class=\"line\">0)</span><br><span class=\"line\">        break ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">        dialog --msgbox \"Sorry, invalid selection\" 10 30</span><br><span class=\"line\">esac</span><br><span class=\"line\">done</span><br><span class=\"line\">rm -f $temp 2&gt; /dev/null</span><br><span class=\"line\">rm -f $temp 2&gt; /dev/null</span><br></pre></td></tr></table></figure>\n<p>使用while循环加一个真值常量创建了一个无限循环来显示菜单对话。当执行完每个函数后，脚本会返回继续显示菜单。</p>\n<p>脚本使用了mktemp命令创建两个临时文件来保存dialog命令的数据。</p>\n<p>后面本来还有图形环境中（KDE、GNOME）使用的一些流行包介绍。以后等我使用ubuntu写笔记时再作学习和介绍吧。</p>\n","site":{"data":{}},"excerpt":"<p><em>来源： Linux命令行与shell脚本编程大全</em></p>\n<p>内容：</p>\n<blockquote>\n<ul>\n<li>创建文本菜单</li>\n<li>创建文本窗口部件</li>\n<li>添加X Window图形</li>\n</ul>\n</blockquote>\n<h2 id=\"创建文本菜单\"><a href=\"#创建文本菜单\" class=\"headerlink\" title=\"创建文本菜单\"></a>创建文本菜单</h2><p>创建交互式shell脚本最常用的方法是使用菜单，它提供了各种选项帮助脚本用户了解脚本能做到的和不能做的。</p>\n<p>shell脚本菜单的核心是<code>case</code>命令，该命令会根据用户在菜单上的选择来执行特定命令。</p>\n<p>下面我们逐步了解和创建基于菜单的shell脚本的步骤。</p>","more":"<h3 id=\"创建菜单布局\"><a href=\"#创建菜单布局\" class=\"headerlink\" title=\"创建菜单布局\"></a>创建菜单布局</h3><p><strong>第一步</strong>是决定在菜单上显示哪些元素以及想要显示的布局方式。</p>\n<p><strong>在创建菜单前，通常先清空显示器上已有的内容。这样能在干净的，没有干扰的环境中显示菜单了。</strong></p>\n<p><code>clear</code>命令使用当前终端的<code>terminfo</code>数据来清理出现在屏幕上的文字。运行<code>clear</code>命令后可以使用<code>echo</code>命令显示菜单元素。</p>\n<p><strong>默认，echo命令只显示可打印的文本字符。</strong>而在创建菜单时一些非文本字符也非常有用，比如制表符和换行符。我们需要添加<code>-e</code>选项使得<code>echo</code>命令能解析包含在其中的非文本字符。</p>\n<p>例如，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ echo -e \"1.\\tDisplay disk space\"</span><br><span class=\"line\">1.\tDisplay disk space</span><br></pre></td></tr></table></figure>\n<p>这对于格式化菜单项布局非常方便，只需要几个<code>echo</code>命令就可以创建一个还不错的菜单。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clear</span><br><span class=\"line\">echo</span><br><span class=\"line\">echo -e \"\\t\\t\\tSys Admin Menu\\n\"</span><br><span class=\"line\">echo -e \"\\t1. Display disk space\"</span><br><span class=\"line\">echo -e \"\\t2. Display logged on users\"</span><br><span class=\"line\">echo -e \"\\t3. Display memory usage\"</span><br><span class=\"line\">echo -e \"\\t0. Exit menu\\n\\n\"</span><br><span class=\"line\">echo -en \"\\t\\tEnter an option: \"</span><br></pre></td></tr></table></figure>\n<p>最后一行<code>-en</code>选项去掉末尾换行符使得菜单更专业点，光标会在行尾等待用户输入。</p>\n<p><strong>创建菜单的最后一步是获取用户输入。</strong>这一步用<code>read</code>命令。因为我们只期望用户使用单字符输入，在命令加<code>-n</code>选项进行限定。这样用户只需要输入一个数字，不用摁回车键。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read -n 1 option</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建菜单函数\"><a href=\"#创建菜单函数\" class=\"headerlink\" title=\"创建菜单函数\"></a>创建菜单函数</h3><p>shell脚本菜单选项作为一组独立的函数实现起来更为容易。要做到这一点，你要为每个菜单项创建独立的shell函数。<strong>第一步</strong>是决定你希望脚本执行那些功能，然后将这些功能以函数的形式放在代码中。</p>\n<p><strong>通常我们会为还没有实现的函数先创建一个<em>桩函数</em>，它是一个控函数，或者只有一个echo语句，说明最终这里需要什么内容。</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function diskspace &#123;</span><br><span class=\"line\">  clear</span><br><span class=\"line\">  echo \"This is where the diskspace commands will do\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这允许菜单在我实现某个函数时仍然能正常操作。不需要我们写出所有函数之后才能让菜单投入使用。函数从<code>clear</code>命令开始，这样我们就能在一个干净的屏幕上执行该函数，不会收到原先菜单的干扰。</p>\n<p><strong>另外，将菜单布局本身作为一个函数来创建有利于菜单制作。</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function menu &#123;</span><br><span class=\"line\">  \tclear</span><br><span class=\"line\">trueecho</span><br><span class=\"line\">trueecho -e \"\\t\\t\\tSys Admin Menu\\n\"</span><br><span class=\"line\">trueecho -e \"\\t1. Display disk space\"</span><br><span class=\"line\">trueecho -e \"\\t2. Display logged on users\"</span><br><span class=\"line\">trueecho -e \"\\t3. Display memory usage\"</span><br><span class=\"line\">trueecho -e \"\\t0. Exit menu\\n\\n\"</span><br><span class=\"line\">trueecho -en \"\\t\\tEnter an option: \"</span><br><span class=\"line\">trueread -n 1 option</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们能在任何时候调用该函数以此重现菜单。</p>\n<h3 id=\"添加菜单逻辑\"><a href=\"#添加菜单逻辑\" class=\"headerlink\" title=\"添加菜单逻辑\"></a>添加菜单逻辑</h3><p>下一步我们需要创建程序逻辑将菜单布局和函数结合起来。这需要使用<code>case</code>命令。</p>\n<p><code>case</code>命令应该根据菜单中输入的字符来调用相应的函数，用case命令字符星号来处理所有不正确的菜单项。</p>\n<p>下面展示了典型菜单的<code>case</code>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu</span><br><span class=\"line\">case $option in</span><br><span class=\"line\">0)</span><br><span class=\"line\">truebreak ;;</span><br><span class=\"line\">1)</span><br><span class=\"line\">truediskspace ;;</span><br><span class=\"line\">2)</span><br><span class=\"line\">truewhoseon ;;</span><br><span class=\"line\">3)</span><br><span class=\"line\">truememusage ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">trueecho \"Sorry, wrong selection\";;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<p>这里首先调用<code>menu</code>函数清空屏幕并显示菜单。<code>menu</code>函数中的<code>read</code>命令会一直等待，知道用户在键盘上键入一个字符。然后<code>case</code>命令会接管余下的处理过程，基于字符调用相应的函数。</p>\n<h3 id=\"整合shell脚本菜单\"><a href=\"#整合shell脚本菜单\" class=\"headerlink\" title=\"整合shell脚本菜单\"></a>整合shell脚本菜单</h3><p>现在让我们将前面的步骤全部组合起来，看看它们是如何协作的。</p>\n<p>这是一个完整的菜单脚本例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test14</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> simple script menu</span></span><br><span class=\"line\"></span><br><span class=\"line\">function diskspace &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truedf -k</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function whoseon &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truewho</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function memusage &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truecat /proc/meminfo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function menu &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">trueecho</span><br><span class=\"line\">trueecho -e \"\\t\\t\\tSys Admin Menu\\n\"</span><br><span class=\"line\">trueecho -e \"\\t1. Display disk space\"</span><br><span class=\"line\">trueecho -e \"\\t2. Display logged on users\"</span><br><span class=\"line\">trueecho -e \"\\t3. Display memory usage\"</span><br><span class=\"line\">trueecho -e \"\\t0. Exit menu\\n\\n\"</span><br><span class=\"line\">trueecho -en \"\\t\\tEnter an option: \"</span><br><span class=\"line\">trueread -n 1 option</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">while [ 1 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">truemenu</span><br><span class=\"line\">truecase $option in</span><br><span class=\"line\">true0)</span><br><span class=\"line\">truetruebreak ;;</span><br><span class=\"line\">true1)</span><br><span class=\"line\">truetruediskspace ;;</span><br><span class=\"line\">true2)</span><br><span class=\"line\">truetruewhoseon ;;</span><br><span class=\"line\">true3)</span><br><span class=\"line\">truetruememusage ;;</span><br><span class=\"line\">true*)</span><br><span class=\"line\">truetrueclear</span><br><span class=\"line\">truetrueecho \"Sorry, wrong selection\" ;;</span><br><span class=\"line\">trueesac</span><br><span class=\"line\">trueecho -en \"\\n\\n\\t\\t\\tHit any key to continue\"</span><br><span class=\"line\">trueread -n 1 line</span><br><span class=\"line\">done</span><br><span class=\"line\">clear</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">truetrueSys Admin Menu</span><br><span class=\"line\"></span><br><span class=\"line\">1. Display disk space</span><br><span class=\"line\">2. Display logged on users</span><br><span class=\"line\">3. Display memory usage</span><br><span class=\"line\">0. Exit menu</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">trueEnter an option:</span><br></pre></td></tr></table></figure>\n<p>输入1：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件系统           1K-块     已用      可用 已用% 挂载点</span><br><span class=\"line\">udev             4006080        0   4006080    0% /dev</span><br><span class=\"line\">tmpfs             807220    81004    726216   11% /run</span><br><span class=\"line\">/dev/sda4      305650672 14226064 275828680    5% /</span><br><span class=\"line\">tmpfs            4036100     1724   4034376    1% /dev/shm</span><br><span class=\"line\">tmpfs               5120        4      5116    1% /run/lock</span><br><span class=\"line\">tmpfs            4036100        0   4036100    0% /sys/fs/cgroup</span><br><span class=\"line\">/dev/sda3         524272     4684    519588    1% /boot/efi</span><br><span class=\"line\">tmpfs             807220       52    807168    1% /run/user/1000</span><br><span class=\"line\">tmpfs             807220       16    807204    1% /run/user/125</span><br><span class=\"line\">/dev/sda2      421886972 23340376 398546596    6% /media/wsx/存储</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">truetruetrueHit any key to continue</span><br></pre></td></tr></table></figure>\n<p>其他都可以自己测试一下，我就不赘言了。</p>\n<h3 id=\"使用select命令\"><a href=\"#使用select命令\" class=\"headerlink\" title=\"使用select命令\"></a>使用select命令</h3><p><code>select</code>命令只需要一条命令就可以创建出菜单，然后获取输入的答案并自动处理。</p>\n<p>命令格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select variable in list</span><br><span class=\"line\">do</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p><strong><code>list</code>参数是由空格分隔的文本选项列表，这些列表构成了整个菜单。</strong><code>select</code>命令会将每个列表项显示成一个带编号的选项，然后为选项显示一个由<code>PS3</code>环境变量定义的特殊提示符。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat smenu1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using select <span class=\"keyword\">in</span> the menu</span></span><br><span class=\"line\"></span><br><span class=\"line\">function diskspace &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truedf -k</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function whoseon &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truewho</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function memusage &#123;</span><br><span class=\"line\">trueclear</span><br><span class=\"line\">truecat /proc/meminfo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PS3=\"Enter an option: \"</span><br><span class=\"line\">select option in \"Display disk space\" \"Display logged on users\" \"Display memory usage\" \"Exit program\"</span><br><span class=\"line\">do</span><br><span class=\"line\">truecase $option in</span><br><span class=\"line\">true\"Exit program\")</span><br><span class=\"line\">truetruebreak ;;</span><br><span class=\"line\">true\"Display disk space\")</span><br><span class=\"line\">truetruediskspace ;;</span><br><span class=\"line\">true\"Display logged on users\")</span><br><span class=\"line\">truetruememusage ;;</span><br><span class=\"line\">true\"Display memory usage\"）</span><br><span class=\"line\">truetruememusage ;;</span><br><span class=\"line\">true*)</span><br><span class=\"line\">truetrueclear</span><br><span class=\"line\">truetrueecho \"Sorry, wrong selection\";;</span><br><span class=\"line\">trueesac</span><br><span class=\"line\">done</span><br><span class=\"line\">clear</span><br></pre></td></tr></table></figure>\n<p>运行会自动生成如下菜单项：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ ./smenu1</span><br><span class=\"line\">1) Display disk space\t    3) Display memory usage</span><br><span class=\"line\">2) Display logged on users  4) Exit program</span><br><span class=\"line\">Enter an option:</span><br></pre></td></tr></table></figure>\n<p><strong>在使用<code>select</code>命令时，记住存储在变量中的结果值是整个文本字符串而不是跟菜单项相关联的数字。文本字符串是要在<code>case</code>语句中比较的内容。</strong></p>\n<h2 id=\"制作窗口\"><a href=\"#制作窗口\" class=\"headerlink\" title=\"制作窗口\"></a>制作窗口</h2><p><code>dialog</code>包能够用ANSI转义控制字符在文本环境中创建标准的窗口对话框。我们可以将这些对话框融入自己的shell脚本中，借此与用户进行交互。这部分我们来学习如何使用<code>dialog</code>包。</p>\n<p>安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install dialog</span><br></pre></td></tr></table></figure>\n<h3 id=\"dialog包\"><a href=\"#dialog包\" class=\"headerlink\" title=\"dialog包\"></a>dialog包</h3><p><code>dialog</code>包使用命令行参数来决定生成哪种窗口部件（widget）。部件是dialog包中窗口元素的术语。</p>\n<table>\n<thead>\n<tr>\n<th>部件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>calendar</td>\n<td>提供选择日期的日历</td>\n</tr>\n<tr>\n<td>checklist</td>\n<td>显示多个选项（其中每个选项都能打开或关闭）</td>\n</tr>\n<tr>\n<td>form</td>\n<td>构建一个带有标签以及文本字段（可以填写内容）的表单</td>\n</tr>\n<tr>\n<td>fselect</td>\n<td>提供一个文件选择窗口来浏览选择文件</td>\n</tr>\n<tr>\n<td>gauge</td>\n<td>显示完成的百分比进度条</td>\n</tr>\n<tr>\n<td>infobox</td>\n<td>显示一条消息，但不用等待回应</td>\n</tr>\n<tr>\n<td>inputbox</td>\n<td>提供一个输入文本用的文本表单</td>\n</tr>\n<tr>\n<td>inputmenu</td>\n<td>提供一个可编辑的菜单</td>\n</tr>\n<tr>\n<td>menu</td>\n<td>显示可选择的一系列选项</td>\n</tr>\n<tr>\n<td>msgbox</td>\n<td>显示一条消息，并要求用户选择OK按钮</td>\n</tr>\n<tr>\n<td>pause</td>\n<td>显示一个进度条来显示暂定期间的状态</td>\n</tr>\n<tr>\n<td>passwordbox</td>\n<td>显示一个文本框，但会隐藏输入的文本</td>\n</tr>\n<tr>\n<td>passwordform</td>\n<td>显示一个带标签的隐藏文本字段的表单</td>\n</tr>\n<tr>\n<td>radiolist</td>\n<td>提供一组菜单选项，但只能选择其中一个</td>\n</tr>\n<tr>\n<td>tailbox</td>\n<td>用tail命令在滚动窗口中显示文件的内容</td>\n</tr>\n<tr>\n<td>tailboxbg</td>\n<td>跟tailbox一样，但是在后台模式中运行</td>\n</tr>\n<tr>\n<td>textbox</td>\n<td>在滚动窗口中显示文件的内容</td>\n</tr>\n<tr>\n<td>timebox</td>\n<td>提供一个选择小时、分钟和秒数的窗口</td>\n</tr>\n<tr>\n<td>yesno</td>\n<td>提供一条带有Yes和No按钮的简单消息</td>\n</tr>\n</tbody>\n</table>\n<p>如上表所见，我们可以选择很多不同的部件。只需要多花点功夫就可以让脚本看起来更专业。</p>\n<p><strong>要在命令行上指定某个特定的部件，需要使用双破折线格式</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog --widget parameters</span><br></pre></td></tr></table></figure>\n<p>其中<code>widget</code>是上表中某个特定的部件，<code>parameters</code>定义了部件窗口的大小以及部件需要的文本。</p>\n<p><strong>每个dialog部件都提供了两种形式的输出：</strong></p>\n<ul>\n<li>使用STDERR</li>\n<li>使用退出状态码</li>\n</ul>\n<p>可以通过<code>dialog</code>命令的退出状态码来确定用户选择的按钮。如果选择了Yes或OK按钮，命令会返回状态码<code>0</code>。如果选择了Cancer或No按钮，命令会返回状态码<code>1</code>。可用标准的<code>$?</code>变量来确定<code>dialog</code>部件具体选择了哪个按钮。</p>\n<p>如果部件返回了数据，<code>dialog</code>命令会将数据发送到STDERR。我们可以用标准的bash shell方法将其重定向到另一个文件或文件描述符中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog --inputbox \"Enter your age:\" 10 20 2&gt;age.txt</span><br></pre></td></tr></table></figure>\n<p>这条命令将文本框输入的文本重定向到age.txt文本中。</p>\n<h4 id=\"msgbox部件\"><a href=\"#msgbox部件\" class=\"headerlink\" title=\"msgbox部件\"></a>msgbox部件</h4><p><code>msgbox</code>部件是对话框中最常见的类型。它会在窗口中显示一条简单的信息，直到用户点击OK后消失。</p>\n<p>使用格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog --msgbox text height width</span><br></pre></td></tr></table></figure>\n<p><code>text</code>参数是要在窗口显示的字符串，<code>height</code>与<code>width</code>参数设定自动换行的窗口大小。如果想要在窗口加一个标题，可以使用<code>--title</code>参数，后接作为标题的文本。</p>\n<p>例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog --title Testing --msgbox \"This is a test\" 10 20</span><br></pre></td></tr></table></figure>\n<p>输入命令后，消息框会显示在终端上。如果你的终端仿真器支持鼠标，可以单击OK来关闭对话框，也可以按下回车键。</p>\n<h4 id=\"yesno部件\"><a href=\"#yesno部件\" class=\"headerlink\" title=\"yesno部件\"></a>yesno部件</h4><p>该部件在窗口底部生成两个按钮：一个是Yes，一个是No。用户可以用鼠标、制表符或者键盘方向键来切换按钮。选择按钮则使用空格或者回车键。</p>\n<p>下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~$ dialog --title \"Please answer\" --yesno \"Is this thing on?\" 10 20</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 中间终端有输出</span></span><br><span class=\"line\">wsx@wsx:~$ echo $?</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<p><code>dialog</code>命令的退出状态码会根据用户选择的按钮来设置。选择No返回1，选择Yes就是0。</p>\n<h4 id=\"inputbox部件\"><a href=\"#inputbox部件\" class=\"headerlink\" title=\"inputbox部件\"></a>inputbox部件</h4><p>inputbox部件提供了一个简单的文本框区域来输入文本字符串，dialog会将它传到STDERR，我们需要重定向获得输入。inputbox提供了两个按钮：OK和Cancel。如果选择了OK，命令退出状态码为0，否则为1。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ dialog --inputbox \"Enter your age:\" 10 20 2&gt;age.txt</span><br><span class=\"line\">wsx@wsx:~/tmp$ cat age.txt</span><br><span class=\"line\">24</span><br></pre></td></tr></table></figure>\n<p>如果你自己运行过的话就会注意到该值后面没有换行符，这让我们能够轻松将文本内容重定向到脚本变量中，以获得用户输入的值。</p>\n<h4 id=\"textbox部件\"><a href=\"#textbox部件\" class=\"headerlink\" title=\"textbox部件\"></a>textbox部件</h4><p>textbox部件是在窗口中显示大量信息的极佳办法。它会生成一个滚动窗口来显示由参数所指定的文件中的文本。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ dialog --textbox /etc/passwd 15 45</span><br></pre></td></tr></table></figure>\n<p><code>/etc/passwd</code>文件内容显示在可滚动的文本窗口中，可以用方向键来左右或上下滚动显示文件的内容。窗口底部的行会显示当前查看文本处于文件中的哪个位置（百分比）。文本框只包含一个用来选择退出部件的Exit按钮。</p>\n<h4 id=\"menu部件\"><a href=\"#menu部件\" class=\"headerlink\" title=\"menu部件\"></a>menu部件</h4><p>我们可以用这个部件来创建之前（上一篇笔记）中制作的文本菜单的窗口版本。只要为每个选项提供一个选择标号和文本就行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ dialog --menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 4 \"Exit\" 2&gt;test.txt</span><br></pre></td></tr></table></figure>\n<p><strong>第一个参数定义了菜单的标题，之后的两个参数定义了菜单窗口的高和宽，而第四个参数则定义了在窗口中一次显示的菜单项总数。如果存在更多选择，则有滚动条。</strong></p>\n<p>菜单项必须使用菜单对：第一个元素是用来选择菜单项的标号（必须唯一）；第二个元素是菜单中使用的文本。</p>\n<p>dialog命令会将选定（鼠标点击或回车键或选择OK）的菜单项文本发送到STDERR。</p>\n<h4 id=\"fselect部件\"><a href=\"#fselect部件\" class=\"headerlink\" title=\"fselect部件\"></a>fselect部件</h4><p>该部件在处理文件名时非常方便。不用强制用户键入文件名，我们就可以用<code>fselect</code>部件来浏览文件的位置并选择文件。</p>\n<p>使用格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ dialog --title \"Select a file\" --fselect $HOME/ 10 50 2&gt;file.txt</span><br></pre></td></tr></table></figure>\n<p><strong>第一个参数是窗口使用的其实目录位置。<code>fselect</code>部件窗口由左侧的目录列表、右侧的文件列表和含有当前选定的文件或目录的简单文本框组成。可以手动在文本框键入文件名，或者用目录和文件列表来选定（使用空格键选定）</strong>。</p>\n<h3 id=\"dialog选项\"><a href=\"#dialog选项\" class=\"headerlink\" title=\"dialog选项\"></a>dialog选项</h3><p>除了标准部件，dialog还有大量定制的选项。前面我们使用的<code>title</code>就是一个。</p>\n<p>下面显示了命令可用的选项：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>–add-widget</td>\n<td>继续下一个对话框直到按下Esc或Cancel选项</td>\n</tr>\n<tr>\n<td>–aspect ratio</td>\n<td>直到窗口宽度和高度的宽高比</td>\n</tr>\n<tr>\n<td>–backtitle title</td>\n<td>直到显示在屏幕顶部背景上的图标</td>\n</tr>\n<tr>\n<td>–begin x y</td>\n<td>指定窗口左上角的起始位置</td>\n</tr>\n<tr>\n<td>–cancel-label label</td>\n<td>指定Cancel按钮的替代标签</td>\n</tr>\n<tr>\n<td>–clear</td>\n<td>用默认的对话背景色来清空屏幕内容</td>\n</tr>\n<tr>\n<td>–colors</td>\n<td>在对话文本中嵌入ANSI色彩编码</td>\n</tr>\n<tr>\n<td>–cr-wrap</td>\n<td>在对话文本中允许使用换行符并强制换行</td>\n</tr>\n<tr>\n<td>–create-rc file</td>\n<td>将示例配置文件的内容复制到指定的file文件中</td>\n</tr>\n<tr>\n<td>–defaultno</td>\n<td>将yes/no对话框的默认答案设为no</td>\n</tr>\n<tr>\n<td>–default-item string</td>\n<td>设定复选列表、表单或菜单对话中的默认项</td>\n</tr>\n<tr>\n<td>–exit-label label</td>\n<td>指定Exit按钮的替代标签</td>\n</tr>\n<tr>\n<td>–extra-button</td>\n<td>在OK按钮和Cancel按钮之间显示一个额外按钮</td>\n</tr>\n<tr>\n<td>–extra-label label</td>\n<td>指定额外按钮的替换标签</td>\n</tr>\n<tr>\n<td>–help</td>\n<td>显示dialog命令的帮助信息</td>\n</tr>\n<tr>\n<td>–help-button</td>\n<td>在OK按钮和Cancel按钮后显示一个Help按钮</td>\n</tr>\n<tr>\n<td>–help-label label</td>\n<td>指定Help按钮的替换标签</td>\n</tr>\n<tr>\n<td>–help-status</td>\n<td>当选定Help按钮后，在帮助信息后写入多选列表、单选列表或表单信息</td>\n</tr>\n<tr>\n<td>–ignore</td>\n<td>忽略dialog不能识别的选项</td>\n</tr>\n<tr>\n<td>–input-fd fd</td>\n<td>指定STDIN之外的另一个文件描述符</td>\n</tr>\n<tr>\n<td>–insecure</td>\n<td>在passwd部件中键入内容时显示星号</td>\n</tr>\n<tr>\n<td>–item-help</td>\n<td>为多选列表、单选列表或菜单中的每个标号在屏幕底部添加一个帮助栏</td>\n</tr>\n<tr>\n<td>–keep-window</td>\n<td>不要清除屏幕上显示过的部件</td>\n</tr>\n<tr>\n<td>–max-input size</td>\n<td>指定输入的最大字符串长度。默认为2048</td>\n</tr>\n<tr>\n<td>–nocancel</td>\n<td>隐藏Cancel按钮</td>\n</tr>\n<tr>\n<td>–no-collapse</td>\n<td>不要将对话文本中的制表符转换为空格</td>\n</tr>\n<tr>\n<td>–no-kill</td>\n<td>将tailboxbg对话放到后台，并禁止该进程的SIGHUP信号</td>\n</tr>\n<tr>\n<td>–no-label label</td>\n<td>为No按钮指定替换标签</td>\n</tr>\n<tr>\n<td>–no-shadow</td>\n<td>不要显示对话窗口的阴影效果</td>\n</tr>\n<tr>\n<td>–ok-label label</td>\n<td>指定OK按钮的替换标签</td>\n</tr>\n<tr>\n<td>–output-fd fd</td>\n<td>指定除STDERR之外的另一个输出文件描述符</td>\n</tr>\n<tr>\n<td>–print-maxsize</td>\n<td>将对话窗口的最大尺寸打印到输出中</td>\n</tr>\n<tr>\n<td>–print-size</td>\n<td>将每个对话窗口的大小打印到输出中</td>\n</tr>\n<tr>\n<td>–print-version</td>\n<td>将dialog的版本号打印到输出中</td>\n</tr>\n<tr>\n<td>–separate-output</td>\n<td>一次一行地输出checklist部件的结果，不使用引号</td>\n</tr>\n<tr>\n<td>–separator string</td>\n<td>指定用于分隔部件输出的字符串</td>\n</tr>\n<tr>\n<td>–separate-widget string</td>\n<td>指定用于分隔部件输出的字符串</td>\n</tr>\n<tr>\n<td>–shadow</td>\n<td>在每个窗口右下角绘制阴影</td>\n</tr>\n<tr>\n<td>–single-quoted</td>\n<td>需要时对多选列表的输出采用单引号</td>\n</tr>\n<tr>\n<td>–sleep sec</td>\n<td>在处理完对话窗口后延迟指定的秒数</td>\n</tr>\n<tr>\n<td>–stderr</td>\n<td>将输出发送到STDERR（默认）</td>\n</tr>\n<tr>\n<td>–stdout</td>\n<td>将输出发送到STDOUT</td>\n</tr>\n<tr>\n<td>–tab-correct</td>\n<td>将制表符转换为空格</td>\n</tr>\n<tr>\n<td>–tab-len n</td>\n<td>指定一个制表符占用的空格数（默认为8）</td>\n</tr>\n<tr>\n<td>–timeout sec</td>\n<td>指定无用户输入时，sec秒后退出并返回错误代码</td>\n</tr>\n<tr>\n<td>–title title</td>\n<td>指定对话窗口的标题</td>\n</tr>\n<tr>\n<td>–trim</td>\n<td>从对话文本中删除前导空格和换行符</td>\n</tr>\n<tr>\n<td>–visit-tiems</td>\n<td>修改对话窗口制表符的停留位置，使其包括选项列表</td>\n</tr>\n<tr>\n<td>–yes-label label</td>\n<td>为Yes按钮指定替换标签</td>\n</tr>\n</tbody>\n</table>\n<p> <strong><code>--backtitle</code>选项是为脚本中的菜单创建公共标题的简便办法。</strong>上表提供的强大特性允许我们创建任何需要的窗口。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dialog命令支持运行时配置。该命令会根据配置文件模板创建一份配置文件。dialog启动时会先去检查是否设置了DIALOGRC环境变量，该变量会保存配置文件名信息。如果未设置该变量或未找到该文件，它会将<span class=\"variable\">$HOME</span><span class=\"regexp\">/.dialogrc作为配置文件。如果这个文件还不存在的话就尝试查找编译时指定的GLOBALRC文件，也就是/</span>etc<span class=\"regexp\">/dialogrc。如果还不存在就用编译时的默认值。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"在脚本中使用dialog命令\"><a href=\"#在脚本中使用dialog命令\" class=\"headerlink\" title=\"在脚本中使用dialog命令\"></a>在脚本中使用dialog命令</h3><p><strong>必须记住两件事：</strong></p>\n<ul>\n<li>如果有Cancel或No按钮，检查dialog命令的退出状态码</li>\n<li>重定向STDERR来获得输出值</li>\n</ul>\n<p>接下来是一个简单的实例，使用dialog部件生成我们之前（上一篇笔记）所创建的系统管理菜单。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~$ cat menu3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using dialog to create a menu</span></span><br><span class=\"line\"></span><br><span class=\"line\">temp=$(mktemp -t test.XXXXXX)</span><br><span class=\"line\">temp2=$(mktemp -t test2.XXXXXX)</span><br><span class=\"line\"></span><br><span class=\"line\">function diskspace &#123;</span><br><span class=\"line\">        df -k &gt; $temp</span><br><span class=\"line\">        dialog --textbox $temp 20 60</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function whoseon &#123;</span><br><span class=\"line\">        who &gt; $temp</span><br><span class=\"line\">        dialog --textbox $temp 20 50</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function menusage &#123;</span><br><span class=\"line\">        cat /proc/meminfo &gt; $temp</span><br><span class=\"line\">        dialog --textbox $temp 20 50</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">while [ 1 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">dialog --menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 0 \"Exit\" 2&gt; $temp2</span><br><span class=\"line\">if [ $? -eq 1 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">  break</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">selection=$(cat $temp2)</span><br><span class=\"line\"></span><br><span class=\"line\">case $selection in</span><br><span class=\"line\">1)</span><br><span class=\"line\">        diskspace ;;</span><br><span class=\"line\">2)</span><br><span class=\"line\">        whoseon ;;</span><br><span class=\"line\">3)</span><br><span class=\"line\">        memusage ;;</span><br><span class=\"line\">0)</span><br><span class=\"line\">        break ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">        dialog --msgbox \"Sorry, invalid selection\" 10 30</span><br><span class=\"line\">esac</span><br><span class=\"line\">done</span><br><span class=\"line\">rm -f $temp 2&gt; /dev/null</span><br><span class=\"line\">rm -f $temp 2&gt; /dev/null</span><br></pre></td></tr></table></figure>\n<p>使用while循环加一个真值常量创建了一个无限循环来显示菜单对话。当执行完每个函数后，脚本会返回继续显示菜单。</p>\n<p>脚本使用了mktemp命令创建两个临时文件来保存dialog命令的数据。</p>\n<p>后面本来还有图形环境中（KDE、GNOME）使用的一些流行包介绍。以后等我使用ubuntu写笔记时再作学习和介绍吧。</p>"},{"title":"R-面向对象编程","author":"王诗翔","date":"2017-09-19T16:00:00.000Z","_content":"\n\n\n\n## 一些概念\n\n这里首先要提及一些概念，然后我们再看具体的实例加以理解。\n\n每一个单独的**对象**都可以被称为对应**类**的一个**实例**（instance）。操作指定类的函数称为**方法**（method）。\n\n把程序接口从具体的实现细节中分离开来的过程称为**封装**。\n\n在OOP（面向对象编程）中，我们可以通过一个类创建出另外一个类，只需要指定新类的不同信息即可，这种方法称为**继承**。由此衍生出，被继承的类称为**父类或超类**（superclass），新创建的类称为**子类**（subclass）。\n\n在OOP中，允许同一个方法名操纵不同对象并得到不同的结果，称为**多态**（polymorphism）。\n\n通过一系列的其他类来创建新类的过程称为**组合**（composition）。在一些语言中，一个类可以从多个类中继承方法，称为**多重继承**（multiple inheritance）。\n\n\n<!-- more -->\n\n\n## 实例\n\n大部分其他语言（比如java）的OOP概念都已经包含在R中，但R中具体的语法和结构却有所不同。我们需要通过调用函数`setClass`来定义一个类，并且需要调用`setMethod`函数来定义方法。\n\n我们先看一个简单的例子：\n\n我们要实现一个类用来表示时间序列，想定义一个对象包含如下信息：\n\n- 一个数据集合，取自固定周期的时间段\n- 一个开始时间\n- 一个结束时间\n- 时间序列的周期\n\n对于可以通过某些属性计算出来的属性信息是多余的。我们从定义一个名为“TimeSeries”的新类开始。\n\n**我们将通过一个包含数据、开始时间、结束时间的数值型向量来描述一个时间序列。然后可以通过它们来计算出时间单位、频率和周期。**\n\n作为类的使用者，如何展现这些信息并不重要。但是对于类的实现者来说，则非常重要。\n\nR语言中对象存储信息的位置称为**槽**（slot）。我们将该对象需要包含的槽命名为`data`、`start`、`end`。使用`setClass`函数来创建新类：\n\n```R\n> setClass(\"TimeSeries\",\n+   representation(\n+     data=\"numeric\",\n+     start=\"POSIXct\",\n+     end=\"POSIXct\"\n+     )\n+ )\n\n```\n\n`representation`部分说明了每个槽所包含的R对象的类型。我们使用`new`函数（针对S4对象的一个泛型[构造方法](https://baike.baidu.com/item/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/10455265?fr=aladdin)）来新建一个TimeSeries对象。第一个参数名指定类名，其他参数指定槽的值：\n\n```R\n> my.TimeSeries <- new(\"TimeSeries\",\n+   data = c(1,2,3,4,5,6),\n+   start=as.POSIXct(\"07/01/2009 0:00:00\", tz=\"GMT\",\n+                   format=\"%m/%d/%Y %H:%M:%S\"),\n+   end=as.POSIXct(\"07/01/2009 0:05:00\", tz=\"GMT\",\n+                   format=\"%m/%d/%Y %H:%M:%S\")\n+ )\n\n> my.TimeSeries\nAn object of class \"TimeSeries\"\nSlot \"data\":\n[1] 1 2 3 4 5 6\n\nSlot \"start\":\n[1] \"2009-07-01 GMT\"\n\nSlot \"end\":\n[1] \"2009-07-01 00:05:00 GMT\"\n```\n\n**对于一个槽来说，并不是所有的可能值都是有效的。**比如，我们想要确保end发生在start之后，并且两者的长度是1。我们需要编写函数来验证该对象的有效性。R允许自定义函数用来验证特定的类。我们可以通过`setValidity`函数来设定。\n\n```R\n> setValidity(\"TimeSeries\",\n+   function(object){\n+     object@start <= object@end &&\n+     length(object@start) == 1 &&\n+     length(object@end) == 1\n+   }\n+ )\nClass \"TimeSeries\" [in \".GlobalEnv\"]\n\nSlots:\n\nName:     data   start     end\nClass: numeric POSIXct POSIXct\n\n```\n\n现在我们可以检查对象在`validObject`函数下是否有效。\n\n```R\n> validObject(my.TimeSeries)\n[1] TRUE\n```\n\n之后我们新建`TimeSeries`对象时，R将会自动检查新对象的有效性，并通过抛出错误来拒绝错误的对象。\n\n（也可以在创建类的时候设定验证有效性的方法，详见setClass的完整定义）\n\n定义了类之后，我们来创建新的方法。时间序列有一个属性是周期。我们可以创建一个方法用来提取时间序列中的周期信息。\n\n```R\n> period.TimeSeries <- function(object) {\n+   if (length(object@data) > 1) {\n+     (object@end - object@start) / (length(object@data) - 1)\n+   } else {\n+     Inf\n+   }\n+ }\n```\n\n**假如我们想创建一组函数用来从不同的对象中提取数据序列，而不用考虑对象的类型（即多态）。R提供了一种叫作泛型函数的机制可以实现。**当我们对某个对象调用泛型函数时，R会基于该对象的类找到正确的方法去执行。我们创建一个函数来从泛型对象中提取数据序列：\n\n```R\n> series <- function(object) { object@data }\n> setGeneric(\"series\")\n[1] \"series\"\n> series(my.TimeSeries)\n[1] 1 2 3 4 5 6\n```\n\n调用`setGeneric`可以将`series`重定义为泛型函数，其默认的方法是旧的`series`函数的函数体：\n\n```R\n> series\nstandardGeneric for \"series\" defined from package \".GlobalEnv\"\n\nfunction (object)\nstandardGeneric(\"series\")\n<environment: 0x205e930>\nMethods may be defined for arguments: object\nUse  showMethods(\"series\")  for currently available ones.\n> showMethods(\"series\")\nFunction: series (package .GlobalEnv)\nobject=\"ANY\"\nobject=\"TimeSeries\"\n    (inherited from: object=\"ANY\")\n```\n\n\n\n\n\n更进一步地，我们创建一个泛型函数来从对象中提取周期信息，并且特别指定它用来处理我们之前的创建的类。\n\n```R\n> period <- function(object) { object@period }\n> setGeneric(\"period\")\n[1] \"period\"\n> setMethod(period, signature=c(\"TimeSeries\"), definition=period.TimeSeries)\n[1] \"period\"\nattr(,\"package\")\n[1] \".GlobalEnv\"\n> showMethods(\"period\")\nFunction: period (package .GlobalEnv)\nobject=\"ANY\"\nobject=\"TimeSeries\"\n```\n\n调用泛型函数`period`可以计算`TimeSeries`对象：\n\n```R\n> period(my.TimeSeries)\nTime difference of 1 mins\n```\n\n也可以对已存在的泛型函数定义自己的方法，比如为我们创建的类定义一个`summary`方法：\n\n```R\n> setMethod(\"summary\",\n+    signature=\"TimeSeries\",\n+    definition=function(object) {\n+      print(paste(object@start,\n+                     \" to \",\n+                 object@end,\n+                 sep=\"\", collapse=\"\"))\n+      print(paste(object@data, sep=\"\", collapse=\",\"))\n+    }\n+  )\n[1] \"summary\"\n> summary(my.TimeSeries)\n[1] \"2009-07-01 to 2009-07-01 00:05:00\"\n[1] \"1,2,3,4,5,6\"\n```\n\n甚至可以为一个已经存在的操作符定义新的方法：\n\n```R\n> setMethod(\"[\",\n+   signature=c(\"TimeSeries\"),\n+   definition=function(x, i, j, ..., drop) {\n+     x@data[i]\n+   }\n+ )\n[1] \"[\"\n> my.TimeSeries[3]\n[1] 3\n\n\n> my.TimeSeries # 查看my.TimeSeries对象\nAn object of class \"TimeSeries\"\nSlot \"data\":\n[1] 1 2 3 4 5 6\n\nSlot \"start\":\n[1] \"2009-07-01 GMT\"\n\nSlot \"end\":\n[1] \"2009-07-01 00:05:00 GMT\"\n\n```\n\n\n\n下面演示如何基于`TimeSeries`类实现一个`WeightHistory`类以记录个人的历史体重信息。\n\n```R\n> setClass(\"TimeSeries\",\n+   representation(\n+     data=\"numeric\",\n+     start=\"POSIXct\",\n+     end=\"POSIXct\"\n+\n+     )\n+ )\n> setValidity(\"TimeSeries\",\n+   function(object) {\n+     object@start <= object@end &&\n+     length(object@start)==1 &&\n+     length(object@end)==1\n+   }\n+ )\nClass \"TimeSeries\" [in \".GlobalEnv\"]\n\nSlots:\n\nName:     data   start     end\nClass: numeric POSIXct POSIXct\n```\n\n创建子类：\n\n```R\n> setClass(\n+   \"WeightHistory\",\n+   representation(\n+     height = \"numeric\",\n+     name = \"character\"\n+  ),\n+   contains = \"TimeSeries\"\n+ )\n\n```\n\n添加实例对象：\n\n```R\n> john.doe <- new(\"WeightHistory\",\n+   data=c(170,169,171,168,170,169),\n+   start=as.POSIXct(\"02/14/2019 0:00:00\", tz=\"GMT\",\n+     format=\"%m/%d/%Y %H:%M:%S\"),\n+   end=as.POSIXct(\"03/28/2019 0:00:00\", tz=\"GMT\",\n+     format=\"%m/%d/%Y %H:%M:%S\"),\n+   height=72,\n+   name=\"John Doe\")\n> john.doe\nAn object of class \"WeightHistory\"\nSlot \"height\":\n[1] 72\n\nSlot \"name\":\n[1] \"John Doe\"\n\nSlot \"data\":\n[1] 170 169 171 168 170 169\n\nSlot \"start\":\n[1] \"2019-02-14 GMT\"\n\nSlot \"end\":\n[1] \"2019-03-28 GMT\"\n\n```\n\n我们还可以通过另外一种方式构建一个体重记录。假设我们已经创建好了一个包含人名和体重的`Person`类。\n\n```R\n> setClass(\"Person\",\n+   representation(\n+     height = \"numeric\",\n+     name = \"character\")\n+ )\n```\n\n我们可以创建一个基于`TimeSeries`类和`Person`类的体重记录类。\n\n```R\n> setClass(\n+   \"AltWeightHistory\",\n+   contains = c(\"TimeSeries\", \"Person\")\n+ )\n```\n\n可以发现，如果我们已经有了先期的开发经验或者相关类的代码，对新任务进行重构是非常方便的。短短几行代码就搞定了，充分利用了代码的可重复性。这也是OOP在高级语言中如此普遍的一个原因吧。\n\n## S4类\n\n我们接下来更深入地探讨构造类的函数。\n\n### 类的定义\n\nR中使用`setClass`函数来创建一个新类，格式如下：\n\n```R\nsetClass(Class, representation, prototype, contains=character(), validity, access, where, version, sealed, package, S3methods=FALSE)\n```\n\n描述\n\n- Class - 字符串，用来指定新类的名字（这是唯一必需的参数）\n- representation - 列表，列表的每一个元素代表不同的槽的类型，元素名为槽名（可以用\"ANY\"来指定类型为任意）\n- prototype - 包含各个槽的默认值的对象\n- contains - 字符向量，包含该类继承的父类名\n- validity - 验证该类的对象有效性的函数（默认没有检查），可以后续使用`setValidity`函数来设置\n- access - 无作用，为了和S-PLUS兼容\n- where - 存储该对象定义的环境\n- version - 无作用，为了和S-PLUS兼容\n- sealed - 逻辑值，表示该类是否还能被setClass按照原来的类名重新定义\n- package - 字符串，指定该类所在的R包名\n- S3methods - 逻辑值，表示是否使用了S3类写这个类\n\n为了简化类的创建，`methods`包提供了`representation`以及`protype`函数。它们在将其他类继承为数据部分、拥有多个父类、或者组合继承类和槽的时候非常有用。\n\n值得注意的是，有些名字是属性的保留字因而不能作为槽名使用，包括\"class\",\"comment\",\"dim\",\"dimnames\",\"names\",\"rownames\"和\"tsp\"。\n\n\n\n可以使用`setIs`函数来显式地定义继承关系。\n\n```R\nsetIs(class1, class2, test=NULL, coerce=NULL, replace=NULL,\n     by=character(), where=topenv(parent.frame()), classDef=, extensionObject=NULL, doComplete=TRUE)\n```\n\n可以使用`setValidity`函数来显式地设置类的验证函数：\n\n```R\nsetValidity(Class, method, where=topenv(parent.frame()))\n```\n\nR可以定义一个虚类作为多个其他类的父类。如果一个虚类本身不包含任何数据，但是如果你想要创建一批函数用于一批类中，这种方式非常有用。可以通过`setClassUnion`函数实现：\n\n```R\nsetClassUnion(name, members, where)\n```\n\n- name - 新的父类的名字\n- members - 字符向量，指定所有子类的名字\n- where - 新类所在的环境\n\n\n\n### 对象的新建\n\n我们可以通过调用类的`new`方法新建一个对象。专业术语中称为构造函数。\n\n```R\nnew(c, ...)\n```\n\n在调用`new`的时候，我们可以通过指定参数将数据填充到槽中。如果`c`中存在名为`initialize`的方法，那么当新的对象被创建后，会立刻调用`initialize`函数进行初始化。\n\n\n\n### 槽的存取\n\n我们可以使用`slot`函数或者简化符号`@`来访问存储对象某个槽中的值，当然也可以用它来赋值。\n\n```R\n> john.doe@name\n[1] \"John Doe\"\n> slot(john.doe, \"name\")\n[1] \"John Doe\"\n```\n\n\n\n### 对象的操作\n\n使用`is(o, c)`函数测试对象`o`是否是类`c`的成员。使用函数`extend(c1, c2)`测试类`c1`是否继承于类`c2`。\n\n如果要得到对象`o`包含的所有槽的名称，使用`slotNames(o)`，如果要得到槽的类型，使用`getSlots(o)`。这两个函数也可以对类使用。\n\n```R\n> getSlots(\"WeightHistory\")\n     height        name        data       start         end\n  \"numeric\" \"character\"   \"numeric\"   \"POSIXct\"   \"POSIXct\"\n\n> slotNames(\"WeightHistory\")\n[1] \"height\" \"name\"   \"data\"   \"start\"  \"end\"\n> slotNames(\"john.doe\")\ncharacter(0)\n> slotNames(john.doe)\n[1] \"height\" \"name\"   \"data\"   \"start\"  \"end\"\n```\n\n注意一些差别，有引号和没引号结果是不同的。\n\n\n\n### 方法\n\n泛型函数允许使用同一个函数名来代表很多不同的函数，针对不同的类，调用不同的参数。\n\n设定方法的第一步是创建一个合适的泛型函数，如果该函数还不存在，可以使用`setGeneric`函数来创建这个泛型方法：\n\n```R\nsetGeneric(name, def=, group=list(), valueClass=character(),\n          where=, package=, signature=, useAsDefault=,\n          genericFUnction=, simpleInheritanceOnly=)\n```\n\n要把一个方法关联到某个类（具体而言就是指定泛型函数的signature参数），可以使用`setMethod`函数：\n\n```R\nsetMethod(f, signature=character(), definition,\n         where = topenv(parent.frame()),\n         valueClass=NULL, sealed=FALSE)\n```\n\n\n\n\n\n#### 方法的管理\n\n`methods`包包含了很多管理泛型方法的函数。\n\n| 函数            | 描述                            |\n| ------------- | ----------------------------- |\n| isGeneric     | 检查指定的泛型函数是否存在                 |\n| isGroup       | 检查指定的分组泛型函数是否存在               |\n| removeGeneric | 删除某个泛型函数关联的所有方法以及该泛型函数本身      |\n| dumpMethod    | 转存储某个方法到文件                    |\n| findFunction  | 根据函数名查找函数对象，返回搜寻列表中的位置或当前顶层环境 |\n| dumpMethods   | 转存储一个泛型函数关联的所有方法              |\n| signature     | 返回在某个指定路径下定义了方法的泛型函数的名称       |\n| removeMethods | 删除某个泛型函数关联的所有方法               |\n| setGeneric    | 根据指定的函数名创建新的泛型函数              |\n\n`methods`包同样包含了很多管理方法的函数。\n\n| 函数                      | 描述                        |\n| ----------------------- | ------------------------- |\n| getMethod, selectMethod | 返回某个特定泛型函数和类型标记的方法        |\n| existsMethod, hasMethod | 检查某个方法（指定了泛型函数名和类型标记）是否存在 |\n| findMethod              | 返回包含了某个方法的包               |\n| showMethods             | 显示关联了某个S4泛型的所有方法          |\n\n\n\n更多的帮助通过`library(help=\"methods\")`命令获取。\n\n\n\n## 守旧派OOP: S3\n\n如果我们想要用R实现复杂的工程，应该使用S4的类和对象。不幸的是，我们在R中是很难避免S3对象的。比如统计包中的大部分建模工具都是用S3对象实现的。为了能够对这些软件包进行更好地理解、修改和扩展。我们必须了解S3类是如何实现的。\n\n### S3的类\n\nS3对象只是原始的R对象加上一些额外的属性（包括一个类名）而已。它没有正式的定义，我们可以手工修改属性甚至类。\n\n之前我们使用了时间序列作为S4的例子，其实在R中已经存在了表示它的S3类，称为`ts`对象。我们这里创建简单的时间序列对象，查看它的属性以及一些底层对象。\n\n```R\n> my.ts <- ts(data=c(1,2,3,4,5), start=c(2009,2), frequency=12)\n> my.ts\n     Feb Mar Apr May Jun\n2009   1   2   3   4   5\n> attributes(my.ts)\n$tsp\n[1] 2009.083 2009.417   12.000\n\n$class\n[1] \"ts\"\n\n> typeof(my.ts)\n[1] \"double\"\n> unclass(my.ts)\n[1] 1 2 3 4 5\nattr(,\"tsp\")\n[1] 2009.083 2009.417   12.000\n> attributes(my.ts)\n$tsp\n[1] 2009.083 2009.417   12.000\n\n$class\n[1] \"ts\"\n\n```\n\n可以发现`ts`对象只不过是一个数值向量加上`class`和`tsp`这两个属性。`class`属性起始只是`ts`对象的类名。我们无法像S4对象中操作槽来提取S3对象的属性。\n\n```R\n> my.ts@tsp\n错误: 非S4类别的对象(类别为\"ts\")没有\"tsp\"这样的槽\n```\n\n\n\n### S3方法\n\nS3的泛型函数是通过命名约定来实现的。以下是步骤：\n\n1. 为泛型函数挑选一个名字，这里我们命名为`gname`。\n2. 新建一个名为`gname`的函数，在`gname`的函数体中，调用`UseMethod(\"gname\")`\n3. 为每一个想要使用`gname`的类创建一个名为`gname.classname`的函数，该函数的第一个参数必须是该对象的类名`classname`。\n\n\n\n一个现成的例子是`plot`函数：\n\n```R\n> plot\nfunction (x, y, ...)\nUseMethod(\"plot\")\n<bytecode: 0x1851c30>\n<environment: namespace:graphics>\n\n```\n\n在调用`plot`的时候，`plot`将会调用`UseMethod(\"plot\")`。`UseMethod`会查看`x`对象的类，然后查找名为`plot.class`的函数，然后调用该函数。\n\n比如给我们之前定义的`TimeSeries`类添加一个`plot`方法。\n\n```R\n> plot.TimeSeries <- function(object, ...) {\n+   plot(object@data, ...)\n+ }\n```\n\n### 在S4的类中使用S3的类\n\n我们不能直接指定S3的类到S4的槽。如果想要做到，我们需要基于S3的类创建一个S4的类。一个简单的方式是使用`setOldClass`函数：\n\n```R\nsetOldClass(Classes, prototype, where, test=FALSE, S4Class)\n```\n\n### 查找隐藏的S3方法\n\n有时候我们会发现一些包的作者会选择隐藏单个方法，而把方法的实现封装在包中。这样可以鼓励用户去使用泛型函数。\n\n```R\n> library(lattice)\n> methods(histogram)\n[1] histogram.factor*  histogram.formula* histogram.numeric*\nsee '?methods' for accessing help and source code\n\n```\n\n有时候我们可能需要找回这些隐藏的方法（想要查看源代码），这时候可以使用`getS3method`函数。例如，想要取到`histgram.formula`中的代码，可以使用以下命令：\n\n```R\n> getS3method(f=\"histogram\", class=\"formula\")\n```\n\n或者使用`getAnywhere`函数：\n\n```R\n> getAnywhere(histogram.formula)\n```\n\n\n\n***\n\n学习整理自《R核心技术手册》\n","source":"_posts/2017-09-20-OOPinR.md","raw":"---\ntitle: \"R-面向对象编程\"\nauthor: 王诗翔\ndate: 2017-09-20\ncategories:\n- 极客R\n- 基本理论\ntags:\n- R\n- OOP\n---\n\n\n\n\n## 一些概念\n\n这里首先要提及一些概念，然后我们再看具体的实例加以理解。\n\n每一个单独的**对象**都可以被称为对应**类**的一个**实例**（instance）。操作指定类的函数称为**方法**（method）。\n\n把程序接口从具体的实现细节中分离开来的过程称为**封装**。\n\n在OOP（面向对象编程）中，我们可以通过一个类创建出另外一个类，只需要指定新类的不同信息即可，这种方法称为**继承**。由此衍生出，被继承的类称为**父类或超类**（superclass），新创建的类称为**子类**（subclass）。\n\n在OOP中，允许同一个方法名操纵不同对象并得到不同的结果，称为**多态**（polymorphism）。\n\n通过一系列的其他类来创建新类的过程称为**组合**（composition）。在一些语言中，一个类可以从多个类中继承方法，称为**多重继承**（multiple inheritance）。\n\n\n<!-- more -->\n\n\n## 实例\n\n大部分其他语言（比如java）的OOP概念都已经包含在R中，但R中具体的语法和结构却有所不同。我们需要通过调用函数`setClass`来定义一个类，并且需要调用`setMethod`函数来定义方法。\n\n我们先看一个简单的例子：\n\n我们要实现一个类用来表示时间序列，想定义一个对象包含如下信息：\n\n- 一个数据集合，取自固定周期的时间段\n- 一个开始时间\n- 一个结束时间\n- 时间序列的周期\n\n对于可以通过某些属性计算出来的属性信息是多余的。我们从定义一个名为“TimeSeries”的新类开始。\n\n**我们将通过一个包含数据、开始时间、结束时间的数值型向量来描述一个时间序列。然后可以通过它们来计算出时间单位、频率和周期。**\n\n作为类的使用者，如何展现这些信息并不重要。但是对于类的实现者来说，则非常重要。\n\nR语言中对象存储信息的位置称为**槽**（slot）。我们将该对象需要包含的槽命名为`data`、`start`、`end`。使用`setClass`函数来创建新类：\n\n```R\n> setClass(\"TimeSeries\",\n+   representation(\n+     data=\"numeric\",\n+     start=\"POSIXct\",\n+     end=\"POSIXct\"\n+     )\n+ )\n\n```\n\n`representation`部分说明了每个槽所包含的R对象的类型。我们使用`new`函数（针对S4对象的一个泛型[构造方法](https://baike.baidu.com/item/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/10455265?fr=aladdin)）来新建一个TimeSeries对象。第一个参数名指定类名，其他参数指定槽的值：\n\n```R\n> my.TimeSeries <- new(\"TimeSeries\",\n+   data = c(1,2,3,4,5,6),\n+   start=as.POSIXct(\"07/01/2009 0:00:00\", tz=\"GMT\",\n+                   format=\"%m/%d/%Y %H:%M:%S\"),\n+   end=as.POSIXct(\"07/01/2009 0:05:00\", tz=\"GMT\",\n+                   format=\"%m/%d/%Y %H:%M:%S\")\n+ )\n\n> my.TimeSeries\nAn object of class \"TimeSeries\"\nSlot \"data\":\n[1] 1 2 3 4 5 6\n\nSlot \"start\":\n[1] \"2009-07-01 GMT\"\n\nSlot \"end\":\n[1] \"2009-07-01 00:05:00 GMT\"\n```\n\n**对于一个槽来说，并不是所有的可能值都是有效的。**比如，我们想要确保end发生在start之后，并且两者的长度是1。我们需要编写函数来验证该对象的有效性。R允许自定义函数用来验证特定的类。我们可以通过`setValidity`函数来设定。\n\n```R\n> setValidity(\"TimeSeries\",\n+   function(object){\n+     object@start <= object@end &&\n+     length(object@start) == 1 &&\n+     length(object@end) == 1\n+   }\n+ )\nClass \"TimeSeries\" [in \".GlobalEnv\"]\n\nSlots:\n\nName:     data   start     end\nClass: numeric POSIXct POSIXct\n\n```\n\n现在我们可以检查对象在`validObject`函数下是否有效。\n\n```R\n> validObject(my.TimeSeries)\n[1] TRUE\n```\n\n之后我们新建`TimeSeries`对象时，R将会自动检查新对象的有效性，并通过抛出错误来拒绝错误的对象。\n\n（也可以在创建类的时候设定验证有效性的方法，详见setClass的完整定义）\n\n定义了类之后，我们来创建新的方法。时间序列有一个属性是周期。我们可以创建一个方法用来提取时间序列中的周期信息。\n\n```R\n> period.TimeSeries <- function(object) {\n+   if (length(object@data) > 1) {\n+     (object@end - object@start) / (length(object@data) - 1)\n+   } else {\n+     Inf\n+   }\n+ }\n```\n\n**假如我们想创建一组函数用来从不同的对象中提取数据序列，而不用考虑对象的类型（即多态）。R提供了一种叫作泛型函数的机制可以实现。**当我们对某个对象调用泛型函数时，R会基于该对象的类找到正确的方法去执行。我们创建一个函数来从泛型对象中提取数据序列：\n\n```R\n> series <- function(object) { object@data }\n> setGeneric(\"series\")\n[1] \"series\"\n> series(my.TimeSeries)\n[1] 1 2 3 4 5 6\n```\n\n调用`setGeneric`可以将`series`重定义为泛型函数，其默认的方法是旧的`series`函数的函数体：\n\n```R\n> series\nstandardGeneric for \"series\" defined from package \".GlobalEnv\"\n\nfunction (object)\nstandardGeneric(\"series\")\n<environment: 0x205e930>\nMethods may be defined for arguments: object\nUse  showMethods(\"series\")  for currently available ones.\n> showMethods(\"series\")\nFunction: series (package .GlobalEnv)\nobject=\"ANY\"\nobject=\"TimeSeries\"\n    (inherited from: object=\"ANY\")\n```\n\n\n\n\n\n更进一步地，我们创建一个泛型函数来从对象中提取周期信息，并且特别指定它用来处理我们之前的创建的类。\n\n```R\n> period <- function(object) { object@period }\n> setGeneric(\"period\")\n[1] \"period\"\n> setMethod(period, signature=c(\"TimeSeries\"), definition=period.TimeSeries)\n[1] \"period\"\nattr(,\"package\")\n[1] \".GlobalEnv\"\n> showMethods(\"period\")\nFunction: period (package .GlobalEnv)\nobject=\"ANY\"\nobject=\"TimeSeries\"\n```\n\n调用泛型函数`period`可以计算`TimeSeries`对象：\n\n```R\n> period(my.TimeSeries)\nTime difference of 1 mins\n```\n\n也可以对已存在的泛型函数定义自己的方法，比如为我们创建的类定义一个`summary`方法：\n\n```R\n> setMethod(\"summary\",\n+    signature=\"TimeSeries\",\n+    definition=function(object) {\n+      print(paste(object@start,\n+                     \" to \",\n+                 object@end,\n+                 sep=\"\", collapse=\"\"))\n+      print(paste(object@data, sep=\"\", collapse=\",\"))\n+    }\n+  )\n[1] \"summary\"\n> summary(my.TimeSeries)\n[1] \"2009-07-01 to 2009-07-01 00:05:00\"\n[1] \"1,2,3,4,5,6\"\n```\n\n甚至可以为一个已经存在的操作符定义新的方法：\n\n```R\n> setMethod(\"[\",\n+   signature=c(\"TimeSeries\"),\n+   definition=function(x, i, j, ..., drop) {\n+     x@data[i]\n+   }\n+ )\n[1] \"[\"\n> my.TimeSeries[3]\n[1] 3\n\n\n> my.TimeSeries # 查看my.TimeSeries对象\nAn object of class \"TimeSeries\"\nSlot \"data\":\n[1] 1 2 3 4 5 6\n\nSlot \"start\":\n[1] \"2009-07-01 GMT\"\n\nSlot \"end\":\n[1] \"2009-07-01 00:05:00 GMT\"\n\n```\n\n\n\n下面演示如何基于`TimeSeries`类实现一个`WeightHistory`类以记录个人的历史体重信息。\n\n```R\n> setClass(\"TimeSeries\",\n+   representation(\n+     data=\"numeric\",\n+     start=\"POSIXct\",\n+     end=\"POSIXct\"\n+\n+     )\n+ )\n> setValidity(\"TimeSeries\",\n+   function(object) {\n+     object@start <= object@end &&\n+     length(object@start)==1 &&\n+     length(object@end)==1\n+   }\n+ )\nClass \"TimeSeries\" [in \".GlobalEnv\"]\n\nSlots:\n\nName:     data   start     end\nClass: numeric POSIXct POSIXct\n```\n\n创建子类：\n\n```R\n> setClass(\n+   \"WeightHistory\",\n+   representation(\n+     height = \"numeric\",\n+     name = \"character\"\n+  ),\n+   contains = \"TimeSeries\"\n+ )\n\n```\n\n添加实例对象：\n\n```R\n> john.doe <- new(\"WeightHistory\",\n+   data=c(170,169,171,168,170,169),\n+   start=as.POSIXct(\"02/14/2019 0:00:00\", tz=\"GMT\",\n+     format=\"%m/%d/%Y %H:%M:%S\"),\n+   end=as.POSIXct(\"03/28/2019 0:00:00\", tz=\"GMT\",\n+     format=\"%m/%d/%Y %H:%M:%S\"),\n+   height=72,\n+   name=\"John Doe\")\n> john.doe\nAn object of class \"WeightHistory\"\nSlot \"height\":\n[1] 72\n\nSlot \"name\":\n[1] \"John Doe\"\n\nSlot \"data\":\n[1] 170 169 171 168 170 169\n\nSlot \"start\":\n[1] \"2019-02-14 GMT\"\n\nSlot \"end\":\n[1] \"2019-03-28 GMT\"\n\n```\n\n我们还可以通过另外一种方式构建一个体重记录。假设我们已经创建好了一个包含人名和体重的`Person`类。\n\n```R\n> setClass(\"Person\",\n+   representation(\n+     height = \"numeric\",\n+     name = \"character\")\n+ )\n```\n\n我们可以创建一个基于`TimeSeries`类和`Person`类的体重记录类。\n\n```R\n> setClass(\n+   \"AltWeightHistory\",\n+   contains = c(\"TimeSeries\", \"Person\")\n+ )\n```\n\n可以发现，如果我们已经有了先期的开发经验或者相关类的代码，对新任务进行重构是非常方便的。短短几行代码就搞定了，充分利用了代码的可重复性。这也是OOP在高级语言中如此普遍的一个原因吧。\n\n## S4类\n\n我们接下来更深入地探讨构造类的函数。\n\n### 类的定义\n\nR中使用`setClass`函数来创建一个新类，格式如下：\n\n```R\nsetClass(Class, representation, prototype, contains=character(), validity, access, where, version, sealed, package, S3methods=FALSE)\n```\n\n描述\n\n- Class - 字符串，用来指定新类的名字（这是唯一必需的参数）\n- representation - 列表，列表的每一个元素代表不同的槽的类型，元素名为槽名（可以用\"ANY\"来指定类型为任意）\n- prototype - 包含各个槽的默认值的对象\n- contains - 字符向量，包含该类继承的父类名\n- validity - 验证该类的对象有效性的函数（默认没有检查），可以后续使用`setValidity`函数来设置\n- access - 无作用，为了和S-PLUS兼容\n- where - 存储该对象定义的环境\n- version - 无作用，为了和S-PLUS兼容\n- sealed - 逻辑值，表示该类是否还能被setClass按照原来的类名重新定义\n- package - 字符串，指定该类所在的R包名\n- S3methods - 逻辑值，表示是否使用了S3类写这个类\n\n为了简化类的创建，`methods`包提供了`representation`以及`protype`函数。它们在将其他类继承为数据部分、拥有多个父类、或者组合继承类和槽的时候非常有用。\n\n值得注意的是，有些名字是属性的保留字因而不能作为槽名使用，包括\"class\",\"comment\",\"dim\",\"dimnames\",\"names\",\"rownames\"和\"tsp\"。\n\n\n\n可以使用`setIs`函数来显式地定义继承关系。\n\n```R\nsetIs(class1, class2, test=NULL, coerce=NULL, replace=NULL,\n     by=character(), where=topenv(parent.frame()), classDef=, extensionObject=NULL, doComplete=TRUE)\n```\n\n可以使用`setValidity`函数来显式地设置类的验证函数：\n\n```R\nsetValidity(Class, method, where=topenv(parent.frame()))\n```\n\nR可以定义一个虚类作为多个其他类的父类。如果一个虚类本身不包含任何数据，但是如果你想要创建一批函数用于一批类中，这种方式非常有用。可以通过`setClassUnion`函数实现：\n\n```R\nsetClassUnion(name, members, where)\n```\n\n- name - 新的父类的名字\n- members - 字符向量，指定所有子类的名字\n- where - 新类所在的环境\n\n\n\n### 对象的新建\n\n我们可以通过调用类的`new`方法新建一个对象。专业术语中称为构造函数。\n\n```R\nnew(c, ...)\n```\n\n在调用`new`的时候，我们可以通过指定参数将数据填充到槽中。如果`c`中存在名为`initialize`的方法，那么当新的对象被创建后，会立刻调用`initialize`函数进行初始化。\n\n\n\n### 槽的存取\n\n我们可以使用`slot`函数或者简化符号`@`来访问存储对象某个槽中的值，当然也可以用它来赋值。\n\n```R\n> john.doe@name\n[1] \"John Doe\"\n> slot(john.doe, \"name\")\n[1] \"John Doe\"\n```\n\n\n\n### 对象的操作\n\n使用`is(o, c)`函数测试对象`o`是否是类`c`的成员。使用函数`extend(c1, c2)`测试类`c1`是否继承于类`c2`。\n\n如果要得到对象`o`包含的所有槽的名称，使用`slotNames(o)`，如果要得到槽的类型，使用`getSlots(o)`。这两个函数也可以对类使用。\n\n```R\n> getSlots(\"WeightHistory\")\n     height        name        data       start         end\n  \"numeric\" \"character\"   \"numeric\"   \"POSIXct\"   \"POSIXct\"\n\n> slotNames(\"WeightHistory\")\n[1] \"height\" \"name\"   \"data\"   \"start\"  \"end\"\n> slotNames(\"john.doe\")\ncharacter(0)\n> slotNames(john.doe)\n[1] \"height\" \"name\"   \"data\"   \"start\"  \"end\"\n```\n\n注意一些差别，有引号和没引号结果是不同的。\n\n\n\n### 方法\n\n泛型函数允许使用同一个函数名来代表很多不同的函数，针对不同的类，调用不同的参数。\n\n设定方法的第一步是创建一个合适的泛型函数，如果该函数还不存在，可以使用`setGeneric`函数来创建这个泛型方法：\n\n```R\nsetGeneric(name, def=, group=list(), valueClass=character(),\n          where=, package=, signature=, useAsDefault=,\n          genericFUnction=, simpleInheritanceOnly=)\n```\n\n要把一个方法关联到某个类（具体而言就是指定泛型函数的signature参数），可以使用`setMethod`函数：\n\n```R\nsetMethod(f, signature=character(), definition,\n         where = topenv(parent.frame()),\n         valueClass=NULL, sealed=FALSE)\n```\n\n\n\n\n\n#### 方法的管理\n\n`methods`包包含了很多管理泛型方法的函数。\n\n| 函数            | 描述                            |\n| ------------- | ----------------------------- |\n| isGeneric     | 检查指定的泛型函数是否存在                 |\n| isGroup       | 检查指定的分组泛型函数是否存在               |\n| removeGeneric | 删除某个泛型函数关联的所有方法以及该泛型函数本身      |\n| dumpMethod    | 转存储某个方法到文件                    |\n| findFunction  | 根据函数名查找函数对象，返回搜寻列表中的位置或当前顶层环境 |\n| dumpMethods   | 转存储一个泛型函数关联的所有方法              |\n| signature     | 返回在某个指定路径下定义了方法的泛型函数的名称       |\n| removeMethods | 删除某个泛型函数关联的所有方法               |\n| setGeneric    | 根据指定的函数名创建新的泛型函数              |\n\n`methods`包同样包含了很多管理方法的函数。\n\n| 函数                      | 描述                        |\n| ----------------------- | ------------------------- |\n| getMethod, selectMethod | 返回某个特定泛型函数和类型标记的方法        |\n| existsMethod, hasMethod | 检查某个方法（指定了泛型函数名和类型标记）是否存在 |\n| findMethod              | 返回包含了某个方法的包               |\n| showMethods             | 显示关联了某个S4泛型的所有方法          |\n\n\n\n更多的帮助通过`library(help=\"methods\")`命令获取。\n\n\n\n## 守旧派OOP: S3\n\n如果我们想要用R实现复杂的工程，应该使用S4的类和对象。不幸的是，我们在R中是很难避免S3对象的。比如统计包中的大部分建模工具都是用S3对象实现的。为了能够对这些软件包进行更好地理解、修改和扩展。我们必须了解S3类是如何实现的。\n\n### S3的类\n\nS3对象只是原始的R对象加上一些额外的属性（包括一个类名）而已。它没有正式的定义，我们可以手工修改属性甚至类。\n\n之前我们使用了时间序列作为S4的例子，其实在R中已经存在了表示它的S3类，称为`ts`对象。我们这里创建简单的时间序列对象，查看它的属性以及一些底层对象。\n\n```R\n> my.ts <- ts(data=c(1,2,3,4,5), start=c(2009,2), frequency=12)\n> my.ts\n     Feb Mar Apr May Jun\n2009   1   2   3   4   5\n> attributes(my.ts)\n$tsp\n[1] 2009.083 2009.417   12.000\n\n$class\n[1] \"ts\"\n\n> typeof(my.ts)\n[1] \"double\"\n> unclass(my.ts)\n[1] 1 2 3 4 5\nattr(,\"tsp\")\n[1] 2009.083 2009.417   12.000\n> attributes(my.ts)\n$tsp\n[1] 2009.083 2009.417   12.000\n\n$class\n[1] \"ts\"\n\n```\n\n可以发现`ts`对象只不过是一个数值向量加上`class`和`tsp`这两个属性。`class`属性起始只是`ts`对象的类名。我们无法像S4对象中操作槽来提取S3对象的属性。\n\n```R\n> my.ts@tsp\n错误: 非S4类别的对象(类别为\"ts\")没有\"tsp\"这样的槽\n```\n\n\n\n### S3方法\n\nS3的泛型函数是通过命名约定来实现的。以下是步骤：\n\n1. 为泛型函数挑选一个名字，这里我们命名为`gname`。\n2. 新建一个名为`gname`的函数，在`gname`的函数体中，调用`UseMethod(\"gname\")`\n3. 为每一个想要使用`gname`的类创建一个名为`gname.classname`的函数，该函数的第一个参数必须是该对象的类名`classname`。\n\n\n\n一个现成的例子是`plot`函数：\n\n```R\n> plot\nfunction (x, y, ...)\nUseMethod(\"plot\")\n<bytecode: 0x1851c30>\n<environment: namespace:graphics>\n\n```\n\n在调用`plot`的时候，`plot`将会调用`UseMethod(\"plot\")`。`UseMethod`会查看`x`对象的类，然后查找名为`plot.class`的函数，然后调用该函数。\n\n比如给我们之前定义的`TimeSeries`类添加一个`plot`方法。\n\n```R\n> plot.TimeSeries <- function(object, ...) {\n+   plot(object@data, ...)\n+ }\n```\n\n### 在S4的类中使用S3的类\n\n我们不能直接指定S3的类到S4的槽。如果想要做到，我们需要基于S3的类创建一个S4的类。一个简单的方式是使用`setOldClass`函数：\n\n```R\nsetOldClass(Classes, prototype, where, test=FALSE, S4Class)\n```\n\n### 查找隐藏的S3方法\n\n有时候我们会发现一些包的作者会选择隐藏单个方法，而把方法的实现封装在包中。这样可以鼓励用户去使用泛型函数。\n\n```R\n> library(lattice)\n> methods(histogram)\n[1] histogram.factor*  histogram.formula* histogram.numeric*\nsee '?methods' for accessing help and source code\n\n```\n\n有时候我们可能需要找回这些隐藏的方法（想要查看源代码），这时候可以使用`getS3method`函数。例如，想要取到`histgram.formula`中的代码，可以使用以下命令：\n\n```R\n> getS3method(f=\"histogram\", class=\"formula\")\n```\n\n或者使用`getAnywhere`函数：\n\n```R\n> getAnywhere(histogram.formula)\n```\n\n\n\n***\n\n学习整理自《R核心技术手册》\n","slug":"OOPinR","published":1,"updated":"2018-01-27T04:08:38.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwum000f9taxevzggt3q","content":"<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>这里首先要提及一些概念，然后我们再看具体的实例加以理解。</p>\n<p>每一个单独的<strong>对象</strong>都可以被称为对应<strong>类</strong>的一个<strong>实例</strong>（instance）。操作指定类的函数称为<strong>方法</strong>（method）。</p>\n<p>把程序接口从具体的实现细节中分离开来的过程称为<strong>封装</strong>。</p>\n<p>在OOP（面向对象编程）中，我们可以通过一个类创建出另外一个类，只需要指定新类的不同信息即可，这种方法称为<strong>继承</strong>。由此衍生出，被继承的类称为<strong>父类或超类</strong>（superclass），新创建的类称为<strong>子类</strong>（subclass）。</p>\n<p>在OOP中，允许同一个方法名操纵不同对象并得到不同的结果，称为<strong>多态</strong>（polymorphism）。</p>\n<p>通过一系列的其他类来创建新类的过程称为<strong>组合</strong>（composition）。在一些语言中，一个类可以从多个类中继承方法，称为<strong>多重继承</strong>（multiple inheritance）。</p>\n<a id=\"more\"></a>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>大部分其他语言（比如java）的OOP概念都已经包含在R中，但R中具体的语法和结构却有所不同。我们需要通过调用函数<code>setClass</code>来定义一个类，并且需要调用<code>setMethod</code>函数来定义方法。</p>\n<p>我们先看一个简单的例子：</p>\n<p>我们要实现一个类用来表示时间序列，想定义一个对象包含如下信息：</p>\n<ul>\n<li>一个数据集合，取自固定周期的时间段</li>\n<li>一个开始时间</li>\n<li>一个结束时间</li>\n<li>时间序列的周期</li>\n</ul>\n<p>对于可以通过某些属性计算出来的属性信息是多余的。我们从定义一个名为“TimeSeries”的新类开始。</p>\n<p><strong>我们将通过一个包含数据、开始时间、结束时间的数值型向量来描述一个时间序列。然后可以通过它们来计算出时间单位、频率和周期。</strong></p>\n<p>作为类的使用者，如何展现这些信息并不重要。但是对于类的实现者来说，则非常重要。</p>\n<p>R语言中对象存储信息的位置称为<strong>槽</strong>（slot）。我们将该对象需要包含的槽命名为<code>data</code>、<code>start</code>、<code>end</code>。使用<code>setClass</code>函数来创建新类：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   representation(</span><br><span class=\"line\">+     data=<span class=\"string\">\"numeric\"</span>,</span><br><span class=\"line\">+     start=<span class=\"string\">\"POSIXct\"</span>,</span><br><span class=\"line\">+     end=<span class=\"string\">\"POSIXct\"</span></span><br><span class=\"line\">+     )</span><br><span class=\"line\">+ )</span><br></pre></td></tr></table></figure>\n<p><code>representation</code>部分说明了每个槽所包含的R对象的类型。我们使用<code>new</code>函数（针对S4对象的一个泛型<a href=\"https://baike.baidu.com/item/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/10455265?fr=aladdin\" target=\"_blank\" rel=\"noopener\">构造方法</a>）来新建一个TimeSeries对象。第一个参数名指定类名，其他参数指定槽的值：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; my.TimeSeries &lt;- new(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   data = c(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>),</span><br><span class=\"line\">+   start=as.POSIXct(<span class=\"string\">\"07/01/2009 0:00:00\"</span>, tz=<span class=\"string\">\"GMT\"</span>,</span><br><span class=\"line\">+                   format=<span class=\"string\">\"%m/%d/%Y %H:%M:%S\"</span>),</span><br><span class=\"line\">+   end=as.POSIXct(<span class=\"string\">\"07/01/2009 0:05:00\"</span>, tz=<span class=\"string\">\"GMT\"</span>,</span><br><span class=\"line\">+                   format=<span class=\"string\">\"%m/%d/%Y %H:%M:%S\"</span>)</span><br><span class=\"line\">+ )</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; my.TimeSeries</span><br><span class=\"line\">An object of class <span class=\"string\">\"TimeSeries\"</span></span><br><span class=\"line\">Slot <span class=\"string\">\"data\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"start\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 GMT\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"end\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 00:05:00 GMT\"</span></span><br></pre></td></tr></table></figure>\n<p><strong>对于一个槽来说，并不是所有的可能值都是有效的。</strong>比如，我们想要确保end发生在start之后，并且两者的长度是1。我们需要编写函数来验证该对象的有效性。R允许自定义函数用来验证特定的类。我们可以通过<code>setValidity</code>函数来设定。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; setValidity(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   <span class=\"keyword\">function</span>(object)&#123;</span><br><span class=\"line\">+     object@start &lt;= object@end &amp;&amp;</span><br><span class=\"line\">+     length(object@start) == <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">+     length(object@end) == <span class=\"number\">1</span></span><br><span class=\"line\">+   &#125;</span><br><span class=\"line\">+ )</span><br><span class=\"line\">Class <span class=\"string\">\"TimeSeries\"</span> [<span class=\"keyword\">in</span> <span class=\"string\">\".GlobalEnv\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">Slots:</span><br><span class=\"line\"></span><br><span class=\"line\">Name:     data   start     end</span><br><span class=\"line\">Class: numeric POSIXct POSIXct</span><br></pre></td></tr></table></figure>\n<p>现在我们可以检查对象在<code>validObject</code>函数下是否有效。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; validObject(my.TimeSeries)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"literal\">TRUE</span></span><br></pre></td></tr></table></figure>\n<p>之后我们新建<code>TimeSeries</code>对象时，R将会自动检查新对象的有效性，并通过抛出错误来拒绝错误的对象。</p>\n<p>（也可以在创建类的时候设定验证有效性的方法，详见setClass的完整定义）</p>\n<p>定义了类之后，我们来创建新的方法。时间序列有一个属性是周期。我们可以创建一个方法用来提取时间序列中的周期信息。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; period.TimeSeries &lt;- <span class=\"keyword\">function</span>(object) &#123;</span><br><span class=\"line\">+   <span class=\"keyword\">if</span> (length(object@data) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">+     (object@end - object@start) / (length(object@data) - <span class=\"number\">1</span>)</span><br><span class=\"line\">+   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">+     <span class=\"literal\">Inf</span></span><br><span class=\"line\">+   &#125;</span><br><span class=\"line\">+ &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>假如我们想创建一组函数用来从不同的对象中提取数据序列，而不用考虑对象的类型（即多态）。R提供了一种叫作泛型函数的机制可以实现。</strong>当我们对某个对象调用泛型函数时，R会基于该对象的类找到正确的方法去执行。我们创建一个函数来从泛型对象中提取数据序列：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; series &lt;- <span class=\"keyword\">function</span>(object) &#123; object@data &#125;</span><br><span class=\"line\">&gt; <span class=\"keyword\">setGeneric</span>(<span class=\"string\">\"series\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"series\"</span></span><br><span class=\"line\">&gt; series(my.TimeSeries)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>调用<code>setGeneric</code>可以将<code>series</code>重定义为泛型函数，其默认的方法是旧的<code>series</code>函数的函数体：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; series</span><br><span class=\"line\">standardGeneric <span class=\"keyword\">for</span> <span class=\"string\">\"series\"</span> defined from package <span class=\"string\">\".GlobalEnv\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> (object)</span><br><span class=\"line\">standardGeneric(<span class=\"string\">\"series\"</span>)</span><br><span class=\"line\">&lt;environment: <span class=\"number\">0x205e930</span>&gt;</span><br><span class=\"line\">Methods may be defined <span class=\"keyword\">for</span> arguments: object</span><br><span class=\"line\">Use  showMethods(<span class=\"string\">\"series\"</span>)  <span class=\"keyword\">for</span> currently available ones.</span><br><span class=\"line\">&gt; showMethods(<span class=\"string\">\"series\"</span>)</span><br><span class=\"line\">Function: series (package .GlobalEnv)</span><br><span class=\"line\">object=<span class=\"string\">\"ANY\"</span></span><br><span class=\"line\">object=<span class=\"string\">\"TimeSeries\"</span></span><br><span class=\"line\">    (inherited from: object=<span class=\"string\">\"ANY\"</span>)</span><br></pre></td></tr></table></figure>\n<p>更进一步地，我们创建一个泛型函数来从对象中提取周期信息，并且特别指定它用来处理我们之前的创建的类。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; period &lt;- <span class=\"keyword\">function</span>(object) &#123; object@period &#125;</span><br><span class=\"line\">&gt; <span class=\"keyword\">setGeneric</span>(<span class=\"string\">\"period\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"period\"</span></span><br><span class=\"line\">&gt; <span class=\"keyword\">setMethod</span>(period, signature=c(<span class=\"string\">\"TimeSeries\"</span>), definition=period.TimeSeries)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"period\"</span></span><br><span class=\"line\">attr(,<span class=\"string\">\"package\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\".GlobalEnv\"</span></span><br><span class=\"line\">&gt; showMethods(<span class=\"string\">\"period\"</span>)</span><br><span class=\"line\">Function: period (package .GlobalEnv)</span><br><span class=\"line\">object=<span class=\"string\">\"ANY\"</span></span><br><span class=\"line\">object=<span class=\"string\">\"TimeSeries\"</span></span><br></pre></td></tr></table></figure>\n<p>调用泛型函数<code>period</code>可以计算<code>TimeSeries</code>对象：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; period(my.TimeSeries)</span><br><span class=\"line\">Time difference of <span class=\"number\">1</span> mins</span><br></pre></td></tr></table></figure>\n<p>也可以对已存在的泛型函数定义自己的方法，比如为我们创建的类定义一个<code>summary</code>方法：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setMethod</span>(<span class=\"string\">\"summary\"</span>,</span><br><span class=\"line\">+    signature=<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+    definition=<span class=\"keyword\">function</span>(object) &#123;</span><br><span class=\"line\">+      print(paste(object@start,</span><br><span class=\"line\">+                     <span class=\"string\">\" to \"</span>,</span><br><span class=\"line\">+                 object@end,</span><br><span class=\"line\">+                 sep=<span class=\"string\">\"\"</span>, collapse=<span class=\"string\">\"\"</span>))</span><br><span class=\"line\">+      print(paste(object@data, sep=<span class=\"string\">\"\"</span>, collapse=<span class=\"string\">\",\"</span>))</span><br><span class=\"line\">+    &#125;</span><br><span class=\"line\">+  )</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"summary\"</span></span><br><span class=\"line\">&gt; summary(my.TimeSeries)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 to 2009-07-01 00:05:00\"</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"1,2,3,4,5,6\"</span></span><br></pre></td></tr></table></figure>\n<p>甚至可以为一个已经存在的操作符定义新的方法：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setMethod</span>(<span class=\"string\">\"[\"</span>,</span><br><span class=\"line\">+   signature=c(<span class=\"string\">\"TimeSeries\"</span>),</span><br><span class=\"line\">+   definition=<span class=\"keyword\">function</span>(x, i, j, <span class=\"keyword\">...</span>, drop) &#123;</span><br><span class=\"line\">+     x@data[i]</span><br><span class=\"line\">+   &#125;</span><br><span class=\"line\">+ )</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"[\"</span></span><br><span class=\"line\">&gt; my.TimeSeries[<span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; my.TimeSeries <span class=\"comment\"># 查看my.TimeSeries对象</span></span><br><span class=\"line\">An object of class <span class=\"string\">\"TimeSeries\"</span></span><br><span class=\"line\">Slot <span class=\"string\">\"data\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"start\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 GMT\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"end\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 00:05:00 GMT\"</span></span><br></pre></td></tr></table></figure>\n<p>下面演示如何基于<code>TimeSeries</code>类实现一个<code>WeightHistory</code>类以记录个人的历史体重信息。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   representation(</span><br><span class=\"line\">+     data=<span class=\"string\">\"numeric\"</span>,</span><br><span class=\"line\">+     start=<span class=\"string\">\"POSIXct\"</span>,</span><br><span class=\"line\">+     end=<span class=\"string\">\"POSIXct\"</span></span><br><span class=\"line\">+</span><br><span class=\"line\">+     )</span><br><span class=\"line\">+ )</span><br><span class=\"line\">&gt; setValidity(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   <span class=\"keyword\">function</span>(object) &#123;</span><br><span class=\"line\">+     object@start &lt;= object@end &amp;&amp;</span><br><span class=\"line\">+     length(object@start)==<span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">+     length(object@end)==<span class=\"number\">1</span></span><br><span class=\"line\">+   &#125;</span><br><span class=\"line\">+ )</span><br><span class=\"line\">Class <span class=\"string\">\"TimeSeries\"</span> [<span class=\"keyword\">in</span> <span class=\"string\">\".GlobalEnv\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">Slots:</span><br><span class=\"line\"></span><br><span class=\"line\">Name:     data   start     end</span><br><span class=\"line\">Class: numeric POSIXct POSIXct</span><br></pre></td></tr></table></figure>\n<p>创建子类：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(</span><br><span class=\"line\">+   <span class=\"string\">\"WeightHistory\"</span>,</span><br><span class=\"line\">+   representation(</span><br><span class=\"line\">+     height = <span class=\"string\">\"numeric\"</span>,</span><br><span class=\"line\">+     name = <span class=\"string\">\"character\"</span></span><br><span class=\"line\">+  ),</span><br><span class=\"line\">+   contains = <span class=\"string\">\"TimeSeries\"</span></span><br><span class=\"line\">+ )</span><br></pre></td></tr></table></figure>\n<p>添加实例对象：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; john.doe &lt;- new(<span class=\"string\">\"WeightHistory\"</span>,</span><br><span class=\"line\">+   data=c(<span class=\"number\">170</span>,<span class=\"number\">169</span>,<span class=\"number\">171</span>,<span class=\"number\">168</span>,<span class=\"number\">170</span>,<span class=\"number\">169</span>),</span><br><span class=\"line\">+   start=as.POSIXct(<span class=\"string\">\"02/14/2019 0:00:00\"</span>, tz=<span class=\"string\">\"GMT\"</span>,</span><br><span class=\"line\">+     format=<span class=\"string\">\"%m/%d/%Y %H:%M:%S\"</span>),</span><br><span class=\"line\">+   end=as.POSIXct(<span class=\"string\">\"03/28/2019 0:00:00\"</span>, tz=<span class=\"string\">\"GMT\"</span>,</span><br><span class=\"line\">+     format=<span class=\"string\">\"%m/%d/%Y %H:%M:%S\"</span>),</span><br><span class=\"line\">+   height=<span class=\"number\">72</span>,</span><br><span class=\"line\">+   name=<span class=\"string\">\"John Doe\"</span>)</span><br><span class=\"line\">&gt; john.doe</span><br><span class=\"line\">An object of class <span class=\"string\">\"WeightHistory\"</span></span><br><span class=\"line\">Slot <span class=\"string\">\"height\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">72</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"name\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"John Doe\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"data\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">170</span> <span class=\"number\">169</span> <span class=\"number\">171</span> <span class=\"number\">168</span> <span class=\"number\">170</span> <span class=\"number\">169</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"start\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2019-02-14 GMT\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"end\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2019-03-28 GMT\"</span></span><br></pre></td></tr></table></figure>\n<p>我们还可以通过另外一种方式构建一个体重记录。假设我们已经创建好了一个包含人名和体重的<code>Person</code>类。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(<span class=\"string\">\"Person\"</span>,</span><br><span class=\"line\">+   representation(</span><br><span class=\"line\">+     height = <span class=\"string\">\"numeric\"</span>,</span><br><span class=\"line\">+     name = <span class=\"string\">\"character\"</span>)</span><br><span class=\"line\">+ )</span><br></pre></td></tr></table></figure>\n<p>我们可以创建一个基于<code>TimeSeries</code>类和<code>Person</code>类的体重记录类。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(</span><br><span class=\"line\">+   <span class=\"string\">\"AltWeightHistory\"</span>,</span><br><span class=\"line\">+   contains = c(<span class=\"string\">\"TimeSeries\"</span>, <span class=\"string\">\"Person\"</span>)</span><br><span class=\"line\">+ )</span><br></pre></td></tr></table></figure>\n<p>可以发现，如果我们已经有了先期的开发经验或者相关类的代码，对新任务进行重构是非常方便的。短短几行代码就搞定了，充分利用了代码的可重复性。这也是OOP在高级语言中如此普遍的一个原因吧。</p>\n<h2 id=\"S4类\"><a href=\"#S4类\" class=\"headerlink\" title=\"S4类\"></a>S4类</h2><p>我们接下来更深入地探讨构造类的函数。</p>\n<h3 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h3><p>R中使用<code>setClass</code>函数来创建一个新类，格式如下：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">setClass</span>(Class, representation, prototype, contains=character(), validity, access, where, version, sealed, package, S3methods=<span class=\"literal\">FALSE</span>)</span><br></pre></td></tr></table></figure>\n<p>描述</p>\n<ul>\n<li>Class - 字符串，用来指定新类的名字（这是唯一必需的参数）</li>\n<li>representation - 列表，列表的每一个元素代表不同的槽的类型，元素名为槽名（可以用”ANY”来指定类型为任意）</li>\n<li>prototype - 包含各个槽的默认值的对象</li>\n<li>contains - 字符向量，包含该类继承的父类名</li>\n<li>validity - 验证该类的对象有效性的函数（默认没有检查），可以后续使用<code>setValidity</code>函数来设置</li>\n<li>access - 无作用，为了和S-PLUS兼容</li>\n<li>where - 存储该对象定义的环境</li>\n<li>version - 无作用，为了和S-PLUS兼容</li>\n<li>sealed - 逻辑值，表示该类是否还能被setClass按照原来的类名重新定义</li>\n<li>package - 字符串，指定该类所在的R包名</li>\n<li>S3methods - 逻辑值，表示是否使用了S3类写这个类</li>\n</ul>\n<p>为了简化类的创建，<code>methods</code>包提供了<code>representation</code>以及<code>protype</code>函数。它们在将其他类继承为数据部分、拥有多个父类、或者组合继承类和槽的时候非常有用。</p>\n<p>值得注意的是，有些名字是属性的保留字因而不能作为槽名使用，包括”class”,”comment”,”dim”,”dimnames”,”names”,”rownames”和”tsp”。</p>\n<p>可以使用<code>setIs</code>函数来显式地定义继承关系。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setIs(class1, class2, test=<span class=\"literal\">NULL</span>, coerce=<span class=\"literal\">NULL</span>, replace=<span class=\"literal\">NULL</span>,</span><br><span class=\"line\">     by=character(), where=topenv(parent.frame()), classDef=, extensionObject=<span class=\"literal\">NULL</span>, doComplete=<span class=\"literal\">TRUE</span>)</span><br></pre></td></tr></table></figure>\n<p>可以使用<code>setValidity</code>函数来显式地设置类的验证函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setValidity(Class, method, where=topenv(parent.frame()))</span><br></pre></td></tr></table></figure>\n<p>R可以定义一个虚类作为多个其他类的父类。如果一个虚类本身不包含任何数据，但是如果你想要创建一批函数用于一批类中，这种方式非常有用。可以通过<code>setClassUnion</code>函数实现：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setClassUnion(name, members, where)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>name - 新的父类的名字</li>\n<li>members - 字符向量，指定所有子类的名字</li>\n<li>where - 新类所在的环境</li>\n</ul>\n<h3 id=\"对象的新建\"><a href=\"#对象的新建\" class=\"headerlink\" title=\"对象的新建\"></a>对象的新建</h3><p>我们可以通过调用类的<code>new</code>方法新建一个对象。专业术语中称为构造函数。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new(c, <span class=\"keyword\">...</span>)</span><br></pre></td></tr></table></figure>\n<p>在调用<code>new</code>的时候，我们可以通过指定参数将数据填充到槽中。如果<code>c</code>中存在名为<code>initialize</code>的方法，那么当新的对象被创建后，会立刻调用<code>initialize</code>函数进行初始化。</p>\n<h3 id=\"槽的存取\"><a href=\"#槽的存取\" class=\"headerlink\" title=\"槽的存取\"></a>槽的存取</h3><p>我们可以使用<code>slot</code>函数或者简化符号<code>@</code>来访问存储对象某个槽中的值，当然也可以用它来赋值。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; john.doe@name</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"John Doe\"</span></span><br><span class=\"line\">&gt; slot(john.doe, <span class=\"string\">\"name\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"John Doe\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"对象的操作\"><a href=\"#对象的操作\" class=\"headerlink\" title=\"对象的操作\"></a>对象的操作</h3><p>使用<code>is(o, c)</code>函数测试对象<code>o</code>是否是类<code>c</code>的成员。使用函数<code>extend(c1, c2)</code>测试类<code>c1</code>是否继承于类<code>c2</code>。</p>\n<p>如果要得到对象<code>o</code>包含的所有槽的名称，使用<code>slotNames(o)</code>，如果要得到槽的类型，使用<code>getSlots(o)</code>。这两个函数也可以对类使用。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; getSlots(<span class=\"string\">\"WeightHistory\"</span>)</span><br><span class=\"line\">     height        name        data       start         end</span><br><span class=\"line\">  <span class=\"string\">\"numeric\"</span> <span class=\"string\">\"character\"</span>   <span class=\"string\">\"numeric\"</span>   <span class=\"string\">\"POSIXct\"</span>   <span class=\"string\">\"POSIXct\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; slotNames(<span class=\"string\">\"WeightHistory\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"height\"</span> <span class=\"string\">\"name\"</span>   <span class=\"string\">\"data\"</span>   <span class=\"string\">\"start\"</span>  <span class=\"string\">\"end\"</span></span><br><span class=\"line\">&gt; slotNames(<span class=\"string\">\"john.doe\"</span>)</span><br><span class=\"line\">character(<span class=\"number\">0</span>)</span><br><span class=\"line\">&gt; slotNames(john.doe)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"height\"</span> <span class=\"string\">\"name\"</span>   <span class=\"string\">\"data\"</span>   <span class=\"string\">\"start\"</span>  <span class=\"string\">\"end\"</span></span><br></pre></td></tr></table></figure>\n<p>注意一些差别，有引号和没引号结果是不同的。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>泛型函数允许使用同一个函数名来代表很多不同的函数，针对不同的类，调用不同的参数。</p>\n<p>设定方法的第一步是创建一个合适的泛型函数，如果该函数还不存在，可以使用<code>setGeneric</code>函数来创建这个泛型方法：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">setGeneric</span>(name, def=, group=list(), valueClass=character(),</span><br><span class=\"line\">          where=, package=, signature=, useAsDefault=,</span><br><span class=\"line\">          genericFUnction=, simpleInheritanceOnly=)</span><br></pre></td></tr></table></figure>\n<p>要把一个方法关联到某个类（具体而言就是指定泛型函数的signature参数），可以使用<code>setMethod</code>函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">setMethod</span>(f, signature=character(), definition,</span><br><span class=\"line\">         where = topenv(parent.frame()),</span><br><span class=\"line\">         valueClass=<span class=\"literal\">NULL</span>, sealed=<span class=\"literal\">FALSE</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法的管理\"><a href=\"#方法的管理\" class=\"headerlink\" title=\"方法的管理\"></a>方法的管理</h4><p><code>methods</code>包包含了很多管理泛型方法的函数。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isGeneric</td>\n<td>检查指定的泛型函数是否存在</td>\n</tr>\n<tr>\n<td>isGroup</td>\n<td>检查指定的分组泛型函数是否存在</td>\n</tr>\n<tr>\n<td>removeGeneric</td>\n<td>删除某个泛型函数关联的所有方法以及该泛型函数本身</td>\n</tr>\n<tr>\n<td>dumpMethod</td>\n<td>转存储某个方法到文件</td>\n</tr>\n<tr>\n<td>findFunction</td>\n<td>根据函数名查找函数对象，返回搜寻列表中的位置或当前顶层环境</td>\n</tr>\n<tr>\n<td>dumpMethods</td>\n<td>转存储一个泛型函数关联的所有方法</td>\n</tr>\n<tr>\n<td>signature</td>\n<td>返回在某个指定路径下定义了方法的泛型函数的名称</td>\n</tr>\n<tr>\n<td>removeMethods</td>\n<td>删除某个泛型函数关联的所有方法</td>\n</tr>\n<tr>\n<td>setGeneric</td>\n<td>根据指定的函数名创建新的泛型函数</td>\n</tr>\n</tbody>\n</table>\n<p><code>methods</code>包同样包含了很多管理方法的函数。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getMethod, selectMethod</td>\n<td>返回某个特定泛型函数和类型标记的方法</td>\n</tr>\n<tr>\n<td>existsMethod, hasMethod</td>\n<td>检查某个方法（指定了泛型函数名和类型标记）是否存在</td>\n</tr>\n<tr>\n<td>findMethod</td>\n<td>返回包含了某个方法的包</td>\n</tr>\n<tr>\n<td>showMethods</td>\n<td>显示关联了某个S4泛型的所有方法</td>\n</tr>\n</tbody>\n</table>\n<p>更多的帮助通过<code>library(help=&quot;methods&quot;)</code>命令获取。</p>\n<h2 id=\"守旧派OOP-S3\"><a href=\"#守旧派OOP-S3\" class=\"headerlink\" title=\"守旧派OOP: S3\"></a>守旧派OOP: S3</h2><p>如果我们想要用R实现复杂的工程，应该使用S4的类和对象。不幸的是，我们在R中是很难避免S3对象的。比如统计包中的大部分建模工具都是用S3对象实现的。为了能够对这些软件包进行更好地理解、修改和扩展。我们必须了解S3类是如何实现的。</p>\n<h3 id=\"S3的类\"><a href=\"#S3的类\" class=\"headerlink\" title=\"S3的类\"></a>S3的类</h3><p>S3对象只是原始的R对象加上一些额外的属性（包括一个类名）而已。它没有正式的定义，我们可以手工修改属性甚至类。</p>\n<p>之前我们使用了时间序列作为S4的例子，其实在R中已经存在了表示它的S3类，称为<code>ts</code>对象。我们这里创建简单的时间序列对象，查看它的属性以及一些底层对象。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; my.ts &lt;- ts(data=c(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>), start=c(<span class=\"number\">2009</span>,<span class=\"number\">2</span>), frequency=<span class=\"number\">12</span>)</span><br><span class=\"line\">&gt; my.ts</span><br><span class=\"line\">     Feb Mar Apr May Jun</span><br><span class=\"line\"><span class=\"number\">2009</span>   <span class=\"number\">1</span>   <span class=\"number\">2</span>   <span class=\"number\">3</span>   <span class=\"number\">4</span>   <span class=\"number\">5</span></span><br><span class=\"line\">&gt; attributes(my.ts)</span><br><span class=\"line\">$tsp</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">2009.083</span> <span class=\"number\">2009.417</span>   <span class=\"number\">12.000</span></span><br><span class=\"line\"></span><br><span class=\"line\">$class</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"ts\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; typeof(my.ts)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"double\"</span></span><br><span class=\"line\">&gt; unclass(my.ts)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\">attr(,<span class=\"string\">\"tsp\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">2009.083</span> <span class=\"number\">2009.417</span>   <span class=\"number\">12.000</span></span><br><span class=\"line\">&gt; attributes(my.ts)</span><br><span class=\"line\">$tsp</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">2009.083</span> <span class=\"number\">2009.417</span>   <span class=\"number\">12.000</span></span><br><span class=\"line\"></span><br><span class=\"line\">$class</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"ts\"</span></span><br></pre></td></tr></table></figure>\n<p>可以发现<code>ts</code>对象只不过是一个数值向量加上<code>class</code>和<code>tsp</code>这两个属性。<code>class</code>属性起始只是<code>ts</code>对象的类名。我们无法像S4对象中操作槽来提取S3对象的属性。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; my.ts@tsp</span><br><span class=\"line\">错误: 非S4类别的对象(类别为<span class=\"string\">\"ts\"</span>)没有<span class=\"string\">\"tsp\"</span>这样的槽</span><br></pre></td></tr></table></figure>\n<h3 id=\"S3方法\"><a href=\"#S3方法\" class=\"headerlink\" title=\"S3方法\"></a>S3方法</h3><p>S3的泛型函数是通过命名约定来实现的。以下是步骤：</p>\n<ol>\n<li>为泛型函数挑选一个名字，这里我们命名为<code>gname</code>。</li>\n<li>新建一个名为<code>gname</code>的函数，在<code>gname</code>的函数体中，调用<code>UseMethod(&quot;gname&quot;)</code></li>\n<li>为每一个想要使用<code>gname</code>的类创建一个名为<code>gname.classname</code>的函数，该函数的第一个参数必须是该对象的类名<code>classname</code>。</li>\n</ol>\n<p>一个现成的例子是<code>plot</code>函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; plot</span><br><span class=\"line\"><span class=\"keyword\">function</span> (x, y, <span class=\"keyword\">...</span>)</span><br><span class=\"line\">UseMethod(<span class=\"string\">\"plot\"</span>)</span><br><span class=\"line\">&lt;bytecode: <span class=\"number\">0x1851c30</span>&gt;</span><br><span class=\"line\">&lt;environment: namespace:graphics&gt;</span><br></pre></td></tr></table></figure>\n<p>在调用<code>plot</code>的时候，<code>plot</code>将会调用<code>UseMethod(&quot;plot&quot;)</code>。<code>UseMethod</code>会查看<code>x</code>对象的类，然后查找名为<code>plot.class</code>的函数，然后调用该函数。</p>\n<p>比如给我们之前定义的<code>TimeSeries</code>类添加一个<code>plot</code>方法。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; plot.TimeSeries &lt;- <span class=\"keyword\">function</span>(object, <span class=\"keyword\">...</span>) &#123;</span><br><span class=\"line\">+   plot(object@data, <span class=\"keyword\">...</span>)</span><br><span class=\"line\">+ &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在S4的类中使用S3的类\"><a href=\"#在S4的类中使用S3的类\" class=\"headerlink\" title=\"在S4的类中使用S3的类\"></a>在S4的类中使用S3的类</h3><p>我们不能直接指定S3的类到S4的槽。如果想要做到，我们需要基于S3的类创建一个S4的类。一个简单的方式是使用<code>setOldClass</code>函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setOldClass(Classes, prototype, where, test=<span class=\"literal\">FALSE</span>, S4Class)</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找隐藏的S3方法\"><a href=\"#查找隐藏的S3方法\" class=\"headerlink\" title=\"查找隐藏的S3方法\"></a>查找隐藏的S3方法</h3><p>有时候我们会发现一些包的作者会选择隐藏单个方法，而把方法的实现封装在包中。这样可以鼓励用户去使用泛型函数。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">library</span>(lattice)</span><br><span class=\"line\">&gt; methods(histogram)</span><br><span class=\"line\">[<span class=\"number\">1</span>] histogram.factor*  histogram.formula* histogram.numeric*</span><br><span class=\"line\">see <span class=\"string\">'?methods'</span> <span class=\"keyword\">for</span> accessing help and <span class=\"keyword\">source</span> code</span><br></pre></td></tr></table></figure>\n<p>有时候我们可能需要找回这些隐藏的方法（想要查看源代码），这时候可以使用<code>getS3method</code>函数。例如，想要取到<code>histgram.formula</code>中的代码，可以使用以下命令：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; getS3method(f=<span class=\"string\">\"histogram\"</span>, class=<span class=\"string\">\"formula\"</span>)</span><br></pre></td></tr></table></figure>\n<p>或者使用<code>getAnywhere</code>函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; getAnywhere(histogram.formula)</span><br></pre></td></tr></table></figure>\n<hr>\n<p>学习整理自《R核心技术手册》</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h2><p>这里首先要提及一些概念，然后我们再看具体的实例加以理解。</p>\n<p>每一个单独的<strong>对象</strong>都可以被称为对应<strong>类</strong>的一个<strong>实例</strong>（instance）。操作指定类的函数称为<strong>方法</strong>（method）。</p>\n<p>把程序接口从具体的实现细节中分离开来的过程称为<strong>封装</strong>。</p>\n<p>在OOP（面向对象编程）中，我们可以通过一个类创建出另外一个类，只需要指定新类的不同信息即可，这种方法称为<strong>继承</strong>。由此衍生出，被继承的类称为<strong>父类或超类</strong>（superclass），新创建的类称为<strong>子类</strong>（subclass）。</p>\n<p>在OOP中，允许同一个方法名操纵不同对象并得到不同的结果，称为<strong>多态</strong>（polymorphism）。</p>\n<p>通过一系列的其他类来创建新类的过程称为<strong>组合</strong>（composition）。在一些语言中，一个类可以从多个类中继承方法，称为<strong>多重继承</strong>（multiple inheritance）。</p>","more":"<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>大部分其他语言（比如java）的OOP概念都已经包含在R中，但R中具体的语法和结构却有所不同。我们需要通过调用函数<code>setClass</code>来定义一个类，并且需要调用<code>setMethod</code>函数来定义方法。</p>\n<p>我们先看一个简单的例子：</p>\n<p>我们要实现一个类用来表示时间序列，想定义一个对象包含如下信息：</p>\n<ul>\n<li>一个数据集合，取自固定周期的时间段</li>\n<li>一个开始时间</li>\n<li>一个结束时间</li>\n<li>时间序列的周期</li>\n</ul>\n<p>对于可以通过某些属性计算出来的属性信息是多余的。我们从定义一个名为“TimeSeries”的新类开始。</p>\n<p><strong>我们将通过一个包含数据、开始时间、结束时间的数值型向量来描述一个时间序列。然后可以通过它们来计算出时间单位、频率和周期。</strong></p>\n<p>作为类的使用者，如何展现这些信息并不重要。但是对于类的实现者来说，则非常重要。</p>\n<p>R语言中对象存储信息的位置称为<strong>槽</strong>（slot）。我们将该对象需要包含的槽命名为<code>data</code>、<code>start</code>、<code>end</code>。使用<code>setClass</code>函数来创建新类：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   representation(</span><br><span class=\"line\">+     data=<span class=\"string\">\"numeric\"</span>,</span><br><span class=\"line\">+     start=<span class=\"string\">\"POSIXct\"</span>,</span><br><span class=\"line\">+     end=<span class=\"string\">\"POSIXct\"</span></span><br><span class=\"line\">+     )</span><br><span class=\"line\">+ )</span><br></pre></td></tr></table></figure>\n<p><code>representation</code>部分说明了每个槽所包含的R对象的类型。我们使用<code>new</code>函数（针对S4对象的一个泛型<a href=\"https://baike.baidu.com/item/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/10455265?fr=aladdin\" target=\"_blank\" rel=\"noopener\">构造方法</a>）来新建一个TimeSeries对象。第一个参数名指定类名，其他参数指定槽的值：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; my.TimeSeries &lt;- new(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   data = c(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>),</span><br><span class=\"line\">+   start=as.POSIXct(<span class=\"string\">\"07/01/2009 0:00:00\"</span>, tz=<span class=\"string\">\"GMT\"</span>,</span><br><span class=\"line\">+                   format=<span class=\"string\">\"%m/%d/%Y %H:%M:%S\"</span>),</span><br><span class=\"line\">+   end=as.POSIXct(<span class=\"string\">\"07/01/2009 0:05:00\"</span>, tz=<span class=\"string\">\"GMT\"</span>,</span><br><span class=\"line\">+                   format=<span class=\"string\">\"%m/%d/%Y %H:%M:%S\"</span>)</span><br><span class=\"line\">+ )</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; my.TimeSeries</span><br><span class=\"line\">An object of class <span class=\"string\">\"TimeSeries\"</span></span><br><span class=\"line\">Slot <span class=\"string\">\"data\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"start\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 GMT\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"end\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 00:05:00 GMT\"</span></span><br></pre></td></tr></table></figure>\n<p><strong>对于一个槽来说，并不是所有的可能值都是有效的。</strong>比如，我们想要确保end发生在start之后，并且两者的长度是1。我们需要编写函数来验证该对象的有效性。R允许自定义函数用来验证特定的类。我们可以通过<code>setValidity</code>函数来设定。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; setValidity(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   <span class=\"keyword\">function</span>(object)&#123;</span><br><span class=\"line\">+     object@start &lt;= object@end &amp;&amp;</span><br><span class=\"line\">+     length(object@start) == <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">+     length(object@end) == <span class=\"number\">1</span></span><br><span class=\"line\">+   &#125;</span><br><span class=\"line\">+ )</span><br><span class=\"line\">Class <span class=\"string\">\"TimeSeries\"</span> [<span class=\"keyword\">in</span> <span class=\"string\">\".GlobalEnv\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">Slots:</span><br><span class=\"line\"></span><br><span class=\"line\">Name:     data   start     end</span><br><span class=\"line\">Class: numeric POSIXct POSIXct</span><br></pre></td></tr></table></figure>\n<p>现在我们可以检查对象在<code>validObject</code>函数下是否有效。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; validObject(my.TimeSeries)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"literal\">TRUE</span></span><br></pre></td></tr></table></figure>\n<p>之后我们新建<code>TimeSeries</code>对象时，R将会自动检查新对象的有效性，并通过抛出错误来拒绝错误的对象。</p>\n<p>（也可以在创建类的时候设定验证有效性的方法，详见setClass的完整定义）</p>\n<p>定义了类之后，我们来创建新的方法。时间序列有一个属性是周期。我们可以创建一个方法用来提取时间序列中的周期信息。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; period.TimeSeries &lt;- <span class=\"keyword\">function</span>(object) &#123;</span><br><span class=\"line\">+   <span class=\"keyword\">if</span> (length(object@data) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">+     (object@end - object@start) / (length(object@data) - <span class=\"number\">1</span>)</span><br><span class=\"line\">+   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">+     <span class=\"literal\">Inf</span></span><br><span class=\"line\">+   &#125;</span><br><span class=\"line\">+ &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>假如我们想创建一组函数用来从不同的对象中提取数据序列，而不用考虑对象的类型（即多态）。R提供了一种叫作泛型函数的机制可以实现。</strong>当我们对某个对象调用泛型函数时，R会基于该对象的类找到正确的方法去执行。我们创建一个函数来从泛型对象中提取数据序列：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; series &lt;- <span class=\"keyword\">function</span>(object) &#123; object@data &#125;</span><br><span class=\"line\">&gt; <span class=\"keyword\">setGeneric</span>(<span class=\"string\">\"series\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"series\"</span></span><br><span class=\"line\">&gt; series(my.TimeSeries)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>调用<code>setGeneric</code>可以将<code>series</code>重定义为泛型函数，其默认的方法是旧的<code>series</code>函数的函数体：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; series</span><br><span class=\"line\">standardGeneric <span class=\"keyword\">for</span> <span class=\"string\">\"series\"</span> defined from package <span class=\"string\">\".GlobalEnv\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> (object)</span><br><span class=\"line\">standardGeneric(<span class=\"string\">\"series\"</span>)</span><br><span class=\"line\">&lt;environment: <span class=\"number\">0x205e930</span>&gt;</span><br><span class=\"line\">Methods may be defined <span class=\"keyword\">for</span> arguments: object</span><br><span class=\"line\">Use  showMethods(<span class=\"string\">\"series\"</span>)  <span class=\"keyword\">for</span> currently available ones.</span><br><span class=\"line\">&gt; showMethods(<span class=\"string\">\"series\"</span>)</span><br><span class=\"line\">Function: series (package .GlobalEnv)</span><br><span class=\"line\">object=<span class=\"string\">\"ANY\"</span></span><br><span class=\"line\">object=<span class=\"string\">\"TimeSeries\"</span></span><br><span class=\"line\">    (inherited from: object=<span class=\"string\">\"ANY\"</span>)</span><br></pre></td></tr></table></figure>\n<p>更进一步地，我们创建一个泛型函数来从对象中提取周期信息，并且特别指定它用来处理我们之前的创建的类。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; period &lt;- <span class=\"keyword\">function</span>(object) &#123; object@period &#125;</span><br><span class=\"line\">&gt; <span class=\"keyword\">setGeneric</span>(<span class=\"string\">\"period\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"period\"</span></span><br><span class=\"line\">&gt; <span class=\"keyword\">setMethod</span>(period, signature=c(<span class=\"string\">\"TimeSeries\"</span>), definition=period.TimeSeries)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"period\"</span></span><br><span class=\"line\">attr(,<span class=\"string\">\"package\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\".GlobalEnv\"</span></span><br><span class=\"line\">&gt; showMethods(<span class=\"string\">\"period\"</span>)</span><br><span class=\"line\">Function: period (package .GlobalEnv)</span><br><span class=\"line\">object=<span class=\"string\">\"ANY\"</span></span><br><span class=\"line\">object=<span class=\"string\">\"TimeSeries\"</span></span><br></pre></td></tr></table></figure>\n<p>调用泛型函数<code>period</code>可以计算<code>TimeSeries</code>对象：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; period(my.TimeSeries)</span><br><span class=\"line\">Time difference of <span class=\"number\">1</span> mins</span><br></pre></td></tr></table></figure>\n<p>也可以对已存在的泛型函数定义自己的方法，比如为我们创建的类定义一个<code>summary</code>方法：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setMethod</span>(<span class=\"string\">\"summary\"</span>,</span><br><span class=\"line\">+    signature=<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+    definition=<span class=\"keyword\">function</span>(object) &#123;</span><br><span class=\"line\">+      print(paste(object@start,</span><br><span class=\"line\">+                     <span class=\"string\">\" to \"</span>,</span><br><span class=\"line\">+                 object@end,</span><br><span class=\"line\">+                 sep=<span class=\"string\">\"\"</span>, collapse=<span class=\"string\">\"\"</span>))</span><br><span class=\"line\">+      print(paste(object@data, sep=<span class=\"string\">\"\"</span>, collapse=<span class=\"string\">\",\"</span>))</span><br><span class=\"line\">+    &#125;</span><br><span class=\"line\">+  )</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"summary\"</span></span><br><span class=\"line\">&gt; summary(my.TimeSeries)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 to 2009-07-01 00:05:00\"</span></span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"1,2,3,4,5,6\"</span></span><br></pre></td></tr></table></figure>\n<p>甚至可以为一个已经存在的操作符定义新的方法：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setMethod</span>(<span class=\"string\">\"[\"</span>,</span><br><span class=\"line\">+   signature=c(<span class=\"string\">\"TimeSeries\"</span>),</span><br><span class=\"line\">+   definition=<span class=\"keyword\">function</span>(x, i, j, <span class=\"keyword\">...</span>, drop) &#123;</span><br><span class=\"line\">+     x@data[i]</span><br><span class=\"line\">+   &#125;</span><br><span class=\"line\">+ )</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"[\"</span></span><br><span class=\"line\">&gt; my.TimeSeries[<span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; my.TimeSeries <span class=\"comment\"># 查看my.TimeSeries对象</span></span><br><span class=\"line\">An object of class <span class=\"string\">\"TimeSeries\"</span></span><br><span class=\"line\">Slot <span class=\"string\">\"data\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"start\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 GMT\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"end\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2009-07-01 00:05:00 GMT\"</span></span><br></pre></td></tr></table></figure>\n<p>下面演示如何基于<code>TimeSeries</code>类实现一个<code>WeightHistory</code>类以记录个人的历史体重信息。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   representation(</span><br><span class=\"line\">+     data=<span class=\"string\">\"numeric\"</span>,</span><br><span class=\"line\">+     start=<span class=\"string\">\"POSIXct\"</span>,</span><br><span class=\"line\">+     end=<span class=\"string\">\"POSIXct\"</span></span><br><span class=\"line\">+</span><br><span class=\"line\">+     )</span><br><span class=\"line\">+ )</span><br><span class=\"line\">&gt; setValidity(<span class=\"string\">\"TimeSeries\"</span>,</span><br><span class=\"line\">+   <span class=\"keyword\">function</span>(object) &#123;</span><br><span class=\"line\">+     object@start &lt;= object@end &amp;&amp;</span><br><span class=\"line\">+     length(object@start)==<span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">+     length(object@end)==<span class=\"number\">1</span></span><br><span class=\"line\">+   &#125;</span><br><span class=\"line\">+ )</span><br><span class=\"line\">Class <span class=\"string\">\"TimeSeries\"</span> [<span class=\"keyword\">in</span> <span class=\"string\">\".GlobalEnv\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">Slots:</span><br><span class=\"line\"></span><br><span class=\"line\">Name:     data   start     end</span><br><span class=\"line\">Class: numeric POSIXct POSIXct</span><br></pre></td></tr></table></figure>\n<p>创建子类：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(</span><br><span class=\"line\">+   <span class=\"string\">\"WeightHistory\"</span>,</span><br><span class=\"line\">+   representation(</span><br><span class=\"line\">+     height = <span class=\"string\">\"numeric\"</span>,</span><br><span class=\"line\">+     name = <span class=\"string\">\"character\"</span></span><br><span class=\"line\">+  ),</span><br><span class=\"line\">+   contains = <span class=\"string\">\"TimeSeries\"</span></span><br><span class=\"line\">+ )</span><br></pre></td></tr></table></figure>\n<p>添加实例对象：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; john.doe &lt;- new(<span class=\"string\">\"WeightHistory\"</span>,</span><br><span class=\"line\">+   data=c(<span class=\"number\">170</span>,<span class=\"number\">169</span>,<span class=\"number\">171</span>,<span class=\"number\">168</span>,<span class=\"number\">170</span>,<span class=\"number\">169</span>),</span><br><span class=\"line\">+   start=as.POSIXct(<span class=\"string\">\"02/14/2019 0:00:00\"</span>, tz=<span class=\"string\">\"GMT\"</span>,</span><br><span class=\"line\">+     format=<span class=\"string\">\"%m/%d/%Y %H:%M:%S\"</span>),</span><br><span class=\"line\">+   end=as.POSIXct(<span class=\"string\">\"03/28/2019 0:00:00\"</span>, tz=<span class=\"string\">\"GMT\"</span>,</span><br><span class=\"line\">+     format=<span class=\"string\">\"%m/%d/%Y %H:%M:%S\"</span>),</span><br><span class=\"line\">+   height=<span class=\"number\">72</span>,</span><br><span class=\"line\">+   name=<span class=\"string\">\"John Doe\"</span>)</span><br><span class=\"line\">&gt; john.doe</span><br><span class=\"line\">An object of class <span class=\"string\">\"WeightHistory\"</span></span><br><span class=\"line\">Slot <span class=\"string\">\"height\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">72</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"name\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"John Doe\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"data\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">170</span> <span class=\"number\">169</span> <span class=\"number\">171</span> <span class=\"number\">168</span> <span class=\"number\">170</span> <span class=\"number\">169</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"start\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2019-02-14 GMT\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Slot <span class=\"string\">\"end\"</span>:</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"2019-03-28 GMT\"</span></span><br></pre></td></tr></table></figure>\n<p>我们还可以通过另外一种方式构建一个体重记录。假设我们已经创建好了一个包含人名和体重的<code>Person</code>类。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(<span class=\"string\">\"Person\"</span>,</span><br><span class=\"line\">+   representation(</span><br><span class=\"line\">+     height = <span class=\"string\">\"numeric\"</span>,</span><br><span class=\"line\">+     name = <span class=\"string\">\"character\"</span>)</span><br><span class=\"line\">+ )</span><br></pre></td></tr></table></figure>\n<p>我们可以创建一个基于<code>TimeSeries</code>类和<code>Person</code>类的体重记录类。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">setClass</span>(</span><br><span class=\"line\">+   <span class=\"string\">\"AltWeightHistory\"</span>,</span><br><span class=\"line\">+   contains = c(<span class=\"string\">\"TimeSeries\"</span>, <span class=\"string\">\"Person\"</span>)</span><br><span class=\"line\">+ )</span><br></pre></td></tr></table></figure>\n<p>可以发现，如果我们已经有了先期的开发经验或者相关类的代码，对新任务进行重构是非常方便的。短短几行代码就搞定了，充分利用了代码的可重复性。这也是OOP在高级语言中如此普遍的一个原因吧。</p>\n<h2 id=\"S4类\"><a href=\"#S4类\" class=\"headerlink\" title=\"S4类\"></a>S4类</h2><p>我们接下来更深入地探讨构造类的函数。</p>\n<h3 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h3><p>R中使用<code>setClass</code>函数来创建一个新类，格式如下：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">setClass</span>(Class, representation, prototype, contains=character(), validity, access, where, version, sealed, package, S3methods=<span class=\"literal\">FALSE</span>)</span><br></pre></td></tr></table></figure>\n<p>描述</p>\n<ul>\n<li>Class - 字符串，用来指定新类的名字（这是唯一必需的参数）</li>\n<li>representation - 列表，列表的每一个元素代表不同的槽的类型，元素名为槽名（可以用”ANY”来指定类型为任意）</li>\n<li>prototype - 包含各个槽的默认值的对象</li>\n<li>contains - 字符向量，包含该类继承的父类名</li>\n<li>validity - 验证该类的对象有效性的函数（默认没有检查），可以后续使用<code>setValidity</code>函数来设置</li>\n<li>access - 无作用，为了和S-PLUS兼容</li>\n<li>where - 存储该对象定义的环境</li>\n<li>version - 无作用，为了和S-PLUS兼容</li>\n<li>sealed - 逻辑值，表示该类是否还能被setClass按照原来的类名重新定义</li>\n<li>package - 字符串，指定该类所在的R包名</li>\n<li>S3methods - 逻辑值，表示是否使用了S3类写这个类</li>\n</ul>\n<p>为了简化类的创建，<code>methods</code>包提供了<code>representation</code>以及<code>protype</code>函数。它们在将其他类继承为数据部分、拥有多个父类、或者组合继承类和槽的时候非常有用。</p>\n<p>值得注意的是，有些名字是属性的保留字因而不能作为槽名使用，包括”class”,”comment”,”dim”,”dimnames”,”names”,”rownames”和”tsp”。</p>\n<p>可以使用<code>setIs</code>函数来显式地定义继承关系。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setIs(class1, class2, test=<span class=\"literal\">NULL</span>, coerce=<span class=\"literal\">NULL</span>, replace=<span class=\"literal\">NULL</span>,</span><br><span class=\"line\">     by=character(), where=topenv(parent.frame()), classDef=, extensionObject=<span class=\"literal\">NULL</span>, doComplete=<span class=\"literal\">TRUE</span>)</span><br></pre></td></tr></table></figure>\n<p>可以使用<code>setValidity</code>函数来显式地设置类的验证函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setValidity(Class, method, where=topenv(parent.frame()))</span><br></pre></td></tr></table></figure>\n<p>R可以定义一个虚类作为多个其他类的父类。如果一个虚类本身不包含任何数据，但是如果你想要创建一批函数用于一批类中，这种方式非常有用。可以通过<code>setClassUnion</code>函数实现：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setClassUnion(name, members, where)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>name - 新的父类的名字</li>\n<li>members - 字符向量，指定所有子类的名字</li>\n<li>where - 新类所在的环境</li>\n</ul>\n<h3 id=\"对象的新建\"><a href=\"#对象的新建\" class=\"headerlink\" title=\"对象的新建\"></a>对象的新建</h3><p>我们可以通过调用类的<code>new</code>方法新建一个对象。专业术语中称为构造函数。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new(c, <span class=\"keyword\">...</span>)</span><br></pre></td></tr></table></figure>\n<p>在调用<code>new</code>的时候，我们可以通过指定参数将数据填充到槽中。如果<code>c</code>中存在名为<code>initialize</code>的方法，那么当新的对象被创建后，会立刻调用<code>initialize</code>函数进行初始化。</p>\n<h3 id=\"槽的存取\"><a href=\"#槽的存取\" class=\"headerlink\" title=\"槽的存取\"></a>槽的存取</h3><p>我们可以使用<code>slot</code>函数或者简化符号<code>@</code>来访问存储对象某个槽中的值，当然也可以用它来赋值。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; john.doe@name</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"John Doe\"</span></span><br><span class=\"line\">&gt; slot(john.doe, <span class=\"string\">\"name\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"John Doe\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"对象的操作\"><a href=\"#对象的操作\" class=\"headerlink\" title=\"对象的操作\"></a>对象的操作</h3><p>使用<code>is(o, c)</code>函数测试对象<code>o</code>是否是类<code>c</code>的成员。使用函数<code>extend(c1, c2)</code>测试类<code>c1</code>是否继承于类<code>c2</code>。</p>\n<p>如果要得到对象<code>o</code>包含的所有槽的名称，使用<code>slotNames(o)</code>，如果要得到槽的类型，使用<code>getSlots(o)</code>。这两个函数也可以对类使用。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; getSlots(<span class=\"string\">\"WeightHistory\"</span>)</span><br><span class=\"line\">     height        name        data       start         end</span><br><span class=\"line\">  <span class=\"string\">\"numeric\"</span> <span class=\"string\">\"character\"</span>   <span class=\"string\">\"numeric\"</span>   <span class=\"string\">\"POSIXct\"</span>   <span class=\"string\">\"POSIXct\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; slotNames(<span class=\"string\">\"WeightHistory\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"height\"</span> <span class=\"string\">\"name\"</span>   <span class=\"string\">\"data\"</span>   <span class=\"string\">\"start\"</span>  <span class=\"string\">\"end\"</span></span><br><span class=\"line\">&gt; slotNames(<span class=\"string\">\"john.doe\"</span>)</span><br><span class=\"line\">character(<span class=\"number\">0</span>)</span><br><span class=\"line\">&gt; slotNames(john.doe)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"height\"</span> <span class=\"string\">\"name\"</span>   <span class=\"string\">\"data\"</span>   <span class=\"string\">\"start\"</span>  <span class=\"string\">\"end\"</span></span><br></pre></td></tr></table></figure>\n<p>注意一些差别，有引号和没引号结果是不同的。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>泛型函数允许使用同一个函数名来代表很多不同的函数，针对不同的类，调用不同的参数。</p>\n<p>设定方法的第一步是创建一个合适的泛型函数，如果该函数还不存在，可以使用<code>setGeneric</code>函数来创建这个泛型方法：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">setGeneric</span>(name, def=, group=list(), valueClass=character(),</span><br><span class=\"line\">          where=, package=, signature=, useAsDefault=,</span><br><span class=\"line\">          genericFUnction=, simpleInheritanceOnly=)</span><br></pre></td></tr></table></figure>\n<p>要把一个方法关联到某个类（具体而言就是指定泛型函数的signature参数），可以使用<code>setMethod</code>函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">setMethod</span>(f, signature=character(), definition,</span><br><span class=\"line\">         where = topenv(parent.frame()),</span><br><span class=\"line\">         valueClass=<span class=\"literal\">NULL</span>, sealed=<span class=\"literal\">FALSE</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法的管理\"><a href=\"#方法的管理\" class=\"headerlink\" title=\"方法的管理\"></a>方法的管理</h4><p><code>methods</code>包包含了很多管理泛型方法的函数。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isGeneric</td>\n<td>检查指定的泛型函数是否存在</td>\n</tr>\n<tr>\n<td>isGroup</td>\n<td>检查指定的分组泛型函数是否存在</td>\n</tr>\n<tr>\n<td>removeGeneric</td>\n<td>删除某个泛型函数关联的所有方法以及该泛型函数本身</td>\n</tr>\n<tr>\n<td>dumpMethod</td>\n<td>转存储某个方法到文件</td>\n</tr>\n<tr>\n<td>findFunction</td>\n<td>根据函数名查找函数对象，返回搜寻列表中的位置或当前顶层环境</td>\n</tr>\n<tr>\n<td>dumpMethods</td>\n<td>转存储一个泛型函数关联的所有方法</td>\n</tr>\n<tr>\n<td>signature</td>\n<td>返回在某个指定路径下定义了方法的泛型函数的名称</td>\n</tr>\n<tr>\n<td>removeMethods</td>\n<td>删除某个泛型函数关联的所有方法</td>\n</tr>\n<tr>\n<td>setGeneric</td>\n<td>根据指定的函数名创建新的泛型函数</td>\n</tr>\n</tbody>\n</table>\n<p><code>methods</code>包同样包含了很多管理方法的函数。</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>getMethod, selectMethod</td>\n<td>返回某个特定泛型函数和类型标记的方法</td>\n</tr>\n<tr>\n<td>existsMethod, hasMethod</td>\n<td>检查某个方法（指定了泛型函数名和类型标记）是否存在</td>\n</tr>\n<tr>\n<td>findMethod</td>\n<td>返回包含了某个方法的包</td>\n</tr>\n<tr>\n<td>showMethods</td>\n<td>显示关联了某个S4泛型的所有方法</td>\n</tr>\n</tbody>\n</table>\n<p>更多的帮助通过<code>library(help=&quot;methods&quot;)</code>命令获取。</p>\n<h2 id=\"守旧派OOP-S3\"><a href=\"#守旧派OOP-S3\" class=\"headerlink\" title=\"守旧派OOP: S3\"></a>守旧派OOP: S3</h2><p>如果我们想要用R实现复杂的工程，应该使用S4的类和对象。不幸的是，我们在R中是很难避免S3对象的。比如统计包中的大部分建模工具都是用S3对象实现的。为了能够对这些软件包进行更好地理解、修改和扩展。我们必须了解S3类是如何实现的。</p>\n<h3 id=\"S3的类\"><a href=\"#S3的类\" class=\"headerlink\" title=\"S3的类\"></a>S3的类</h3><p>S3对象只是原始的R对象加上一些额外的属性（包括一个类名）而已。它没有正式的定义，我们可以手工修改属性甚至类。</p>\n<p>之前我们使用了时间序列作为S4的例子，其实在R中已经存在了表示它的S3类，称为<code>ts</code>对象。我们这里创建简单的时间序列对象，查看它的属性以及一些底层对象。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; my.ts &lt;- ts(data=c(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>), start=c(<span class=\"number\">2009</span>,<span class=\"number\">2</span>), frequency=<span class=\"number\">12</span>)</span><br><span class=\"line\">&gt; my.ts</span><br><span class=\"line\">     Feb Mar Apr May Jun</span><br><span class=\"line\"><span class=\"number\">2009</span>   <span class=\"number\">1</span>   <span class=\"number\">2</span>   <span class=\"number\">3</span>   <span class=\"number\">4</span>   <span class=\"number\">5</span></span><br><span class=\"line\">&gt; attributes(my.ts)</span><br><span class=\"line\">$tsp</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">2009.083</span> <span class=\"number\">2009.417</span>   <span class=\"number\">12.000</span></span><br><span class=\"line\"></span><br><span class=\"line\">$class</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"ts\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; typeof(my.ts)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"double\"</span></span><br><span class=\"line\">&gt; unclass(my.ts)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\">attr(,<span class=\"string\">\"tsp\"</span>)</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">2009.083</span> <span class=\"number\">2009.417</span>   <span class=\"number\">12.000</span></span><br><span class=\"line\">&gt; attributes(my.ts)</span><br><span class=\"line\">$tsp</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"number\">2009.083</span> <span class=\"number\">2009.417</span>   <span class=\"number\">12.000</span></span><br><span class=\"line\"></span><br><span class=\"line\">$class</span><br><span class=\"line\">[<span class=\"number\">1</span>] <span class=\"string\">\"ts\"</span></span><br></pre></td></tr></table></figure>\n<p>可以发现<code>ts</code>对象只不过是一个数值向量加上<code>class</code>和<code>tsp</code>这两个属性。<code>class</code>属性起始只是<code>ts</code>对象的类名。我们无法像S4对象中操作槽来提取S3对象的属性。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; my.ts@tsp</span><br><span class=\"line\">错误: 非S4类别的对象(类别为<span class=\"string\">\"ts\"</span>)没有<span class=\"string\">\"tsp\"</span>这样的槽</span><br></pre></td></tr></table></figure>\n<h3 id=\"S3方法\"><a href=\"#S3方法\" class=\"headerlink\" title=\"S3方法\"></a>S3方法</h3><p>S3的泛型函数是通过命名约定来实现的。以下是步骤：</p>\n<ol>\n<li>为泛型函数挑选一个名字，这里我们命名为<code>gname</code>。</li>\n<li>新建一个名为<code>gname</code>的函数，在<code>gname</code>的函数体中，调用<code>UseMethod(&quot;gname&quot;)</code></li>\n<li>为每一个想要使用<code>gname</code>的类创建一个名为<code>gname.classname</code>的函数，该函数的第一个参数必须是该对象的类名<code>classname</code>。</li>\n</ol>\n<p>一个现成的例子是<code>plot</code>函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; plot</span><br><span class=\"line\"><span class=\"keyword\">function</span> (x, y, <span class=\"keyword\">...</span>)</span><br><span class=\"line\">UseMethod(<span class=\"string\">\"plot\"</span>)</span><br><span class=\"line\">&lt;bytecode: <span class=\"number\">0x1851c30</span>&gt;</span><br><span class=\"line\">&lt;environment: namespace:graphics&gt;</span><br></pre></td></tr></table></figure>\n<p>在调用<code>plot</code>的时候，<code>plot</code>将会调用<code>UseMethod(&quot;plot&quot;)</code>。<code>UseMethod</code>会查看<code>x</code>对象的类，然后查找名为<code>plot.class</code>的函数，然后调用该函数。</p>\n<p>比如给我们之前定义的<code>TimeSeries</code>类添加一个<code>plot</code>方法。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; plot.TimeSeries &lt;- <span class=\"keyword\">function</span>(object, <span class=\"keyword\">...</span>) &#123;</span><br><span class=\"line\">+   plot(object@data, <span class=\"keyword\">...</span>)</span><br><span class=\"line\">+ &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在S4的类中使用S3的类\"><a href=\"#在S4的类中使用S3的类\" class=\"headerlink\" title=\"在S4的类中使用S3的类\"></a>在S4的类中使用S3的类</h3><p>我们不能直接指定S3的类到S4的槽。如果想要做到，我们需要基于S3的类创建一个S4的类。一个简单的方式是使用<code>setOldClass</code>函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setOldClass(Classes, prototype, where, test=<span class=\"literal\">FALSE</span>, S4Class)</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找隐藏的S3方法\"><a href=\"#查找隐藏的S3方法\" class=\"headerlink\" title=\"查找隐藏的S3方法\"></a>查找隐藏的S3方法</h3><p>有时候我们会发现一些包的作者会选择隐藏单个方法，而把方法的实现封装在包中。这样可以鼓励用户去使用泛型函数。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; <span class=\"keyword\">library</span>(lattice)</span><br><span class=\"line\">&gt; methods(histogram)</span><br><span class=\"line\">[<span class=\"number\">1</span>] histogram.factor*  histogram.formula* histogram.numeric*</span><br><span class=\"line\">see <span class=\"string\">'?methods'</span> <span class=\"keyword\">for</span> accessing help and <span class=\"keyword\">source</span> code</span><br></pre></td></tr></table></figure>\n<p>有时候我们可能需要找回这些隐藏的方法（想要查看源代码），这时候可以使用<code>getS3method</code>函数。例如，想要取到<code>histgram.formula</code>中的代码，可以使用以下命令：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; getS3method(f=<span class=\"string\">\"histogram\"</span>, class=<span class=\"string\">\"formula\"</span>)</span><br></pre></td></tr></table></figure>\n<p>或者使用<code>getAnywhere</code>函数：</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; getAnywhere(histogram.formula)</span><br></pre></td></tr></table></figure>\n<hr>\n<p>学习整理自《R核心技术手册》</p>"},{"title":"学习git","author":"王诗翔","date":"2017-12-07T16:00:00.000Z","_content":"\n纯属搬砖操作，资料来源《Github入门与实战》，这本书的重要信息也就这些了，需要的时候找一找。\n\n书上提到的一个学习网站<https://learngitbranching.js.org/>非常棒，线上学习。\n\n<!-- more -->\n\n# Git基本操作\n\n## git init——初始化仓库\n\n```shell\n$ mkdir git-tutorial\n$ cd git-tutorial\n$ git init\nInitialized empty Git repository in /Users/hirocaster/github/github-book\n/git-tutorial/.git/\n```\n\n如果初始化成功，执行了 git init命令的目录下就会生成 .git 目录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。 在 Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开。\n\n\n\n## git status——查看仓库状态\n\ngit status命令用于显示 Git 仓库的状态。这是一个十分常用的命令，请务必牢记。\n\n工作树和仓库在被操作的过程中，状态会不断发生变化。在 Git 操作过程中时常用 git status命令查看当前状态，可谓基本中的基本。下面，就让我们来实际查看一下当前状态 ：\n\n```shell\n$ git status\n# On branch master\n#\n# Initial commit\n#\nnothing to commit (create/copy files and use \"git add\" to track)\n```\n\n结果显示了我们当前正处于 master 分支下。关于分支我们会在不久后讲到，现在不必深究。接着还显示了没有可提交的内容。所谓提交（Commit），是指“记录工作树中所有文件的当前状态”。\n\n\n\n## git add——向暂存区中添加文件\n\n要想让文件成为 Git 仓库的管理对象，就需要用 git add命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。\n\n```shell\n$ git add README.md\n$ git status\n# On branch master\n#\n# Initial commit\n#\n# Changes to be committed:\n# (use \"git rm --cached <file>...\" to unstage)\n#\n# new file: README.md\n#\n```\n\n将 README.md 文件加入暂存区后， git status命令的显示结果发生了变化。可以看到， README.md 文件显示在 Changes to be committed 中了。\n\n\n\n## git commit——保存仓库的历史记录\n\ngit commit命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件。\n\n```shell\n$ git commit -m \"First commit\"\n[master (root-commit) 9f129ba] First commit\n1 file changed, 0 insertions(+), 0 deletions(-)\ncreate mode 100644 README.md\n```\n\n-m 参数后的 \"First commit\"称作提交信息，是对这个提交的概述。\n\n\n\n## git log——查看提交日志\n\ngit log命令可以查看以往仓库中提交的日志。包括可以查看什 么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。关于合并我们会在后面解说。\n\n我们先来看看刚才的 git commit命令是否被记录了。\n\n```shell\n$ git log\ncommit 9f129bae19b2c82fb4e98cde5890e52a6c546922\nAuthor: hirocaster <hohtsuka@gmail.com>\nDate: Sun May 5 16:06:49 2013 +0900\nFirst commit\n```\n\n如上图所示，屏幕显示了刚刚的提交操作。 commit 栏旁边显示的“9f129b……”是指向这个提交的哈希值。 Git 的其他命令中，在指向提交时会用到这个哈希值。\n\nAuthor 栏中显示我们给 Git 设置的用户名和邮箱地址。 Date 栏中显示提交执行的日期和时间。再往下就是该提交的提交信息。\n\n\n\n### 只显示提交信息的第一行\n\n如果只想让程序显示第一行简述信息，可以在 git log命令后加上 --pretty=short。这样一来开发人员就能够更轻松地把握多个提交。\n\n\n\n### 只显示指定目录、文件的日志\n\n只要在 git log命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。\n\n\n\n### 显示文件的改动\n\n如果想查看提交所带来的改动，可以加上 -p参数，文件的前后差别就会显示在提交信息之后。\n\n```shell\n$ git log -p\n```\n\n如上所述， git log命令可以利用多种参数帮助开发者把握以往提交的内容。不必勉强自己一次记下全部参数，每当有想查看的日志就积极去查，慢慢就能得心应手了。\n\n\n\n## git diff——查看更改前后的差别\n\ngit diff命令可以查看工作树、暂存区、最新提交之间的差别。单从字面上可能很难理解，各位不妨跟着笔者的解说亲手试一试。\n\n\n\n### 查看工作树和暂存区的差别\n\n```shell\n$ git diff\ndiff --git a/README.md b/README.md\nindex e69de29..cb5dc9f 100644\n--- a/README.md\n+++ b/README.md\n@@ -0,0 +1 @@\n+# Git教程\n```\n\n这里解释一下显示的内容。“+”号标出的是新添加的行，被删除的行则用“-”号标出。我们可以看到，这次只添加了一行 。\n\n### 查看工作树和最新提交的差别\n\n要查看与最新提交的差别，请执行以下命令。\n\n```shell\n$ git diff HEAD\ndiff --git a/README.md b/README.md\nindex e69de29..cb5dc9f 100644\n--- a/README.md\n+++ b/README.md\n@@ -0,0 +1 @@\n+# Git教程\n```\n\n **不妨养成这样一个好习惯：在执行 git commit命令之前先执行git diff HEAD命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交**。这里的 HEAD 是指向当前分支中最新一次提交的指针。\n\n\n\n# 分支操作\n\n通过灵活运用分支，可以让多人同时高效地进行并行开发。在这里，我们将带大家学习与分支相关的 Git 操作。\n\n## git branch——显示分支一览表\n\ngit branch命令可以将分支名列表显示，同时可以确认当前所在分支。让我们来实际运行 git branch命令。\n\n```shell\n$ git branch\n* master\n```\n\n可以看到 master 分支左侧标有“*”（星号），表示这是我们当前所在的分支。也就是说，我们正在 master 分支下进行开发。结果中没有显示其他分支名，表示本地仓库中只存在 master 一个分支。\n\n## git checkout -b——创建、切换分支\n\n如果想以当前的 master 分支为基础创建新的分支，我们需要用到git checkout -b命令。\n\n### 切换到 feature-A 分支并进行提交\n\n执行下面的命令，创建名为 feature-A 的分支。\n\n```shell\n$ git checkout -b feature-A\nSwitched to a new branch 'feature-A'\n```\n\n实际上，连续执行下面两条命令也能收到同样效果。\n\n```shell\n$ git branch feature-A\n$ git checkout feature-A\n```\n\n创建 feature-A 分支，并将当前分支切换为 feature-A 分支。这时再来查看分支列表，会显示我们处于 feature-A 分支下。\n\n```shell\n$ git branch\n* feature-A\nmaster\n```\n\nfeature-A 分支左侧标有“*”，表示当前分支为 feature-A。在这个状态下像正常开发那样修改代码、执行 git add命令并进行提交的话，代 码 就 会 提 交 至 feature-A 分 支。 像 这 样 不 断 对 一 个 分 支（例 如feature-A）进行提交的操作，我们称为“培育分支”。\n\n\n\n### 切换回上一个分支\n\n```shell\n$ git checkout -\n```\n\n像上面这样用“-”（连字符）代替分支名，就可以切换至上一个分支。\n\n\n\n## 特性分支\n\nGit 与 Subversion（SVN）等集中型版本管理系统不同，创建分支时不需要连接中央仓库，所以能够相对轻松地创建分支。因此，当今大部分工作流程中都用到了特性（Topic）分支。\n\n特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由 master 分支担当。\n\n 基于特定主题的作业在特性分支中进行，主题完成后再与 master 分支合并。只要保持这样一个开发流程，就能保证 master 分支可以随时供人查看。这样一来，其他开发者也可以放心大胆地从 master 分支创建新的特性分支 。\n\n## git merge——合并分支\n\n接下来，我们假设 feature-A 已经实现完毕，想要将它合并到主干分支 master 中。首先切换到 master 分支。\n\n```shell\n$ git checkout master\nSwitched to branch 'master'\n```\n\n然后合并 feature-A 分支。为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交。因此，在合并时加上 --no-ff参数。\n\n```shell\n$ git merge --no-ff feature-A\n```\n\n随后编辑器会启动，用于录入合并提交的信息。\n\n\n\n## git log --graph——以图表形式查看分支\n\n用 git log --graph命令进行查看的话，能很清楚地看到特性分支（feature-A）提交的内容已被合并。除此以外，特性分支的创建以及合并也都清楚明了。\n\n```shell\n$ git log --graph\n* commit 83b0b94268675cb715ac6c8a5bc1965938c15f62\n|\\ Merge: fd0cbf0 8a6c8b9\n| | Author: hirocaster <hohtsuka@gmail.com>\n| | Date: Sun May 5 16:37:57 2013 +0900\n| |\n| | Merge branch 'feature-A'\n| |\n| * commit 8a6c8b97c8962cd44afb69c65f26d6e1a6c088d8\n|/ Author: hirocaster <hohtsuka@gmail.com>\n| Date: Sun May 5 16:22:02 2013 +0900\n|\n| Add feature-A\n|\n* commit fd0cbf0d4a25f747230694d95cac1be72d33441d\n| Author: hirocaster <hohtsuka@gmail.com>\n| Date: Sun May 5 16:10:15 2013 +0900\n|\n| Add index\n|\n* commit 9f129bae19b2c82fb4e98cde5890e52a6c546922\nAuthor: hirocaster <hohtsuka@gmail.com>\nDate: Sun May 5 16:06:49 2013 +0900\nFirst commit\n```\n\ngit log --graph命令可以用图表形式输出提交日志，非常直观，请大家务必记住。\n\n\n\n# 更改提交的操作\n\n## git reset——回溯历史版本\n\nGit 的另一特征便是可以灵活操作历史版本。借助分散仓库的优势，可以在不影响其他仓库的前提下对历史版本进行操作。\n\n要让仓库的 HEAD、暂存区、当前工作树回溯到指定状态，需要用到 git rest --hard命令。只要提供目标时间点的哈希值 ，就可以 完全恢复至该时间点的状态。事不宜迟，让我们执行下面的命令。\n\n```shell\n$ git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d (使用时这里需要个人更改哈希值)\nHEAD is now at fd0cbf0 Add index\n```\n\n**git log命令只能查看以当前状态为终点的历史日志。所以这里要使用 git reflog命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过 git reset --hard命令恢复到回溯历史前的状态 。**\n\n## 消除冲突\n\n### 查看冲突部分并将其解决\n\n用编辑器打开 README.md （如果你发生了冲突，查看相应的冲突文件）文件，就会发现其内容变成了下面这个样子。 （这是书上的例子）\n\n```shell\n# Git教程\n<<<<<<< HEAD\n- feature-A\n=======\n- fix-B\n>>>>>>> fix-B\n```\n\n`======= `以上的部分是当前 HEAD 的内容，以下的部分是要合并的 fix-B 分支中的内容。我们在编辑器中将其改成想要的样子。\n\n```shell\n# Git教程\n- feature-A\n- fix-B\n```\n\n如上所示，本次修正让 feature-A 与 fix-B 的内容并存于文件之中。但是在实际的软件开发中，往往需要删除其中之一，所以各位在处理冲突时，务必要仔细分析冲突部分的内容后再行修改。\n\n### 提交解决后的结果\n\n冲突解决后，执行 git add命令与 git commit命令。\n\n\n\n## git commit --amend——修改提交信息\n\n\n\n## git rebase -i——压缩历史\n\n在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。这是个会经常用到的技巧，让我们来实际操作体会一下。\n\n首先，新建一个 feature-C 特性分支。\n\n作为 feature-C 的功能实现，我们在 README.md 文件中添加一行文字，并且故意留下拼写错误，以便之后修正。\n\n```shell\n$ git checkout -b feature-C\nSwitched to a new branch 'feature-C'\n```\n\n```shell\n# Git教程\n- feature-A\n- fix-B\n- faeture-C\n```\n\n提交这部分内容。这个小小的变更就没必要先执行 git add命令再执行 git commit命令了，我们**用 git commit -am命令来一次完成这两步操作**。\n\n```shell\n$ git commit -am \"Add feature-C\"\n[feature-C 7a34294] Add feature-C\n1 file changed, 1 insertion(+)\n```\n\n现在来修正刚才预留的拼写错误。 然后进行提交。\n\n```shell\n$ git commit -am \"Fix typo\"\n[feature-C 6fba227] Fix typo\n1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n错字漏字等失误称作 typo，所以我们将提交信息记为 \"Fix typo\"。 实际上，我们不希望在历史记录中看到这类提交，因为健全的历史记录并不需要它们。如果能在最初提交之前就发现并修正这些错误，也就不会出现这类提交了。\n\n我们来更改历史。将 \" Fix typo\"修正的内容与之前一次的提交合并，在历史记录中合并为一次完美的提交。为此，我们要用到git rebase命令。\n\n```shell\n$ git rebase -i HEAD~2\n```\n\n用上述方式执行 git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。\n\n```shell\npick 7a34294 Add feature-C\npick 6fba227 Fix typo\n# Rebase 2e7db6f..6fba227 onto 2e7db6f\n#\n# Commands:\n# p, pick = use commit\n# r, reword = use commit, but edit the commit message\n# e, edit = use commit, but stop for amending\n# s, squash = use commit, but meld into previous commit\n# f, fixup = like \"squash\", but discard this commit's log message\n# x, exec = run command (the rest of the line) using shell\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n```\n\n我们将 6fba227 的 Fix typo 的历史记录压缩到 7a34294 的 Add feature-C里。按照下图所示，将 6fba227 左侧的 pick 部分删除，改写为 fixup。\n\n```shell\npick 7a34294 Add feature-C\nfixup 6fba227 Fix typo\n[detached HEAD 51440c5] Add feature-C\n1 file changed, 1 insertion(+)\nSuccessfully rebased and updated refs/heads/feature-C.\n```\n\n这样一来， Fix typo 就从历史中被抹去，也就相当于 Add feature-C中从来没有出现过拼写错误。这算是一种**良性的历史改写**。\n\n\n\n# 推送至远程仓库\n\n## git remote add——添加远程仓库\n\n在 GitHub 上创建的仓库路径为“git@github.com:用户名 /git-tutorial.git”。现在我们用 git remote add命令将它设置成本地仓库的远程仓库。\n\n ```shell\n$ git remote add origin git@github.com:github-book/git-tutorial.git\n ```\n\n按照上述格式执行 git remote add命令之后， Git 会自动git@github.com:github-book/git-tutorial.git远程仓库的名称设置为 origin（标识符）。\n\n\n\n## git push——推送至远程仓库\n\n### 推送至 master 分支\n\n如果想将当前分支下本地仓库中的内容推送给远程仓库，需要用到git push命令。现在假定我们在 master 分支下进行操作。\n\n```shell\n$ git push -u origin master\nCounting objects: 20, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (10/10), done.\nWriting objects: 100% (20/20), 1.60 KiB, done.\nTotal 20 (delta 3), reused 0 (delta 0)\nTo git@github.com:github-book/git-tutorial.git\n* [new branch] master -> master\nBranch master set up to track remote branch master from origin.\n```\n\n像这样执行 git push命令，当前分支的内容就会被推送给远程仓库origin 的 master 分支。 -u参数可以在推送的同时，将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦。执行该操作后，当前本地仓库 master 分支的内容将会被推送到GitHub 的远程仓库中。在 GitHub 上也可以确认远程 master 分支的内容 和本地 master 分支相同。\n\n\n\n### 推送至 master 以外的分支\n\n除了 master 分支之外，远程仓库也可以创建其他分支。举个例子，我们在本地仓库中创建 feature-D 分支，并将它以同名形式 push 至远程仓库。\n\n```shell\n$ git checkout -b feature-D\nSwitched to a new branch 'feature-D'\n```\n\n我们在本地仓库中创建了 feature-D 分支，现在将它 push 给远程仓库并保持分支名称不变。\n\n```shell\n$ git push -u origin feature-D\nTotal 0 (delta 0), reused 0 (delta 0)\nTo git@github.com:github-book/git-tutorial.git\n* [new branch] feature-D -> feature-D\nBranch feature-D set up to track remote branch feature-D from origin.\n```\n\n\n\n# 从远程仓库获取\n\n## git clone——获取远程仓库\n\n\n\n### 获取远程仓库\n\n首先我们换到其他目录下，将 GitHub 上的仓库 clone 到本地。注意 不要与之前操作的仓库在同一目录下。\n\n```shell\n$ git clone git@github.com:github-book/git-tutorial.git\nCloning into 'git-tutorial'...\nremote: Counting objects: 20, done.\nremote: Compressing objects: 100% (7/7), done.\nremote: Total 20 (delta 3), reused 20 (delta 3)\nReceiving objects: 100% (20/20), done.\nResolving deltas: 100% (3/3), done.\n$ cd git-tutorial\n```\n\n执行 git clone命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master 分支在内容上是完全相同的。\n\n ```shell\n$ git branch -a\n* master\nremotes/origin/HEAD -> origin/master\nremotes/origin/feature-D\nremotes/origin/master\n ```\n\n我们用 git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息。\n结果中显示了 remotes/origin/feature-D，证明我们的远程仓库中已经有了 feature-D 分支 。\n\n### 获取远程的 feature-D 分支\n\n我们试着将 feature-D 分支获取至本地仓库。\n\n```shell\n$ git checkout -b feature-D origin/feature-D\nBranch feature-D set up to track remote branch feature-D from origin.\nSwitched to a new branch 'feature-D'\n```\n\n-b 参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了 origin/feature-D，就是说以名为 origin 的仓库（这里指 GitHub 端的仓库）的 feature-D 分支为来源，在本地仓库中创建 feature-D 分支。\n\n\n\n## git pull——获取最新的远程仓库分支\n\n远程仓库的 feature-D 分支中已经有了我们刚刚推送的提交。这时我们就可以使用 git pull 命令，将本地的 feature-D 分支更新到最新状态。当前分支为 feature-D 分支。\n\n```shell\n$ git pull origin feature-D\nremote: Counting objects: 5, done.\nremote: Compressing objects: 100% (1/1), done.\nremote: Total 3 (delta 1), reused 3 (delta 1)\nUnpacking objects: 100% (3/3), done.\nFrom github.com:github-book/git-tutorial\n* branch feature-D -> FETCH_HEAD\nFirst, rewinding head to replay your work on top of it...\nFast-forwarded feature-D to ed9721e686f8c588e55ec6b8071b669f411486b8.\n```\n\n\n\n-----\n\n# 如何用Github的gh-pages分支展示自己的项目\n\n```\ngit subtree push --prefix=dist origin gh-pages\n```\n\n意思就是把指定的dist文件提交到gh-pages分支上\n","source":"_posts/2017-12-08-Git-basic-operation.md","raw":"---\ntitle: 学习git\nauthor: 王诗翔\ndate: 2017-12-08\ncategories:\n- Linux杂烩\n- Git\ntags:\n- linux\n- git\n- github\n---\n\n纯属搬砖操作，资料来源《Github入门与实战》，这本书的重要信息也就这些了，需要的时候找一找。\n\n书上提到的一个学习网站<https://learngitbranching.js.org/>非常棒，线上学习。\n\n<!-- more -->\n\n# Git基本操作\n\n## git init——初始化仓库\n\n```shell\n$ mkdir git-tutorial\n$ cd git-tutorial\n$ git init\nInitialized empty Git repository in /Users/hirocaster/github/github-book\n/git-tutorial/.git/\n```\n\n如果初始化成功，执行了 git init命令的目录下就会生成 .git 目录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。 在 Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开。\n\n\n\n## git status——查看仓库状态\n\ngit status命令用于显示 Git 仓库的状态。这是一个十分常用的命令，请务必牢记。\n\n工作树和仓库在被操作的过程中，状态会不断发生变化。在 Git 操作过程中时常用 git status命令查看当前状态，可谓基本中的基本。下面，就让我们来实际查看一下当前状态 ：\n\n```shell\n$ git status\n# On branch master\n#\n# Initial commit\n#\nnothing to commit (create/copy files and use \"git add\" to track)\n```\n\n结果显示了我们当前正处于 master 分支下。关于分支我们会在不久后讲到，现在不必深究。接着还显示了没有可提交的内容。所谓提交（Commit），是指“记录工作树中所有文件的当前状态”。\n\n\n\n## git add——向暂存区中添加文件\n\n要想让文件成为 Git 仓库的管理对象，就需要用 git add命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。\n\n```shell\n$ git add README.md\n$ git status\n# On branch master\n#\n# Initial commit\n#\n# Changes to be committed:\n# (use \"git rm --cached <file>...\" to unstage)\n#\n# new file: README.md\n#\n```\n\n将 README.md 文件加入暂存区后， git status命令的显示结果发生了变化。可以看到， README.md 文件显示在 Changes to be committed 中了。\n\n\n\n## git commit——保存仓库的历史记录\n\ngit commit命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件。\n\n```shell\n$ git commit -m \"First commit\"\n[master (root-commit) 9f129ba] First commit\n1 file changed, 0 insertions(+), 0 deletions(-)\ncreate mode 100644 README.md\n```\n\n-m 参数后的 \"First commit\"称作提交信息，是对这个提交的概述。\n\n\n\n## git log——查看提交日志\n\ngit log命令可以查看以往仓库中提交的日志。包括可以查看什 么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。关于合并我们会在后面解说。\n\n我们先来看看刚才的 git commit命令是否被记录了。\n\n```shell\n$ git log\ncommit 9f129bae19b2c82fb4e98cde5890e52a6c546922\nAuthor: hirocaster <hohtsuka@gmail.com>\nDate: Sun May 5 16:06:49 2013 +0900\nFirst commit\n```\n\n如上图所示，屏幕显示了刚刚的提交操作。 commit 栏旁边显示的“9f129b……”是指向这个提交的哈希值。 Git 的其他命令中，在指向提交时会用到这个哈希值。\n\nAuthor 栏中显示我们给 Git 设置的用户名和邮箱地址。 Date 栏中显示提交执行的日期和时间。再往下就是该提交的提交信息。\n\n\n\n### 只显示提交信息的第一行\n\n如果只想让程序显示第一行简述信息，可以在 git log命令后加上 --pretty=short。这样一来开发人员就能够更轻松地把握多个提交。\n\n\n\n### 只显示指定目录、文件的日志\n\n只要在 git log命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。\n\n\n\n### 显示文件的改动\n\n如果想查看提交所带来的改动，可以加上 -p参数，文件的前后差别就会显示在提交信息之后。\n\n```shell\n$ git log -p\n```\n\n如上所述， git log命令可以利用多种参数帮助开发者把握以往提交的内容。不必勉强自己一次记下全部参数，每当有想查看的日志就积极去查，慢慢就能得心应手了。\n\n\n\n## git diff——查看更改前后的差别\n\ngit diff命令可以查看工作树、暂存区、最新提交之间的差别。单从字面上可能很难理解，各位不妨跟着笔者的解说亲手试一试。\n\n\n\n### 查看工作树和暂存区的差别\n\n```shell\n$ git diff\ndiff --git a/README.md b/README.md\nindex e69de29..cb5dc9f 100644\n--- a/README.md\n+++ b/README.md\n@@ -0,0 +1 @@\n+# Git教程\n```\n\n这里解释一下显示的内容。“+”号标出的是新添加的行，被删除的行则用“-”号标出。我们可以看到，这次只添加了一行 。\n\n### 查看工作树和最新提交的差别\n\n要查看与最新提交的差别，请执行以下命令。\n\n```shell\n$ git diff HEAD\ndiff --git a/README.md b/README.md\nindex e69de29..cb5dc9f 100644\n--- a/README.md\n+++ b/README.md\n@@ -0,0 +1 @@\n+# Git教程\n```\n\n **不妨养成这样一个好习惯：在执行 git commit命令之前先执行git diff HEAD命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交**。这里的 HEAD 是指向当前分支中最新一次提交的指针。\n\n\n\n# 分支操作\n\n通过灵活运用分支，可以让多人同时高效地进行并行开发。在这里，我们将带大家学习与分支相关的 Git 操作。\n\n## git branch——显示分支一览表\n\ngit branch命令可以将分支名列表显示，同时可以确认当前所在分支。让我们来实际运行 git branch命令。\n\n```shell\n$ git branch\n* master\n```\n\n可以看到 master 分支左侧标有“*”（星号），表示这是我们当前所在的分支。也就是说，我们正在 master 分支下进行开发。结果中没有显示其他分支名，表示本地仓库中只存在 master 一个分支。\n\n## git checkout -b——创建、切换分支\n\n如果想以当前的 master 分支为基础创建新的分支，我们需要用到git checkout -b命令。\n\n### 切换到 feature-A 分支并进行提交\n\n执行下面的命令，创建名为 feature-A 的分支。\n\n```shell\n$ git checkout -b feature-A\nSwitched to a new branch 'feature-A'\n```\n\n实际上，连续执行下面两条命令也能收到同样效果。\n\n```shell\n$ git branch feature-A\n$ git checkout feature-A\n```\n\n创建 feature-A 分支，并将当前分支切换为 feature-A 分支。这时再来查看分支列表，会显示我们处于 feature-A 分支下。\n\n```shell\n$ git branch\n* feature-A\nmaster\n```\n\nfeature-A 分支左侧标有“*”，表示当前分支为 feature-A。在这个状态下像正常开发那样修改代码、执行 git add命令并进行提交的话，代 码 就 会 提 交 至 feature-A 分 支。 像 这 样 不 断 对 一 个 分 支（例 如feature-A）进行提交的操作，我们称为“培育分支”。\n\n\n\n### 切换回上一个分支\n\n```shell\n$ git checkout -\n```\n\n像上面这样用“-”（连字符）代替分支名，就可以切换至上一个分支。\n\n\n\n## 特性分支\n\nGit 与 Subversion（SVN）等集中型版本管理系统不同，创建分支时不需要连接中央仓库，所以能够相对轻松地创建分支。因此，当今大部分工作流程中都用到了特性（Topic）分支。\n\n特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由 master 分支担当。\n\n 基于特定主题的作业在特性分支中进行，主题完成后再与 master 分支合并。只要保持这样一个开发流程，就能保证 master 分支可以随时供人查看。这样一来，其他开发者也可以放心大胆地从 master 分支创建新的特性分支 。\n\n## git merge——合并分支\n\n接下来，我们假设 feature-A 已经实现完毕，想要将它合并到主干分支 master 中。首先切换到 master 分支。\n\n```shell\n$ git checkout master\nSwitched to branch 'master'\n```\n\n然后合并 feature-A 分支。为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交。因此，在合并时加上 --no-ff参数。\n\n```shell\n$ git merge --no-ff feature-A\n```\n\n随后编辑器会启动，用于录入合并提交的信息。\n\n\n\n## git log --graph——以图表形式查看分支\n\n用 git log --graph命令进行查看的话，能很清楚地看到特性分支（feature-A）提交的内容已被合并。除此以外，特性分支的创建以及合并也都清楚明了。\n\n```shell\n$ git log --graph\n* commit 83b0b94268675cb715ac6c8a5bc1965938c15f62\n|\\ Merge: fd0cbf0 8a6c8b9\n| | Author: hirocaster <hohtsuka@gmail.com>\n| | Date: Sun May 5 16:37:57 2013 +0900\n| |\n| | Merge branch 'feature-A'\n| |\n| * commit 8a6c8b97c8962cd44afb69c65f26d6e1a6c088d8\n|/ Author: hirocaster <hohtsuka@gmail.com>\n| Date: Sun May 5 16:22:02 2013 +0900\n|\n| Add feature-A\n|\n* commit fd0cbf0d4a25f747230694d95cac1be72d33441d\n| Author: hirocaster <hohtsuka@gmail.com>\n| Date: Sun May 5 16:10:15 2013 +0900\n|\n| Add index\n|\n* commit 9f129bae19b2c82fb4e98cde5890e52a6c546922\nAuthor: hirocaster <hohtsuka@gmail.com>\nDate: Sun May 5 16:06:49 2013 +0900\nFirst commit\n```\n\ngit log --graph命令可以用图表形式输出提交日志，非常直观，请大家务必记住。\n\n\n\n# 更改提交的操作\n\n## git reset——回溯历史版本\n\nGit 的另一特征便是可以灵活操作历史版本。借助分散仓库的优势，可以在不影响其他仓库的前提下对历史版本进行操作。\n\n要让仓库的 HEAD、暂存区、当前工作树回溯到指定状态，需要用到 git rest --hard命令。只要提供目标时间点的哈希值 ，就可以 完全恢复至该时间点的状态。事不宜迟，让我们执行下面的命令。\n\n```shell\n$ git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d (使用时这里需要个人更改哈希值)\nHEAD is now at fd0cbf0 Add index\n```\n\n**git log命令只能查看以当前状态为终点的历史日志。所以这里要使用 git reflog命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过 git reset --hard命令恢复到回溯历史前的状态 。**\n\n## 消除冲突\n\n### 查看冲突部分并将其解决\n\n用编辑器打开 README.md （如果你发生了冲突，查看相应的冲突文件）文件，就会发现其内容变成了下面这个样子。 （这是书上的例子）\n\n```shell\n# Git教程\n<<<<<<< HEAD\n- feature-A\n=======\n- fix-B\n>>>>>>> fix-B\n```\n\n`======= `以上的部分是当前 HEAD 的内容，以下的部分是要合并的 fix-B 分支中的内容。我们在编辑器中将其改成想要的样子。\n\n```shell\n# Git教程\n- feature-A\n- fix-B\n```\n\n如上所示，本次修正让 feature-A 与 fix-B 的内容并存于文件之中。但是在实际的软件开发中，往往需要删除其中之一，所以各位在处理冲突时，务必要仔细分析冲突部分的内容后再行修改。\n\n### 提交解决后的结果\n\n冲突解决后，执行 git add命令与 git commit命令。\n\n\n\n## git commit --amend——修改提交信息\n\n\n\n## git rebase -i——压缩历史\n\n在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。这是个会经常用到的技巧，让我们来实际操作体会一下。\n\n首先，新建一个 feature-C 特性分支。\n\n作为 feature-C 的功能实现，我们在 README.md 文件中添加一行文字，并且故意留下拼写错误，以便之后修正。\n\n```shell\n$ git checkout -b feature-C\nSwitched to a new branch 'feature-C'\n```\n\n```shell\n# Git教程\n- feature-A\n- fix-B\n- faeture-C\n```\n\n提交这部分内容。这个小小的变更就没必要先执行 git add命令再执行 git commit命令了，我们**用 git commit -am命令来一次完成这两步操作**。\n\n```shell\n$ git commit -am \"Add feature-C\"\n[feature-C 7a34294] Add feature-C\n1 file changed, 1 insertion(+)\n```\n\n现在来修正刚才预留的拼写错误。 然后进行提交。\n\n```shell\n$ git commit -am \"Fix typo\"\n[feature-C 6fba227] Fix typo\n1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n错字漏字等失误称作 typo，所以我们将提交信息记为 \"Fix typo\"。 实际上，我们不希望在历史记录中看到这类提交，因为健全的历史记录并不需要它们。如果能在最初提交之前就发现并修正这些错误，也就不会出现这类提交了。\n\n我们来更改历史。将 \" Fix typo\"修正的内容与之前一次的提交合并，在历史记录中合并为一次完美的提交。为此，我们要用到git rebase命令。\n\n```shell\n$ git rebase -i HEAD~2\n```\n\n用上述方式执行 git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。\n\n```shell\npick 7a34294 Add feature-C\npick 6fba227 Fix typo\n# Rebase 2e7db6f..6fba227 onto 2e7db6f\n#\n# Commands:\n# p, pick = use commit\n# r, reword = use commit, but edit the commit message\n# e, edit = use commit, but stop for amending\n# s, squash = use commit, but meld into previous commit\n# f, fixup = like \"squash\", but discard this commit's log message\n# x, exec = run command (the rest of the line) using shell\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n```\n\n我们将 6fba227 的 Fix typo 的历史记录压缩到 7a34294 的 Add feature-C里。按照下图所示，将 6fba227 左侧的 pick 部分删除，改写为 fixup。\n\n```shell\npick 7a34294 Add feature-C\nfixup 6fba227 Fix typo\n[detached HEAD 51440c5] Add feature-C\n1 file changed, 1 insertion(+)\nSuccessfully rebased and updated refs/heads/feature-C.\n```\n\n这样一来， Fix typo 就从历史中被抹去，也就相当于 Add feature-C中从来没有出现过拼写错误。这算是一种**良性的历史改写**。\n\n\n\n# 推送至远程仓库\n\n## git remote add——添加远程仓库\n\n在 GitHub 上创建的仓库路径为“git@github.com:用户名 /git-tutorial.git”。现在我们用 git remote add命令将它设置成本地仓库的远程仓库。\n\n ```shell\n$ git remote add origin git@github.com:github-book/git-tutorial.git\n ```\n\n按照上述格式执行 git remote add命令之后， Git 会自动git@github.com:github-book/git-tutorial.git远程仓库的名称设置为 origin（标识符）。\n\n\n\n## git push——推送至远程仓库\n\n### 推送至 master 分支\n\n如果想将当前分支下本地仓库中的内容推送给远程仓库，需要用到git push命令。现在假定我们在 master 分支下进行操作。\n\n```shell\n$ git push -u origin master\nCounting objects: 20, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (10/10), done.\nWriting objects: 100% (20/20), 1.60 KiB, done.\nTotal 20 (delta 3), reused 0 (delta 0)\nTo git@github.com:github-book/git-tutorial.git\n* [new branch] master -> master\nBranch master set up to track remote branch master from origin.\n```\n\n像这样执行 git push命令，当前分支的内容就会被推送给远程仓库origin 的 master 分支。 -u参数可以在推送的同时，将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦。执行该操作后，当前本地仓库 master 分支的内容将会被推送到GitHub 的远程仓库中。在 GitHub 上也可以确认远程 master 分支的内容 和本地 master 分支相同。\n\n\n\n### 推送至 master 以外的分支\n\n除了 master 分支之外，远程仓库也可以创建其他分支。举个例子，我们在本地仓库中创建 feature-D 分支，并将它以同名形式 push 至远程仓库。\n\n```shell\n$ git checkout -b feature-D\nSwitched to a new branch 'feature-D'\n```\n\n我们在本地仓库中创建了 feature-D 分支，现在将它 push 给远程仓库并保持分支名称不变。\n\n```shell\n$ git push -u origin feature-D\nTotal 0 (delta 0), reused 0 (delta 0)\nTo git@github.com:github-book/git-tutorial.git\n* [new branch] feature-D -> feature-D\nBranch feature-D set up to track remote branch feature-D from origin.\n```\n\n\n\n# 从远程仓库获取\n\n## git clone——获取远程仓库\n\n\n\n### 获取远程仓库\n\n首先我们换到其他目录下，将 GitHub 上的仓库 clone 到本地。注意 不要与之前操作的仓库在同一目录下。\n\n```shell\n$ git clone git@github.com:github-book/git-tutorial.git\nCloning into 'git-tutorial'...\nremote: Counting objects: 20, done.\nremote: Compressing objects: 100% (7/7), done.\nremote: Total 20 (delta 3), reused 20 (delta 3)\nReceiving objects: 100% (20/20), done.\nResolving deltas: 100% (3/3), done.\n$ cd git-tutorial\n```\n\n执行 git clone命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master 分支在内容上是完全相同的。\n\n ```shell\n$ git branch -a\n* master\nremotes/origin/HEAD -> origin/master\nremotes/origin/feature-D\nremotes/origin/master\n ```\n\n我们用 git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息。\n结果中显示了 remotes/origin/feature-D，证明我们的远程仓库中已经有了 feature-D 分支 。\n\n### 获取远程的 feature-D 分支\n\n我们试着将 feature-D 分支获取至本地仓库。\n\n```shell\n$ git checkout -b feature-D origin/feature-D\nBranch feature-D set up to track remote branch feature-D from origin.\nSwitched to a new branch 'feature-D'\n```\n\n-b 参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了 origin/feature-D，就是说以名为 origin 的仓库（这里指 GitHub 端的仓库）的 feature-D 分支为来源，在本地仓库中创建 feature-D 分支。\n\n\n\n## git pull——获取最新的远程仓库分支\n\n远程仓库的 feature-D 分支中已经有了我们刚刚推送的提交。这时我们就可以使用 git pull 命令，将本地的 feature-D 分支更新到最新状态。当前分支为 feature-D 分支。\n\n```shell\n$ git pull origin feature-D\nremote: Counting objects: 5, done.\nremote: Compressing objects: 100% (1/1), done.\nremote: Total 3 (delta 1), reused 3 (delta 1)\nUnpacking objects: 100% (3/3), done.\nFrom github.com:github-book/git-tutorial\n* branch feature-D -> FETCH_HEAD\nFirst, rewinding head to replay your work on top of it...\nFast-forwarded feature-D to ed9721e686f8c588e55ec6b8071b669f411486b8.\n```\n\n\n\n-----\n\n# 如何用Github的gh-pages分支展示自己的项目\n\n```\ngit subtree push --prefix=dist origin gh-pages\n```\n\n意思就是把指定的dist文件提交到gh-pages分支上\n","slug":"Git-basic-operation","published":1,"updated":"2018-01-27T04:08:54.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwup000h9taxid0q9iw3","content":"<p>纯属搬砖操作，资料来源《Github入门与实战》，这本书的重要信息也就这些了，需要的时候找一找。</p>\n<p>书上提到的一个学习网站<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">https://learngitbranching.js.org/</a>非常棒，线上学习。</p>\n<a id=\"more\"></a>\n<h1 id=\"Git基本操作\"><a href=\"#Git基本操作\" class=\"headerlink\" title=\"Git基本操作\"></a>Git基本操作</h1><h2 id=\"git-init——初始化仓库\"><a href=\"#git-init——初始化仓库\" class=\"headerlink\" title=\"git init——初始化仓库\"></a>git init——初始化仓库</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir git-tutorial</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> git-tutorial</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git init</span></span><br><span class=\"line\">Initialized empty Git repository in /Users/hirocaster/github/github-book</span><br><span class=\"line\">/git-tutorial/.git/</span><br></pre></td></tr></table></figure>\n<p>如果初始化成功，执行了 git init命令的目录下就会生成 .git 目录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。 在 Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开。</p>\n<h2 id=\"git-status——查看仓库状态\"><a href=\"#git-status——查看仓库状态\" class=\"headerlink\" title=\"git status——查看仓库状态\"></a>git status——查看仓库状态</h2><p>git status命令用于显示 Git 仓库的状态。这是一个十分常用的命令，请务必牢记。</p>\n<p>工作树和仓库在被操作的过程中，状态会不断发生变化。在 Git 操作过程中时常用 git status命令查看当前状态，可谓基本中的基本。下面，就让我们来实际查看一下当前状态 ：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git status</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> On branch master</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Initial commit</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">nothing to commit (create/copy files and use \"git add\" to track)</span><br></pre></td></tr></table></figure>\n<p>结果显示了我们当前正处于 master 分支下。关于分支我们会在不久后讲到，现在不必深究。接着还显示了没有可提交的内容。所谓提交（Commit），是指“记录工作树中所有文件的当前状态”。</p>\n<h2 id=\"git-add——向暂存区中添加文件\"><a href=\"#git-add——向暂存区中添加文件\" class=\"headerlink\" title=\"git add——向暂存区中添加文件\"></a>git add——向暂存区中添加文件</h2><p>要想让文件成为 Git 仓库的管理对象，就需要用 git add命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git add README.md</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git status</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> On branch master</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Initial commit</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Changes to be committed:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> (use <span class=\"string\">\"git rm --cached &lt;file&gt;...\"</span> to unstage)</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> new file: README.md</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n<p>将 README.md 文件加入暂存区后， git status命令的显示结果发生了变化。可以看到， README.md 文件显示在 Changes to be committed 中了。</p>\n<h2 id=\"git-commit——保存仓库的历史记录\"><a href=\"#git-commit——保存仓库的历史记录\" class=\"headerlink\" title=\"git commit——保存仓库的历史记录\"></a>git commit——保存仓库的历史记录</h2><p>git commit命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -m <span class=\"string\">\"First commit\"</span></span></span><br><span class=\"line\">[master (root-commit) 9f129ba] First commit</span><br><span class=\"line\">1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class=\"line\">create mode 100644 README.md</span><br></pre></td></tr></table></figure>\n<p>-m 参数后的 “First commit”称作提交信息，是对这个提交的概述。</p>\n<h2 id=\"git-log——查看提交日志\"><a href=\"#git-log——查看提交日志\" class=\"headerlink\" title=\"git log——查看提交日志\"></a>git log——查看提交日志</h2><p>git log命令可以查看以往仓库中提交的日志。包括可以查看什 么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。关于合并我们会在后面解说。</p>\n<p>我们先来看看刚才的 git commit命令是否被记录了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">log</span></span></span><br><span class=\"line\">commit 9f129bae19b2c82fb4e98cde5890e52a6c546922</span><br><span class=\"line\">Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">Date: Sun May 5 16:06:49 2013 +0900</span><br><span class=\"line\">First commit</span><br></pre></td></tr></table></figure>\n<p>如上图所示，屏幕显示了刚刚的提交操作。 commit 栏旁边显示的“9f129b……”是指向这个提交的哈希值。 Git 的其他命令中，在指向提交时会用到这个哈希值。</p>\n<p>Author 栏中显示我们给 Git 设置的用户名和邮箱地址。 Date 栏中显示提交执行的日期和时间。再往下就是该提交的提交信息。</p>\n<h3 id=\"只显示提交信息的第一行\"><a href=\"#只显示提交信息的第一行\" class=\"headerlink\" title=\"只显示提交信息的第一行\"></a>只显示提交信息的第一行</h3><p>如果只想让程序显示第一行简述信息，可以在 git log命令后加上 –pretty=short。这样一来开发人员就能够更轻松地把握多个提交。</p>\n<h3 id=\"只显示指定目录、文件的日志\"><a href=\"#只显示指定目录、文件的日志\" class=\"headerlink\" title=\"只显示指定目录、文件的日志\"></a>只显示指定目录、文件的日志</h3><p>只要在 git log命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。</p>\n<h3 id=\"显示文件的改动\"><a href=\"#显示文件的改动\" class=\"headerlink\" title=\"显示文件的改动\"></a>显示文件的改动</h3><p>如果想查看提交所带来的改动，可以加上 -p参数，文件的前后差别就会显示在提交信息之后。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">log</span> -p</span></span><br></pre></td></tr></table></figure>\n<p>如上所述， git log命令可以利用多种参数帮助开发者把握以往提交的内容。不必勉强自己一次记下全部参数，每当有想查看的日志就积极去查，慢慢就能得心应手了。</p>\n<h2 id=\"git-diff——查看更改前后的差别\"><a href=\"#git-diff——查看更改前后的差别\" class=\"headerlink\" title=\"git diff——查看更改前后的差别\"></a>git diff——查看更改前后的差别</h2><p>git diff命令可以查看工作树、暂存区、最新提交之间的差别。单从字面上可能很难理解，各位不妨跟着笔者的解说亲手试一试。</p>\n<h3 id=\"查看工作树和暂存区的差别\"><a href=\"#查看工作树和暂存区的差别\" class=\"headerlink\" title=\"查看工作树和暂存区的差别\"></a>查看工作树和暂存区的差别</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git diff</span></span><br><span class=\"line\">diff --git a/README.md b/README.md</span><br><span class=\"line\">index e69de29..cb5dc9f 100644</span><br><span class=\"line\">--- a/README.md</span><br><span class=\"line\">+++ b/README.md</span><br><span class=\"line\">@@ -0,0 +1 @@</span><br><span class=\"line\">+# Git教程</span><br></pre></td></tr></table></figure>\n<p>这里解释一下显示的内容。“+”号标出的是新添加的行，被删除的行则用“-”号标出。我们可以看到，这次只添加了一行 。</p>\n<h3 id=\"查看工作树和最新提交的差别\"><a href=\"#查看工作树和最新提交的差别\" class=\"headerlink\" title=\"查看工作树和最新提交的差别\"></a>查看工作树和最新提交的差别</h3><p>要查看与最新提交的差别，请执行以下命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git diff HEAD</span></span><br><span class=\"line\">diff --git a/README.md b/README.md</span><br><span class=\"line\">index e69de29..cb5dc9f 100644</span><br><span class=\"line\">--- a/README.md</span><br><span class=\"line\">+++ b/README.md</span><br><span class=\"line\">@@ -0,0 +1 @@</span><br><span class=\"line\">+# Git教程</span><br></pre></td></tr></table></figure>\n<p> <strong>不妨养成这样一个好习惯：在执行 git commit命令之前先执行git diff HEAD命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交</strong>。这里的 HEAD 是指向当前分支中最新一次提交的指针。</p>\n<h1 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h1><p>通过灵活运用分支，可以让多人同时高效地进行并行开发。在这里，我们将带大家学习与分支相关的 Git 操作。</p>\n<h2 id=\"git-branch——显示分支一览表\"><a href=\"#git-branch——显示分支一览表\" class=\"headerlink\" title=\"git branch——显示分支一览表\"></a>git branch——显示分支一览表</h2><p>git branch命令可以将分支名列表显示，同时可以确认当前所在分支。让我们来实际运行 git branch命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git branch</span></span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n<p>可以看到 master 分支左侧标有“*”（星号），表示这是我们当前所在的分支。也就是说，我们正在 master 分支下进行开发。结果中没有显示其他分支名，表示本地仓库中只存在 master 一个分支。</p>\n<h2 id=\"git-checkout-b——创建、切换分支\"><a href=\"#git-checkout-b——创建、切换分支\" class=\"headerlink\" title=\"git checkout -b——创建、切换分支\"></a>git checkout -b——创建、切换分支</h2><p>如果想以当前的 master 分支为基础创建新的分支，我们需要用到git checkout -b命令。</p>\n<h3 id=\"切换到-feature-A-分支并进行提交\"><a href=\"#切换到-feature-A-分支并进行提交\" class=\"headerlink\" title=\"切换到 feature-A 分支并进行提交\"></a>切换到 feature-A 分支并进行提交</h3><p>执行下面的命令，创建名为 feature-A 的分支。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -b feature-A</span></span><br><span class=\"line\">Switched to a new branch 'feature-A'</span><br></pre></td></tr></table></figure>\n<p>实际上，连续执行下面两条命令也能收到同样效果。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git branch feature-A</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout feature-A</span></span><br></pre></td></tr></table></figure>\n<p>创建 feature-A 分支，并将当前分支切换为 feature-A 分支。这时再来查看分支列表，会显示我们处于 feature-A 分支下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git branch</span></span><br><span class=\"line\">* feature-A</span><br><span class=\"line\">master</span><br></pre></td></tr></table></figure>\n<p>feature-A 分支左侧标有“*”，表示当前分支为 feature-A。在这个状态下像正常开发那样修改代码、执行 git add命令并进行提交的话，代 码 就 会 提 交 至 feature-A 分 支。 像 这 样 不 断 对 一 个 分 支（例 如feature-A）进行提交的操作，我们称为“培育分支”。</p>\n<h3 id=\"切换回上一个分支\"><a href=\"#切换回上一个分支\" class=\"headerlink\" title=\"切换回上一个分支\"></a>切换回上一个分支</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -</span></span><br></pre></td></tr></table></figure>\n<p>像上面这样用“-”（连字符）代替分支名，就可以切换至上一个分支。</p>\n<h2 id=\"特性分支\"><a href=\"#特性分支\" class=\"headerlink\" title=\"特性分支\"></a>特性分支</h2><p>Git 与 Subversion（SVN）等集中型版本管理系统不同，创建分支时不需要连接中央仓库，所以能够相对轻松地创建分支。因此，当今大部分工作流程中都用到了特性（Topic）分支。</p>\n<p>特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由 master 分支担当。</p>\n<p> 基于特定主题的作业在特性分支中进行，主题完成后再与 master 分支合并。只要保持这样一个开发流程，就能保证 master 分支可以随时供人查看。这样一来，其他开发者也可以放心大胆地从 master 分支创建新的特性分支 。</p>\n<h2 id=\"git-merge——合并分支\"><a href=\"#git-merge——合并分支\" class=\"headerlink\" title=\"git merge——合并分支\"></a>git merge——合并分支</h2><p>接下来，我们假设 feature-A 已经实现完毕，想要将它合并到主干分支 master 中。首先切换到 master 分支。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout master</span></span><br><span class=\"line\">Switched to branch 'master'</span><br></pre></td></tr></table></figure>\n<p>然后合并 feature-A 分支。为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交。因此，在合并时加上 –no-ff参数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git merge --no-ff feature-A</span></span><br></pre></td></tr></table></figure>\n<p>随后编辑器会启动，用于录入合并提交的信息。</p>\n<h2 id=\"git-log-–graph——以图表形式查看分支\"><a href=\"#git-log-–graph——以图表形式查看分支\" class=\"headerlink\" title=\"git log –graph——以图表形式查看分支\"></a>git log –graph——以图表形式查看分支</h2><p>用 git log –graph命令进行查看的话，能很清楚地看到特性分支（feature-A）提交的内容已被合并。除此以外，特性分支的创建以及合并也都清楚明了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">log</span> --graph</span></span><br><span class=\"line\">* commit 83b0b94268675cb715ac6c8a5bc1965938c15f62</span><br><span class=\"line\">|\\ Merge: fd0cbf0 8a6c8b9</span><br><span class=\"line\">| | Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">| | Date: Sun May 5 16:37:57 2013 +0900</span><br><span class=\"line\">| |</span><br><span class=\"line\">| | Merge branch 'feature-A'</span><br><span class=\"line\">| |</span><br><span class=\"line\">| * commit 8a6c8b97c8962cd44afb69c65f26d6e1a6c088d8</span><br><span class=\"line\">|/ Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">| Date: Sun May 5 16:22:02 2013 +0900</span><br><span class=\"line\">|</span><br><span class=\"line\">| Add feature-A</span><br><span class=\"line\">|</span><br><span class=\"line\">* commit fd0cbf0d4a25f747230694d95cac1be72d33441d</span><br><span class=\"line\">| Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">| Date: Sun May 5 16:10:15 2013 +0900</span><br><span class=\"line\">|</span><br><span class=\"line\">| Add index</span><br><span class=\"line\">|</span><br><span class=\"line\">* commit 9f129bae19b2c82fb4e98cde5890e52a6c546922</span><br><span class=\"line\">Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">Date: Sun May 5 16:06:49 2013 +0900</span><br><span class=\"line\">First commit</span><br></pre></td></tr></table></figure>\n<p>git log –graph命令可以用图表形式输出提交日志，非常直观，请大家务必记住。</p>\n<h1 id=\"更改提交的操作\"><a href=\"#更改提交的操作\" class=\"headerlink\" title=\"更改提交的操作\"></a>更改提交的操作</h1><h2 id=\"git-reset——回溯历史版本\"><a href=\"#git-reset——回溯历史版本\" class=\"headerlink\" title=\"git reset——回溯历史版本\"></a>git reset——回溯历史版本</h2><p>Git 的另一特征便是可以灵活操作历史版本。借助分散仓库的优势，可以在不影响其他仓库的前提下对历史版本进行操作。</p>\n<p>要让仓库的 HEAD、暂存区、当前工作树回溯到指定状态，需要用到 git rest –hard命令。只要提供目标时间点的哈希值 ，就可以 完全恢复至该时间点的状态。事不宜迟，让我们执行下面的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d (使用时这里需要个人更改哈希值)</span></span><br><span class=\"line\">HEAD is now at fd0cbf0 Add index</span><br></pre></td></tr></table></figure>\n<p><strong>git log命令只能查看以当前状态为终点的历史日志。所以这里要使用 git reflog命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过 git reset –hard命令恢复到回溯历史前的状态 。</strong></p>\n<h2 id=\"消除冲突\"><a href=\"#消除冲突\" class=\"headerlink\" title=\"消除冲突\"></a>消除冲突</h2><h3 id=\"查看冲突部分并将其解决\"><a href=\"#查看冲突部分并将其解决\" class=\"headerlink\" title=\"查看冲突部分并将其解决\"></a>查看冲突部分并将其解决</h3><p>用编辑器打开 README.md （如果你发生了冲突，查看相应的冲突文件）文件，就会发现其内容变成了下面这个样子。 （这是书上的例子）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Git教程</span></span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">- feature-A</span><br><span class=\"line\">=======</span><br><span class=\"line\">- fix-B</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt;&gt;&gt;&gt;&gt; fix-B</span></span><br></pre></td></tr></table></figure>\n<p><code>=======</code>以上的部分是当前 HEAD 的内容，以下的部分是要合并的 fix-B 分支中的内容。我们在编辑器中将其改成想要的样子。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Git教程</span></span><br><span class=\"line\">- feature-A</span><br><span class=\"line\">- fix-B</span><br></pre></td></tr></table></figure>\n<p>如上所示，本次修正让 feature-A 与 fix-B 的内容并存于文件之中。但是在实际的软件开发中，往往需要删除其中之一，所以各位在处理冲突时，务必要仔细分析冲突部分的内容后再行修改。</p>\n<h3 id=\"提交解决后的结果\"><a href=\"#提交解决后的结果\" class=\"headerlink\" title=\"提交解决后的结果\"></a>提交解决后的结果</h3><p>冲突解决后，执行 git add命令与 git commit命令。</p>\n<h2 id=\"git-commit-–amend——修改提交信息\"><a href=\"#git-commit-–amend——修改提交信息\" class=\"headerlink\" title=\"git commit –amend——修改提交信息\"></a>git commit –amend——修改提交信息</h2><h2 id=\"git-rebase-i——压缩历史\"><a href=\"#git-rebase-i——压缩历史\" class=\"headerlink\" title=\"git rebase -i——压缩历史\"></a>git rebase -i——压缩历史</h2><p>在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。这是个会经常用到的技巧，让我们来实际操作体会一下。</p>\n<p>首先，新建一个 feature-C 特性分支。</p>\n<p>作为 feature-C 的功能实现，我们在 README.md 文件中添加一行文字，并且故意留下拼写错误，以便之后修正。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -b feature-C</span></span><br><span class=\"line\">Switched to a new branch 'feature-C'</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Git教程</span></span><br><span class=\"line\">- feature-A</span><br><span class=\"line\">- fix-B</span><br><span class=\"line\">- faeture-C</span><br></pre></td></tr></table></figure>\n<p>提交这部分内容。这个小小的变更就没必要先执行 git add命令再执行 git commit命令了，我们<strong>用 git commit -am命令来一次完成这两步操作</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -am <span class=\"string\">\"Add feature-C\"</span></span></span><br><span class=\"line\">[feature-C 7a34294] Add feature-C</span><br><span class=\"line\">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n<p>现在来修正刚才预留的拼写错误。 然后进行提交。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -am <span class=\"string\">\"Fix typo\"</span></span></span><br><span class=\"line\">[feature-C 6fba227] Fix typo</span><br><span class=\"line\">1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\n<p>错字漏字等失误称作 typo，所以我们将提交信息记为 “Fix typo”。 实际上，我们不希望在历史记录中看到这类提交，因为健全的历史记录并不需要它们。如果能在最初提交之前就发现并修正这些错误，也就不会出现这类提交了。</p>\n<p>我们来更改历史。将 “ Fix typo”修正的内容与之前一次的提交合并，在历史记录中合并为一次完美的提交。为此，我们要用到git rebase命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git rebase -i HEAD~2</span></span><br></pre></td></tr></table></figure>\n<p>用上述方式执行 git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 7a34294 Add feature-C</span><br><span class=\"line\">pick 6fba227 Fix typo</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Rebase 2e7db6f..6fba227 onto 2e7db6f</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Commands:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> p, pick = use commit</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> r, reword = use commit, but edit the commit message</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> e, edit = use commit, but stop <span class=\"keyword\">for</span> amending</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> s, squash = use commit, but meld into previous commit</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> f, fixup = like <span class=\"string\">\"squash\"</span>, but discard this commit<span class=\"string\">'s log message</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> x, <span class=\"built_in\">exec</span> = run <span class=\"built_in\">command</span> (the rest of the line) using shell</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> However, <span class=\"keyword\">if</span> you remove everything, the rebase will be aborted.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure>\n<p>我们将 6fba227 的 Fix typo 的历史记录压缩到 7a34294 的 Add feature-C里。按照下图所示，将 6fba227 左侧的 pick 部分删除，改写为 fixup。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 7a34294 Add feature-C</span><br><span class=\"line\">fixup 6fba227 Fix typo</span><br><span class=\"line\">[detached HEAD 51440c5] Add feature-C</span><br><span class=\"line\">1 file changed, 1 insertion(+)</span><br><span class=\"line\">Successfully rebased and updated refs/heads/feature-C.</span><br></pre></td></tr></table></figure>\n<p>这样一来， Fix typo 就从历史中被抹去，也就相当于 Add feature-C中从来没有出现过拼写错误。这算是一种<strong>良性的历史改写</strong>。</p>\n<h1 id=\"推送至远程仓库\"><a href=\"#推送至远程仓库\" class=\"headerlink\" title=\"推送至远程仓库\"></a>推送至远程仓库</h1><h2 id=\"git-remote-add——添加远程仓库\"><a href=\"#git-remote-add——添加远程仓库\" class=\"headerlink\" title=\"git remote add——添加远程仓库\"></a>git remote add——添加远程仓库</h2><p>在 GitHub 上创建的仓库路径为“git@github.com:用户名 /git-tutorial.git”。现在我们用 git remote add命令将它设置成本地仓库的远程仓库。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git remote add origin git@github.com:github-book/git-tutorial.git</span></span><br></pre></td></tr></table></figure>\n<p>按照上述格式执行 git remote add命令之后， Git 会自动git@github.com:github-book/git-tutorial.git远程仓库的名称设置为 origin（标识符）。</p>\n<h2 id=\"git-push——推送至远程仓库\"><a href=\"#git-push——推送至远程仓库\" class=\"headerlink\" title=\"git push——推送至远程仓库\"></a>git push——推送至远程仓库</h2><h3 id=\"推送至-master-分支\"><a href=\"#推送至-master-分支\" class=\"headerlink\" title=\"推送至 master 分支\"></a>推送至 master 分支</h3><p>如果想将当前分支下本地仓库中的内容推送给远程仓库，需要用到git push命令。现在假定我们在 master 分支下进行操作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push -u origin master</span></span><br><span class=\"line\">Counting objects: 20, done.</span><br><span class=\"line\">Delta compression using up to 8 threads.</span><br><span class=\"line\">Compressing objects: 100% (10/10), done.</span><br><span class=\"line\">Writing objects: 100% (20/20), 1.60 KiB, done.</span><br><span class=\"line\">Total 20 (delta 3), reused 0 (delta 0)</span><br><span class=\"line\">To git@github.com:github-book/git-tutorial.git</span><br><span class=\"line\">* [new branch] master -&gt; master</span><br><span class=\"line\">Branch master set up to track remote branch master from origin.</span><br></pre></td></tr></table></figure>\n<p>像这样执行 git push命令，当前分支的内容就会被推送给远程仓库origin 的 master 分支。 -u参数可以在推送的同时，将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦。执行该操作后，当前本地仓库 master 分支的内容将会被推送到GitHub 的远程仓库中。在 GitHub 上也可以确认远程 master 分支的内容 和本地 master 分支相同。</p>\n<h3 id=\"推送至-master-以外的分支\"><a href=\"#推送至-master-以外的分支\" class=\"headerlink\" title=\"推送至 master 以外的分支\"></a>推送至 master 以外的分支</h3><p>除了 master 分支之外，远程仓库也可以创建其他分支。举个例子，我们在本地仓库中创建 feature-D 分支，并将它以同名形式 push 至远程仓库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -b feature-D</span></span><br><span class=\"line\">Switched to a new branch 'feature-D'</span><br></pre></td></tr></table></figure>\n<p>我们在本地仓库中创建了 feature-D 分支，现在将它 push 给远程仓库并保持分支名称不变。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push -u origin feature-D</span></span><br><span class=\"line\">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To git@github.com:github-book/git-tutorial.git</span><br><span class=\"line\">* [new branch] feature-D -&gt; feature-D</span><br><span class=\"line\">Branch feature-D set up to track remote branch feature-D from origin.</span><br></pre></td></tr></table></figure>\n<h1 id=\"从远程仓库获取\"><a href=\"#从远程仓库获取\" class=\"headerlink\" title=\"从远程仓库获取\"></a>从远程仓库获取</h1><h2 id=\"git-clone——获取远程仓库\"><a href=\"#git-clone——获取远程仓库\" class=\"headerlink\" title=\"git clone——获取远程仓库\"></a>git clone——获取远程仓库</h2><h3 id=\"获取远程仓库\"><a href=\"#获取远程仓库\" class=\"headerlink\" title=\"获取远程仓库\"></a>获取远程仓库</h3><p>首先我们换到其他目录下，将 GitHub 上的仓库 clone 到本地。注意 不要与之前操作的仓库在同一目录下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git@github.com:github-book/git-tutorial.git</span></span><br><span class=\"line\">Cloning into 'git-tutorial'...</span><br><span class=\"line\">remote: Counting objects: 20, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (7/7), done.</span><br><span class=\"line\">remote: Total 20 (delta 3), reused 20 (delta 3)</span><br><span class=\"line\">Receiving objects: 100% (20/20), done.</span><br><span class=\"line\">Resolving deltas: 100% (3/3), done.</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> git-tutorial</span></span><br></pre></td></tr></table></figure>\n<p>执行 git clone命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master 分支在内容上是完全相同的。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git branch -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">remotes/origin/HEAD -&gt; origin/master</span><br><span class=\"line\">remotes/origin/feature-D</span><br><span class=\"line\">remotes/origin/master</span><br></pre></td></tr></table></figure>\n<p>我们用 git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息。<br>结果中显示了 remotes/origin/feature-D，证明我们的远程仓库中已经有了 feature-D 分支 。</p>\n<h3 id=\"获取远程的-feature-D-分支\"><a href=\"#获取远程的-feature-D-分支\" class=\"headerlink\" title=\"获取远程的 feature-D 分支\"></a>获取远程的 feature-D 分支</h3><p>我们试着将 feature-D 分支获取至本地仓库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -b feature-D origin/feature-D</span></span><br><span class=\"line\">Branch feature-D set up to track remote branch feature-D from origin.</span><br><span class=\"line\">Switched to a new branch 'feature-D'</span><br></pre></td></tr></table></figure>\n<p>-b 参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了 origin/feature-D，就是说以名为 origin 的仓库（这里指 GitHub 端的仓库）的 feature-D 分支为来源，在本地仓库中创建 feature-D 分支。</p>\n<h2 id=\"git-pull——获取最新的远程仓库分支\"><a href=\"#git-pull——获取最新的远程仓库分支\" class=\"headerlink\" title=\"git pull——获取最新的远程仓库分支\"></a>git pull——获取最新的远程仓库分支</h2><p>远程仓库的 feature-D 分支中已经有了我们刚刚推送的提交。这时我们就可以使用 git pull 命令，将本地的 feature-D 分支更新到最新状态。当前分支为 feature-D 分支。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git pull origin feature-D</span></span><br><span class=\"line\">remote: Counting objects: 5, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (1/1), done.</span><br><span class=\"line\">remote: Total 3 (delta 1), reused 3 (delta 1)</span><br><span class=\"line\">Unpacking objects: 100% (3/3), done.</span><br><span class=\"line\">From github.com:github-book/git-tutorial</span><br><span class=\"line\">* branch feature-D -&gt; FETCH_HEAD</span><br><span class=\"line\">First, rewinding head to replay your work on top of it...</span><br><span class=\"line\">Fast-forwarded feature-D to ed9721e686f8c588e55ec6b8071b669f411486b8.</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"如何用Github的gh-pages分支展示自己的项目\"><a href=\"#如何用Github的gh-pages分支展示自己的项目\" class=\"headerlink\" title=\"如何用Github的gh-pages分支展示自己的项目\"></a>如何用Github的gh-pages分支展示自己的项目</h1><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree <span class=\"built_in\">push</span> --<span class=\"built_in\">prefix</span>=dist <span class=\"built_in\">origin</span> gh-pages</span><br></pre></td></tr></table></figure>\n<p>意思就是把指定的dist文件提交到gh-pages分支上</p>\n","site":{"data":{}},"excerpt":"<p>纯属搬砖操作，资料来源《Github入门与实战》，这本书的重要信息也就这些了，需要的时候找一找。</p>\n<p>书上提到的一个学习网站<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">https://learngitbranching.js.org/</a>非常棒，线上学习。</p>","more":"<h1 id=\"Git基本操作\"><a href=\"#Git基本操作\" class=\"headerlink\" title=\"Git基本操作\"></a>Git基本操作</h1><h2 id=\"git-init——初始化仓库\"><a href=\"#git-init——初始化仓库\" class=\"headerlink\" title=\"git init——初始化仓库\"></a>git init——初始化仓库</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir git-tutorial</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> git-tutorial</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git init</span></span><br><span class=\"line\">Initialized empty Git repository in /Users/hirocaster/github/github-book</span><br><span class=\"line\">/git-tutorial/.git/</span><br></pre></td></tr></table></figure>\n<p>如果初始化成功，执行了 git init命令的目录下就会生成 .git 目录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。 在 Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开。</p>\n<h2 id=\"git-status——查看仓库状态\"><a href=\"#git-status——查看仓库状态\" class=\"headerlink\" title=\"git status——查看仓库状态\"></a>git status——查看仓库状态</h2><p>git status命令用于显示 Git 仓库的状态。这是一个十分常用的命令，请务必牢记。</p>\n<p>工作树和仓库在被操作的过程中，状态会不断发生变化。在 Git 操作过程中时常用 git status命令查看当前状态，可谓基本中的基本。下面，就让我们来实际查看一下当前状态 ：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git status</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> On branch master</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Initial commit</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">nothing to commit (create/copy files and use \"git add\" to track)</span><br></pre></td></tr></table></figure>\n<p>结果显示了我们当前正处于 master 分支下。关于分支我们会在不久后讲到，现在不必深究。接着还显示了没有可提交的内容。所谓提交（Commit），是指“记录工作树中所有文件的当前状态”。</p>\n<h2 id=\"git-add——向暂存区中添加文件\"><a href=\"#git-add——向暂存区中添加文件\" class=\"headerlink\" title=\"git add——向暂存区中添加文件\"></a>git add——向暂存区中添加文件</h2><p>要想让文件成为 Git 仓库的管理对象，就需要用 git add命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git add README.md</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git status</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> On branch master</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Initial commit</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Changes to be committed:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> (use <span class=\"string\">\"git rm --cached &lt;file&gt;...\"</span> to unstage)</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> new file: README.md</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n<p>将 README.md 文件加入暂存区后， git status命令的显示结果发生了变化。可以看到， README.md 文件显示在 Changes to be committed 中了。</p>\n<h2 id=\"git-commit——保存仓库的历史记录\"><a href=\"#git-commit——保存仓库的历史记录\" class=\"headerlink\" title=\"git commit——保存仓库的历史记录\"></a>git commit——保存仓库的历史记录</h2><p>git commit命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。通过这些记录，我们就可以在工作树中复原文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -m <span class=\"string\">\"First commit\"</span></span></span><br><span class=\"line\">[master (root-commit) 9f129ba] First commit</span><br><span class=\"line\">1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class=\"line\">create mode 100644 README.md</span><br></pre></td></tr></table></figure>\n<p>-m 参数后的 “First commit”称作提交信息，是对这个提交的概述。</p>\n<h2 id=\"git-log——查看提交日志\"><a href=\"#git-log——查看提交日志\" class=\"headerlink\" title=\"git log——查看提交日志\"></a>git log——查看提交日志</h2><p>git log命令可以查看以往仓库中提交的日志。包括可以查看什 么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。关于合并我们会在后面解说。</p>\n<p>我们先来看看刚才的 git commit命令是否被记录了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">log</span></span></span><br><span class=\"line\">commit 9f129bae19b2c82fb4e98cde5890e52a6c546922</span><br><span class=\"line\">Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">Date: Sun May 5 16:06:49 2013 +0900</span><br><span class=\"line\">First commit</span><br></pre></td></tr></table></figure>\n<p>如上图所示，屏幕显示了刚刚的提交操作。 commit 栏旁边显示的“9f129b……”是指向这个提交的哈希值。 Git 的其他命令中，在指向提交时会用到这个哈希值。</p>\n<p>Author 栏中显示我们给 Git 设置的用户名和邮箱地址。 Date 栏中显示提交执行的日期和时间。再往下就是该提交的提交信息。</p>\n<h3 id=\"只显示提交信息的第一行\"><a href=\"#只显示提交信息的第一行\" class=\"headerlink\" title=\"只显示提交信息的第一行\"></a>只显示提交信息的第一行</h3><p>如果只想让程序显示第一行简述信息，可以在 git log命令后加上 –pretty=short。这样一来开发人员就能够更轻松地把握多个提交。</p>\n<h3 id=\"只显示指定目录、文件的日志\"><a href=\"#只显示指定目录、文件的日志\" class=\"headerlink\" title=\"只显示指定目录、文件的日志\"></a>只显示指定目录、文件的日志</h3><p>只要在 git log命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。</p>\n<h3 id=\"显示文件的改动\"><a href=\"#显示文件的改动\" class=\"headerlink\" title=\"显示文件的改动\"></a>显示文件的改动</h3><p>如果想查看提交所带来的改动，可以加上 -p参数，文件的前后差别就会显示在提交信息之后。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">log</span> -p</span></span><br></pre></td></tr></table></figure>\n<p>如上所述， git log命令可以利用多种参数帮助开发者把握以往提交的内容。不必勉强自己一次记下全部参数，每当有想查看的日志就积极去查，慢慢就能得心应手了。</p>\n<h2 id=\"git-diff——查看更改前后的差别\"><a href=\"#git-diff——查看更改前后的差别\" class=\"headerlink\" title=\"git diff——查看更改前后的差别\"></a>git diff——查看更改前后的差别</h2><p>git diff命令可以查看工作树、暂存区、最新提交之间的差别。单从字面上可能很难理解，各位不妨跟着笔者的解说亲手试一试。</p>\n<h3 id=\"查看工作树和暂存区的差别\"><a href=\"#查看工作树和暂存区的差别\" class=\"headerlink\" title=\"查看工作树和暂存区的差别\"></a>查看工作树和暂存区的差别</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git diff</span></span><br><span class=\"line\">diff --git a/README.md b/README.md</span><br><span class=\"line\">index e69de29..cb5dc9f 100644</span><br><span class=\"line\">--- a/README.md</span><br><span class=\"line\">+++ b/README.md</span><br><span class=\"line\">@@ -0,0 +1 @@</span><br><span class=\"line\">+# Git教程</span><br></pre></td></tr></table></figure>\n<p>这里解释一下显示的内容。“+”号标出的是新添加的行，被删除的行则用“-”号标出。我们可以看到，这次只添加了一行 。</p>\n<h3 id=\"查看工作树和最新提交的差别\"><a href=\"#查看工作树和最新提交的差别\" class=\"headerlink\" title=\"查看工作树和最新提交的差别\"></a>查看工作树和最新提交的差别</h3><p>要查看与最新提交的差别，请执行以下命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git diff HEAD</span></span><br><span class=\"line\">diff --git a/README.md b/README.md</span><br><span class=\"line\">index e69de29..cb5dc9f 100644</span><br><span class=\"line\">--- a/README.md</span><br><span class=\"line\">+++ b/README.md</span><br><span class=\"line\">@@ -0,0 +1 @@</span><br><span class=\"line\">+# Git教程</span><br></pre></td></tr></table></figure>\n<p> <strong>不妨养成这样一个好习惯：在执行 git commit命令之前先执行git diff HEAD命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交</strong>。这里的 HEAD 是指向当前分支中最新一次提交的指针。</p>\n<h1 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h1><p>通过灵活运用分支，可以让多人同时高效地进行并行开发。在这里，我们将带大家学习与分支相关的 Git 操作。</p>\n<h2 id=\"git-branch——显示分支一览表\"><a href=\"#git-branch——显示分支一览表\" class=\"headerlink\" title=\"git branch——显示分支一览表\"></a>git branch——显示分支一览表</h2><p>git branch命令可以将分支名列表显示，同时可以确认当前所在分支。让我们来实际运行 git branch命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git branch</span></span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n<p>可以看到 master 分支左侧标有“*”（星号），表示这是我们当前所在的分支。也就是说，我们正在 master 分支下进行开发。结果中没有显示其他分支名，表示本地仓库中只存在 master 一个分支。</p>\n<h2 id=\"git-checkout-b——创建、切换分支\"><a href=\"#git-checkout-b——创建、切换分支\" class=\"headerlink\" title=\"git checkout -b——创建、切换分支\"></a>git checkout -b——创建、切换分支</h2><p>如果想以当前的 master 分支为基础创建新的分支，我们需要用到git checkout -b命令。</p>\n<h3 id=\"切换到-feature-A-分支并进行提交\"><a href=\"#切换到-feature-A-分支并进行提交\" class=\"headerlink\" title=\"切换到 feature-A 分支并进行提交\"></a>切换到 feature-A 分支并进行提交</h3><p>执行下面的命令，创建名为 feature-A 的分支。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -b feature-A</span></span><br><span class=\"line\">Switched to a new branch 'feature-A'</span><br></pre></td></tr></table></figure>\n<p>实际上，连续执行下面两条命令也能收到同样效果。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git branch feature-A</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout feature-A</span></span><br></pre></td></tr></table></figure>\n<p>创建 feature-A 分支，并将当前分支切换为 feature-A 分支。这时再来查看分支列表，会显示我们处于 feature-A 分支下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git branch</span></span><br><span class=\"line\">* feature-A</span><br><span class=\"line\">master</span><br></pre></td></tr></table></figure>\n<p>feature-A 分支左侧标有“*”，表示当前分支为 feature-A。在这个状态下像正常开发那样修改代码、执行 git add命令并进行提交的话，代 码 就 会 提 交 至 feature-A 分 支。 像 这 样 不 断 对 一 个 分 支（例 如feature-A）进行提交的操作，我们称为“培育分支”。</p>\n<h3 id=\"切换回上一个分支\"><a href=\"#切换回上一个分支\" class=\"headerlink\" title=\"切换回上一个分支\"></a>切换回上一个分支</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -</span></span><br></pre></td></tr></table></figure>\n<p>像上面这样用“-”（连字符）代替分支名，就可以切换至上一个分支。</p>\n<h2 id=\"特性分支\"><a href=\"#特性分支\" class=\"headerlink\" title=\"特性分支\"></a>特性分支</h2><p>Git 与 Subversion（SVN）等集中型版本管理系统不同，创建分支时不需要连接中央仓库，所以能够相对轻松地创建分支。因此，当今大部分工作流程中都用到了特性（Topic）分支。</p>\n<p>特性分支顾名思义，是集中实现单一特性（主题），除此之外不进行任何作业的分支。在日常开发中，往往会创建数个特性分支，同时在此之外再保留一个随时可以发布软件的稳定分支。稳定分支的角色通常由 master 分支担当。</p>\n<p> 基于特定主题的作业在特性分支中进行，主题完成后再与 master 分支合并。只要保持这样一个开发流程，就能保证 master 分支可以随时供人查看。这样一来，其他开发者也可以放心大胆地从 master 分支创建新的特性分支 。</p>\n<h2 id=\"git-merge——合并分支\"><a href=\"#git-merge——合并分支\" class=\"headerlink\" title=\"git merge——合并分支\"></a>git merge——合并分支</h2><p>接下来，我们假设 feature-A 已经实现完毕，想要将它合并到主干分支 master 中。首先切换到 master 分支。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout master</span></span><br><span class=\"line\">Switched to branch 'master'</span><br></pre></td></tr></table></figure>\n<p>然后合并 feature-A 分支。为了在历史记录中明确记录下本次分支合并，我们需要创建合并提交。因此，在合并时加上 –no-ff参数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git merge --no-ff feature-A</span></span><br></pre></td></tr></table></figure>\n<p>随后编辑器会启动，用于录入合并提交的信息。</p>\n<h2 id=\"git-log-–graph——以图表形式查看分支\"><a href=\"#git-log-–graph——以图表形式查看分支\" class=\"headerlink\" title=\"git log –graph——以图表形式查看分支\"></a>git log –graph——以图表形式查看分支</h2><p>用 git log –graph命令进行查看的话，能很清楚地看到特性分支（feature-A）提交的内容已被合并。除此以外，特性分支的创建以及合并也都清楚明了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">log</span> --graph</span></span><br><span class=\"line\">* commit 83b0b94268675cb715ac6c8a5bc1965938c15f62</span><br><span class=\"line\">|\\ Merge: fd0cbf0 8a6c8b9</span><br><span class=\"line\">| | Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">| | Date: Sun May 5 16:37:57 2013 +0900</span><br><span class=\"line\">| |</span><br><span class=\"line\">| | Merge branch 'feature-A'</span><br><span class=\"line\">| |</span><br><span class=\"line\">| * commit 8a6c8b97c8962cd44afb69c65f26d6e1a6c088d8</span><br><span class=\"line\">|/ Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">| Date: Sun May 5 16:22:02 2013 +0900</span><br><span class=\"line\">|</span><br><span class=\"line\">| Add feature-A</span><br><span class=\"line\">|</span><br><span class=\"line\">* commit fd0cbf0d4a25f747230694d95cac1be72d33441d</span><br><span class=\"line\">| Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">| Date: Sun May 5 16:10:15 2013 +0900</span><br><span class=\"line\">|</span><br><span class=\"line\">| Add index</span><br><span class=\"line\">|</span><br><span class=\"line\">* commit 9f129bae19b2c82fb4e98cde5890e52a6c546922</span><br><span class=\"line\">Author: hirocaster &lt;hohtsuka@gmail.com&gt;</span><br><span class=\"line\">Date: Sun May 5 16:06:49 2013 +0900</span><br><span class=\"line\">First commit</span><br></pre></td></tr></table></figure>\n<p>git log –graph命令可以用图表形式输出提交日志，非常直观，请大家务必记住。</p>\n<h1 id=\"更改提交的操作\"><a href=\"#更改提交的操作\" class=\"headerlink\" title=\"更改提交的操作\"></a>更改提交的操作</h1><h2 id=\"git-reset——回溯历史版本\"><a href=\"#git-reset——回溯历史版本\" class=\"headerlink\" title=\"git reset——回溯历史版本\"></a>git reset——回溯历史版本</h2><p>Git 的另一特征便是可以灵活操作历史版本。借助分散仓库的优势，可以在不影响其他仓库的前提下对历史版本进行操作。</p>\n<p>要让仓库的 HEAD、暂存区、当前工作树回溯到指定状态，需要用到 git rest –hard命令。只要提供目标时间点的哈希值 ，就可以 完全恢复至该时间点的状态。事不宜迟，让我们执行下面的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d (使用时这里需要个人更改哈希值)</span></span><br><span class=\"line\">HEAD is now at fd0cbf0 Add index</span><br></pre></td></tr></table></figure>\n<p><strong>git log命令只能查看以当前状态为终点的历史日志。所以这里要使用 git reflog命令，查看当前仓库的操作日志。在日志中找出回溯历史之前的哈希值，通过 git reset –hard命令恢复到回溯历史前的状态 。</strong></p>\n<h2 id=\"消除冲突\"><a href=\"#消除冲突\" class=\"headerlink\" title=\"消除冲突\"></a>消除冲突</h2><h3 id=\"查看冲突部分并将其解决\"><a href=\"#查看冲突部分并将其解决\" class=\"headerlink\" title=\"查看冲突部分并将其解决\"></a>查看冲突部分并将其解决</h3><p>用编辑器打开 README.md （如果你发生了冲突，查看相应的冲突文件）文件，就会发现其内容变成了下面这个样子。 （这是书上的例子）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Git教程</span></span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">- feature-A</span><br><span class=\"line\">=======</span><br><span class=\"line\">- fix-B</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">&gt;&gt;&gt;&gt;&gt;&gt; fix-B</span></span><br></pre></td></tr></table></figure>\n<p><code>=======</code>以上的部分是当前 HEAD 的内容，以下的部分是要合并的 fix-B 分支中的内容。我们在编辑器中将其改成想要的样子。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Git教程</span></span><br><span class=\"line\">- feature-A</span><br><span class=\"line\">- fix-B</span><br></pre></td></tr></table></figure>\n<p>如上所示，本次修正让 feature-A 与 fix-B 的内容并存于文件之中。但是在实际的软件开发中，往往需要删除其中之一，所以各位在处理冲突时，务必要仔细分析冲突部分的内容后再行修改。</p>\n<h3 id=\"提交解决后的结果\"><a href=\"#提交解决后的结果\" class=\"headerlink\" title=\"提交解决后的结果\"></a>提交解决后的结果</h3><p>冲突解决后，执行 git add命令与 git commit命令。</p>\n<h2 id=\"git-commit-–amend——修改提交信息\"><a href=\"#git-commit-–amend——修改提交信息\" class=\"headerlink\" title=\"git commit –amend——修改提交信息\"></a>git commit –amend——修改提交信息</h2><h2 id=\"git-rebase-i——压缩历史\"><a href=\"#git-rebase-i——压缩历史\" class=\"headerlink\" title=\"git rebase -i——压缩历史\"></a>git rebase -i——压缩历史</h2><p>在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。这是个会经常用到的技巧，让我们来实际操作体会一下。</p>\n<p>首先，新建一个 feature-C 特性分支。</p>\n<p>作为 feature-C 的功能实现，我们在 README.md 文件中添加一行文字，并且故意留下拼写错误，以便之后修正。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -b feature-C</span></span><br><span class=\"line\">Switched to a new branch 'feature-C'</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Git教程</span></span><br><span class=\"line\">- feature-A</span><br><span class=\"line\">- fix-B</span><br><span class=\"line\">- faeture-C</span><br></pre></td></tr></table></figure>\n<p>提交这部分内容。这个小小的变更就没必要先执行 git add命令再执行 git commit命令了，我们<strong>用 git commit -am命令来一次完成这两步操作</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -am <span class=\"string\">\"Add feature-C\"</span></span></span><br><span class=\"line\">[feature-C 7a34294] Add feature-C</span><br><span class=\"line\">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>\n<p>现在来修正刚才预留的拼写错误。 然后进行提交。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git commit -am <span class=\"string\">\"Fix typo\"</span></span></span><br><span class=\"line\">[feature-C 6fba227] Fix typo</span><br><span class=\"line\">1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\n<p>错字漏字等失误称作 typo，所以我们将提交信息记为 “Fix typo”。 实际上，我们不希望在历史记录中看到这类提交，因为健全的历史记录并不需要它们。如果能在最初提交之前就发现并修正这些错误，也就不会出现这类提交了。</p>\n<p>我们来更改历史。将 “ Fix typo”修正的内容与之前一次的提交合并，在历史记录中合并为一次完美的提交。为此，我们要用到git rebase命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git rebase -i HEAD~2</span></span><br></pre></td></tr></table></figure>\n<p>用上述方式执行 git rebase命令，可以选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 7a34294 Add feature-C</span><br><span class=\"line\">pick 6fba227 Fix typo</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Rebase 2e7db6f..6fba227 onto 2e7db6f</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Commands:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> p, pick = use commit</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> r, reword = use commit, but edit the commit message</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> e, edit = use commit, but stop <span class=\"keyword\">for</span> amending</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> s, squash = use commit, but meld into previous commit</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> f, fixup = like <span class=\"string\">\"squash\"</span>, but discard this commit<span class=\"string\">'s log message</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> x, <span class=\"built_in\">exec</span> = run <span class=\"built_in\">command</span> (the rest of the line) using shell</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> However, <span class=\"keyword\">if</span> you remove everything, the rebase will be aborted.</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure>\n<p>我们将 6fba227 的 Fix typo 的历史记录压缩到 7a34294 的 Add feature-C里。按照下图所示，将 6fba227 左侧的 pick 部分删除，改写为 fixup。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 7a34294 Add feature-C</span><br><span class=\"line\">fixup 6fba227 Fix typo</span><br><span class=\"line\">[detached HEAD 51440c5] Add feature-C</span><br><span class=\"line\">1 file changed, 1 insertion(+)</span><br><span class=\"line\">Successfully rebased and updated refs/heads/feature-C.</span><br></pre></td></tr></table></figure>\n<p>这样一来， Fix typo 就从历史中被抹去，也就相当于 Add feature-C中从来没有出现过拼写错误。这算是一种<strong>良性的历史改写</strong>。</p>\n<h1 id=\"推送至远程仓库\"><a href=\"#推送至远程仓库\" class=\"headerlink\" title=\"推送至远程仓库\"></a>推送至远程仓库</h1><h2 id=\"git-remote-add——添加远程仓库\"><a href=\"#git-remote-add——添加远程仓库\" class=\"headerlink\" title=\"git remote add——添加远程仓库\"></a>git remote add——添加远程仓库</h2><p>在 GitHub 上创建的仓库路径为“git@github.com:用户名 /git-tutorial.git”。现在我们用 git remote add命令将它设置成本地仓库的远程仓库。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git remote add origin git@github.com:github-book/git-tutorial.git</span></span><br></pre></td></tr></table></figure>\n<p>按照上述格式执行 git remote add命令之后， Git 会自动git@github.com:github-book/git-tutorial.git远程仓库的名称设置为 origin（标识符）。</p>\n<h2 id=\"git-push——推送至远程仓库\"><a href=\"#git-push——推送至远程仓库\" class=\"headerlink\" title=\"git push——推送至远程仓库\"></a>git push——推送至远程仓库</h2><h3 id=\"推送至-master-分支\"><a href=\"#推送至-master-分支\" class=\"headerlink\" title=\"推送至 master 分支\"></a>推送至 master 分支</h3><p>如果想将当前分支下本地仓库中的内容推送给远程仓库，需要用到git push命令。现在假定我们在 master 分支下进行操作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push -u origin master</span></span><br><span class=\"line\">Counting objects: 20, done.</span><br><span class=\"line\">Delta compression using up to 8 threads.</span><br><span class=\"line\">Compressing objects: 100% (10/10), done.</span><br><span class=\"line\">Writing objects: 100% (20/20), 1.60 KiB, done.</span><br><span class=\"line\">Total 20 (delta 3), reused 0 (delta 0)</span><br><span class=\"line\">To git@github.com:github-book/git-tutorial.git</span><br><span class=\"line\">* [new branch] master -&gt; master</span><br><span class=\"line\">Branch master set up to track remote branch master from origin.</span><br></pre></td></tr></table></figure>\n<p>像这样执行 git push命令，当前分支的内容就会被推送给远程仓库origin 的 master 分支。 -u参数可以在推送的同时，将 origin 仓库的 master 分支设置为本地仓库当前分支的 upstream（上游）。添加了这个参数，将来运行 git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从 origin 的 master 分支获取内容，省去了另外添加参数的麻烦。执行该操作后，当前本地仓库 master 分支的内容将会被推送到GitHub 的远程仓库中。在 GitHub 上也可以确认远程 master 分支的内容 和本地 master 分支相同。</p>\n<h3 id=\"推送至-master-以外的分支\"><a href=\"#推送至-master-以外的分支\" class=\"headerlink\" title=\"推送至 master 以外的分支\"></a>推送至 master 以外的分支</h3><p>除了 master 分支之外，远程仓库也可以创建其他分支。举个例子，我们在本地仓库中创建 feature-D 分支，并将它以同名形式 push 至远程仓库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -b feature-D</span></span><br><span class=\"line\">Switched to a new branch 'feature-D'</span><br></pre></td></tr></table></figure>\n<p>我们在本地仓库中创建了 feature-D 分支，现在将它 push 给远程仓库并保持分支名称不变。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git push -u origin feature-D</span></span><br><span class=\"line\">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To git@github.com:github-book/git-tutorial.git</span><br><span class=\"line\">* [new branch] feature-D -&gt; feature-D</span><br><span class=\"line\">Branch feature-D set up to track remote branch feature-D from origin.</span><br></pre></td></tr></table></figure>\n<h1 id=\"从远程仓库获取\"><a href=\"#从远程仓库获取\" class=\"headerlink\" title=\"从远程仓库获取\"></a>从远程仓库获取</h1><h2 id=\"git-clone——获取远程仓库\"><a href=\"#git-clone——获取远程仓库\" class=\"headerlink\" title=\"git clone——获取远程仓库\"></a>git clone——获取远程仓库</h2><h3 id=\"获取远程仓库\"><a href=\"#获取远程仓库\" class=\"headerlink\" title=\"获取远程仓库\"></a>获取远程仓库</h3><p>首先我们换到其他目录下，将 GitHub 上的仓库 clone 到本地。注意 不要与之前操作的仓库在同一目录下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> git@github.com:github-book/git-tutorial.git</span></span><br><span class=\"line\">Cloning into 'git-tutorial'...</span><br><span class=\"line\">remote: Counting objects: 20, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (7/7), done.</span><br><span class=\"line\">remote: Total 20 (delta 3), reused 20 (delta 3)</span><br><span class=\"line\">Receiving objects: 100% (20/20), done.</span><br><span class=\"line\">Resolving deltas: 100% (3/3), done.</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> git-tutorial</span></span><br></pre></td></tr></table></figure>\n<p>执行 git clone命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master 分支在内容上是完全相同的。</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git branch -a</span></span><br><span class=\"line\">* master</span><br><span class=\"line\">remotes/origin/HEAD -&gt; origin/master</span><br><span class=\"line\">remotes/origin/feature-D</span><br><span class=\"line\">remotes/origin/master</span><br></pre></td></tr></table></figure>\n<p>我们用 git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息。<br>结果中显示了 remotes/origin/feature-D，证明我们的远程仓库中已经有了 feature-D 分支 。</p>\n<h3 id=\"获取远程的-feature-D-分支\"><a href=\"#获取远程的-feature-D-分支\" class=\"headerlink\" title=\"获取远程的 feature-D 分支\"></a>获取远程的 feature-D 分支</h3><p>我们试着将 feature-D 分支获取至本地仓库。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git checkout -b feature-D origin/feature-D</span></span><br><span class=\"line\">Branch feature-D set up to track remote branch feature-D from origin.</span><br><span class=\"line\">Switched to a new branch 'feature-D'</span><br></pre></td></tr></table></figure>\n<p>-b 参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了 origin/feature-D，就是说以名为 origin 的仓库（这里指 GitHub 端的仓库）的 feature-D 分支为来源，在本地仓库中创建 feature-D 分支。</p>\n<h2 id=\"git-pull——获取最新的远程仓库分支\"><a href=\"#git-pull——获取最新的远程仓库分支\" class=\"headerlink\" title=\"git pull——获取最新的远程仓库分支\"></a>git pull——获取最新的远程仓库分支</h2><p>远程仓库的 feature-D 分支中已经有了我们刚刚推送的提交。这时我们就可以使用 git pull 命令，将本地的 feature-D 分支更新到最新状态。当前分支为 feature-D 分支。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git pull origin feature-D</span></span><br><span class=\"line\">remote: Counting objects: 5, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (1/1), done.</span><br><span class=\"line\">remote: Total 3 (delta 1), reused 3 (delta 1)</span><br><span class=\"line\">Unpacking objects: 100% (3/3), done.</span><br><span class=\"line\">From github.com:github-book/git-tutorial</span><br><span class=\"line\">* branch feature-D -&gt; FETCH_HEAD</span><br><span class=\"line\">First, rewinding head to replay your work on top of it...</span><br><span class=\"line\">Fast-forwarded feature-D to ed9721e686f8c588e55ec6b8071b669f411486b8.</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"如何用Github的gh-pages分支展示自己的项目\"><a href=\"#如何用Github的gh-pages分支展示自己的项目\" class=\"headerlink\" title=\"如何用Github的gh-pages分支展示自己的项目\"></a>如何用Github的gh-pages分支展示自己的项目</h1><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git subtree <span class=\"built_in\">push</span> --<span class=\"built_in\">prefix</span>=dist <span class=\"built_in\">origin</span> gh-pages</span><br></pre></td></tr></table></figure>\n<p>意思就是把指定的dist文件提交到gh-pages分支上</p>"},{"title":"sed如何在执行命令前过滤特定文本行","author":"王诗翔","date":"2018-01-31T13:19:40.000Z","_content":"\n有人在微信群里问到这样一个问题：\n>请问我想把参考基因组中所有的A和C替换成C和A，小写也按照这样的规则替换，该怎么实现呢，tr可以做到，但是我想保证>后面的染色体名字不会被替换?\n>![](http://upload-images.jianshu.io/upload_images/3884693-da7fbb654d3f7bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n[`tr`](http://man.linuxde.net/tr)命令确实可以完成文本字符替换一对一的映射，但很显然，这样的功能想要解决这个问题是不够的，它把不想要改变的文本也改变了。\n\n解决问题的思路在于如何实现带>标志的文本直接输出，而DNA字符行被执行转换命令。这个问题其实使用sed命令就可以快速解决，不少朋友对于`sed`的使用可能记忆为我在[笔记](https://shixiangwang.github.io/2017/09/03/Linux-data-analysis-tools/#用Sed进行流编辑)中写的：\n\n```shell\ncommand/pattern/replacement/flag\n```\n`command`是一些命令，比如`s`,`d`等，`flag`是一些标记，`i`,`g`等等。\n\n这样认识sed命令其实不是很全面，sed允许指定文本模式来过滤出命令要作用的行，格式如下：\n\n```shell\n/pattern/command\n```\n\n所以整理起来，sed格式其实（除了一些选项）为\n\n```shell\n/pattern/command/pattern/replacement/flag\n```\n\n第一个`pattern`用来过滤出要处理的文本行，第二个`pattern`是sed命令要作用的模式。\n\n那么利用这个特定，一开始的问题可以利用正则表达式非常简单地解决了：\n\n先用`/^[^>]/`找到不以`>`开始的行，然后执行`sed`字符转换命令。\n\n```shell\n\n# 随便写一个测试文本\n$ cat test\n> CAACCA\nacgtACGTACTGagct\ntacgactNNNNNNNNNNNNNNNN\n\n$ cat test | sed '/^[^>]/y/ACac/CAca/'\n> CAACCA\ncagtCAGTCATGcgat\ntcagcatNNNNNNNNNNNNNNNN\n\n```\n\n\n***\n\n有兴趣的可以看看[初识sed与awk](https://shixiangwang.github.io/2017/12/25/sed-and-gawk/)这篇笔记。\n","source":"_posts/2018-01-31-sed-how-to-filter-rows-before-using-command.md","raw":"---\ntitle: sed如何在执行命令前过滤特定文本行\nauthor: 王诗翔\ncategories: Linux杂烩\ndate: 2018-01-31 21:19:40\ntags:\n- sed\n- 生物信息学\n- 文本处理\n- fasta\n---\n\n有人在微信群里问到这样一个问题：\n>请问我想把参考基因组中所有的A和C替换成C和A，小写也按照这样的规则替换，该怎么实现呢，tr可以做到，但是我想保证>后面的染色体名字不会被替换?\n>![](http://upload-images.jianshu.io/upload_images/3884693-da7fbb654d3f7bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n[`tr`](http://man.linuxde.net/tr)命令确实可以完成文本字符替换一对一的映射，但很显然，这样的功能想要解决这个问题是不够的，它把不想要改变的文本也改变了。\n\n解决问题的思路在于如何实现带>标志的文本直接输出，而DNA字符行被执行转换命令。这个问题其实使用sed命令就可以快速解决，不少朋友对于`sed`的使用可能记忆为我在[笔记](https://shixiangwang.github.io/2017/09/03/Linux-data-analysis-tools/#用Sed进行流编辑)中写的：\n\n```shell\ncommand/pattern/replacement/flag\n```\n`command`是一些命令，比如`s`,`d`等，`flag`是一些标记，`i`,`g`等等。\n\n这样认识sed命令其实不是很全面，sed允许指定文本模式来过滤出命令要作用的行，格式如下：\n\n```shell\n/pattern/command\n```\n\n所以整理起来，sed格式其实（除了一些选项）为\n\n```shell\n/pattern/command/pattern/replacement/flag\n```\n\n第一个`pattern`用来过滤出要处理的文本行，第二个`pattern`是sed命令要作用的模式。\n\n那么利用这个特定，一开始的问题可以利用正则表达式非常简单地解决了：\n\n先用`/^[^>]/`找到不以`>`开始的行，然后执行`sed`字符转换命令。\n\n```shell\n\n# 随便写一个测试文本\n$ cat test\n> CAACCA\nacgtACGTACTGagct\ntacgactNNNNNNNNNNNNNNNN\n\n$ cat test | sed '/^[^>]/y/ACac/CAca/'\n> CAACCA\ncagtCAGTCATGcgat\ntcagcatNNNNNNNNNNNNNNNN\n\n```\n\n\n***\n\n有兴趣的可以看看[初识sed与awk](https://shixiangwang.github.io/2017/12/25/sed-and-gawk/)这篇笔记。\n","slug":"sed-how-to-filter-rows-before-using-command","published":1,"updated":"2018-01-31T13:23:44.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwus000l9tax74xlw580","content":"<p>有人在微信群里问到这样一个问题：</p>\n<blockquote>\n<p>请问我想把参考基因组中所有的A和C替换成C和A，小写也按照这样的规则替换，该怎么实现呢，tr可以做到，但是我想保证&gt;后面的染色体名字不会被替换?<br><img src=\"http://upload-images.jianshu.io/upload_images/3884693-da7fbb654d3f7bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<a id=\"more\"></a>\n<p><a href=\"http://man.linuxde.net/tr\" target=\"_blank\" rel=\"noopener\"><code>tr</code></a>命令确实可以完成文本字符替换一对一的映射，但很显然，这样的功能想要解决这个问题是不够的，它把不想要改变的文本也改变了。</p>\n<p>解决问题的思路在于如何实现带&gt;标志的文本直接输出，而DNA字符行被执行转换命令。这个问题其实使用sed命令就可以快速解决，不少朋友对于<code>sed</code>的使用可能记忆为我在<a href=\"https://shixiangwang.github.io/2017/09/03/Linux-data-analysis-tools/#用Sed进行流编辑\">笔记</a>中写的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command/pattern/replacement/flag</span><br></pre></td></tr></table></figure>\n<p><code>command</code>是一些命令，比如<code>s</code>,<code>d</code>等，<code>flag</code>是一些标记，<code>i</code>,<code>g</code>等等。</p>\n<p>这样认识sed命令其实不是很全面，sed允许指定文本模式来过滤出命令要作用的行，格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/pattern/command</span><br></pre></td></tr></table></figure>\n<p>所以整理起来，sed格式其实（除了一些选项）为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/pattern/command/pattern/replacement/flag</span><br></pre></td></tr></table></figure>\n<p>第一个<code>pattern</code>用来过滤出要处理的文本行，第二个<code>pattern</code>是sed命令要作用的模式。</p>\n<p>那么利用这个特定，一开始的问题可以利用正则表达式非常简单地解决了：</p>\n<p>先用<code>/^[^&gt;]/</code>找到不以<code>&gt;</code>开始的行，然后执行<code>sed</code>字符转换命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 随便写一个测试文本</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat <span class=\"built_in\">test</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> CAACCA</span></span><br><span class=\"line\">acgtACGTACTGagct</span><br><span class=\"line\">tacgactNNNNNNNNNNNNNNNN</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat <span class=\"built_in\">test</span> | sed <span class=\"string\">'/^[^&gt;]/y/ACac/CAca/'</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> CAACCA</span></span><br><span class=\"line\">cagtCAGTCATGcgat</span><br><span class=\"line\">tcagcatNNNNNNNNNNNNNNNN</span><br></pre></td></tr></table></figure>\n<hr>\n<p>有兴趣的可以看看<a href=\"https://shixiangwang.github.io/2017/12/25/sed-and-gawk/\">初识sed与awk</a>这篇笔记。</p>\n","site":{"data":{}},"excerpt":"<p>有人在微信群里问到这样一个问题：</p>\n<blockquote>\n<p>请问我想把参考基因组中所有的A和C替换成C和A，小写也按照这样的规则替换，该怎么实现呢，tr可以做到，但是我想保证&gt;后面的染色体名字不会被替换?<br><img src=\"http://upload-images.jianshu.io/upload_images/3884693-da7fbb654d3f7bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>","more":"<p><a href=\"http://man.linuxde.net/tr\" target=\"_blank\" rel=\"noopener\"><code>tr</code></a>命令确实可以完成文本字符替换一对一的映射，但很显然，这样的功能想要解决这个问题是不够的，它把不想要改变的文本也改变了。</p>\n<p>解决问题的思路在于如何实现带&gt;标志的文本直接输出，而DNA字符行被执行转换命令。这个问题其实使用sed命令就可以快速解决，不少朋友对于<code>sed</code>的使用可能记忆为我在<a href=\"https://shixiangwang.github.io/2017/09/03/Linux-data-analysis-tools/#用Sed进行流编辑\">笔记</a>中写的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command/pattern/replacement/flag</span><br></pre></td></tr></table></figure>\n<p><code>command</code>是一些命令，比如<code>s</code>,<code>d</code>等，<code>flag</code>是一些标记，<code>i</code>,<code>g</code>等等。</p>\n<p>这样认识sed命令其实不是很全面，sed允许指定文本模式来过滤出命令要作用的行，格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/pattern/command</span><br></pre></td></tr></table></figure>\n<p>所以整理起来，sed格式其实（除了一些选项）为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/pattern/command/pattern/replacement/flag</span><br></pre></td></tr></table></figure>\n<p>第一个<code>pattern</code>用来过滤出要处理的文本行，第二个<code>pattern</code>是sed命令要作用的模式。</p>\n<p>那么利用这个特定，一开始的问题可以利用正则表达式非常简单地解决了：</p>\n<p>先用<code>/^[^&gt;]/</code>找到不以<code>&gt;</code>开始的行，然后执行<code>sed</code>字符转换命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 随便写一个测试文本</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat <span class=\"built_in\">test</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> CAACCA</span></span><br><span class=\"line\">acgtACGTACTGagct</span><br><span class=\"line\">tacgactNNNNNNNNNNNNNNNN</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> cat <span class=\"built_in\">test</span> | sed <span class=\"string\">'/^[^&gt;]/y/ACac/CAca/'</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> CAACCA</span></span><br><span class=\"line\">cagtCAGTCATGcgat</span><br><span class=\"line\">tcagcatNNNNNNNNNNNNNNNN</span><br></pre></td></tr></table></figure>\n<hr>\n<p>有兴趣的可以看看<a href=\"https://shixiangwang.github.io/2017/12/25/sed-and-gawk/\">初识sed与awk</a>这篇笔记。</p>"},{"title":"初识sed与awk","author":"王诗翔","date":"2017-12-24T16:00:00.000Z","_content":"\n\n\n**学习内容**：\n\n>- 学习sed编辑器\n>- gawk编辑器入门\n>- sed编辑器基础\n\nshell脚本最常见的一个用途就是处理文本文件，但仅靠shell脚本命令来处理文本文件的内容有点勉为其难。如果我们想在shell脚本中处理任何类型的数据，需要熟悉Linux中的sed和gawk工具。这两个工具可以极大简化我们需要进行的数据处理任务。\n\n<!-- more -->\n\n## 文本处理\n\n当我们需要自动处理文本文件，又不想动用交互式文本编辑器时，sed和gawk是我们最好的选择。\n\n### sed编辑器\n\n也被称为**流编辑器**（stream editor），会在编辑器处理数据之前**基于预先提供的一组规则**来编辑数据流。\n\nsed编辑器可以根据命令来处理数据流中的数据，这些命令既可以从终端输入，也可以存储进脚本文件中。\n\nsed会执行以下的操作：\n\n- 一次从输入中读取一行数据\n- 根据所提供的命令匹配数据\n- 按照命令修改流中的数据\n- 将新的数据输出到STDOUT\n\n这一过程会重复直至处理完流中的所有数据行。\n\nsed命令的格式如下：\n\n```shell\nsed options script file\n```\n\n选项`options`可以允许我们修改`sed`命令的行为\n\n| 选项        | 描述                            |\n| --------- | ----------------------------- |\n| -e script | 在处理输入时，将script中指定的命令添加到已有的命令中 |\n| -f file   | 在处理输入时，将file中指定的命令添加到已有的命令中   |\n| -n        | 不产生命令输出，使用`print`命令来完成输出      |\n\n`script`参数指定用于流数据上的单个命令，如果需要多个命令，要么使用`-e`选项在命令行中指定，要么使用`-f`选项在单独的文件中指定。\n\n#### 在命令行中定义编辑器命令\n\n默认sed会将指定命令应用到STDIN输入流上，我们可以配合管道命令使用。\n\n```shell\nwsx@wsx-laptop:~/tmp$ echo \"This is a test\" | sed 's/test/big test/'\nThis is a big test\n```\n\n`s`命令使用斜线间指定的第二个文本来替换第一个文本字符串模式（注意是替换整个模式，支持正则匹配），比如这个例子用`big test`替换了`test`。\n\n假如有以下文本：\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\n```\n\n键入命令，查看输出\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 's/dog/cat/' data1.txt\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\n```\n\n可以看到符合模式的字符串都被修改了。\n\n要记住，sed并不会修改文本文件的数据，**它只会将修改后的数据发送到STDOUT**。\n\n#### 在命令行上使用多个编辑器命令\n\n使用`-e`选项可以执行多个命令\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed -e 's/brown/green/; s/dog/cat/' data1.txt\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\n```\n\n两个命令都作用到文件中的每一行数据上。命令之间必须用分号隔开，并且**在命令末尾与分号之间不同有空格**。\n\n如果不想使用分号，可以用bash shell中的次提示符来分隔命令。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed -e '\n> s/brown/green/\n> s/fox/elephant/\n> s/dog/cat/' data1.txt\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\n```\n\n#### 从文件中读取编辑器命令\n\n如果有大量要处理的sed命令，将其单独放入一个文本中会更方便，可以用sed命令的`-f`选项来指定文件。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat script1.sed\ns/brown/green/\ns/fox/elephant/\ns/dog/cat/\n\nwsx@wsx-laptop:~/tmp$ sed -f script1.sed data1.txt\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\n```\n\n这种情况不用在每个命令后面放一个分号，sed知道每行都有一条单独的命令。\n\n\n\n### gawk程序\n\ngawk是一个处理文本的更高级工具，能够提供一个类编程环境来修改和重新组织文件中的数据。\n\n```\n说明\t在所有的发行版都没有默认安装gawk程序，请先安装\n```\n\ngawk程序是Unix中原始awk的GNU版本，它让流编辑器迈上了一个新的台阶，提供了一种编程语言而不只是编辑器命令。\n\n我们可以利用它做下面的事情：\n\n- 定义变量来保存数据\n- 使用算术和字符串操作符来处理数据\n- 使用结构化编程概念来为数据处理增加处理逻辑\n- 通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告\n\ngawk程序的报告生成能力通常用来从大文本文件中提取数据元素，并将它们格式化成可读的报告，使得重要的数据更易于可读。\n\n#### 基本命令格式\n\n```shell\ngawk options program file\n```\n\n下面显示了gawk程序的可用选项\n\n| 选项           | 描述                  |\n| ------------ | ------------------- |\n| -F fs        | 指定行中划分数据字段的字段分隔符    |\n| -f file      | 从指定文件中读取程序          |\n| -v var=value | 定义gawk程序中的一个变量及其默认值 |\n| -mf N        | 指定要处理的数据文件中的最大字段数   |\n| -mr N        | 指定数据文件中的最大数据行数      |\n| -W keyword   | 指定gawk的兼容模式或警告等级    |\n\ngawk的**强大之处在于程序脚本**（善于利用工具最强之处），可以写脚本来读取文本行的数据，然后处理并显示数据，创建任何类型的输出报告。\n\n#### 从命令行读取脚本\n\n我们必须将脚本命令放入两个花括号中，而由于gawk命令行假定脚本是单个文本字符串，所以我们必须把脚本放到单引号中。\n\n下面是一个简单的例子：\n\n```shell\nwsx@wsx-laptop:~/tmp$ gawk '{print \"Hello World!\"}'\n\nHello World!\nThis is a test\nHello World!\nThis is\nHello World!\n\nHello World!\n\n```\n\n`print`命令将文本打印到STDOUT。如果尝试允许命令，我们可能会有些失望，因为什么都不会发生，原因是没有指定文件名，所以gawk会从STDIN接收数据，如果我们按下回车，gawk会对这行文本允许一遍程序脚本。\n\n要终止这个程序必须表明数据流已经结束了，bash shell提供组合键来生成EOF(End-of-File)字符。Ctrl+D组合键会在bash中产生一个EOF字符。\n\n#### 使用数据字段变量\n\ngawk的主要特性之一是其处理文本文件中数据的能力，它自动给一行的每个数据元素分配一个变量。\n\n- $0代表整个文本行\n- $1代表文本行的第一个数据字段\n- $2代表文本行的第二个数据字段\n- $n代表文本行的第n个数据字段\n\ngawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。默认字段分隔符为任意的空白字符（例如空格或制表符）。\n\n下面例子gawk读取文本显示第一个数据字段的值。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data2.txt\nOne line of test text.\nTwo lines of test text.\nThree lines of test text.\nwsx@wsx-laptop:~/tmp$ gawk '{print $1}' data2.txt\nOne\nTwo\nThree\n```\n\n我们可以使用`-F`选项指定其他字段分隔符：\n\n```shell\nwsx@wsx-laptop:~/tmp$ gawk -F: '{print $1}' /etc/passwd\nroot\ndaemon\nbin\nsys\nsync\ngames\nman\nlp\nmail\nnews\nuucp\nproxy\nwww-data\nbackup\n...\n```\n\n这个简短程序显示了系统中密码文件的第一个数据字段。\n\n#### 在程序脚本中使用多个命令\n\n在命令之间放个分号即可。\n\n```shell\nwsx@wsx-laptop:~/tmp$ echo \"My name is Shixiang\" | gawk '{$4=\"Christine\"; print $0}'\nMy name is Christine\n```\n\n也可以使用次提示符一次一行输入程序脚本命令（类似sed）。\n\n#### 从文件中读取程序\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat script2.gawk\n{print $1 \" 's home directory is \" $6}\nwsx@wsx-laptop:~/tmp$ gawk -F: -f script2.gawk  /etc/passwd\nroot 's home directory is /root\ndaemon 's home directory is /usr/sbin\nbin 's home directory is /bin\nsys 's home directory is /dev\nsync 's home directory is /bin\ngames 's home directory is /usr/games\nman 's home directory is /var/cache/man\nlp 's home directory is /var/spool/lpd\nmail 's home directory is /var/mail\nnews 's home directory is /var/spool/news\nuucp 's home directory is /var/spool/uucp\nproxy 's home directory is /bin\n...\n```\n\n可以在程序文件中指定多条命令：\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat script3.gawk\n{\ntext = \"'s home directory is \"\nprint $1 text $6\n}\nwsx@wsx-laptop:~/tmp$ gawk -F: -f script3.gawk /etc/passwd\nroot's home directory is /root\ndaemon's home directory is /usr/sbin\nbin's home directory is /bin\nsys's home directory is /dev\nsync's home directory is /bin\ngames's home directory is /usr/games\nman's home directory is /var/cache/man\nlp's home directory is /var/spool/lpd\nmail's home directory is /var/mail\nnews's home directory is /var/spool/news\n...\n```\n\n#### 在处理数据前运行脚本\n\n使用BEGIN关键字可以强制gawk再读取数据前执行BEGIN关键字指定的程序脚本。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data3.txt\nLine 1\nLine 2\nLine 3\nwsx@wsx-laptop:~/tmp$ gawk 'BEGIN {print \"The data3 File Contents:\"}\n> {print $0}' data3.txt\nThe data3 File Contents:\nLine 1\nLine 2\nLine 3\n```\n\n在gawk执行了BEGIN脚本后，它会用第二段脚本来处理文件数据。\n\n#### 在处理数据后允许脚本\n\n与BEGIN关键字类似，END关键字允许我们指定一个脚本，gawk在读完数据后执行。\n\n```shell\nwsx@wsx-laptop:~/tmp$ gawk 'BEGIN {print \"The data3 File Contents:\"}\n> {print $0}\n> END {print \"End of File\"}' data3.txt\nThe data3 File Contents:\nLine 1\nLine 2\nLine 3\nEnd of File\n```\n\n我们把所有的内容放在一起组成一个漂亮的小程序脚本，用它从简单的数据文件中创建一份完整报告。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat script4.gawk\nBEGIN {\nprint \"The latest list of users and shells\"\nprint \" UserID \\t Shell\"\nprint \"-------- \\t ------\"\nFS=\":\"\n}\n\n{\nprint $1 \"      \\t \" $7\n}\n\nEND {\nprint \"This concludes the listing\"\n}\nwsx@wsx-laptop:~/tmp$ gawk -f script4.gawk /etc/passwd\nThe latest list of users and shells\n UserID          Shell\n--------         ------\nroot             /bin/bash\ndaemon           /usr/sbin/nologin\nbin              /usr/sbin/nologin\nsys              /usr/sbin/nologin\nsync             /bin/sync\ngames            /usr/sbin/nologin\nman              /usr/sbin/nologin\nlp               /usr/sbin/nologin\nmail             /usr/sbin/nologin\nnews             /usr/sbin/nologin\nuucp             /usr/sbin/nologin\nproxy            /usr/sbin/nologin\nwww-data         /usr/sbin/nologin\nbackup           /usr/sbin/nologin\nlist             /usr/sbin/nologin\nirc              /usr/sbin/nologin\ngnats            /usr/sbin/nologin\nnobody           /usr/sbin/nologin\nsystemd-timesync         /bin/false\nsystemd-network          /bin/false\nsystemd-resolve          /bin/false\nsystemd-bus-proxy        /bin/false\nsyslog           /bin/false\n_apt             /bin/false\nlxd              /bin/false\nmessagebus               /bin/false\nuuidd            /bin/false\ndnsmasq          /bin/false\nsshd             /usr/sbin/nologin\npollinate        /bin/false\nwsx              /bin/bash\nThis concludes the listing\n```\n\n我们以后会继续学习gawk高级编程。\n\n## sed编辑器基础\n\n下面介绍一些可以集成到脚本中的基本命令和功能。\n\n### 更多的替换选项\n\n之前我们已经学习了用`s`命令在行中替换文本，这个命令还有一些其他选项。\n\n#### 替换标记\n\n替换命令`s`默认只替换每行中出现的第一处。要让该命令能替换一行中不同地方出现的文本必须使用**替换标记**。该标记在替换命令字符串之后设置。\n\n```shell\ns/pattern/replacement/flags\n```\n\n替换标记有4种：\n\n- 数字，表明替换第几处模式匹配的地方\n- g，表明替换所有匹配的文本\n- p，表明原先行的内容要打印出来\n- w file，将替换的结果写入文件中\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data4.txt\nThis is a test of the test script.\nThis is the second test of the test script.\nwsx@wsx-laptop:~/tmp$ sed 's/test/trial/2' data4.txt\nThis is a test of the trial script.\nThis is the second test of the trial script.\n```\n\n该命令只替换每行中第二次出现的匹配模式。而`g`标记替换所有的匹配之处。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 's/test/trial/g' data4.txt\nThis is a trial of the trial script.\nThis is the second trial of the trial script.\n```\n\n`p`替换标记会打印与替换命令中指定的模式匹配的行，通常与sed的`-n`选项一起使用。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data5.txt\nThis is a test line.\nThis is a different line.\nwsx@wsx-laptop:~/tmp$ sed -n 's/test/trial/p' data5.txt\nThis is a trial line.\n```\n\n`-n`选项禁止sed编辑器输出，但`p`标记会输出修改过的行。两者配合使用就是**只输出被替换命令修改过的行**。\n\n`w`标记会产生同样的输出，不过会将输出（只输出被替换命令修改过的行）保存到指定文件中。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 's/test/trial/w test.txt' data5.txt\nThis is a trial line.\nThis is a different line.\nwsx@wsx-laptop:~/tmp$ cat test.txt\nThis is a trial line.\n```\n\n#### 替换字符\n\n有一些字符不方便在替换模式中使用，常见的例子为正斜线。\n\n替换文件中的路径名会比较麻烦，比如用C shell替换/etc/passwd文件中的bash shell，必须这样做（通过反斜线转义）：\n\n```shell\nwsx@wsx-laptop:~/tmp$ head /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n...\nwsx@wsx-laptop:~/tmp$ sed 's/\\/bin\\/bash/\\/bin\\/csh/' /etc/passwd\nroot:x:0:0:root:/root:/bin/csh\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\n...\n```\n\n为解决这样的问题，sed编辑器允许选择其他字符来替换命令中的字符串分隔符：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 's!/bin/bash!/bin/csh!' /etc/passwd\nroot:x:0:0:root:/root:/bin/csh\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n...\n```\n\n\n\n### 使用地址\n\n如果只想要命令作用于特定行或某些行，必须使用**行寻址**。\n\n有两种形式：\n\n- 以数字形式表示行区间\n- 用文本模式来过滤出行\n\n它们都使用相同地格式来指定地址：\n\n```shell\n[address]command\n```\n\n也可以将多个命令分组\n\n```shell\naddress {\n  command1\n  command2\n  command3\n}\n```\n\n#### 以数字的方式行寻址\n\nsed编辑器会将文本流中的第一行编号为1，然后继续按顺序给以下行编号。\n\n指定的地址**可以是单个行号，或者用行号、逗号以及结尾行号指定的一定区间范围的行**。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed '2s/dog/cat/' data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed '2,3s/dog/cat/' data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed '2,$s/dog/cat/' data1.txt  # 美元符指代最后一行\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\n```\n\n#### 使用文本模式过滤器\n\nsed允许指定文本模式来过滤出命令要作用的行，格式如下：\n\n```\n/pattern/command\n```\n\n比如我要修改默认的shell，可以使用sed命令：\n\n```shell\nwsx@wsx-laptop:~/tmp$ grep wsx /etc/passwd\nwsx:x:1000:1000:\"\",,,:/home/wsx:/bin/bash\nwsx@wsx-laptop:~/tmp$ grep '/wsx/s/bash/csh/' /etc/passwd\nwsx@wsx-laptop:~/tmp$ sed '/wsx/s/bash/csh/' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\n...\nwsx:x:1000:1000:\"\",,,:/home/wsx:/bin/csh\n```\n\n正则表达式允许创建高级文本模式匹配表达式来匹配各种数据，结合一系列通配符、特殊字符来生成几乎任何形式文本的简练模式。我们后续会学习到。\n\n#### 命令组合\n\n使用花括号可以将多条命令组合在一起。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '2{\n> s/fox/elephant/\n> s/dog/cat/\n> }' data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown elephant jumps over the lazy cat.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\n```\n\n也可以在一组命令前指定一个地址区间。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '3,${\ns/brown/green/\ns/lazy/active/\n}' data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\n```\n\n### 删除行\n\n如果需要删除文本流中的特定行，使用删除命令`d`，它会删除匹配指定寻址模式的所有行。**使用时要特别小心**，如果忘记加入寻址模式，会将所有文本行删除。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed 'd' data1.txt\n```\n\n和指定的地址一起使用才能发挥删除命令的最大功用。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ sed '3d' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 4.\n```\n\n通过特定行区间指定：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '2,3d' data6.txt\nThis is line number 1.\nThis is line number 4.\n```\n\n通过特殊文本结尾字符指定：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '2,$d' data6.txt\nThis is line number 1.\n```\n\n还可以使用模式匹配特性：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '/number 1/d' data6.txt\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\n```\n\nsed会删除包含匹配模式的行。\n\n记住，sed不会修改原始文件。\n\n还可以使用两个文本模式来删除某个区间内的行，但做的时候需要特别小心，指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed会删除两个指定行之间的所有行（包括指定行）。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data7.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nThis is line number 1 again.\nThis is text you want to keep.\nThis is the last line in the file.\nwsx@wsx-laptop:~/tmp$ sed '/1/,/3/d' data7.txt\nThis is line number 4.\n```\n\n第二个出现的数字“1”的行再次触发了删除命令，因为未能找到停止模式“3”，所以将数据流剩余的行全部删掉了。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '/1/,/5/d' data7.txt\nwsx@wsx-laptop:~/tmp$ sed '/2/,/4/d' data7.txt\nThis is line number 1.\nThis is line number 1 again.\nThis is text you want to keep.\nThis is the last line in the file.\n```\n\n### 插入和附加文本\n\nsed允许向数据流插入和附加文本行：\n\n- 插入命令`i`会在指定行前增加一个新行\n- 附加命令`a`会在指定行后增加一个新行\n\n注意，它们不能在单个命令行上使用，必须要指定是要插入还是要附加到的那一行。\n\n```shell\nwsx@wsx-laptop:~/tmp$ echo \"Test Line 2\" | sed 'i\\Test Line 1'\nTest Line 1\nTest Line 2\nwsx@wsx-laptop:~/tmp$ echo \"Test Line 2\" | sed 'a\\Test Line 1'\nTest Line 2\nTest Line 1\n```\n\n要向数据流行内部插入或附加数据，必须用寻址来告诉sed数据应该出现在什么位置。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '3i\\ This is an inserted line.' data6.txt\nThis is line number 1.\nThis is line number 2.\n This is an inserted line.\nThis is line number 3.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ sed '3a\\ This is an inserted line.' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\n This is an inserted line.\nThis is line number 4.\n```\n\n如果想要给数据流末尾添加多行数据，通过`$`指定位置即可。\n\n```shell\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\n This is a new line.\n```\n\n\n\n### 修改行\n\n修改（change）命令允许修改整个数据流中整行文本内容。它跟插入和附加命令的工作机制一样。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '3c\\This is a changed line.' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is a changed line.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ sed '/number 3/c\\This is a changed line.' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is a changed line.\nThis is line number 4.\n```\n\n\n\n### 转换命令\n\n转换命令（y）是**唯一可以处理单字符的sed命令**。格式如下：\n\n```shell\n[address]y/inchars/outchars\n```\n\n转换命令会对`inchars`和`outchars`值进行一对一的映射。如果两者字符长度不同，则sed产生一条错误信息。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 'y/123/789/' data6.txt\nThis is line number 7.\nThis is line number 8.\nThis is line number 9.\nThis is line number 4.\n```\n\n转换命令是一个全局命令，**它会在文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置**。\n\n### 回顾命令\n\n另有3个命令可以用来打印数据流中的信息：\n\n- `p`命令用来打印文本行\n- 等号`=`命令用来打印行号\n- `l`用来列出行\n\n#### 打印行\n\n```shell\nwsx@wsx-laptop:~/tmp$ echo \"this is a test\" | sed 'p'\nthis is a test\nthis is a test\n```\n\n`p`打印已有的数据文本。最常用的用法是打印符合匹配文本模式的行。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ sed -n '/number 3/p' data6.txt\nThis is line number 3.\n```\n\n在命令行上使用`-n`选项，可以禁止输出其他行，只打印包含匹配文本模式的行。\n\n也可以用来快速打印数据流中的某些行：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed -n '2,3p' data6.txt\nThis is line number 2.\nThis is line number 3.\n```\n\n#### 打印行号\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed '=' data1.txt\n1\nThe quick brown fox jumps over the lazy dog.\n2\nThe quick brown fox jumps over the lazy dog.\n3\nThe quick brown fox jumps over the lazy dog.\n4\nThe quick brown fox jumps over the lazy dog.\n5\nThe quick brown fox jumps over the lazy dog.\n6\nThe quick brown fox jumps over the lazy dog.\n7\nThe quick brown fox jumps over the lazy dog.\n8\nThe quick brown fox jumps over the lazy dog.\n9\nThe quick brown fox jumps over the lazy dog.\n```\n\n这用来查找特定文本模式的话非常方便：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed -n '/number 4/{\n> =\n> p\n> }' data6.txt\n4\nThis is line number 4.\n```\n\n#### 列出行\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data9.txt\nThis    line    contains        tabs.\nwsx@wsx-laptop:~/tmp$ sed -n 'l' data9.txt\nThis\\tline\\tcontains\\ttabs.$\n```\n\n### 使用Sed处理文件\n\n#### 写入文件\n\n`w`命令用来向文件写入行。该命令格式如下：\n\n```shell\n[address]w filename\n```\n\n将文本的前两行写入其他文件：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '1,2w test.txt' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ cat test.txt\nThis is line number 1.\nThis is line number 2.\n```\n\n如果不想让行显示到STDOUT（因为sed默认数据文本流），可以使用sed命令的`-n`选项。\n\n#### 读取数据\n\n读取命令为`r`。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data12.txt\nThis is an added line.\nThis is the second added line.\nwsx@wsx-laptop:~/tmp$ sed '3r data12.txt' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is an added line.\nThis is the second added line.\nThis is line number 4.\n```\n\n这效果有点像插入文本命令`i`和补充命令`a`。\n\n 同样适用于文本模式地址：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '/number 2/r data12.txt' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is an added line.\nThis is the second added line.\nThis is line number 3.\nThis is line number 4.\n```\n\n文本末尾添加：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '$r data12.txt' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nThis is an added line.\nThis is the second added line.\n```\n\n**读取命令的一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本**。假如你有一份套用信件保存在文本中：\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat notice.std\nWould the following people:\nLIST\nplease report to the ship's captain.\n```\n\n套用信件将通用占位文本`LIST`放在人物名单的位置，我们先根据它插入文本字符，然后删除它。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '/LIST/{\n> r data10.txt\n> d\n> }' notice.std\nWould the following people:\nThis line contains an escape character.\nplease report to the ship's captain.\nwsx@wsx-laptop:~/tmp$ cat data10.txt\nThis line contains an escape character.\nwsx@wsx-laptop:~/tmp$ cat data11.txt\nwangshx zhdan\nwsx@wsx-laptop:~/tmp$ sed '/LIST/{\nr data11.txt\nd\n}' notice.std\nWould the following people:\nwangshx zhdan\nplease report to the ship's captain.\n```\n\n可以看到占位符被替换成了数据文件中的文字。\n\n完。\n","source":"_posts/2017-12-25-sed-and-gawk.md","raw":"---\ntitle: \"初识sed与awk\"\nauthor: 王诗翔\ndate: 2017-12-25\ncategories:\n- Linux杂烩\n- 文本处理\ntags:\n- linux\n- shell笔记\n---\n\n\n\n**学习内容**：\n\n>- 学习sed编辑器\n>- gawk编辑器入门\n>- sed编辑器基础\n\nshell脚本最常见的一个用途就是处理文本文件，但仅靠shell脚本命令来处理文本文件的内容有点勉为其难。如果我们想在shell脚本中处理任何类型的数据，需要熟悉Linux中的sed和gawk工具。这两个工具可以极大简化我们需要进行的数据处理任务。\n\n<!-- more -->\n\n## 文本处理\n\n当我们需要自动处理文本文件，又不想动用交互式文本编辑器时，sed和gawk是我们最好的选择。\n\n### sed编辑器\n\n也被称为**流编辑器**（stream editor），会在编辑器处理数据之前**基于预先提供的一组规则**来编辑数据流。\n\nsed编辑器可以根据命令来处理数据流中的数据，这些命令既可以从终端输入，也可以存储进脚本文件中。\n\nsed会执行以下的操作：\n\n- 一次从输入中读取一行数据\n- 根据所提供的命令匹配数据\n- 按照命令修改流中的数据\n- 将新的数据输出到STDOUT\n\n这一过程会重复直至处理完流中的所有数据行。\n\nsed命令的格式如下：\n\n```shell\nsed options script file\n```\n\n选项`options`可以允许我们修改`sed`命令的行为\n\n| 选项        | 描述                            |\n| --------- | ----------------------------- |\n| -e script | 在处理输入时，将script中指定的命令添加到已有的命令中 |\n| -f file   | 在处理输入时，将file中指定的命令添加到已有的命令中   |\n| -n        | 不产生命令输出，使用`print`命令来完成输出      |\n\n`script`参数指定用于流数据上的单个命令，如果需要多个命令，要么使用`-e`选项在命令行中指定，要么使用`-f`选项在单独的文件中指定。\n\n#### 在命令行中定义编辑器命令\n\n默认sed会将指定命令应用到STDIN输入流上，我们可以配合管道命令使用。\n\n```shell\nwsx@wsx-laptop:~/tmp$ echo \"This is a test\" | sed 's/test/big test/'\nThis is a big test\n```\n\n`s`命令使用斜线间指定的第二个文本来替换第一个文本字符串模式（注意是替换整个模式，支持正则匹配），比如这个例子用`big test`替换了`test`。\n\n假如有以下文本：\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\n```\n\n键入命令，查看输出\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 's/dog/cat/' data1.txt\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\n```\n\n可以看到符合模式的字符串都被修改了。\n\n要记住，sed并不会修改文本文件的数据，**它只会将修改后的数据发送到STDOUT**。\n\n#### 在命令行上使用多个编辑器命令\n\n使用`-e`选项可以执行多个命令\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed -e 's/brown/green/; s/dog/cat/' data1.txt\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\nThe quick green fox jumps over the lazy cat.\n```\n\n两个命令都作用到文件中的每一行数据上。命令之间必须用分号隔开，并且**在命令末尾与分号之间不同有空格**。\n\n如果不想使用分号，可以用bash shell中的次提示符来分隔命令。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed -e '\n> s/brown/green/\n> s/fox/elephant/\n> s/dog/cat/' data1.txt\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\n```\n\n#### 从文件中读取编辑器命令\n\n如果有大量要处理的sed命令，将其单独放入一个文本中会更方便，可以用sed命令的`-f`选项来指定文件。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat script1.sed\ns/brown/green/\ns/fox/elephant/\ns/dog/cat/\n\nwsx@wsx-laptop:~/tmp$ sed -f script1.sed data1.txt\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\nThe quick green elephant jumps over the lazy cat.\n```\n\n这种情况不用在每个命令后面放一个分号，sed知道每行都有一条单独的命令。\n\n\n\n### gawk程序\n\ngawk是一个处理文本的更高级工具，能够提供一个类编程环境来修改和重新组织文件中的数据。\n\n```\n说明\t在所有的发行版都没有默认安装gawk程序，请先安装\n```\n\ngawk程序是Unix中原始awk的GNU版本，它让流编辑器迈上了一个新的台阶，提供了一种编程语言而不只是编辑器命令。\n\n我们可以利用它做下面的事情：\n\n- 定义变量来保存数据\n- 使用算术和字符串操作符来处理数据\n- 使用结构化编程概念来为数据处理增加处理逻辑\n- 通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告\n\ngawk程序的报告生成能力通常用来从大文本文件中提取数据元素，并将它们格式化成可读的报告，使得重要的数据更易于可读。\n\n#### 基本命令格式\n\n```shell\ngawk options program file\n```\n\n下面显示了gawk程序的可用选项\n\n| 选项           | 描述                  |\n| ------------ | ------------------- |\n| -F fs        | 指定行中划分数据字段的字段分隔符    |\n| -f file      | 从指定文件中读取程序          |\n| -v var=value | 定义gawk程序中的一个变量及其默认值 |\n| -mf N        | 指定要处理的数据文件中的最大字段数   |\n| -mr N        | 指定数据文件中的最大数据行数      |\n| -W keyword   | 指定gawk的兼容模式或警告等级    |\n\ngawk的**强大之处在于程序脚本**（善于利用工具最强之处），可以写脚本来读取文本行的数据，然后处理并显示数据，创建任何类型的输出报告。\n\n#### 从命令行读取脚本\n\n我们必须将脚本命令放入两个花括号中，而由于gawk命令行假定脚本是单个文本字符串，所以我们必须把脚本放到单引号中。\n\n下面是一个简单的例子：\n\n```shell\nwsx@wsx-laptop:~/tmp$ gawk '{print \"Hello World!\"}'\n\nHello World!\nThis is a test\nHello World!\nThis is\nHello World!\n\nHello World!\n\n```\n\n`print`命令将文本打印到STDOUT。如果尝试允许命令，我们可能会有些失望，因为什么都不会发生，原因是没有指定文件名，所以gawk会从STDIN接收数据，如果我们按下回车，gawk会对这行文本允许一遍程序脚本。\n\n要终止这个程序必须表明数据流已经结束了，bash shell提供组合键来生成EOF(End-of-File)字符。Ctrl+D组合键会在bash中产生一个EOF字符。\n\n#### 使用数据字段变量\n\ngawk的主要特性之一是其处理文本文件中数据的能力，它自动给一行的每个数据元素分配一个变量。\n\n- $0代表整个文本行\n- $1代表文本行的第一个数据字段\n- $2代表文本行的第二个数据字段\n- $n代表文本行的第n个数据字段\n\ngawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。默认字段分隔符为任意的空白字符（例如空格或制表符）。\n\n下面例子gawk读取文本显示第一个数据字段的值。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data2.txt\nOne line of test text.\nTwo lines of test text.\nThree lines of test text.\nwsx@wsx-laptop:~/tmp$ gawk '{print $1}' data2.txt\nOne\nTwo\nThree\n```\n\n我们可以使用`-F`选项指定其他字段分隔符：\n\n```shell\nwsx@wsx-laptop:~/tmp$ gawk -F: '{print $1}' /etc/passwd\nroot\ndaemon\nbin\nsys\nsync\ngames\nman\nlp\nmail\nnews\nuucp\nproxy\nwww-data\nbackup\n...\n```\n\n这个简短程序显示了系统中密码文件的第一个数据字段。\n\n#### 在程序脚本中使用多个命令\n\n在命令之间放个分号即可。\n\n```shell\nwsx@wsx-laptop:~/tmp$ echo \"My name is Shixiang\" | gawk '{$4=\"Christine\"; print $0}'\nMy name is Christine\n```\n\n也可以使用次提示符一次一行输入程序脚本命令（类似sed）。\n\n#### 从文件中读取程序\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat script2.gawk\n{print $1 \" 's home directory is \" $6}\nwsx@wsx-laptop:~/tmp$ gawk -F: -f script2.gawk  /etc/passwd\nroot 's home directory is /root\ndaemon 's home directory is /usr/sbin\nbin 's home directory is /bin\nsys 's home directory is /dev\nsync 's home directory is /bin\ngames 's home directory is /usr/games\nman 's home directory is /var/cache/man\nlp 's home directory is /var/spool/lpd\nmail 's home directory is /var/mail\nnews 's home directory is /var/spool/news\nuucp 's home directory is /var/spool/uucp\nproxy 's home directory is /bin\n...\n```\n\n可以在程序文件中指定多条命令：\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat script3.gawk\n{\ntext = \"'s home directory is \"\nprint $1 text $6\n}\nwsx@wsx-laptop:~/tmp$ gawk -F: -f script3.gawk /etc/passwd\nroot's home directory is /root\ndaemon's home directory is /usr/sbin\nbin's home directory is /bin\nsys's home directory is /dev\nsync's home directory is /bin\ngames's home directory is /usr/games\nman's home directory is /var/cache/man\nlp's home directory is /var/spool/lpd\nmail's home directory is /var/mail\nnews's home directory is /var/spool/news\n...\n```\n\n#### 在处理数据前运行脚本\n\n使用BEGIN关键字可以强制gawk再读取数据前执行BEGIN关键字指定的程序脚本。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data3.txt\nLine 1\nLine 2\nLine 3\nwsx@wsx-laptop:~/tmp$ gawk 'BEGIN {print \"The data3 File Contents:\"}\n> {print $0}' data3.txt\nThe data3 File Contents:\nLine 1\nLine 2\nLine 3\n```\n\n在gawk执行了BEGIN脚本后，它会用第二段脚本来处理文件数据。\n\n#### 在处理数据后允许脚本\n\n与BEGIN关键字类似，END关键字允许我们指定一个脚本，gawk在读完数据后执行。\n\n```shell\nwsx@wsx-laptop:~/tmp$ gawk 'BEGIN {print \"The data3 File Contents:\"}\n> {print $0}\n> END {print \"End of File\"}' data3.txt\nThe data3 File Contents:\nLine 1\nLine 2\nLine 3\nEnd of File\n```\n\n我们把所有的内容放在一起组成一个漂亮的小程序脚本，用它从简单的数据文件中创建一份完整报告。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat script4.gawk\nBEGIN {\nprint \"The latest list of users and shells\"\nprint \" UserID \\t Shell\"\nprint \"-------- \\t ------\"\nFS=\":\"\n}\n\n{\nprint $1 \"      \\t \" $7\n}\n\nEND {\nprint \"This concludes the listing\"\n}\nwsx@wsx-laptop:~/tmp$ gawk -f script4.gawk /etc/passwd\nThe latest list of users and shells\n UserID          Shell\n--------         ------\nroot             /bin/bash\ndaemon           /usr/sbin/nologin\nbin              /usr/sbin/nologin\nsys              /usr/sbin/nologin\nsync             /bin/sync\ngames            /usr/sbin/nologin\nman              /usr/sbin/nologin\nlp               /usr/sbin/nologin\nmail             /usr/sbin/nologin\nnews             /usr/sbin/nologin\nuucp             /usr/sbin/nologin\nproxy            /usr/sbin/nologin\nwww-data         /usr/sbin/nologin\nbackup           /usr/sbin/nologin\nlist             /usr/sbin/nologin\nirc              /usr/sbin/nologin\ngnats            /usr/sbin/nologin\nnobody           /usr/sbin/nologin\nsystemd-timesync         /bin/false\nsystemd-network          /bin/false\nsystemd-resolve          /bin/false\nsystemd-bus-proxy        /bin/false\nsyslog           /bin/false\n_apt             /bin/false\nlxd              /bin/false\nmessagebus               /bin/false\nuuidd            /bin/false\ndnsmasq          /bin/false\nsshd             /usr/sbin/nologin\npollinate        /bin/false\nwsx              /bin/bash\nThis concludes the listing\n```\n\n我们以后会继续学习gawk高级编程。\n\n## sed编辑器基础\n\n下面介绍一些可以集成到脚本中的基本命令和功能。\n\n### 更多的替换选项\n\n之前我们已经学习了用`s`命令在行中替换文本，这个命令还有一些其他选项。\n\n#### 替换标记\n\n替换命令`s`默认只替换每行中出现的第一处。要让该命令能替换一行中不同地方出现的文本必须使用**替换标记**。该标记在替换命令字符串之后设置。\n\n```shell\ns/pattern/replacement/flags\n```\n\n替换标记有4种：\n\n- 数字，表明替换第几处模式匹配的地方\n- g，表明替换所有匹配的文本\n- p，表明原先行的内容要打印出来\n- w file，将替换的结果写入文件中\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data4.txt\nThis is a test of the test script.\nThis is the second test of the test script.\nwsx@wsx-laptop:~/tmp$ sed 's/test/trial/2' data4.txt\nThis is a test of the trial script.\nThis is the second test of the trial script.\n```\n\n该命令只替换每行中第二次出现的匹配模式。而`g`标记替换所有的匹配之处。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 's/test/trial/g' data4.txt\nThis is a trial of the trial script.\nThis is the second trial of the trial script.\n```\n\n`p`替换标记会打印与替换命令中指定的模式匹配的行，通常与sed的`-n`选项一起使用。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data5.txt\nThis is a test line.\nThis is a different line.\nwsx@wsx-laptop:~/tmp$ sed -n 's/test/trial/p' data5.txt\nThis is a trial line.\n```\n\n`-n`选项禁止sed编辑器输出，但`p`标记会输出修改过的行。两者配合使用就是**只输出被替换命令修改过的行**。\n\n`w`标记会产生同样的输出，不过会将输出（只输出被替换命令修改过的行）保存到指定文件中。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 's/test/trial/w test.txt' data5.txt\nThis is a trial line.\nThis is a different line.\nwsx@wsx-laptop:~/tmp$ cat test.txt\nThis is a trial line.\n```\n\n#### 替换字符\n\n有一些字符不方便在替换模式中使用，常见的例子为正斜线。\n\n替换文件中的路径名会比较麻烦，比如用C shell替换/etc/passwd文件中的bash shell，必须这样做（通过反斜线转义）：\n\n```shell\nwsx@wsx-laptop:~/tmp$ head /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n...\nwsx@wsx-laptop:~/tmp$ sed 's/\\/bin\\/bash/\\/bin\\/csh/' /etc/passwd\nroot:x:0:0:root:/root:/bin/csh\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\n...\n```\n\n为解决这样的问题，sed编辑器允许选择其他字符来替换命令中的字符串分隔符：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 's!/bin/bash!/bin/csh!' /etc/passwd\nroot:x:0:0:root:/root:/bin/csh\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n...\n```\n\n\n\n### 使用地址\n\n如果只想要命令作用于特定行或某些行，必须使用**行寻址**。\n\n有两种形式：\n\n- 以数字形式表示行区间\n- 用文本模式来过滤出行\n\n它们都使用相同地格式来指定地址：\n\n```shell\n[address]command\n```\n\n也可以将多个命令分组\n\n```shell\naddress {\n  command1\n  command2\n  command3\n}\n```\n\n#### 以数字的方式行寻址\n\nsed编辑器会将文本流中的第一行编号为1，然后继续按顺序给以下行编号。\n\n指定的地址**可以是单个行号，或者用行号、逗号以及结尾行号指定的一定区间范围的行**。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed '2s/dog/cat/' data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed '2,3s/dog/cat/' data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed '2,$s/dog/cat/' data1.txt  # 美元符指代最后一行\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\nThe quick brown fox jumps over the lazy cat.\n```\n\n#### 使用文本模式过滤器\n\nsed允许指定文本模式来过滤出命令要作用的行，格式如下：\n\n```\n/pattern/command\n```\n\n比如我要修改默认的shell，可以使用sed命令：\n\n```shell\nwsx@wsx-laptop:~/tmp$ grep wsx /etc/passwd\nwsx:x:1000:1000:\"\",,,:/home/wsx:/bin/bash\nwsx@wsx-laptop:~/tmp$ grep '/wsx/s/bash/csh/' /etc/passwd\nwsx@wsx-laptop:~/tmp$ sed '/wsx/s/bash/csh/' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\n...\nwsx:x:1000:1000:\"\",,,:/home/wsx:/bin/csh\n```\n\n正则表达式允许创建高级文本模式匹配表达式来匹配各种数据，结合一系列通配符、特殊字符来生成几乎任何形式文本的简练模式。我们后续会学习到。\n\n#### 命令组合\n\n使用花括号可以将多条命令组合在一起。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '2{\n> s/fox/elephant/\n> s/dog/cat/\n> }' data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown elephant jumps over the lazy cat.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\n```\n\n也可以在一组命令前指定一个地址区间。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '3,${\ns/brown/green/\ns/lazy/active/\n}' data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\nThe quick green fox jumps over the active dog.\n```\n\n### 删除行\n\n如果需要删除文本流中的特定行，使用删除命令`d`，它会删除匹配指定寻址模式的所有行。**使用时要特别小心**，如果忘记加入寻址模式，会将所有文本行删除。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed 'd' data1.txt\n```\n\n和指定的地址一起使用才能发挥删除命令的最大功用。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ sed '3d' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 4.\n```\n\n通过特定行区间指定：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '2,3d' data6.txt\nThis is line number 1.\nThis is line number 4.\n```\n\n通过特殊文本结尾字符指定：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '2,$d' data6.txt\nThis is line number 1.\n```\n\n还可以使用模式匹配特性：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '/number 1/d' data6.txt\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\n```\n\nsed会删除包含匹配模式的行。\n\n记住，sed不会修改原始文件。\n\n还可以使用两个文本模式来删除某个区间内的行，但做的时候需要特别小心，指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed会删除两个指定行之间的所有行（包括指定行）。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data7.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nThis is line number 1 again.\nThis is text you want to keep.\nThis is the last line in the file.\nwsx@wsx-laptop:~/tmp$ sed '/1/,/3/d' data7.txt\nThis is line number 4.\n```\n\n第二个出现的数字“1”的行再次触发了删除命令，因为未能找到停止模式“3”，所以将数据流剩余的行全部删掉了。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '/1/,/5/d' data7.txt\nwsx@wsx-laptop:~/tmp$ sed '/2/,/4/d' data7.txt\nThis is line number 1.\nThis is line number 1 again.\nThis is text you want to keep.\nThis is the last line in the file.\n```\n\n### 插入和附加文本\n\nsed允许向数据流插入和附加文本行：\n\n- 插入命令`i`会在指定行前增加一个新行\n- 附加命令`a`会在指定行后增加一个新行\n\n注意，它们不能在单个命令行上使用，必须要指定是要插入还是要附加到的那一行。\n\n```shell\nwsx@wsx-laptop:~/tmp$ echo \"Test Line 2\" | sed 'i\\Test Line 1'\nTest Line 1\nTest Line 2\nwsx@wsx-laptop:~/tmp$ echo \"Test Line 2\" | sed 'a\\Test Line 1'\nTest Line 2\nTest Line 1\n```\n\n要向数据流行内部插入或附加数据，必须用寻址来告诉sed数据应该出现在什么位置。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '3i\\ This is an inserted line.' data6.txt\nThis is line number 1.\nThis is line number 2.\n This is an inserted line.\nThis is line number 3.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ sed '3a\\ This is an inserted line.' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\n This is an inserted line.\nThis is line number 4.\n```\n\n如果想要给数据流末尾添加多行数据，通过`$`指定位置即可。\n\n```shell\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\n This is a new line.\n```\n\n\n\n### 修改行\n\n修改（change）命令允许修改整个数据流中整行文本内容。它跟插入和附加命令的工作机制一样。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '3c\\This is a changed line.' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is a changed line.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ sed '/number 3/c\\This is a changed line.' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is a changed line.\nThis is line number 4.\n```\n\n\n\n### 转换命令\n\n转换命令（y）是**唯一可以处理单字符的sed命令**。格式如下：\n\n```shell\n[address]y/inchars/outchars\n```\n\n转换命令会对`inchars`和`outchars`值进行一对一的映射。如果两者字符长度不同，则sed产生一条错误信息。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed 'y/123/789/' data6.txt\nThis is line number 7.\nThis is line number 8.\nThis is line number 9.\nThis is line number 4.\n```\n\n转换命令是一个全局命令，**它会在文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置**。\n\n### 回顾命令\n\n另有3个命令可以用来打印数据流中的信息：\n\n- `p`命令用来打印文本行\n- 等号`=`命令用来打印行号\n- `l`用来列出行\n\n#### 打印行\n\n```shell\nwsx@wsx-laptop:~/tmp$ echo \"this is a test\" | sed 'p'\nthis is a test\nthis is a test\n```\n\n`p`打印已有的数据文本。最常用的用法是打印符合匹配文本模式的行。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ sed -n '/number 3/p' data6.txt\nThis is line number 3.\n```\n\n在命令行上使用`-n`选项，可以禁止输出其他行，只打印包含匹配文本模式的行。\n\n也可以用来快速打印数据流中的某些行：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed -n '2,3p' data6.txt\nThis is line number 2.\nThis is line number 3.\n```\n\n#### 打印行号\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data1.txt\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog.\nwsx@wsx-laptop:~/tmp$ sed '=' data1.txt\n1\nThe quick brown fox jumps over the lazy dog.\n2\nThe quick brown fox jumps over the lazy dog.\n3\nThe quick brown fox jumps over the lazy dog.\n4\nThe quick brown fox jumps over the lazy dog.\n5\nThe quick brown fox jumps over the lazy dog.\n6\nThe quick brown fox jumps over the lazy dog.\n7\nThe quick brown fox jumps over the lazy dog.\n8\nThe quick brown fox jumps over the lazy dog.\n9\nThe quick brown fox jumps over the lazy dog.\n```\n\n这用来查找特定文本模式的话非常方便：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed -n '/number 4/{\n> =\n> p\n> }' data6.txt\n4\nThis is line number 4.\n```\n\n#### 列出行\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data9.txt\nThis    line    contains        tabs.\nwsx@wsx-laptop:~/tmp$ sed -n 'l' data9.txt\nThis\\tline\\tcontains\\ttabs.$\n```\n\n### 使用Sed处理文件\n\n#### 写入文件\n\n`w`命令用来向文件写入行。该命令格式如下：\n\n```shell\n[address]w filename\n```\n\n将文本的前两行写入其他文件：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '1,2w test.txt' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nwsx@wsx-laptop:~/tmp$ cat test.txt\nThis is line number 1.\nThis is line number 2.\n```\n\n如果不想让行显示到STDOUT（因为sed默认数据文本流），可以使用sed命令的`-n`选项。\n\n#### 读取数据\n\n读取命令为`r`。\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat data12.txt\nThis is an added line.\nThis is the second added line.\nwsx@wsx-laptop:~/tmp$ sed '3r data12.txt' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is an added line.\nThis is the second added line.\nThis is line number 4.\n```\n\n这效果有点像插入文本命令`i`和补充命令`a`。\n\n 同样适用于文本模式地址：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '/number 2/r data12.txt' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is an added line.\nThis is the second added line.\nThis is line number 3.\nThis is line number 4.\n```\n\n文本末尾添加：\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '$r data12.txt' data6.txt\nThis is line number 1.\nThis is line number 2.\nThis is line number 3.\nThis is line number 4.\nThis is an added line.\nThis is the second added line.\n```\n\n**读取命令的一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本**。假如你有一份套用信件保存在文本中：\n\n```shell\nwsx@wsx-laptop:~/tmp$ cat notice.std\nWould the following people:\nLIST\nplease report to the ship's captain.\n```\n\n套用信件将通用占位文本`LIST`放在人物名单的位置，我们先根据它插入文本字符，然后删除它。\n\n```shell\nwsx@wsx-laptop:~/tmp$ sed '/LIST/{\n> r data10.txt\n> d\n> }' notice.std\nWould the following people:\nThis line contains an escape character.\nplease report to the ship's captain.\nwsx@wsx-laptop:~/tmp$ cat data10.txt\nThis line contains an escape character.\nwsx@wsx-laptop:~/tmp$ cat data11.txt\nwangshx zhdan\nwsx@wsx-laptop:~/tmp$ sed '/LIST/{\nr data11.txt\nd\n}' notice.std\nWould the following people:\nwangshx zhdan\nplease report to the ship's captain.\n```\n\n可以看到占位符被替换成了数据文件中的文字。\n\n完。\n","slug":"sed-and-gawk","published":1,"updated":"2018-01-27T04:08:59.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwuw000m9taxcev33qo9","content":"<p><strong>学习内容</strong>：</p>\n<blockquote>\n<ul>\n<li>学习sed编辑器</li>\n<li>gawk编辑器入门</li>\n<li>sed编辑器基础</li>\n</ul>\n</blockquote>\n<p>shell脚本最常见的一个用途就是处理文本文件，但仅靠shell脚本命令来处理文本文件的内容有点勉为其难。如果我们想在shell脚本中处理任何类型的数据，需要熟悉Linux中的sed和gawk工具。这两个工具可以极大简化我们需要进行的数据处理任务。</p>\n<a id=\"more\"></a>\n<h2 id=\"文本处理\"><a href=\"#文本处理\" class=\"headerlink\" title=\"文本处理\"></a>文本处理</h2><p>当我们需要自动处理文本文件，又不想动用交互式文本编辑器时，sed和gawk是我们最好的选择。</p>\n<h3 id=\"sed编辑器\"><a href=\"#sed编辑器\" class=\"headerlink\" title=\"sed编辑器\"></a>sed编辑器</h3><p>也被称为<strong>流编辑器</strong>（stream editor），会在编辑器处理数据之前<strong>基于预先提供的一组规则</strong>来编辑数据流。</p>\n<p>sed编辑器可以根据命令来处理数据流中的数据，这些命令既可以从终端输入，也可以存储进脚本文件中。</p>\n<p>sed会执行以下的操作：</p>\n<ul>\n<li>一次从输入中读取一行数据</li>\n<li>根据所提供的命令匹配数据</li>\n<li>按照命令修改流中的数据</li>\n<li>将新的数据输出到STDOUT</li>\n</ul>\n<p>这一过程会重复直至处理完流中的所有数据行。</p>\n<p>sed命令的格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed options script file</span><br></pre></td></tr></table></figure>\n<p>选项<code>options</code>可以允许我们修改<code>sed</code>命令的行为</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-e script</td>\n<td>在处理输入时，将script中指定的命令添加到已有的命令中</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>在处理输入时，将file中指定的命令添加到已有的命令中</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>不产生命令输出，使用<code>print</code>命令来完成输出</td>\n</tr>\n</tbody>\n</table>\n<p><code>script</code>参数指定用于流数据上的单个命令，如果需要多个命令，要么使用<code>-e</code>选项在命令行中指定，要么使用<code>-f</code>选项在单独的文件中指定。</p>\n<h4 id=\"在命令行中定义编辑器命令\"><a href=\"#在命令行中定义编辑器命令\" class=\"headerlink\" title=\"在命令行中定义编辑器命令\"></a>在命令行中定义编辑器命令</h4><p>默认sed会将指定命令应用到STDIN输入流上，我们可以配合管道命令使用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"This is a test\" | sed 's/test/big test/'</span><br><span class=\"line\">This is a big test</span><br></pre></td></tr></table></figure>\n<p><code>s</code>命令使用斜线间指定的第二个文本来替换第一个文本字符串模式（注意是替换整个模式，支持正则匹配），比如这个例子用<code>big test</code>替换了<code>test</code>。</p>\n<p>假如有以下文本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure>\n<p>键入命令，查看输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/dog/cat/' data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<p>可以看到符合模式的字符串都被修改了。</p>\n<p>要记住，sed并不会修改文本文件的数据，<strong>它只会将修改后的数据发送到STDOUT</strong>。</p>\n<h4 id=\"在命令行上使用多个编辑器命令\"><a href=\"#在命令行上使用多个编辑器命令\" class=\"headerlink\" title=\"在命令行上使用多个编辑器命令\"></a>在命令行上使用多个编辑器命令</h4><p>使用<code>-e</code>选项可以执行多个命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -e 's/brown/green/; s/dog/cat/' data1.txt</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<p>两个命令都作用到文件中的每一行数据上。命令之间必须用分号隔开，并且<strong>在命令末尾与分号之间不同有空格</strong>。</p>\n<p>如果不想使用分号，可以用bash shell中的次提示符来分隔命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -e '</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/brown/green/</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/fox/elephant/</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/dog/cat/<span class=\"string\">' data1.txt</span></span></span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<h4 id=\"从文件中读取编辑器命令\"><a href=\"#从文件中读取编辑器命令\" class=\"headerlink\" title=\"从文件中读取编辑器命令\"></a>从文件中读取编辑器命令</h4><p>如果有大量要处理的sed命令，将其单独放入一个文本中会更方便，可以用sed命令的<code>-f</code>选项来指定文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat script1.sed</span><br><span class=\"line\">s/brown/green/</span><br><span class=\"line\">s/fox/elephant/</span><br><span class=\"line\">s/dog/cat/</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -f script1.sed data1.txt</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<p>这种情况不用在每个命令后面放一个分号，sed知道每行都有一条单独的命令。</p>\n<h3 id=\"gawk程序\"><a href=\"#gawk程序\" class=\"headerlink\" title=\"gawk程序\"></a>gawk程序</h3><p>gawk是一个处理文本的更高级工具，能够提供一个类编程环境来修改和重新组织文件中的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">说明\t在所有的发行版都没有默认安装gawk程序，请先安装</span><br></pre></td></tr></table></figure>\n<p>gawk程序是Unix中原始awk的GNU版本，它让流编辑器迈上了一个新的台阶，提供了一种编程语言而不只是编辑器命令。</p>\n<p>我们可以利用它做下面的事情：</p>\n<ul>\n<li>定义变量来保存数据</li>\n<li>使用算术和字符串操作符来处理数据</li>\n<li>使用结构化编程概念来为数据处理增加处理逻辑</li>\n<li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告</li>\n</ul>\n<p>gawk程序的报告生成能力通常用来从大文本文件中提取数据元素，并将它们格式化成可读的报告，使得重要的数据更易于可读。</p>\n<h4 id=\"基本命令格式\"><a href=\"#基本命令格式\" class=\"headerlink\" title=\"基本命令格式\"></a>基本命令格式</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gawk options program file</span><br></pre></td></tr></table></figure>\n<p>下面显示了gawk程序的可用选项</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-F fs</td>\n<td>指定行中划分数据字段的字段分隔符</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>从指定文件中读取程序</td>\n</tr>\n<tr>\n<td>-v var=value</td>\n<td>定义gawk程序中的一个变量及其默认值</td>\n</tr>\n<tr>\n<td>-mf N</td>\n<td>指定要处理的数据文件中的最大字段数</td>\n</tr>\n<tr>\n<td>-mr N</td>\n<td>指定数据文件中的最大数据行数</td>\n</tr>\n<tr>\n<td>-W keyword</td>\n<td>指定gawk的兼容模式或警告等级</td>\n</tr>\n</tbody>\n</table>\n<p>gawk的<strong>强大之处在于程序脚本</strong>（善于利用工具最强之处），可以写脚本来读取文本行的数据，然后处理并显示数据，创建任何类型的输出报告。</p>\n<h4 id=\"从命令行读取脚本\"><a href=\"#从命令行读取脚本\" class=\"headerlink\" title=\"从命令行读取脚本\"></a>从命令行读取脚本</h4><p>我们必须将脚本命令放入两个花括号中，而由于gawk命令行假定脚本是单个文本字符串，所以我们必须把脚本放到单引号中。</p>\n<p>下面是一个简单的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk '&#123;print \"Hello World!\"&#125;'</span><br><span class=\"line\"></span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">This is a test</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">This is</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\"></span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>\n<p><code>print</code>命令将文本打印到STDOUT。如果尝试允许命令，我们可能会有些失望，因为什么都不会发生，原因是没有指定文件名，所以gawk会从STDIN接收数据，如果我们按下回车，gawk会对这行文本允许一遍程序脚本。</p>\n<p>要终止这个程序必须表明数据流已经结束了，bash shell提供组合键来生成EOF(End-of-File)字符。Ctrl+D组合键会在bash中产生一个EOF字符。</p>\n<h4 id=\"使用数据字段变量\"><a href=\"#使用数据字段变量\" class=\"headerlink\" title=\"使用数据字段变量\"></a>使用数据字段变量</h4><p>gawk的主要特性之一是其处理文本文件中数据的能力，它自动给一行的每个数据元素分配一个变量。</p>\n<ul>\n<li>$0代表整个文本行</li>\n<li>$1代表文本行的第一个数据字段</li>\n<li>$2代表文本行的第二个数据字段</li>\n<li>$n代表文本行的第n个数据字段</li>\n</ul>\n<p>gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。默认字段分隔符为任意的空白字符（例如空格或制表符）。</p>\n<p>下面例子gawk读取文本显示第一个数据字段的值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data2.txt</span><br><span class=\"line\">One line of test text.</span><br><span class=\"line\">Two lines of test text.</span><br><span class=\"line\">Three lines of test text.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk '&#123;print $1&#125;' data2.txt</span><br><span class=\"line\">One</span><br><span class=\"line\">Two</span><br><span class=\"line\">Three</span><br></pre></td></tr></table></figure>\n<p>我们可以使用<code>-F</code>选项指定其他字段分隔符：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk -F: '&#123;print $1&#125;' /etc/passwd</span><br><span class=\"line\">root</span><br><span class=\"line\">daemon</span><br><span class=\"line\">bin</span><br><span class=\"line\">sys</span><br><span class=\"line\">sync</span><br><span class=\"line\">games</span><br><span class=\"line\">man</span><br><span class=\"line\">lp</span><br><span class=\"line\">mail</span><br><span class=\"line\">news</span><br><span class=\"line\">uucp</span><br><span class=\"line\">proxy</span><br><span class=\"line\">www-data</span><br><span class=\"line\">backup</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>这个简短程序显示了系统中密码文件的第一个数据字段。</p>\n<h4 id=\"在程序脚本中使用多个命令\"><a href=\"#在程序脚本中使用多个命令\" class=\"headerlink\" title=\"在程序脚本中使用多个命令\"></a>在程序脚本中使用多个命令</h4><p>在命令之间放个分号即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"My name is Shixiang\" | gawk '&#123;$4=\"Christine\"; print $0&#125;'</span><br><span class=\"line\">My name is Christine</span><br></pre></td></tr></table></figure>\n<p>也可以使用次提示符一次一行输入程序脚本命令（类似sed）。</p>\n<h4 id=\"从文件中读取程序\"><a href=\"#从文件中读取程序\" class=\"headerlink\" title=\"从文件中读取程序\"></a>从文件中读取程序</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat script2.gawk</span><br><span class=\"line\">&#123;print $1 \" 's home directory is \" $6&#125;</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk -F: -f script2.gawk  /etc/passwd</span><br><span class=\"line\">root 's home directory is /root</span><br><span class=\"line\">daemon 's home directory is /usr/sbin</span><br><span class=\"line\">bin 's home directory is /bin</span><br><span class=\"line\">sys 's home directory is /dev</span><br><span class=\"line\">sync 's home directory is /bin</span><br><span class=\"line\">games 's home directory is /usr/games</span><br><span class=\"line\">man 's home directory is /var/cache/man</span><br><span class=\"line\">lp 's home directory is /var/spool/lpd</span><br><span class=\"line\">mail 's home directory is /var/mail</span><br><span class=\"line\">news 's home directory is /var/spool/news</span><br><span class=\"line\">uucp 's home directory is /var/spool/uucp</span><br><span class=\"line\">proxy 's home directory is /bin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>可以在程序文件中指定多条命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat script3.gawk</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">text = \"'s home directory is \"</span><br><span class=\"line\">print $1 text $6</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk -F: -f script3.gawk /etc/passwd</span><br><span class=\"line\">root's home directory is /root</span><br><span class=\"line\">daemon's home directory is /usr/sbin</span><br><span class=\"line\">bin's home directory is /bin</span><br><span class=\"line\">sys's home directory is /dev</span><br><span class=\"line\">sync's home directory is /bin</span><br><span class=\"line\">games's home directory is /usr/games</span><br><span class=\"line\">man's home directory is /var/cache/man</span><br><span class=\"line\">lp's home directory is /var/spool/lpd</span><br><span class=\"line\">mail's home directory is /var/mail</span><br><span class=\"line\">news's home directory is /var/spool/news</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h4 id=\"在处理数据前运行脚本\"><a href=\"#在处理数据前运行脚本\" class=\"headerlink\" title=\"在处理数据前运行脚本\"></a>在处理数据前运行脚本</h4><p>使用BEGIN关键字可以强制gawk再读取数据前执行BEGIN关键字指定的程序脚本。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data3.txt</span><br><span class=\"line\">Line 1</span><br><span class=\"line\">Line 2</span><br><span class=\"line\">Line 3</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk 'BEGIN &#123;print \"The data3 File Contents:\"&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#123;<span class=\"built_in\">print</span> <span class=\"variable\">$0</span>&#125;<span class=\"string\">' data3.txt</span></span></span><br><span class=\"line\">The data3 File Contents:</span><br><span class=\"line\">Line 1</span><br><span class=\"line\">Line 2</span><br><span class=\"line\">Line 3</span><br></pre></td></tr></table></figure>\n<p>在gawk执行了BEGIN脚本后，它会用第二段脚本来处理文件数据。</p>\n<h4 id=\"在处理数据后允许脚本\"><a href=\"#在处理数据后允许脚本\" class=\"headerlink\" title=\"在处理数据后允许脚本\"></a>在处理数据后允许脚本</h4><p>与BEGIN关键字类似，END关键字允许我们指定一个脚本，gawk在读完数据后执行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk 'BEGIN &#123;print \"The data3 File Contents:\"&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#123;<span class=\"built_in\">print</span> <span class=\"variable\">$0</span>&#125;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> END &#123;<span class=\"built_in\">print</span> <span class=\"string\">\"End of File\"</span>&#125;<span class=\"string\">' data3.txt</span></span></span><br><span class=\"line\">The data3 File Contents:</span><br><span class=\"line\">Line 1</span><br><span class=\"line\">Line 2</span><br><span class=\"line\">Line 3</span><br><span class=\"line\">End of File</span><br></pre></td></tr></table></figure>\n<p>我们把所有的内容放在一起组成一个漂亮的小程序脚本，用它从简单的数据文件中创建一份完整报告。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat script4.gawk</span><br><span class=\"line\">BEGIN &#123;</span><br><span class=\"line\">print \"The latest list of users and shells\"</span><br><span class=\"line\">print \" UserID \\t Shell\"</span><br><span class=\"line\">print \"-------- \\t ------\"</span><br><span class=\"line\">FS=\":\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">print $1 \"      \\t \" $7</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">END &#123;</span><br><span class=\"line\">print \"This concludes the listing\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk -f script4.gawk /etc/passwd</span><br><span class=\"line\">The latest list of users and shells</span><br><span class=\"line\"> UserID          Shell</span><br><span class=\"line\">--------         ------</span><br><span class=\"line\">root             /bin/bash</span><br><span class=\"line\">daemon           /usr/sbin/nologin</span><br><span class=\"line\">bin              /usr/sbin/nologin</span><br><span class=\"line\">sys              /usr/sbin/nologin</span><br><span class=\"line\">sync             /bin/sync</span><br><span class=\"line\">games            /usr/sbin/nologin</span><br><span class=\"line\">man              /usr/sbin/nologin</span><br><span class=\"line\">lp               /usr/sbin/nologin</span><br><span class=\"line\">mail             /usr/sbin/nologin</span><br><span class=\"line\">news             /usr/sbin/nologin</span><br><span class=\"line\">uucp             /usr/sbin/nologin</span><br><span class=\"line\">proxy            /usr/sbin/nologin</span><br><span class=\"line\">www-data         /usr/sbin/nologin</span><br><span class=\"line\">backup           /usr/sbin/nologin</span><br><span class=\"line\">list             /usr/sbin/nologin</span><br><span class=\"line\">irc              /usr/sbin/nologin</span><br><span class=\"line\">gnats            /usr/sbin/nologin</span><br><span class=\"line\">nobody           /usr/sbin/nologin</span><br><span class=\"line\">systemd-timesync         /bin/false</span><br><span class=\"line\">systemd-network          /bin/false</span><br><span class=\"line\">systemd-resolve          /bin/false</span><br><span class=\"line\">systemd-bus-proxy        /bin/false</span><br><span class=\"line\">syslog           /bin/false</span><br><span class=\"line\">_apt             /bin/false</span><br><span class=\"line\">lxd              /bin/false</span><br><span class=\"line\">messagebus               /bin/false</span><br><span class=\"line\">uuidd            /bin/false</span><br><span class=\"line\">dnsmasq          /bin/false</span><br><span class=\"line\">sshd             /usr/sbin/nologin</span><br><span class=\"line\">pollinate        /bin/false</span><br><span class=\"line\">wsx              /bin/bash</span><br><span class=\"line\">This concludes the listing</span><br></pre></td></tr></table></figure>\n<p>我们以后会继续学习gawk高级编程。</p>\n<h2 id=\"sed编辑器基础\"><a href=\"#sed编辑器基础\" class=\"headerlink\" title=\"sed编辑器基础\"></a>sed编辑器基础</h2><p>下面介绍一些可以集成到脚本中的基本命令和功能。</p>\n<h3 id=\"更多的替换选项\"><a href=\"#更多的替换选项\" class=\"headerlink\" title=\"更多的替换选项\"></a>更多的替换选项</h3><p>之前我们已经学习了用<code>s</code>命令在行中替换文本，这个命令还有一些其他选项。</p>\n<h4 id=\"替换标记\"><a href=\"#替换标记\" class=\"headerlink\" title=\"替换标记\"></a>替换标记</h4><p>替换命令<code>s</code>默认只替换每行中出现的第一处。要让该命令能替换一行中不同地方出现的文本必须使用<strong>替换标记</strong>。该标记在替换命令字符串之后设置。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/flags</span><br></pre></td></tr></table></figure>\n<p>替换标记有4种：</p>\n<ul>\n<li>数字，表明替换第几处模式匹配的地方</li>\n<li>g，表明替换所有匹配的文本</li>\n<li>p，表明原先行的内容要打印出来</li>\n<li>w file，将替换的结果写入文件中</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data4.txt</span><br><span class=\"line\">This is a test of the test script.</span><br><span class=\"line\">This is the second test of the test script.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/test/trial/2' data4.txt</span><br><span class=\"line\">This is a test of the trial script.</span><br><span class=\"line\">This is the second test of the trial script.</span><br></pre></td></tr></table></figure>\n<p>该命令只替换每行中第二次出现的匹配模式。而<code>g</code>标记替换所有的匹配之处。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/test/trial/g' data4.txt</span><br><span class=\"line\">This is a trial of the trial script.</span><br><span class=\"line\">This is the second trial of the trial script.</span><br></pre></td></tr></table></figure>\n<p><code>p</code>替换标记会打印与替换命令中指定的模式匹配的行，通常与sed的<code>-n</code>选项一起使用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data5.txt</span><br><span class=\"line\">This is a test line.</span><br><span class=\"line\">This is a different line.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n 's/test/trial/p' data5.txt</span><br><span class=\"line\">This is a trial line.</span><br></pre></td></tr></table></figure>\n<p><code>-n</code>选项禁止sed编辑器输出，但<code>p</code>标记会输出修改过的行。两者配合使用就是<strong>只输出被替换命令修改过的行</strong>。</p>\n<p><code>w</code>标记会产生同样的输出，不过会将输出（只输出被替换命令修改过的行）保存到指定文件中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/test/trial/w test.txt' data5.txt</span><br><span class=\"line\">This is a trial line.</span><br><span class=\"line\">This is a different line.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat test.txt</span><br><span class=\"line\">This is a trial line.</span><br></pre></td></tr></table></figure>\n<h4 id=\"替换字符\"><a href=\"#替换字符\" class=\"headerlink\" title=\"替换字符\"></a>替换字符</h4><p>有一些字符不方便在替换模式中使用，常见的例子为正斜线。</p>\n<p>替换文件中的路径名会比较麻烦，比如用C shell替换/etc/passwd文件中的bash shell，必须这样做（通过反斜线转义）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ head /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class=\"line\">...</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/\\/bin\\/bash/\\/bin\\/csh/' /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/csh</span><br><span class=\"line\">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class=\"line\">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>为解决这样的问题，sed编辑器允许选择其他字符来替换命令中的字符串分隔符：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's!/bin/bash!/bin/csh!' /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/csh</span><br><span class=\"line\">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用地址\"><a href=\"#使用地址\" class=\"headerlink\" title=\"使用地址\"></a>使用地址</h3><p>如果只想要命令作用于特定行或某些行，必须使用<strong>行寻址</strong>。</p>\n<p>有两种形式：</p>\n<ul>\n<li>以数字形式表示行区间</li>\n<li>用文本模式来过滤出行</li>\n</ul>\n<p>它们都使用相同地格式来指定地址：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[address]command</span><br></pre></td></tr></table></figure>\n<p>也可以将多个命令分组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address &#123;</span><br><span class=\"line\">  command1</span><br><span class=\"line\">  command2</span><br><span class=\"line\">  command3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"以数字的方式行寻址\"><a href=\"#以数字的方式行寻址\" class=\"headerlink\" title=\"以数字的方式行寻址\"></a>以数字的方式行寻址</h4><p>sed编辑器会将文本流中的第一行编号为1，然后继续按顺序给以下行编号。</p>\n<p>指定的地址<strong>可以是单个行号，或者用行号、逗号以及结尾行号指定的一定区间范围的行</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2s/dog/cat/' data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2,3s/dog/cat/' data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2,$s/dog/cat/' data1.txt  # 美元符指代最后一行</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用文本模式过滤器\"><a href=\"#使用文本模式过滤器\" class=\"headerlink\" title=\"使用文本模式过滤器\"></a>使用文本模式过滤器</h4><p>sed允许指定文本模式来过滤出命令要作用的行，格式如下：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/pattern/<span class=\"keyword\">command</span></span><br></pre></td></tr></table></figure>\n<p>比如我要修改默认的shell，可以使用sed命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ grep wsx /etc/passwd</span><br><span class=\"line\">wsx:x:1000:1000:\"\",,,:/home/wsx:/bin/bash</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ grep '/wsx/s/bash/csh/' /etc/passwd</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/wsx/s/bash/csh/' /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class=\"line\">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class=\"line\">...</span><br><span class=\"line\">wsx:x:1000:1000:\"\",,,:/home/wsx:/bin/csh</span><br></pre></td></tr></table></figure>\n<p>正则表达式允许创建高级文本模式匹配表达式来匹配各种数据，结合一系列通配符、特殊字符来生成几乎任何形式文本的简练模式。我们后续会学习到。</p>\n<h4 id=\"命令组合\"><a href=\"#命令组合\" class=\"headerlink\" title=\"命令组合\"></a>命令组合</h4><p>使用花括号可以将多条命令组合在一起。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2&#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/fox/elephant/</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/dog/cat/</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#125;<span class=\"string\">' data1.txt</span></span></span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure>\n<p>也可以在一组命令前指定一个地址区间。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3,$&#123;</span><br><span class=\"line\">s/brown/green/</span><br><span class=\"line\">s/lazy/active/</span><br><span class=\"line\">&#125;' data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除行\"><a href=\"#删除行\" class=\"headerlink\" title=\"删除行\"></a>删除行</h3><p>如果需要删除文本流中的特定行，使用删除命令<code>d</code>，它会删除匹配指定寻址模式的所有行。<strong>使用时要特别小心</strong>，如果忘记加入寻址模式，会将所有文本行删除。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 'd' data1.txt</span><br></pre></td></tr></table></figure>\n<p>和指定的地址一起使用才能发挥删除命令的最大功用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3d' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>通过特定行区间指定：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2,3d' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>通过特殊文本结尾字符指定：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2,$d' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br></pre></td></tr></table></figure>\n<p>还可以使用模式匹配特性：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/number 1/d' data6.txt</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>sed会删除包含匹配模式的行。</p>\n<p>记住，sed不会修改原始文件。</p>\n<p>还可以使用两个文本模式来删除某个区间内的行，但做的时候需要特别小心，指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed会删除两个指定行之间的所有行（包括指定行）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data7.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">This is line number 1 again.</span><br><span class=\"line\">This is text you want to keep.</span><br><span class=\"line\">This is the last line in the file.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/1/,/3/d' data7.txt</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>第二个出现的数字“1”的行再次触发了删除命令，因为未能找到停止模式“3”，所以将数据流剩余的行全部删掉了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/1/,/5/d' data7.txt</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/2/,/4/d' data7.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 1 again.</span><br><span class=\"line\">This is text you want to keep.</span><br><span class=\"line\">This is the last line in the file.</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入和附加文本\"><a href=\"#插入和附加文本\" class=\"headerlink\" title=\"插入和附加文本\"></a>插入和附加文本</h3><p>sed允许向数据流插入和附加文本行：</p>\n<ul>\n<li>插入命令<code>i</code>会在指定行前增加一个新行</li>\n<li>附加命令<code>a</code>会在指定行后增加一个新行</li>\n</ul>\n<p>注意，它们不能在单个命令行上使用，必须要指定是要插入还是要附加到的那一行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"Test Line 2\" | sed 'i\\Test Line 1'</span><br><span class=\"line\">Test Line 1</span><br><span class=\"line\">Test Line 2</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"Test Line 2\" | sed 'a\\Test Line 1'</span><br><span class=\"line\">Test Line 2</span><br><span class=\"line\">Test Line 1</span><br></pre></td></tr></table></figure>\n<p>要向数据流行内部插入或附加数据，必须用寻址来告诉sed数据应该出现在什么位置。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3i\\ This is an inserted line.' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\"> This is an inserted line.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3a\\ This is an inserted line.' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\"> This is an inserted line.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>如果想要给数据流末尾添加多行数据，通过<code>$</code>指定位置即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\"> This is a new line.</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改行\"><a href=\"#修改行\" class=\"headerlink\" title=\"修改行\"></a>修改行</h3><p>修改（change）命令允许修改整个数据流中整行文本内容。它跟插入和附加命令的工作机制一样。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3c\\This is a changed line.' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is a changed line.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/number 3/c\\This is a changed line.' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is a changed line.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<h3 id=\"转换命令\"><a href=\"#转换命令\" class=\"headerlink\" title=\"转换命令\"></a>转换命令</h3><p>转换命令（y）是<strong>唯一可以处理单字符的sed命令</strong>。格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[address]y/inchars/outchars</span><br></pre></td></tr></table></figure>\n<p>转换命令会对<code>inchars</code>和<code>outchars</code>值进行一对一的映射。如果两者字符长度不同，则sed产生一条错误信息。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 'y/123/789/' data6.txt</span><br><span class=\"line\">This is line number 7.</span><br><span class=\"line\">This is line number 8.</span><br><span class=\"line\">This is line number 9.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>转换命令是一个全局命令，<strong>它会在文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置</strong>。</p>\n<h3 id=\"回顾命令\"><a href=\"#回顾命令\" class=\"headerlink\" title=\"回顾命令\"></a>回顾命令</h3><p>另有3个命令可以用来打印数据流中的信息：</p>\n<ul>\n<li><code>p</code>命令用来打印文本行</li>\n<li>等号<code>=</code>命令用来打印行号</li>\n<li><code>l</code>用来列出行</li>\n</ul>\n<h4 id=\"打印行\"><a href=\"#打印行\" class=\"headerlink\" title=\"打印行\"></a>打印行</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"this is a test\" | sed 'p'</span><br><span class=\"line\">this is a test</span><br><span class=\"line\">this is a test</span><br></pre></td></tr></table></figure>\n<p><code>p</code>打印已有的数据文本。最常用的用法是打印符合匹配文本模式的行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n '/number 3/p' data6.txt</span><br><span class=\"line\">This is line number 3.</span><br></pre></td></tr></table></figure>\n<p>在命令行上使用<code>-n</code>选项，可以禁止输出其他行，只打印包含匹配文本模式的行。</p>\n<p>也可以用来快速打印数据流中的某些行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n '2,3p' data6.txt</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印行号\"><a href=\"#打印行号\" class=\"headerlink\" title=\"打印行号\"></a>打印行号</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '=' data1.txt</span><br><span class=\"line\">1</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">2</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">3</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">4</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">5</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">6</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">7</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">8</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">9</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure>\n<p>这用来查找特定文本模式的话非常方便：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n '/number 4/&#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> =</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> p</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#125;<span class=\"string\">' data6.txt</span></span></span><br><span class=\"line\">4</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<h4 id=\"列出行\"><a href=\"#列出行\" class=\"headerlink\" title=\"列出行\"></a>列出行</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data9.txt</span><br><span class=\"line\">This    line    contains        tabs.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n 'l' data9.txt</span><br><span class=\"line\">This\\tline\\tcontains\\ttabs.$</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Sed处理文件\"><a href=\"#使用Sed处理文件\" class=\"headerlink\" title=\"使用Sed处理文件\"></a>使用Sed处理文件</h3><h4 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h4><p><code>w</code>命令用来向文件写入行。该命令格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[address]w filename</span><br></pre></td></tr></table></figure>\n<p>将文本的前两行写入其他文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '1,2w test.txt' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat test.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br></pre></td></tr></table></figure>\n<p>如果不想让行显示到STDOUT（因为sed默认数据文本流），可以使用sed命令的<code>-n</code>选项。</p>\n<h4 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h4><p>读取命令为<code>r</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data12.txt</span><br><span class=\"line\">This is an added line.</span><br><span class=\"line\">This is the second added line.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3r data12.txt' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is an added line.</span><br><span class=\"line\">This is the second added line.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>这效果有点像插入文本命令<code>i</code>和补充命令<code>a</code>。</p>\n<p> 同样适用于文本模式地址：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/number 2/r data12.txt' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is an added line.</span><br><span class=\"line\">This is the second added line.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>文本末尾添加：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '$r data12.txt' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">This is an added line.</span><br><span class=\"line\">This is the second added line.</span><br></pre></td></tr></table></figure>\n<p><strong>读取命令的一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本</strong>。假如你有一份套用信件保存在文本中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat notice.std</span><br><span class=\"line\">Would the following people:</span><br><span class=\"line\">LIST</span><br><span class=\"line\">please report to the ship's captain.</span><br></pre></td></tr></table></figure>\n<p>套用信件将通用占位文本<code>LIST</code>放在人物名单的位置，我们先根据它插入文本字符，然后删除它。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/LIST/&#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> r data10.txt</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> d</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#125;<span class=\"string\">' notice.std</span></span></span><br><span class=\"line\">Would the following people:</span><br><span class=\"line\">This line contains an escape character.</span><br><span class=\"line\">please report to the ship's captain.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data10.txt</span><br><span class=\"line\">This line contains an escape character.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data11.txt</span><br><span class=\"line\">wangshx zhdan</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/LIST/&#123;</span><br><span class=\"line\">r data11.txt</span><br><span class=\"line\">d</span><br><span class=\"line\">&#125;' notice.std</span><br><span class=\"line\">Would the following people:</span><br><span class=\"line\">wangshx zhdan</span><br><span class=\"line\">please report to the ship's captain.</span><br></pre></td></tr></table></figure>\n<p>可以看到占位符被替换成了数据文件中的文字。</p>\n<p>完。</p>\n","site":{"data":{}},"excerpt":"<p><strong>学习内容</strong>：</p>\n<blockquote>\n<ul>\n<li>学习sed编辑器</li>\n<li>gawk编辑器入门</li>\n<li>sed编辑器基础</li>\n</ul>\n</blockquote>\n<p>shell脚本最常见的一个用途就是处理文本文件，但仅靠shell脚本命令来处理文本文件的内容有点勉为其难。如果我们想在shell脚本中处理任何类型的数据，需要熟悉Linux中的sed和gawk工具。这两个工具可以极大简化我们需要进行的数据处理任务。</p>","more":"<h2 id=\"文本处理\"><a href=\"#文本处理\" class=\"headerlink\" title=\"文本处理\"></a>文本处理</h2><p>当我们需要自动处理文本文件，又不想动用交互式文本编辑器时，sed和gawk是我们最好的选择。</p>\n<h3 id=\"sed编辑器\"><a href=\"#sed编辑器\" class=\"headerlink\" title=\"sed编辑器\"></a>sed编辑器</h3><p>也被称为<strong>流编辑器</strong>（stream editor），会在编辑器处理数据之前<strong>基于预先提供的一组规则</strong>来编辑数据流。</p>\n<p>sed编辑器可以根据命令来处理数据流中的数据，这些命令既可以从终端输入，也可以存储进脚本文件中。</p>\n<p>sed会执行以下的操作：</p>\n<ul>\n<li>一次从输入中读取一行数据</li>\n<li>根据所提供的命令匹配数据</li>\n<li>按照命令修改流中的数据</li>\n<li>将新的数据输出到STDOUT</li>\n</ul>\n<p>这一过程会重复直至处理完流中的所有数据行。</p>\n<p>sed命令的格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed options script file</span><br></pre></td></tr></table></figure>\n<p>选项<code>options</code>可以允许我们修改<code>sed</code>命令的行为</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-e script</td>\n<td>在处理输入时，将script中指定的命令添加到已有的命令中</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>在处理输入时，将file中指定的命令添加到已有的命令中</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>不产生命令输出，使用<code>print</code>命令来完成输出</td>\n</tr>\n</tbody>\n</table>\n<p><code>script</code>参数指定用于流数据上的单个命令，如果需要多个命令，要么使用<code>-e</code>选项在命令行中指定，要么使用<code>-f</code>选项在单独的文件中指定。</p>\n<h4 id=\"在命令行中定义编辑器命令\"><a href=\"#在命令行中定义编辑器命令\" class=\"headerlink\" title=\"在命令行中定义编辑器命令\"></a>在命令行中定义编辑器命令</h4><p>默认sed会将指定命令应用到STDIN输入流上，我们可以配合管道命令使用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"This is a test\" | sed 's/test/big test/'</span><br><span class=\"line\">This is a big test</span><br></pre></td></tr></table></figure>\n<p><code>s</code>命令使用斜线间指定的第二个文本来替换第一个文本字符串模式（注意是替换整个模式，支持正则匹配），比如这个例子用<code>big test</code>替换了<code>test</code>。</p>\n<p>假如有以下文本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure>\n<p>键入命令，查看输出</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/dog/cat/' data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<p>可以看到符合模式的字符串都被修改了。</p>\n<p>要记住，sed并不会修改文本文件的数据，<strong>它只会将修改后的数据发送到STDOUT</strong>。</p>\n<h4 id=\"在命令行上使用多个编辑器命令\"><a href=\"#在命令行上使用多个编辑器命令\" class=\"headerlink\" title=\"在命令行上使用多个编辑器命令\"></a>在命令行上使用多个编辑器命令</h4><p>使用<code>-e</code>选项可以执行多个命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -e 's/brown/green/; s/dog/cat/' data1.txt</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br><span class=\"line\">The quick green fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<p>两个命令都作用到文件中的每一行数据上。命令之间必须用分号隔开，并且<strong>在命令末尾与分号之间不同有空格</strong>。</p>\n<p>如果不想使用分号，可以用bash shell中的次提示符来分隔命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -e '</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/brown/green/</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/fox/elephant/</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/dog/cat/<span class=\"string\">' data1.txt</span></span></span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<h4 id=\"从文件中读取编辑器命令\"><a href=\"#从文件中读取编辑器命令\" class=\"headerlink\" title=\"从文件中读取编辑器命令\"></a>从文件中读取编辑器命令</h4><p>如果有大量要处理的sed命令，将其单独放入一个文本中会更方便，可以用sed命令的<code>-f</code>选项来指定文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat script1.sed</span><br><span class=\"line\">s/brown/green/</span><br><span class=\"line\">s/fox/elephant/</span><br><span class=\"line\">s/dog/cat/</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -f script1.sed data1.txt</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick green elephant jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<p>这种情况不用在每个命令后面放一个分号，sed知道每行都有一条单独的命令。</p>\n<h3 id=\"gawk程序\"><a href=\"#gawk程序\" class=\"headerlink\" title=\"gawk程序\"></a>gawk程序</h3><p>gawk是一个处理文本的更高级工具，能够提供一个类编程环境来修改和重新组织文件中的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">说明\t在所有的发行版都没有默认安装gawk程序，请先安装</span><br></pre></td></tr></table></figure>\n<p>gawk程序是Unix中原始awk的GNU版本，它让流编辑器迈上了一个新的台阶，提供了一种编程语言而不只是编辑器命令。</p>\n<p>我们可以利用它做下面的事情：</p>\n<ul>\n<li>定义变量来保存数据</li>\n<li>使用算术和字符串操作符来处理数据</li>\n<li>使用结构化编程概念来为数据处理增加处理逻辑</li>\n<li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告</li>\n</ul>\n<p>gawk程序的报告生成能力通常用来从大文本文件中提取数据元素，并将它们格式化成可读的报告，使得重要的数据更易于可读。</p>\n<h4 id=\"基本命令格式\"><a href=\"#基本命令格式\" class=\"headerlink\" title=\"基本命令格式\"></a>基本命令格式</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gawk options program file</span><br></pre></td></tr></table></figure>\n<p>下面显示了gawk程序的可用选项</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-F fs</td>\n<td>指定行中划分数据字段的字段分隔符</td>\n</tr>\n<tr>\n<td>-f file</td>\n<td>从指定文件中读取程序</td>\n</tr>\n<tr>\n<td>-v var=value</td>\n<td>定义gawk程序中的一个变量及其默认值</td>\n</tr>\n<tr>\n<td>-mf N</td>\n<td>指定要处理的数据文件中的最大字段数</td>\n</tr>\n<tr>\n<td>-mr N</td>\n<td>指定数据文件中的最大数据行数</td>\n</tr>\n<tr>\n<td>-W keyword</td>\n<td>指定gawk的兼容模式或警告等级</td>\n</tr>\n</tbody>\n</table>\n<p>gawk的<strong>强大之处在于程序脚本</strong>（善于利用工具最强之处），可以写脚本来读取文本行的数据，然后处理并显示数据，创建任何类型的输出报告。</p>\n<h4 id=\"从命令行读取脚本\"><a href=\"#从命令行读取脚本\" class=\"headerlink\" title=\"从命令行读取脚本\"></a>从命令行读取脚本</h4><p>我们必须将脚本命令放入两个花括号中，而由于gawk命令行假定脚本是单个文本字符串，所以我们必须把脚本放到单引号中。</p>\n<p>下面是一个简单的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk '&#123;print \"Hello World!\"&#125;'</span><br><span class=\"line\"></span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">This is a test</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\">This is</span><br><span class=\"line\">Hello World!</span><br><span class=\"line\"></span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>\n<p><code>print</code>命令将文本打印到STDOUT。如果尝试允许命令，我们可能会有些失望，因为什么都不会发生，原因是没有指定文件名，所以gawk会从STDIN接收数据，如果我们按下回车，gawk会对这行文本允许一遍程序脚本。</p>\n<p>要终止这个程序必须表明数据流已经结束了，bash shell提供组合键来生成EOF(End-of-File)字符。Ctrl+D组合键会在bash中产生一个EOF字符。</p>\n<h4 id=\"使用数据字段变量\"><a href=\"#使用数据字段变量\" class=\"headerlink\" title=\"使用数据字段变量\"></a>使用数据字段变量</h4><p>gawk的主要特性之一是其处理文本文件中数据的能力，它自动给一行的每个数据元素分配一个变量。</p>\n<ul>\n<li>$0代表整个文本行</li>\n<li>$1代表文本行的第一个数据字段</li>\n<li>$2代表文本行的第二个数据字段</li>\n<li>$n代表文本行的第n个数据字段</li>\n</ul>\n<p>gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。默认字段分隔符为任意的空白字符（例如空格或制表符）。</p>\n<p>下面例子gawk读取文本显示第一个数据字段的值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data2.txt</span><br><span class=\"line\">One line of test text.</span><br><span class=\"line\">Two lines of test text.</span><br><span class=\"line\">Three lines of test text.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk '&#123;print $1&#125;' data2.txt</span><br><span class=\"line\">One</span><br><span class=\"line\">Two</span><br><span class=\"line\">Three</span><br></pre></td></tr></table></figure>\n<p>我们可以使用<code>-F</code>选项指定其他字段分隔符：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk -F: '&#123;print $1&#125;' /etc/passwd</span><br><span class=\"line\">root</span><br><span class=\"line\">daemon</span><br><span class=\"line\">bin</span><br><span class=\"line\">sys</span><br><span class=\"line\">sync</span><br><span class=\"line\">games</span><br><span class=\"line\">man</span><br><span class=\"line\">lp</span><br><span class=\"line\">mail</span><br><span class=\"line\">news</span><br><span class=\"line\">uucp</span><br><span class=\"line\">proxy</span><br><span class=\"line\">www-data</span><br><span class=\"line\">backup</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>这个简短程序显示了系统中密码文件的第一个数据字段。</p>\n<h4 id=\"在程序脚本中使用多个命令\"><a href=\"#在程序脚本中使用多个命令\" class=\"headerlink\" title=\"在程序脚本中使用多个命令\"></a>在程序脚本中使用多个命令</h4><p>在命令之间放个分号即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"My name is Shixiang\" | gawk '&#123;$4=\"Christine\"; print $0&#125;'</span><br><span class=\"line\">My name is Christine</span><br></pre></td></tr></table></figure>\n<p>也可以使用次提示符一次一行输入程序脚本命令（类似sed）。</p>\n<h4 id=\"从文件中读取程序\"><a href=\"#从文件中读取程序\" class=\"headerlink\" title=\"从文件中读取程序\"></a>从文件中读取程序</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat script2.gawk</span><br><span class=\"line\">&#123;print $1 \" 's home directory is \" $6&#125;</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk -F: -f script2.gawk  /etc/passwd</span><br><span class=\"line\">root 's home directory is /root</span><br><span class=\"line\">daemon 's home directory is /usr/sbin</span><br><span class=\"line\">bin 's home directory is /bin</span><br><span class=\"line\">sys 's home directory is /dev</span><br><span class=\"line\">sync 's home directory is /bin</span><br><span class=\"line\">games 's home directory is /usr/games</span><br><span class=\"line\">man 's home directory is /var/cache/man</span><br><span class=\"line\">lp 's home directory is /var/spool/lpd</span><br><span class=\"line\">mail 's home directory is /var/mail</span><br><span class=\"line\">news 's home directory is /var/spool/news</span><br><span class=\"line\">uucp 's home directory is /var/spool/uucp</span><br><span class=\"line\">proxy 's home directory is /bin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>可以在程序文件中指定多条命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat script3.gawk</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">text = \"'s home directory is \"</span><br><span class=\"line\">print $1 text $6</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk -F: -f script3.gawk /etc/passwd</span><br><span class=\"line\">root's home directory is /root</span><br><span class=\"line\">daemon's home directory is /usr/sbin</span><br><span class=\"line\">bin's home directory is /bin</span><br><span class=\"line\">sys's home directory is /dev</span><br><span class=\"line\">sync's home directory is /bin</span><br><span class=\"line\">games's home directory is /usr/games</span><br><span class=\"line\">man's home directory is /var/cache/man</span><br><span class=\"line\">lp's home directory is /var/spool/lpd</span><br><span class=\"line\">mail's home directory is /var/mail</span><br><span class=\"line\">news's home directory is /var/spool/news</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h4 id=\"在处理数据前运行脚本\"><a href=\"#在处理数据前运行脚本\" class=\"headerlink\" title=\"在处理数据前运行脚本\"></a>在处理数据前运行脚本</h4><p>使用BEGIN关键字可以强制gawk再读取数据前执行BEGIN关键字指定的程序脚本。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data3.txt</span><br><span class=\"line\">Line 1</span><br><span class=\"line\">Line 2</span><br><span class=\"line\">Line 3</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk 'BEGIN &#123;print \"The data3 File Contents:\"&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#123;<span class=\"built_in\">print</span> <span class=\"variable\">$0</span>&#125;<span class=\"string\">' data3.txt</span></span></span><br><span class=\"line\">The data3 File Contents:</span><br><span class=\"line\">Line 1</span><br><span class=\"line\">Line 2</span><br><span class=\"line\">Line 3</span><br></pre></td></tr></table></figure>\n<p>在gawk执行了BEGIN脚本后，它会用第二段脚本来处理文件数据。</p>\n<h4 id=\"在处理数据后允许脚本\"><a href=\"#在处理数据后允许脚本\" class=\"headerlink\" title=\"在处理数据后允许脚本\"></a>在处理数据后允许脚本</h4><p>与BEGIN关键字类似，END关键字允许我们指定一个脚本，gawk在读完数据后执行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk 'BEGIN &#123;print \"The data3 File Contents:\"&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#123;<span class=\"built_in\">print</span> <span class=\"variable\">$0</span>&#125;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> END &#123;<span class=\"built_in\">print</span> <span class=\"string\">\"End of File\"</span>&#125;<span class=\"string\">' data3.txt</span></span></span><br><span class=\"line\">The data3 File Contents:</span><br><span class=\"line\">Line 1</span><br><span class=\"line\">Line 2</span><br><span class=\"line\">Line 3</span><br><span class=\"line\">End of File</span><br></pre></td></tr></table></figure>\n<p>我们把所有的内容放在一起组成一个漂亮的小程序脚本，用它从简单的数据文件中创建一份完整报告。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat script4.gawk</span><br><span class=\"line\">BEGIN &#123;</span><br><span class=\"line\">print \"The latest list of users and shells\"</span><br><span class=\"line\">print \" UserID \\t Shell\"</span><br><span class=\"line\">print \"-------- \\t ------\"</span><br><span class=\"line\">FS=\":\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">print $1 \"      \\t \" $7</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">END &#123;</span><br><span class=\"line\">print \"This concludes the listing\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ gawk -f script4.gawk /etc/passwd</span><br><span class=\"line\">The latest list of users and shells</span><br><span class=\"line\"> UserID          Shell</span><br><span class=\"line\">--------         ------</span><br><span class=\"line\">root             /bin/bash</span><br><span class=\"line\">daemon           /usr/sbin/nologin</span><br><span class=\"line\">bin              /usr/sbin/nologin</span><br><span class=\"line\">sys              /usr/sbin/nologin</span><br><span class=\"line\">sync             /bin/sync</span><br><span class=\"line\">games            /usr/sbin/nologin</span><br><span class=\"line\">man              /usr/sbin/nologin</span><br><span class=\"line\">lp               /usr/sbin/nologin</span><br><span class=\"line\">mail             /usr/sbin/nologin</span><br><span class=\"line\">news             /usr/sbin/nologin</span><br><span class=\"line\">uucp             /usr/sbin/nologin</span><br><span class=\"line\">proxy            /usr/sbin/nologin</span><br><span class=\"line\">www-data         /usr/sbin/nologin</span><br><span class=\"line\">backup           /usr/sbin/nologin</span><br><span class=\"line\">list             /usr/sbin/nologin</span><br><span class=\"line\">irc              /usr/sbin/nologin</span><br><span class=\"line\">gnats            /usr/sbin/nologin</span><br><span class=\"line\">nobody           /usr/sbin/nologin</span><br><span class=\"line\">systemd-timesync         /bin/false</span><br><span class=\"line\">systemd-network          /bin/false</span><br><span class=\"line\">systemd-resolve          /bin/false</span><br><span class=\"line\">systemd-bus-proxy        /bin/false</span><br><span class=\"line\">syslog           /bin/false</span><br><span class=\"line\">_apt             /bin/false</span><br><span class=\"line\">lxd              /bin/false</span><br><span class=\"line\">messagebus               /bin/false</span><br><span class=\"line\">uuidd            /bin/false</span><br><span class=\"line\">dnsmasq          /bin/false</span><br><span class=\"line\">sshd             /usr/sbin/nologin</span><br><span class=\"line\">pollinate        /bin/false</span><br><span class=\"line\">wsx              /bin/bash</span><br><span class=\"line\">This concludes the listing</span><br></pre></td></tr></table></figure>\n<p>我们以后会继续学习gawk高级编程。</p>\n<h2 id=\"sed编辑器基础\"><a href=\"#sed编辑器基础\" class=\"headerlink\" title=\"sed编辑器基础\"></a>sed编辑器基础</h2><p>下面介绍一些可以集成到脚本中的基本命令和功能。</p>\n<h3 id=\"更多的替换选项\"><a href=\"#更多的替换选项\" class=\"headerlink\" title=\"更多的替换选项\"></a>更多的替换选项</h3><p>之前我们已经学习了用<code>s</code>命令在行中替换文本，这个命令还有一些其他选项。</p>\n<h4 id=\"替换标记\"><a href=\"#替换标记\" class=\"headerlink\" title=\"替换标记\"></a>替换标记</h4><p>替换命令<code>s</code>默认只替换每行中出现的第一处。要让该命令能替换一行中不同地方出现的文本必须使用<strong>替换标记</strong>。该标记在替换命令字符串之后设置。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s/pattern/replacement/flags</span><br></pre></td></tr></table></figure>\n<p>替换标记有4种：</p>\n<ul>\n<li>数字，表明替换第几处模式匹配的地方</li>\n<li>g，表明替换所有匹配的文本</li>\n<li>p，表明原先行的内容要打印出来</li>\n<li>w file，将替换的结果写入文件中</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data4.txt</span><br><span class=\"line\">This is a test of the test script.</span><br><span class=\"line\">This is the second test of the test script.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/test/trial/2' data4.txt</span><br><span class=\"line\">This is a test of the trial script.</span><br><span class=\"line\">This is the second test of the trial script.</span><br></pre></td></tr></table></figure>\n<p>该命令只替换每行中第二次出现的匹配模式。而<code>g</code>标记替换所有的匹配之处。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/test/trial/g' data4.txt</span><br><span class=\"line\">This is a trial of the trial script.</span><br><span class=\"line\">This is the second trial of the trial script.</span><br></pre></td></tr></table></figure>\n<p><code>p</code>替换标记会打印与替换命令中指定的模式匹配的行，通常与sed的<code>-n</code>选项一起使用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data5.txt</span><br><span class=\"line\">This is a test line.</span><br><span class=\"line\">This is a different line.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n 's/test/trial/p' data5.txt</span><br><span class=\"line\">This is a trial line.</span><br></pre></td></tr></table></figure>\n<p><code>-n</code>选项禁止sed编辑器输出，但<code>p</code>标记会输出修改过的行。两者配合使用就是<strong>只输出被替换命令修改过的行</strong>。</p>\n<p><code>w</code>标记会产生同样的输出，不过会将输出（只输出被替换命令修改过的行）保存到指定文件中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/test/trial/w test.txt' data5.txt</span><br><span class=\"line\">This is a trial line.</span><br><span class=\"line\">This is a different line.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat test.txt</span><br><span class=\"line\">This is a trial line.</span><br></pre></td></tr></table></figure>\n<h4 id=\"替换字符\"><a href=\"#替换字符\" class=\"headerlink\" title=\"替换字符\"></a>替换字符</h4><p>有一些字符不方便在替换模式中使用，常见的例子为正斜线。</p>\n<p>替换文件中的路径名会比较麻烦，比如用C shell替换/etc/passwd文件中的bash shell，必须这样做（通过反斜线转义）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ head /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class=\"line\">...</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's/\\/bin\\/bash/\\/bin\\/csh/' /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/csh</span><br><span class=\"line\">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class=\"line\">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>为解决这样的问题，sed编辑器允许选择其他字符来替换命令中的字符串分隔符：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 's!/bin/bash!/bin/csh!' /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/csh</span><br><span class=\"line\">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用地址\"><a href=\"#使用地址\" class=\"headerlink\" title=\"使用地址\"></a>使用地址</h3><p>如果只想要命令作用于特定行或某些行，必须使用<strong>行寻址</strong>。</p>\n<p>有两种形式：</p>\n<ul>\n<li>以数字形式表示行区间</li>\n<li>用文本模式来过滤出行</li>\n</ul>\n<p>它们都使用相同地格式来指定地址：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[address]command</span><br></pre></td></tr></table></figure>\n<p>也可以将多个命令分组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address &#123;</span><br><span class=\"line\">  command1</span><br><span class=\"line\">  command2</span><br><span class=\"line\">  command3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"以数字的方式行寻址\"><a href=\"#以数字的方式行寻址\" class=\"headerlink\" title=\"以数字的方式行寻址\"></a>以数字的方式行寻址</h4><p>sed编辑器会将文本流中的第一行编号为1，然后继续按顺序给以下行编号。</p>\n<p>指定的地址<strong>可以是单个行号，或者用行号、逗号以及结尾行号指定的一定区间范围的行</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2s/dog/cat/' data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2,3s/dog/cat/' data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2,$s/dog/cat/' data1.txt  # 美元符指代最后一行</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy cat.</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用文本模式过滤器\"><a href=\"#使用文本模式过滤器\" class=\"headerlink\" title=\"使用文本模式过滤器\"></a>使用文本模式过滤器</h4><p>sed允许指定文本模式来过滤出命令要作用的行，格式如下：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/pattern/<span class=\"keyword\">command</span></span><br></pre></td></tr></table></figure>\n<p>比如我要修改默认的shell，可以使用sed命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ grep wsx /etc/passwd</span><br><span class=\"line\">wsx:x:1000:1000:\"\",,,:/home/wsx:/bin/bash</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ grep '/wsx/s/bash/csh/' /etc/passwd</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/wsx/s/bash/csh/' /etc/passwd</span><br><span class=\"line\">root:x:0:0:root:/root:/bin/bash</span><br><span class=\"line\">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class=\"line\">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class=\"line\">...</span><br><span class=\"line\">wsx:x:1000:1000:\"\",,,:/home/wsx:/bin/csh</span><br></pre></td></tr></table></figure>\n<p>正则表达式允许创建高级文本模式匹配表达式来匹配各种数据，结合一系列通配符、特殊字符来生成几乎任何形式文本的简练模式。我们后续会学习到。</p>\n<h4 id=\"命令组合\"><a href=\"#命令组合\" class=\"headerlink\" title=\"命令组合\"></a>命令组合</h4><p>使用花括号可以将多条命令组合在一起。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2&#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/fox/elephant/</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> s/dog/cat/</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#125;<span class=\"string\">' data1.txt</span></span></span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown elephant jumps over the lazy cat.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure>\n<p>也可以在一组命令前指定一个地址区间。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3,$&#123;</span><br><span class=\"line\">s/brown/green/</span><br><span class=\"line\">s/lazy/active/</span><br><span class=\"line\">&#125;' data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br><span class=\"line\">The quick green fox jumps over the active dog.</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除行\"><a href=\"#删除行\" class=\"headerlink\" title=\"删除行\"></a>删除行</h3><p>如果需要删除文本流中的特定行，使用删除命令<code>d</code>，它会删除匹配指定寻址模式的所有行。<strong>使用时要特别小心</strong>，如果忘记加入寻址模式，会将所有文本行删除。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 'd' data1.txt</span><br></pre></td></tr></table></figure>\n<p>和指定的地址一起使用才能发挥删除命令的最大功用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3d' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>通过特定行区间指定：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2,3d' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>通过特殊文本结尾字符指定：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '2,$d' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br></pre></td></tr></table></figure>\n<p>还可以使用模式匹配特性：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/number 1/d' data6.txt</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>sed会删除包含匹配模式的行。</p>\n<p>记住，sed不会修改原始文件。</p>\n<p>还可以使用两个文本模式来删除某个区间内的行，但做的时候需要特别小心，指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed会删除两个指定行之间的所有行（包括指定行）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data7.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">This is line number 1 again.</span><br><span class=\"line\">This is text you want to keep.</span><br><span class=\"line\">This is the last line in the file.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/1/,/3/d' data7.txt</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>第二个出现的数字“1”的行再次触发了删除命令，因为未能找到停止模式“3”，所以将数据流剩余的行全部删掉了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/1/,/5/d' data7.txt</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/2/,/4/d' data7.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 1 again.</span><br><span class=\"line\">This is text you want to keep.</span><br><span class=\"line\">This is the last line in the file.</span><br></pre></td></tr></table></figure>\n<h3 id=\"插入和附加文本\"><a href=\"#插入和附加文本\" class=\"headerlink\" title=\"插入和附加文本\"></a>插入和附加文本</h3><p>sed允许向数据流插入和附加文本行：</p>\n<ul>\n<li>插入命令<code>i</code>会在指定行前增加一个新行</li>\n<li>附加命令<code>a</code>会在指定行后增加一个新行</li>\n</ul>\n<p>注意，它们不能在单个命令行上使用，必须要指定是要插入还是要附加到的那一行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"Test Line 2\" | sed 'i\\Test Line 1'</span><br><span class=\"line\">Test Line 1</span><br><span class=\"line\">Test Line 2</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"Test Line 2\" | sed 'a\\Test Line 1'</span><br><span class=\"line\">Test Line 2</span><br><span class=\"line\">Test Line 1</span><br></pre></td></tr></table></figure>\n<p>要向数据流行内部插入或附加数据，必须用寻址来告诉sed数据应该出现在什么位置。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3i\\ This is an inserted line.' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\"> This is an inserted line.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3a\\ This is an inserted line.' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\"> This is an inserted line.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>如果想要给数据流末尾添加多行数据，通过<code>$</code>指定位置即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\"> This is a new line.</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改行\"><a href=\"#修改行\" class=\"headerlink\" title=\"修改行\"></a>修改行</h3><p>修改（change）命令允许修改整个数据流中整行文本内容。它跟插入和附加命令的工作机制一样。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3c\\This is a changed line.' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is a changed line.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/number 3/c\\This is a changed line.' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is a changed line.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<h3 id=\"转换命令\"><a href=\"#转换命令\" class=\"headerlink\" title=\"转换命令\"></a>转换命令</h3><p>转换命令（y）是<strong>唯一可以处理单字符的sed命令</strong>。格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[address]y/inchars/outchars</span><br></pre></td></tr></table></figure>\n<p>转换命令会对<code>inchars</code>和<code>outchars</code>值进行一对一的映射。如果两者字符长度不同，则sed产生一条错误信息。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed 'y/123/789/' data6.txt</span><br><span class=\"line\">This is line number 7.</span><br><span class=\"line\">This is line number 8.</span><br><span class=\"line\">This is line number 9.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>转换命令是一个全局命令，<strong>它会在文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置</strong>。</p>\n<h3 id=\"回顾命令\"><a href=\"#回顾命令\" class=\"headerlink\" title=\"回顾命令\"></a>回顾命令</h3><p>另有3个命令可以用来打印数据流中的信息：</p>\n<ul>\n<li><code>p</code>命令用来打印文本行</li>\n<li>等号<code>=</code>命令用来打印行号</li>\n<li><code>l</code>用来列出行</li>\n</ul>\n<h4 id=\"打印行\"><a href=\"#打印行\" class=\"headerlink\" title=\"打印行\"></a>打印行</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ echo \"this is a test\" | sed 'p'</span><br><span class=\"line\">this is a test</span><br><span class=\"line\">this is a test</span><br></pre></td></tr></table></figure>\n<p><code>p</code>打印已有的数据文本。最常用的用法是打印符合匹配文本模式的行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n '/number 3/p' data6.txt</span><br><span class=\"line\">This is line number 3.</span><br></pre></td></tr></table></figure>\n<p>在命令行上使用<code>-n</code>选项，可以禁止输出其他行，只打印包含匹配文本模式的行。</p>\n<p>也可以用来快速打印数据流中的某些行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n '2,3p' data6.txt</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印行号\"><a href=\"#打印行号\" class=\"headerlink\" title=\"打印行号\"></a>打印行号</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data1.txt</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '=' data1.txt</span><br><span class=\"line\">1</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">2</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">3</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">4</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">5</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">6</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">7</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">8</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br><span class=\"line\">9</span><br><span class=\"line\">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure>\n<p>这用来查找特定文本模式的话非常方便：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n '/number 4/&#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> =</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> p</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#125;<span class=\"string\">' data6.txt</span></span></span><br><span class=\"line\">4</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<h4 id=\"列出行\"><a href=\"#列出行\" class=\"headerlink\" title=\"列出行\"></a>列出行</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data9.txt</span><br><span class=\"line\">This    line    contains        tabs.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed -n 'l' data9.txt</span><br><span class=\"line\">This\\tline\\tcontains\\ttabs.$</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Sed处理文件\"><a href=\"#使用Sed处理文件\" class=\"headerlink\" title=\"使用Sed处理文件\"></a>使用Sed处理文件</h3><h4 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h4><p><code>w</code>命令用来向文件写入行。该命令格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[address]w filename</span><br></pre></td></tr></table></figure>\n<p>将文本的前两行写入其他文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '1,2w test.txt' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat test.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br></pre></td></tr></table></figure>\n<p>如果不想让行显示到STDOUT（因为sed默认数据文本流），可以使用sed命令的<code>-n</code>选项。</p>\n<h4 id=\"读取数据\"><a href=\"#读取数据\" class=\"headerlink\" title=\"读取数据\"></a>读取数据</h4><p>读取命令为<code>r</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data12.txt</span><br><span class=\"line\">This is an added line.</span><br><span class=\"line\">This is the second added line.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '3r data12.txt' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is an added line.</span><br><span class=\"line\">This is the second added line.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>这效果有点像插入文本命令<code>i</code>和补充命令<code>a</code>。</p>\n<p> 同样适用于文本模式地址：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/number 2/r data12.txt' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is an added line.</span><br><span class=\"line\">This is the second added line.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br></pre></td></tr></table></figure>\n<p>文本末尾添加：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '$r data12.txt' data6.txt</span><br><span class=\"line\">This is line number 1.</span><br><span class=\"line\">This is line number 2.</span><br><span class=\"line\">This is line number 3.</span><br><span class=\"line\">This is line number 4.</span><br><span class=\"line\">This is an added line.</span><br><span class=\"line\">This is the second added line.</span><br></pre></td></tr></table></figure>\n<p><strong>读取命令的一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本</strong>。假如你有一份套用信件保存在文本中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat notice.std</span><br><span class=\"line\">Would the following people:</span><br><span class=\"line\">LIST</span><br><span class=\"line\">please report to the ship's captain.</span><br></pre></td></tr></table></figure>\n<p>套用信件将通用占位文本<code>LIST</code>放在人物名单的位置，我们先根据它插入文本字符，然后删除它。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/LIST/&#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> r data10.txt</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> d</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#125;<span class=\"string\">' notice.std</span></span></span><br><span class=\"line\">Would the following people:</span><br><span class=\"line\">This line contains an escape character.</span><br><span class=\"line\">please report to the ship's captain.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data10.txt</span><br><span class=\"line\">This line contains an escape character.</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ cat data11.txt</span><br><span class=\"line\">wangshx zhdan</span><br><span class=\"line\">wsx@wsx-laptop:~/tmp$ sed '/LIST/&#123;</span><br><span class=\"line\">r data11.txt</span><br><span class=\"line\">d</span><br><span class=\"line\">&#125;' notice.std</span><br><span class=\"line\">Would the following people:</span><br><span class=\"line\">wangshx zhdan</span><br><span class=\"line\">please report to the ship's captain.</span><br></pre></td></tr></table></figure>\n<p>可以看到占位符被替换成了数据文件中的文字。</p>\n<p>完。</p>"},{"title":"控制脚本","author":"王诗翔","date":"2017-09-03T16:00:00.000Z","_content":"\n\n\n> **内容**\n>\n> - 处理信号\n> - 以后台模式运行脚本\n> - 禁止挂起\n> - 作业控制\n> - 修改脚本优先级\n> - 脚本执行自动化\n\n<!-- more -->\n\n除了在命令行界面世界运行脚本，还存在一些方法：**向脚本发送信号、修改脚本的优先级以及在脚本运行时切换到运行模式**。\n\n下面逐一讲述。\n\n## 处理信号\n\nLinux利用信号与运行在系统中的进程进行通信。我们可以通过对脚本编程，使其在收到特定信号时执行某些命令，从而实现对脚本运行的控制。\n\n### Linux信号\n\nLinux和应用程序可以生成超过30个信号。下面列出最常见的系统信号。\n\n|  信号  |    值    |       描述        |\n| :--: | :-----: | :-------------: |\n|  1   | SIGHUP  |      挂起进程       |\n|  2   | SIGINT  |      终止进程       |\n|  3   | SIGQUIT |      停止进程       |\n|  9   | SIGKILL |     无条件终止进程     |\n|  15  | SIGTERM |     尽可能终止进程     |\n|  17  | SIGSTOP | 无条件停止进程，但不是终止进程 |\n|  18  | SIGTSTP | 停止或暂停进程，但不是终止进程 |\n|  19  | SIGCONT |    继续运行停止的进程    |\n\n\n\n默认情况下，bash shell会忽略收到的任何`SIGQUIT`和`SIGTERM`信号（所以交互式shell不会被终止）。但是bash shell会处理收到的`SIGHUP`和`SIGINT`信号。\n\nShell会将这些信号传给shell脚本程序来处理。而shell脚本默认是忽略这些信号的，为了避免它，我们可以在脚本中加入识别信号的代码，并执行命令来处理信号。\n\n\n\n### 生成信号\n\n键盘上的组合可以生成两种基本的Linux信号。它在停止或暂停失控程序时非常有用。\n\n1. 中断程序： 使用`Ctrl`+`C`，它会发送`SIGINT`信号。\n\n   ~~（测试没起作用，尴尬了～）~~\n\n2. 暂停进程：使用`Ctrl`+`Z`，它会发送`SIGTSTP`信号。\n\n   ```shell\n   wsx@wsx-ubuntu:~$ sleep 1000\n   ^Z\n   [2]+  已停止               sleep 1000\n\n   ```\n\n**注意**：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。\n\n方括号中的数字是shell自动为程序分配的*作业号*。shell将shell中运行的每个进程成为*作业*，并为其分配唯一的作业号。\n\n退出shell时发现有停止的进程，用`ps`命令查看\n\n```shell\nwsx@wsx-ubuntu:~$ exit\nexit\n有停止的任务。\nwsx@wsx-ubuntu:~$ ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n0 S  1000  5438  5433  0  80   0 -  6153 wait   pts/4    00:00:00 bash\n0 T  1000  5452  5438  0  80   0 -  2258 signal pts/4    00:00:00 sleep\n0 T  1000  5456  5438  0  80   0 -  2258 signal pts/4    00:00:00 sleep\n4 R  1000  5525  5438  0  80   0 -  7665 -      pts/4    00:00:00 ps\n\n```\n\n在表示进程状态的S列中，`ps`命令将已经停止作业的状态显示为`T`。这说明命令要么被跟踪，要么被停止了。\n\n如果你仍想退出shell，只需要再输入一遍`exit`。也可以用`kill`生成`SIGKILL`信号标识上`PID`杀死进程。\n\n```shell\nwsx@wsx-ubuntu:~$ kill 5456\nwsx@wsx-ubuntu:~$ kill -9 5456\nwsx@wsx-ubuntu:~$ kill -9 5452\n[1]-  已杀死               sleep 1000\n[2]+  已杀死               sleep 1000\n```\n\n\n\n### 捕获信号\n\n`trap`命令允许我们来指定shell脚本要监看并从shell中拦截的Linux信号。\n\n格式为：\n\n```shell\ntrap commands signals\n```\n\n下面展示一个简单的例子，看如何使用`trap`命令忽略`SIGINT`信号，并控制脚本的行为。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test1.sh\n#!/bin/bash\n# Testing signal trapping\n#\ntrap \"echo ' Sorry! I have trapped Ctrl-C'\" SIGINT\n#\necho This is a test script\n#\ncount=1\nwhile [ $count -le 10 ]\ndo\n    echo \"Loop #$count\"\n    sleep 1\n    count=$[ $count + 1 ]\ndone\n#\necho \"This is the end of the test script\"\n#\n```\n\n来运行测试一下：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test1.sh\nThis is a test script\nLoop #1\nLoop #2\nLoop #3\nLoop #4\nLoop #5\nLoop #6\n^C Sorry! I have trapped Ctrl-C\nLoop #7\nLoop #8\nLoop #9\nLoop #10\nThis is the end of the test script\n```\n\n\n\n### 捕获信号\n\n我们也可以在shell脚本退出时进行捕获。这是**在shell完成任务时执行命令的一种简便方法**。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test2.sh\n#!/bin/bash\n# Trapping the script exit\n#\ntrap \"echo Goodbye...\" EXIT\n#\ncount=1\nwhile [ $count -le 5 ]\ndo\n    echo \"Loop #$count\"\n    sleep 1\n    count=$[ $count + 1 ]\ndone\n#\n\nwangsx@SC-201708020022:~/tmp$ ./test2.sh\nLoop #1\nLoop #2\nLoop #3\nLoop #4\nLoop #5\nGoodbye...\n```\n\n当该脚本运行到退出位置，捕获就触发了，shell会执行在`trap`命令行指定的命令。就算提取退出，也能够成功捕获。\n\n\n\n### 修改或移除捕获\n\n想在不同的位置进行不同的捕获处理，只需要重新使用带新选项的`trap`命令。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test3.sh\n#!/bin/bash\n# Modifying a set trap\n#\ntrap \"echo ' Sorry... Ctrc-C is trapped.'\" SIGINT # SIGINT是退出信号\n#\ncount=1\nwhile [ $count -le 5 ]  # 当count<5的时候\ndo\n    echo \"Loop #$count\"\n    sleep 1    # 睡1秒\n    count=$[ $count + 1 ]\ndone\n\n#\ntrap \"echo ' I modified the trap!'\" SIGINT\n#\ncount=1\nwhile [ $count -le 5 ]  # 当count<5的时候\ndo\n    echo \"Loop #$count\"\n    sleep 1    # 睡1秒\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~/tmp$ ./test3.sh\nLoop #1\nLoop #2\nLoop #3\n^C Sorry... Ctrc-C is trapped.\nLoop #4\nLoop #5\nLoop #1\nLoop #2\nLoop #3\n^C I modified the trap!\nLoop #4\nLoop #5\n```\n\n相当于两次不同的捕获。\n\n我们也可以删除已经设置好的捕获。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test3.sh\n#!/bin/bash\n# Modifying a set trap\n#\ntrap \"echo ' Sorry... Ctrc-C is trapped.'\" SIGINT # SIGINT是退出信号  在这里设置捕获\n#\ncount=1\nwhile [ $count -le 5 ]  # 当count<5的时候\ndo\n    echo \"Loop #$count\"\n    sleep 1    # 睡1秒\n    count=$[ $count + 1 ]\ndone\n\n#\ntrap -- SIGINT # 在这里删除捕获\necho \"I modified the trap!\"\n#\ncount=1\nwhile [ $count -le 5 ]  # 当count<5的时候\ndo\n    echo \"Loop #$count\"\n    sleep 1    # 睡1秒\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~/tmp$ ./test3.sh\nLoop #1\nLoop #2\nLoop #3\nLoop #4\nLoop #5\nI modified the trap!\nLoop #1\nLoop #2\nLoop #3\n^C\n```\n\n信号捕获被移除之后，脚本会按照原来的方式处理`SIGINT`信号。所以使用`Ctrl+C`键时，脚本运行会退出。当然，如果是在这个信号捕获移除前接受到`SIGINT`信号，那么脚本还是会捕获。（因为shell脚本运行是按步的，前面没有接收到信号捕获的移除，自然不会实现信号捕获的移除）\n\n\n\n## 以后台模式运行脚本\n\n### 后台运行脚本\n\n以后台模式运行shell脚本非常简单，只要再命令后加`&`符就可以了。\n\n```shell\nwangsx@SC-201708020022:~$ cat test4.sh\n#!/bin/bash\n# Testing running in the background\n#\ncount=1\nwhile [ $count -le 10 ]\ndo\n    sleep 1\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~$ ./test4.sh &\n[1] 69\n```\n\n当添加`&`符号后，命令和bash shell会分离而作为一个独立的后台进行运行。并返回作业号（方括号内）和进程ID（PID），Linux系统上运行的每一个进程都必须有一个唯一的PID。\n\n当后台进程结束后，它会在终端显示出消息：\n\n```shell\n[1]   已完成               ./test4.sh\n```\n\n需要注意的是，当后台程序运行时，它仍然会使用终端显示器显示`STDOUT`和`STDERR`消息。最好是将`STDOUT`和`STDERR`进行重定向。\n\n\n\n### 运行多个后台作业\n\n我们可以在命令提示符中同时启动多个后台作用，然后用`ps`命令查看。\n\n```shell\nwangsx@SC-201708020022:~$ ./test4.sh &\n[1] 117\nwangsx@SC-201708020022:~$ ./test5.sh &\n[2] 122\nwangsx@SC-201708020022:~$ ./test6.sh &\n[3] 128\nwangsx@SC-201708020022:~$ ps\n  PID TTY          TIME CMD\n    2 tty1     00:00:00 bash\n  117 tty1     00:00:00 test4.sh\n  122 tty1     00:00:00 test5.sh\n  128 tty1     00:00:00 test6.sh\n  135 tty1     00:00:00 sleep\n  136 tty1     00:00:00 sleep\n  137 tty1     00:00:00 ps\n  138 tty1     00:00:00 sleep\n```\n\n我们特别需要注意，如果终端退出，后台程序也会随之退出。\n\n## 在非控制台下运行脚本\n\n如果我们不想出现终端退出后台程序退出的情况，可以使用`nohup`命令来实现。\n\n**`nohup`命令运行了另外一个命令来阻断所有发送给该进程的`SIGHUP`信号。这会在退出终端会话时阻止进程退出。**\n\n其格式如下：\n\n```shell\nwangsx@SC-201708020022:~$ nohup ./test4.sh  &\n[1] 156\nwangsx@SC-201708020022:~$ nohup: 忽略输入并把输出追加到'nohup.out'\n```\n\n由于`nohup`命令会解除终端与进程的关联，进程也就不再同`STDOUT`和`STDERR`联系在一起。它会自动将这两者重定向到名为`nohup.out`的文件中。\n\n\n\n## 作业控制\n\n启动、停止终止以及恢复作业统称为**作业控制**。我们可以通过这几种方式完全控制shell环境中所有的进程的运行方式。\n\n### 查看作业\n\n作业控制的**关键命令**是`jobs`命令。它允许查看shell当前正在处理的作业。\n\n```shell\nwangsx@SC-201708020022:~$ cat test10.sh\n#!/bin/bash\n# Test job control\n#\necho \"Script Process ID: $$\"\n#\ncount=1\nwhile [ $count -le 10 ]\ndo\n    echo \"Loop #$count\"\n    sleep 10\n    count=$[ $count + 1 ]\ndone\n#\necho \"End of script...\"\n#\nwangsx@SC-201708020022:~$ ./test10.sh\nScript Process ID: 27\nLoop #1\nLoop #2\n^Z^C # 我的ctrl+z好像不起作用\n```\n\n脚本用`$$`变量来显示系统分配给脚本的PID。使用Ctrl+Z组合键来停止脚本（我的在这不起作用~之前好像也是）。\n\n我们使用同样的脚本，利用`&`将另外一个作业作为后台进程启动。我们通过`jobs -l`命令查看作业的PID。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test10.sh > test10.out &\n[1] 121\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]+   121 运行中               ./test10.sh > test10.out &\n```\n\n下面看`jobs`命令的一些参数：\n\n| 参数   | 语法                       |\n| ---- | ------------------------ |\n| -l   | 列出进程的PID以及作业号            |\n| -n   | 只列出上次shell发出的通知后改变了状态的作业 |\n| -p   | 只列出作业的PID                |\n| -r   | 只列出运行中的作业                |\n| -s   | 只列出已停止的作业                |\n\n如果仔细注意的话，我们发现作业号后面有`+`号。带加号的作业会被当成默认作业。当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候只有一个带加号的作业和一个带减号的作业。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]    132 运行中               ./test10.sh > test10.out &\n[2]-   134 运行中               ./test10.sh > test10.out &\n[3]+   136 运行中               ./test10.sh > test10.out &\n```\n\n可以发现最好运行的脚本输出排在最前面。\n\n我们调用了`kill`命令向默认进程发送了一个`SIGHUP`信号，终止了该作业。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test10.sh > test10.out &\n[1] 165\nwangsx@SC-201708020022:~/tmp$ ./test10.sh > test10.out &\n[2] 167\nwangsx@SC-201708020022:~/tmp$ ./test10.sh > test10.out &\n[3] 169\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]    165 运行中               ./test10.sh > test10.out &\n[2]-   167 运行中               ./test10.sh > test10.out &\n[3]+   169 运行中               ./test10.sh > test10.out &\nwangsx@SC-201708020022:~/tmp$ kill 169\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]    165 运行中               ./test10.sh > test10.out &\n[2]-   167 运行中               ./test10.sh > test10.out &\n[3]+   169 已终止               ./test10.sh > test10.out\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]-   165 运行中               ./test10.sh > test10.out &\n[2]+   167 运行中               ./test10.sh > test10.out &\n```\n\n### 重启停止的作业\n\n我们可以将已经停止的作业作为后台进程或者前台进程重启。前台进程会接管当前工作的终端，所以使用时需要注意。\n\n要以后台模式重启一个作业，可以用`bg`命令加上作业号（我的Window10子系统好像确实不能使用Ctrl+Z的功能，有兴趣可以自己测试一下）。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test10.sh\nScript Process ID: 13\nLoop #1\n^ZLoop #2\n^C\nwangsx@SC-201708020022:~/tmp$ bg\nbash: bg: 当前: 无此任务\nwangsx@SC-201708020022:~/tmp$ jobs\n```\n\n如果是默认作业，只需要使用`bg`命令。如果有多个作业，你得在`bg`命令后加上作业号。\n\n\n\n## 调整谦让度\n\n在Linux中，内核负责将CPU时间分配给系统上运行的每一个进程。**调度优先级**是内核分配给进程的CPU时间。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。\n\n调度优先级是一个整数值，从-20（最高）到+19（最低）。默认bash shell以优先级0来启动所有进程。\n\n我们可以使用`nice`命令来改变shell脚本的优先级。\n\n### nice命令\n\n要让命令以更低的优先级运行，只要用`nice`的`-n`命令行来指定新的优先级级别。\n\n```shell\nwsx@ubuntu:~/tmp$ nice -n 10 ./test10.sh > test10.out &\n[5] 18953\nwsx@ubuntu:~/tmp$ ps -p 18953 -o pid,ppid,ni,cmd\n   PID   PPID  NI CMD\n 18953  18782  10 /bin/bash ./test10.sh\n\n```\n\n如果想要提高优先级，需要使用超级用户权限。`nice`命令的`-n`选项不是必须的，只需要在破折号后面跟上优先级就行了。\n\n```shell\nwsx@ubuntu:~/tmp$ nice -10 ./test10.sh > test10.out &\n[6] 18999\n[5]   Done                    nice -n 10 ./test10.sh > test10.out\nwsx@ubuntu:~/tmp$ ps -p 18999 -o pid,ppid,ni,cmd\n   PID   PPID  NI CMD\n 18999  18782  10 /bin/bash ./test10.sh\n```\n\n### renice命令\n\n有时候我们想要改变系统上已经运行命令的优先级，这是`renice`命令可以做到的。它允许我们指定PID来改变它的优先级。\n\n```shell\nwsx@ubuntu:~/tmp$ ./test10.sh &\n[3] 19086\nwsx@ubuntu:~$ ps -p 19086 -o pid,ppid,ni,cmd\n   PID   PPID  NI CMD\n 19086  19070   0 /bin/bash ./test10.sh\nwsx@ubuntu:~$ renice -n 10 -p 19086\n19086 (process ID) old priority 0, new priority 10\nwsx@ubuntu:~$ ps -p 19086 -o pid,ppid,ni,cmd\n   PID   PPID  NI CMD\n 19086  19070  10 /bin/bash ./test10.sh\n```\n\n## 定时运行脚本\n\nLinux系统提供了多个在预定时间运行脚本的方法：`at`命令和`cron`表。\n\n### 用at命令来计划执行任务\n\n`at`命令允许指定Linux系统何时运行脚本。`at`命令会将作业提交到队列中，指定shell何时运行该作业。`at`的守护进程`atd`会以后台模式运行，检查作业队列来运行作业。\n\n`atd`守护进程会检查系统上的一个特殊目录（通常位于`/var/spool/at`）来获取用`at`命令提交的作业。\n\n#### at命令的格式\n\n```shell\nat [-f filename] time\n```\n\n默认，`at`命令会将`STDIN`的输入放入队列中。我们可以用`-f`参数来指定用于读取命令的文件名。`time`参数指定了Linux系统何时运行该脚本。\n\n`at`命令能识别多种不同的时间格式。\n\n- 标准的小时和分钟格式，比如10:15\n- AM/PM指示符，比如10:15 PM\n- 特定可命令的时间，比如now, noon, midnight或teatime （4 PM）\n\n除了指定运行时间，还可以指定运行的日期。\n\n- 标准日期格式，比如MMDDYY, MM/DD/YY或DD.MM.YY\n- 文本日期，比如Jul 4或Dec 25，加不加年份都可以\n- 还可以指定时间增量\n  - 当前时间+25min\n  - 明天10:15PM\n  - 10:15+7天\n\n针对不同的优先级，存在26种不同的作业队列。作业队列通常用小写字母a-z和大写字母A-Z来指代。\n\n作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。可以用`-q`参数指定不同的队列字母。\n\n#### 获取作业的输出\n\nLinux系统会将提交作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给用户。\n\n```shell\n# 解决atd没启动的问题\nwangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start\n```\n\n\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test13.sh\n#!/bin/bash\n# Test using at command\n#\necho \"This script ran at $(date +%B%d,%T)\"\necho\nsleep 5\necho \"This is the script's end...\"\n#\nwangsx@SC-201708020022:~/tmp$ at -f test13.sh now\nwarning: commands will be executed using /bin/sh\njob 4 at Tue Sep 26 12:12:00 2017\n```\n\n`at`命令会显示分配给作业的作业号以及为作业安排的运行时间。`at`命令利用`sendmail`应用程序来发送邮件。如果没有安装这个工具就无法获得输出，因此在使用`at`命令时，最好在脚本中对STDOUT和STDERR进行重定向。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test13b.sh\n#!/bin/bash\n# Test using at command\n#\necho \"This script ran at $(date +%B%d,%T)\" > test13b.out\necho >> test13b.out\nsleep 5\necho \"This is the script's end...\" >> test13b.out\n#\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh now\nwarning: commands will be executed using /bin/sh\njob 7 at Tue Sep 26 12:16:00 2017\nwangsx@SC-201708020022:~/tmp$ cat test13b.out\nThis script ran at 九月26,12:16:24\n\nThis is the script's end...\n```\n\n这里使用了`-M`选项来屏蔽作业产生的输出信息。\n\n#### 列出等待的作业\n\n`atq`命令可以查看系统中有哪些作业再等待。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime\nwarning: commands will be executed using /bin/sh\njob 11 at Wed Sep 27 16:00:00 2017\nCan't open /var/run/atd.pid to signal atd. No atd running?\nwangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start\n[sudo] wangsx 的密码：\n * Starting deferred execution scheduler atd                                                                     [ OK ]\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime\nwarning: commands will be executed using /bin/sh\njob 12 at Wed Sep 27 16:00:00 2017\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh tomorrow\nwarning: commands will be executed using /bin/sh\njob 13 at Wed Sep 27 21:44:00 2017\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh 13:30\nwarning: commands will be executed using /bin/sh\njob 14 at Wed Sep 27 13:30:00 2017\nwangsx@SC-201708020022:~/tmp$ atq\n11      Wed Sep 27 16:00:00 2017 a wangsx\n12      Wed Sep 27 16:00:00 2017 a wangsx\n13      Wed Sep 27 21:44:00 2017 a wangsx\n14      Wed Sep 27 13:30:00 2017 a wangsx\n```\n\n作业列表中显示了作业号、系统运行该作业的日期和时间以及它所在的队列位置。\n\n#### 删除作业\n\n使用`atrm`命令删除等待中的作业。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ atq\n11      Wed Sep 27 16:00:00 2017 a wangsx\n12      Wed Sep 27 16:00:00 2017 a wangsx\n13      Wed Sep 27 21:44:00 2017 a wangsx\n14      Wed Sep 27 13:30:00 2017 a wangsx\nwangsx@SC-201708020022:~/tmp$ atrm 11\nwangsx@SC-201708020022:~/tmp$ atq\n12      Wed Sep 27 16:00:00 2017 a wangsx\n13      Wed Sep 27 21:44:00 2017 a wangsx\n14      Wed Sep 27 13:30:00 2017 a wangsx\n```\n\n只能删除自己提交的作业，不能删除其他人的。\n\n\n\n### 安排需要定期执行的脚本\n\n如果是需要定期执行的脚本，我们不需要使用`at`不断提交作业，而是可以利用Linux系统的另一个功能。\n\n**Linux系统使用`cron`程序来安排要定期执行的作业。它会在后台运行并检查一个特殊的表（成为cron时间表），以获得已安排执行的作业。**\n\n#### cron时间表\n\n`cron`时间表的格式如下：\n\n```shell\nmin hour dayofmonth month dayofweek command\n```\n\n`cron`时间表允许我们用特定值、取值范围（比如1-5）或者通配符（星号）来指定条目。\n\n例如，我们想在每天的10:15运行一个命令，可以使用：\n\n```shell\n15 10 * * * command\n```\n\n在其中三个字段使用了通配符，表明`cron`会在每个月的每天的10:15执行该命令。\n\n要指定在每周一4:15PM运行命令，可以使用：\n\n```shell\n15 16 * * 1 command\n```\n\n可以用三字符的文本值mon,tue,wed,thu,fri,sat,sum或数值（0为周日，6为周六）来指定dayofweek的表项。\n\n`dayofmonth`可以用1-31表示。\n\n```shell\n# 怎么在每个月的最后一天执行命令？\n00 12 * * * if [`date +%d -d tomorrow` = 01 ]; then ; command\n```\n\n命令列表必须指定要运行的命令或脚本的全路径名。\n\n```shell\n# 例如\n15 10 * * * /home/rich/test4.sh > test4out\n```\n\n注意：`corn`会用提交作业的用户账户运行脚本，所以我们在操作指定文件时必须有相应权限。\n\n#### 构建cron时间表\n\nLinux提供了`crontab`命令来处理`cron`时间表。我们可以使用`-l`选项列出时间表。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ crontab -l\nno crontab for wangsx\n```\n\n要添加条目，使用`-e`选项。在添加条目时，`crontab`命令会启动一个文本编辑器，使用已有的`cron`时间表作为文件内容。\n\n#### 浏览cron目录\n\n如果对时间精确性要求不高，用预配置的`cron`脚本目录会更方便。有4个基本目录：hourly, daily, monthly和weekly。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ls /etc/cron.*ly\n/etc/cron.daily:\napport      bsdmainutils  man-db   passwd                  upstart\napt-compat  dpkg          mdadm    popularity-contest\naptitude    logrotate     mlocate  update-notifier-common\n\n/etc/cron.hourly:\n\n/etc/cron.monthly:\n\n/etc/cron.weekly:\nfstrim  man-db  update-notifier-common\n```\n\n如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron每天会执行它。\n\n#### anacron程序\n\n如果提交的作业需要运行时系统处于关机状态，`cron`不会运行那些错过的脚本。为了解决这个问题，`anacron`程序诞生了。\n\n如果`anacron`知道某个作业错过了执行时间，它会尽快运行该作业。这个功能常用于进行常规日志维护的脚本。\n\n`anacron`程序只会处理位于`cron`目录下的程序，比如`/etc/cron.monthly`。它使用时间戳来决定作业是否在正确的计划间隔内运行了，每个`cron`目录都有个时间戳文件，该文件位于`/var/spool/anacron`。\n\n`anacron`程序使用自己的时间表来检查作业目录。\n\n```shell\nwsx@ubuntu:~$ sudo cat /var/spool/anacron/cron.monthly\n[sudo] password for wsx:\n20170926\nwsx@ubuntu:~$ sudo cat /etc/anacrontab\n# /etc/anacrontab: configuration file for anacron\n\n# See anacron(8) and anacrontab(5) for details.\n\nSHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\nHOME=/root\nLOGNAME=root\n\n# These replace cron's entries\n1       5       cron.daily      run-parts --report /etc/cron.daily\n7       10      cron.weekly     run-parts --report /etc/cron.weekly\n@monthly        15      cron.monthly    run-parts --report /etc/cron.monthly\n\n```\n\n`anacron`的时间表的基本格式和`cron`时间表略有不同：\n\n```shell\nperiod delay identifier command\n```\n\n`period`定义了作业多久运行一次，以天为单位。`anacron`用此条目来检查作业的时间戳文件。`delay`条目会指定系统启动后`anacron`程序需要等待多少分钟再开始运行错过的脚本。`command`条目包含了`run-parts`程序和一个`cron`脚本目录名。`run-parts`程序负责运行目录中传给它的任何脚本。\n\n注意了，`anacron`不会处理执行时间需求小于一天的脚本，所以它是不会运行`/etc/cron.hourly`的脚本。\n\n`identifier`条目是一种特别的非空字符串，如`cron-weekly`。它用于唯一标识日志消息和错误邮件中的作业。\n","source":"_posts/2017-09-04-control_shell.md","raw":"---\ntitle: 控制脚本\nauthor: 王诗翔\ndate: 2017-09-04\ncategories:\n- Linux杂烩\n- shell编程\ntags:\n- linux\n- shell笔记\n\n---\n\n\n\n> **内容**\n>\n> - 处理信号\n> - 以后台模式运行脚本\n> - 禁止挂起\n> - 作业控制\n> - 修改脚本优先级\n> - 脚本执行自动化\n\n<!-- more -->\n\n除了在命令行界面世界运行脚本，还存在一些方法：**向脚本发送信号、修改脚本的优先级以及在脚本运行时切换到运行模式**。\n\n下面逐一讲述。\n\n## 处理信号\n\nLinux利用信号与运行在系统中的进程进行通信。我们可以通过对脚本编程，使其在收到特定信号时执行某些命令，从而实现对脚本运行的控制。\n\n### Linux信号\n\nLinux和应用程序可以生成超过30个信号。下面列出最常见的系统信号。\n\n|  信号  |    值    |       描述        |\n| :--: | :-----: | :-------------: |\n|  1   | SIGHUP  |      挂起进程       |\n|  2   | SIGINT  |      终止进程       |\n|  3   | SIGQUIT |      停止进程       |\n|  9   | SIGKILL |     无条件终止进程     |\n|  15  | SIGTERM |     尽可能终止进程     |\n|  17  | SIGSTOP | 无条件停止进程，但不是终止进程 |\n|  18  | SIGTSTP | 停止或暂停进程，但不是终止进程 |\n|  19  | SIGCONT |    继续运行停止的进程    |\n\n\n\n默认情况下，bash shell会忽略收到的任何`SIGQUIT`和`SIGTERM`信号（所以交互式shell不会被终止）。但是bash shell会处理收到的`SIGHUP`和`SIGINT`信号。\n\nShell会将这些信号传给shell脚本程序来处理。而shell脚本默认是忽略这些信号的，为了避免它，我们可以在脚本中加入识别信号的代码，并执行命令来处理信号。\n\n\n\n### 生成信号\n\n键盘上的组合可以生成两种基本的Linux信号。它在停止或暂停失控程序时非常有用。\n\n1. 中断程序： 使用`Ctrl`+`C`，它会发送`SIGINT`信号。\n\n   ~~（测试没起作用，尴尬了～）~~\n\n2. 暂停进程：使用`Ctrl`+`Z`，它会发送`SIGTSTP`信号。\n\n   ```shell\n   wsx@wsx-ubuntu:~$ sleep 1000\n   ^Z\n   [2]+  已停止               sleep 1000\n\n   ```\n\n**注意**：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。\n\n方括号中的数字是shell自动为程序分配的*作业号*。shell将shell中运行的每个进程成为*作业*，并为其分配唯一的作业号。\n\n退出shell时发现有停止的进程，用`ps`命令查看\n\n```shell\nwsx@wsx-ubuntu:~$ exit\nexit\n有停止的任务。\nwsx@wsx-ubuntu:~$ ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n0 S  1000  5438  5433  0  80   0 -  6153 wait   pts/4    00:00:00 bash\n0 T  1000  5452  5438  0  80   0 -  2258 signal pts/4    00:00:00 sleep\n0 T  1000  5456  5438  0  80   0 -  2258 signal pts/4    00:00:00 sleep\n4 R  1000  5525  5438  0  80   0 -  7665 -      pts/4    00:00:00 ps\n\n```\n\n在表示进程状态的S列中，`ps`命令将已经停止作业的状态显示为`T`。这说明命令要么被跟踪，要么被停止了。\n\n如果你仍想退出shell，只需要再输入一遍`exit`。也可以用`kill`生成`SIGKILL`信号标识上`PID`杀死进程。\n\n```shell\nwsx@wsx-ubuntu:~$ kill 5456\nwsx@wsx-ubuntu:~$ kill -9 5456\nwsx@wsx-ubuntu:~$ kill -9 5452\n[1]-  已杀死               sleep 1000\n[2]+  已杀死               sleep 1000\n```\n\n\n\n### 捕获信号\n\n`trap`命令允许我们来指定shell脚本要监看并从shell中拦截的Linux信号。\n\n格式为：\n\n```shell\ntrap commands signals\n```\n\n下面展示一个简单的例子，看如何使用`trap`命令忽略`SIGINT`信号，并控制脚本的行为。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test1.sh\n#!/bin/bash\n# Testing signal trapping\n#\ntrap \"echo ' Sorry! I have trapped Ctrl-C'\" SIGINT\n#\necho This is a test script\n#\ncount=1\nwhile [ $count -le 10 ]\ndo\n    echo \"Loop #$count\"\n    sleep 1\n    count=$[ $count + 1 ]\ndone\n#\necho \"This is the end of the test script\"\n#\n```\n\n来运行测试一下：\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test1.sh\nThis is a test script\nLoop #1\nLoop #2\nLoop #3\nLoop #4\nLoop #5\nLoop #6\n^C Sorry! I have trapped Ctrl-C\nLoop #7\nLoop #8\nLoop #9\nLoop #10\nThis is the end of the test script\n```\n\n\n\n### 捕获信号\n\n我们也可以在shell脚本退出时进行捕获。这是**在shell完成任务时执行命令的一种简便方法**。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test2.sh\n#!/bin/bash\n# Trapping the script exit\n#\ntrap \"echo Goodbye...\" EXIT\n#\ncount=1\nwhile [ $count -le 5 ]\ndo\n    echo \"Loop #$count\"\n    sleep 1\n    count=$[ $count + 1 ]\ndone\n#\n\nwangsx@SC-201708020022:~/tmp$ ./test2.sh\nLoop #1\nLoop #2\nLoop #3\nLoop #4\nLoop #5\nGoodbye...\n```\n\n当该脚本运行到退出位置，捕获就触发了，shell会执行在`trap`命令行指定的命令。就算提取退出，也能够成功捕获。\n\n\n\n### 修改或移除捕获\n\n想在不同的位置进行不同的捕获处理，只需要重新使用带新选项的`trap`命令。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test3.sh\n#!/bin/bash\n# Modifying a set trap\n#\ntrap \"echo ' Sorry... Ctrc-C is trapped.'\" SIGINT # SIGINT是退出信号\n#\ncount=1\nwhile [ $count -le 5 ]  # 当count<5的时候\ndo\n    echo \"Loop #$count\"\n    sleep 1    # 睡1秒\n    count=$[ $count + 1 ]\ndone\n\n#\ntrap \"echo ' I modified the trap!'\" SIGINT\n#\ncount=1\nwhile [ $count -le 5 ]  # 当count<5的时候\ndo\n    echo \"Loop #$count\"\n    sleep 1    # 睡1秒\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~/tmp$ ./test3.sh\nLoop #1\nLoop #2\nLoop #3\n^C Sorry... Ctrc-C is trapped.\nLoop #4\nLoop #5\nLoop #1\nLoop #2\nLoop #3\n^C I modified the trap!\nLoop #4\nLoop #5\n```\n\n相当于两次不同的捕获。\n\n我们也可以删除已经设置好的捕获。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test3.sh\n#!/bin/bash\n# Modifying a set trap\n#\ntrap \"echo ' Sorry... Ctrc-C is trapped.'\" SIGINT # SIGINT是退出信号  在这里设置捕获\n#\ncount=1\nwhile [ $count -le 5 ]  # 当count<5的时候\ndo\n    echo \"Loop #$count\"\n    sleep 1    # 睡1秒\n    count=$[ $count + 1 ]\ndone\n\n#\ntrap -- SIGINT # 在这里删除捕获\necho \"I modified the trap!\"\n#\ncount=1\nwhile [ $count -le 5 ]  # 当count<5的时候\ndo\n    echo \"Loop #$count\"\n    sleep 1    # 睡1秒\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~/tmp$ ./test3.sh\nLoop #1\nLoop #2\nLoop #3\nLoop #4\nLoop #5\nI modified the trap!\nLoop #1\nLoop #2\nLoop #3\n^C\n```\n\n信号捕获被移除之后，脚本会按照原来的方式处理`SIGINT`信号。所以使用`Ctrl+C`键时，脚本运行会退出。当然，如果是在这个信号捕获移除前接受到`SIGINT`信号，那么脚本还是会捕获。（因为shell脚本运行是按步的，前面没有接收到信号捕获的移除，自然不会实现信号捕获的移除）\n\n\n\n## 以后台模式运行脚本\n\n### 后台运行脚本\n\n以后台模式运行shell脚本非常简单，只要再命令后加`&`符就可以了。\n\n```shell\nwangsx@SC-201708020022:~$ cat test4.sh\n#!/bin/bash\n# Testing running in the background\n#\ncount=1\nwhile [ $count -le 10 ]\ndo\n    sleep 1\n    count=$[ $count + 1 ]\ndone\nwangsx@SC-201708020022:~$ ./test4.sh &\n[1] 69\n```\n\n当添加`&`符号后，命令和bash shell会分离而作为一个独立的后台进行运行。并返回作业号（方括号内）和进程ID（PID），Linux系统上运行的每一个进程都必须有一个唯一的PID。\n\n当后台进程结束后，它会在终端显示出消息：\n\n```shell\n[1]   已完成               ./test4.sh\n```\n\n需要注意的是，当后台程序运行时，它仍然会使用终端显示器显示`STDOUT`和`STDERR`消息。最好是将`STDOUT`和`STDERR`进行重定向。\n\n\n\n### 运行多个后台作业\n\n我们可以在命令提示符中同时启动多个后台作用，然后用`ps`命令查看。\n\n```shell\nwangsx@SC-201708020022:~$ ./test4.sh &\n[1] 117\nwangsx@SC-201708020022:~$ ./test5.sh &\n[2] 122\nwangsx@SC-201708020022:~$ ./test6.sh &\n[3] 128\nwangsx@SC-201708020022:~$ ps\n  PID TTY          TIME CMD\n    2 tty1     00:00:00 bash\n  117 tty1     00:00:00 test4.sh\n  122 tty1     00:00:00 test5.sh\n  128 tty1     00:00:00 test6.sh\n  135 tty1     00:00:00 sleep\n  136 tty1     00:00:00 sleep\n  137 tty1     00:00:00 ps\n  138 tty1     00:00:00 sleep\n```\n\n我们特别需要注意，如果终端退出，后台程序也会随之退出。\n\n## 在非控制台下运行脚本\n\n如果我们不想出现终端退出后台程序退出的情况，可以使用`nohup`命令来实现。\n\n**`nohup`命令运行了另外一个命令来阻断所有发送给该进程的`SIGHUP`信号。这会在退出终端会话时阻止进程退出。**\n\n其格式如下：\n\n```shell\nwangsx@SC-201708020022:~$ nohup ./test4.sh  &\n[1] 156\nwangsx@SC-201708020022:~$ nohup: 忽略输入并把输出追加到'nohup.out'\n```\n\n由于`nohup`命令会解除终端与进程的关联，进程也就不再同`STDOUT`和`STDERR`联系在一起。它会自动将这两者重定向到名为`nohup.out`的文件中。\n\n\n\n## 作业控制\n\n启动、停止终止以及恢复作业统称为**作业控制**。我们可以通过这几种方式完全控制shell环境中所有的进程的运行方式。\n\n### 查看作业\n\n作业控制的**关键命令**是`jobs`命令。它允许查看shell当前正在处理的作业。\n\n```shell\nwangsx@SC-201708020022:~$ cat test10.sh\n#!/bin/bash\n# Test job control\n#\necho \"Script Process ID: $$\"\n#\ncount=1\nwhile [ $count -le 10 ]\ndo\n    echo \"Loop #$count\"\n    sleep 10\n    count=$[ $count + 1 ]\ndone\n#\necho \"End of script...\"\n#\nwangsx@SC-201708020022:~$ ./test10.sh\nScript Process ID: 27\nLoop #1\nLoop #2\n^Z^C # 我的ctrl+z好像不起作用\n```\n\n脚本用`$$`变量来显示系统分配给脚本的PID。使用Ctrl+Z组合键来停止脚本（我的在这不起作用~之前好像也是）。\n\n我们使用同样的脚本，利用`&`将另外一个作业作为后台进程启动。我们通过`jobs -l`命令查看作业的PID。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test10.sh > test10.out &\n[1] 121\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]+   121 运行中               ./test10.sh > test10.out &\n```\n\n下面看`jobs`命令的一些参数：\n\n| 参数   | 语法                       |\n| ---- | ------------------------ |\n| -l   | 列出进程的PID以及作业号            |\n| -n   | 只列出上次shell发出的通知后改变了状态的作业 |\n| -p   | 只列出作业的PID                |\n| -r   | 只列出运行中的作业                |\n| -s   | 只列出已停止的作业                |\n\n如果仔细注意的话，我们发现作业号后面有`+`号。带加号的作业会被当成默认作业。当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候只有一个带加号的作业和一个带减号的作业。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]    132 运行中               ./test10.sh > test10.out &\n[2]-   134 运行中               ./test10.sh > test10.out &\n[3]+   136 运行中               ./test10.sh > test10.out &\n```\n\n可以发现最好运行的脚本输出排在最前面。\n\n我们调用了`kill`命令向默认进程发送了一个`SIGHUP`信号，终止了该作业。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test10.sh > test10.out &\n[1] 165\nwangsx@SC-201708020022:~/tmp$ ./test10.sh > test10.out &\n[2] 167\nwangsx@SC-201708020022:~/tmp$ ./test10.sh > test10.out &\n[3] 169\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]    165 运行中               ./test10.sh > test10.out &\n[2]-   167 运行中               ./test10.sh > test10.out &\n[3]+   169 运行中               ./test10.sh > test10.out &\nwangsx@SC-201708020022:~/tmp$ kill 169\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]    165 运行中               ./test10.sh > test10.out &\n[2]-   167 运行中               ./test10.sh > test10.out &\n[3]+   169 已终止               ./test10.sh > test10.out\nwangsx@SC-201708020022:~/tmp$ jobs -l\n[1]-   165 运行中               ./test10.sh > test10.out &\n[2]+   167 运行中               ./test10.sh > test10.out &\n```\n\n### 重启停止的作业\n\n我们可以将已经停止的作业作为后台进程或者前台进程重启。前台进程会接管当前工作的终端，所以使用时需要注意。\n\n要以后台模式重启一个作业，可以用`bg`命令加上作业号（我的Window10子系统好像确实不能使用Ctrl+Z的功能，有兴趣可以自己测试一下）。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ./test10.sh\nScript Process ID: 13\nLoop #1\n^ZLoop #2\n^C\nwangsx@SC-201708020022:~/tmp$ bg\nbash: bg: 当前: 无此任务\nwangsx@SC-201708020022:~/tmp$ jobs\n```\n\n如果是默认作业，只需要使用`bg`命令。如果有多个作业，你得在`bg`命令后加上作业号。\n\n\n\n## 调整谦让度\n\n在Linux中，内核负责将CPU时间分配给系统上运行的每一个进程。**调度优先级**是内核分配给进程的CPU时间。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。\n\n调度优先级是一个整数值，从-20（最高）到+19（最低）。默认bash shell以优先级0来启动所有进程。\n\n我们可以使用`nice`命令来改变shell脚本的优先级。\n\n### nice命令\n\n要让命令以更低的优先级运行，只要用`nice`的`-n`命令行来指定新的优先级级别。\n\n```shell\nwsx@ubuntu:~/tmp$ nice -n 10 ./test10.sh > test10.out &\n[5] 18953\nwsx@ubuntu:~/tmp$ ps -p 18953 -o pid,ppid,ni,cmd\n   PID   PPID  NI CMD\n 18953  18782  10 /bin/bash ./test10.sh\n\n```\n\n如果想要提高优先级，需要使用超级用户权限。`nice`命令的`-n`选项不是必须的，只需要在破折号后面跟上优先级就行了。\n\n```shell\nwsx@ubuntu:~/tmp$ nice -10 ./test10.sh > test10.out &\n[6] 18999\n[5]   Done                    nice -n 10 ./test10.sh > test10.out\nwsx@ubuntu:~/tmp$ ps -p 18999 -o pid,ppid,ni,cmd\n   PID   PPID  NI CMD\n 18999  18782  10 /bin/bash ./test10.sh\n```\n\n### renice命令\n\n有时候我们想要改变系统上已经运行命令的优先级，这是`renice`命令可以做到的。它允许我们指定PID来改变它的优先级。\n\n```shell\nwsx@ubuntu:~/tmp$ ./test10.sh &\n[3] 19086\nwsx@ubuntu:~$ ps -p 19086 -o pid,ppid,ni,cmd\n   PID   PPID  NI CMD\n 19086  19070   0 /bin/bash ./test10.sh\nwsx@ubuntu:~$ renice -n 10 -p 19086\n19086 (process ID) old priority 0, new priority 10\nwsx@ubuntu:~$ ps -p 19086 -o pid,ppid,ni,cmd\n   PID   PPID  NI CMD\n 19086  19070  10 /bin/bash ./test10.sh\n```\n\n## 定时运行脚本\n\nLinux系统提供了多个在预定时间运行脚本的方法：`at`命令和`cron`表。\n\n### 用at命令来计划执行任务\n\n`at`命令允许指定Linux系统何时运行脚本。`at`命令会将作业提交到队列中，指定shell何时运行该作业。`at`的守护进程`atd`会以后台模式运行，检查作业队列来运行作业。\n\n`atd`守护进程会检查系统上的一个特殊目录（通常位于`/var/spool/at`）来获取用`at`命令提交的作业。\n\n#### at命令的格式\n\n```shell\nat [-f filename] time\n```\n\n默认，`at`命令会将`STDIN`的输入放入队列中。我们可以用`-f`参数来指定用于读取命令的文件名。`time`参数指定了Linux系统何时运行该脚本。\n\n`at`命令能识别多种不同的时间格式。\n\n- 标准的小时和分钟格式，比如10:15\n- AM/PM指示符，比如10:15 PM\n- 特定可命令的时间，比如now, noon, midnight或teatime （4 PM）\n\n除了指定运行时间，还可以指定运行的日期。\n\n- 标准日期格式，比如MMDDYY, MM/DD/YY或DD.MM.YY\n- 文本日期，比如Jul 4或Dec 25，加不加年份都可以\n- 还可以指定时间增量\n  - 当前时间+25min\n  - 明天10:15PM\n  - 10:15+7天\n\n针对不同的优先级，存在26种不同的作业队列。作业队列通常用小写字母a-z和大写字母A-Z来指代。\n\n作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。可以用`-q`参数指定不同的队列字母。\n\n#### 获取作业的输出\n\nLinux系统会将提交作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给用户。\n\n```shell\n# 解决atd没启动的问题\nwangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start\n```\n\n\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test13.sh\n#!/bin/bash\n# Test using at command\n#\necho \"This script ran at $(date +%B%d,%T)\"\necho\nsleep 5\necho \"This is the script's end...\"\n#\nwangsx@SC-201708020022:~/tmp$ at -f test13.sh now\nwarning: commands will be executed using /bin/sh\njob 4 at Tue Sep 26 12:12:00 2017\n```\n\n`at`命令会显示分配给作业的作业号以及为作业安排的运行时间。`at`命令利用`sendmail`应用程序来发送邮件。如果没有安装这个工具就无法获得输出，因此在使用`at`命令时，最好在脚本中对STDOUT和STDERR进行重定向。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ cat test13b.sh\n#!/bin/bash\n# Test using at command\n#\necho \"This script ran at $(date +%B%d,%T)\" > test13b.out\necho >> test13b.out\nsleep 5\necho \"This is the script's end...\" >> test13b.out\n#\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh now\nwarning: commands will be executed using /bin/sh\njob 7 at Tue Sep 26 12:16:00 2017\nwangsx@SC-201708020022:~/tmp$ cat test13b.out\nThis script ran at 九月26,12:16:24\n\nThis is the script's end...\n```\n\n这里使用了`-M`选项来屏蔽作业产生的输出信息。\n\n#### 列出等待的作业\n\n`atq`命令可以查看系统中有哪些作业再等待。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime\nwarning: commands will be executed using /bin/sh\njob 11 at Wed Sep 27 16:00:00 2017\nCan't open /var/run/atd.pid to signal atd. No atd running?\nwangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start\n[sudo] wangsx 的密码：\n * Starting deferred execution scheduler atd                                                                     [ OK ]\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime\nwarning: commands will be executed using /bin/sh\njob 12 at Wed Sep 27 16:00:00 2017\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh tomorrow\nwarning: commands will be executed using /bin/sh\njob 13 at Wed Sep 27 21:44:00 2017\nwangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh 13:30\nwarning: commands will be executed using /bin/sh\njob 14 at Wed Sep 27 13:30:00 2017\nwangsx@SC-201708020022:~/tmp$ atq\n11      Wed Sep 27 16:00:00 2017 a wangsx\n12      Wed Sep 27 16:00:00 2017 a wangsx\n13      Wed Sep 27 21:44:00 2017 a wangsx\n14      Wed Sep 27 13:30:00 2017 a wangsx\n```\n\n作业列表中显示了作业号、系统运行该作业的日期和时间以及它所在的队列位置。\n\n#### 删除作业\n\n使用`atrm`命令删除等待中的作业。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ atq\n11      Wed Sep 27 16:00:00 2017 a wangsx\n12      Wed Sep 27 16:00:00 2017 a wangsx\n13      Wed Sep 27 21:44:00 2017 a wangsx\n14      Wed Sep 27 13:30:00 2017 a wangsx\nwangsx@SC-201708020022:~/tmp$ atrm 11\nwangsx@SC-201708020022:~/tmp$ atq\n12      Wed Sep 27 16:00:00 2017 a wangsx\n13      Wed Sep 27 21:44:00 2017 a wangsx\n14      Wed Sep 27 13:30:00 2017 a wangsx\n```\n\n只能删除自己提交的作业，不能删除其他人的。\n\n\n\n### 安排需要定期执行的脚本\n\n如果是需要定期执行的脚本，我们不需要使用`at`不断提交作业，而是可以利用Linux系统的另一个功能。\n\n**Linux系统使用`cron`程序来安排要定期执行的作业。它会在后台运行并检查一个特殊的表（成为cron时间表），以获得已安排执行的作业。**\n\n#### cron时间表\n\n`cron`时间表的格式如下：\n\n```shell\nmin hour dayofmonth month dayofweek command\n```\n\n`cron`时间表允许我们用特定值、取值范围（比如1-5）或者通配符（星号）来指定条目。\n\n例如，我们想在每天的10:15运行一个命令，可以使用：\n\n```shell\n15 10 * * * command\n```\n\n在其中三个字段使用了通配符，表明`cron`会在每个月的每天的10:15执行该命令。\n\n要指定在每周一4:15PM运行命令，可以使用：\n\n```shell\n15 16 * * 1 command\n```\n\n可以用三字符的文本值mon,tue,wed,thu,fri,sat,sum或数值（0为周日，6为周六）来指定dayofweek的表项。\n\n`dayofmonth`可以用1-31表示。\n\n```shell\n# 怎么在每个月的最后一天执行命令？\n00 12 * * * if [`date +%d -d tomorrow` = 01 ]; then ; command\n```\n\n命令列表必须指定要运行的命令或脚本的全路径名。\n\n```shell\n# 例如\n15 10 * * * /home/rich/test4.sh > test4out\n```\n\n注意：`corn`会用提交作业的用户账户运行脚本，所以我们在操作指定文件时必须有相应权限。\n\n#### 构建cron时间表\n\nLinux提供了`crontab`命令来处理`cron`时间表。我们可以使用`-l`选项列出时间表。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ crontab -l\nno crontab for wangsx\n```\n\n要添加条目，使用`-e`选项。在添加条目时，`crontab`命令会启动一个文本编辑器，使用已有的`cron`时间表作为文件内容。\n\n#### 浏览cron目录\n\n如果对时间精确性要求不高，用预配置的`cron`脚本目录会更方便。有4个基本目录：hourly, daily, monthly和weekly。\n\n```shell\nwangsx@SC-201708020022:~/tmp$ ls /etc/cron.*ly\n/etc/cron.daily:\napport      bsdmainutils  man-db   passwd                  upstart\napt-compat  dpkg          mdadm    popularity-contest\naptitude    logrotate     mlocate  update-notifier-common\n\n/etc/cron.hourly:\n\n/etc/cron.monthly:\n\n/etc/cron.weekly:\nfstrim  man-db  update-notifier-common\n```\n\n如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron每天会执行它。\n\n#### anacron程序\n\n如果提交的作业需要运行时系统处于关机状态，`cron`不会运行那些错过的脚本。为了解决这个问题，`anacron`程序诞生了。\n\n如果`anacron`知道某个作业错过了执行时间，它会尽快运行该作业。这个功能常用于进行常规日志维护的脚本。\n\n`anacron`程序只会处理位于`cron`目录下的程序，比如`/etc/cron.monthly`。它使用时间戳来决定作业是否在正确的计划间隔内运行了，每个`cron`目录都有个时间戳文件，该文件位于`/var/spool/anacron`。\n\n`anacron`程序使用自己的时间表来检查作业目录。\n\n```shell\nwsx@ubuntu:~$ sudo cat /var/spool/anacron/cron.monthly\n[sudo] password for wsx:\n20170926\nwsx@ubuntu:~$ sudo cat /etc/anacrontab\n# /etc/anacrontab: configuration file for anacron\n\n# See anacron(8) and anacrontab(5) for details.\n\nSHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\nHOME=/root\nLOGNAME=root\n\n# These replace cron's entries\n1       5       cron.daily      run-parts --report /etc/cron.daily\n7       10      cron.weekly     run-parts --report /etc/cron.weekly\n@monthly        15      cron.monthly    run-parts --report /etc/cron.monthly\n\n```\n\n`anacron`的时间表的基本格式和`cron`时间表略有不同：\n\n```shell\nperiod delay identifier command\n```\n\n`period`定义了作业多久运行一次，以天为单位。`anacron`用此条目来检查作业的时间戳文件。`delay`条目会指定系统启动后`anacron`程序需要等待多少分钟再开始运行错过的脚本。`command`条目包含了`run-parts`程序和一个`cron`脚本目录名。`run-parts`程序负责运行目录中传给它的任何脚本。\n\n注意了，`anacron`不会处理执行时间需求小于一天的脚本，所以它是不会运行`/etc/cron.hourly`的脚本。\n\n`identifier`条目是一种特别的非空字符串，如`cron-weekly`。它用于唯一标识日志消息和错误邮件中的作业。\n","slug":"control_shell","published":1,"updated":"2018-01-27T04:08:26.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwuz000p9taxwckty66v","content":"<blockquote>\n<p><strong>内容</strong></p>\n<ul>\n<li>处理信号</li>\n<li>以后台模式运行脚本</li>\n<li>禁止挂起</li>\n<li>作业控制</li>\n<li>修改脚本优先级</li>\n<li>脚本执行自动化</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>除了在命令行界面世界运行脚本，还存在一些方法：<strong>向脚本发送信号、修改脚本的优先级以及在脚本运行时切换到运行模式</strong>。</p>\n<p>下面逐一讲述。</p>\n<h2 id=\"处理信号\"><a href=\"#处理信号\" class=\"headerlink\" title=\"处理信号\"></a>处理信号</h2><p>Linux利用信号与运行在系统中的进程进行通信。我们可以通过对脚本编程，使其在收到特定信号时执行某些命令，从而实现对脚本运行的控制。</p>\n<h3 id=\"Linux信号\"><a href=\"#Linux信号\" class=\"headerlink\" title=\"Linux信号\"></a>Linux信号</h3><p>Linux和应用程序可以生成超过30个信号。下面列出最常见的系统信号。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">信号</th>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">SIGHUP</td>\n<td style=\"text-align:center\">挂起进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">SIGINT</td>\n<td style=\"text-align:center\">终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">SIGQUIT</td>\n<td style=\"text-align:center\">停止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">SIGKILL</td>\n<td style=\"text-align:center\">无条件终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">SIGTERM</td>\n<td style=\"text-align:center\">尽可能终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">SIGSTOP</td>\n<td style=\"text-align:center\">无条件停止进程，但不是终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">SIGTSTP</td>\n<td style=\"text-align:center\">停止或暂停进程，但不是终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">SIGCONT</td>\n<td style=\"text-align:center\">继续运行停止的进程</td>\n</tr>\n</tbody>\n</table>\n<p>默认情况下，bash shell会忽略收到的任何<code>SIGQUIT</code>和<code>SIGTERM</code>信号（所以交互式shell不会被终止）。但是bash shell会处理收到的<code>SIGHUP</code>和<code>SIGINT</code>信号。</p>\n<p>Shell会将这些信号传给shell脚本程序来处理。而shell脚本默认是忽略这些信号的，为了避免它，我们可以在脚本中加入识别信号的代码，并执行命令来处理信号。</p>\n<h3 id=\"生成信号\"><a href=\"#生成信号\" class=\"headerlink\" title=\"生成信号\"></a>生成信号</h3><p>键盘上的组合可以生成两种基本的Linux信号。它在停止或暂停失控程序时非常有用。</p>\n<ol>\n<li><p>中断程序： 使用<code>Ctrl</code>+<code>C</code>，它会发送<code>SIGINT</code>信号。</p>\n<p><del>（测试没起作用，尴尬了～）</del></p>\n</li>\n<li><p>暂停进程：使用<code>Ctrl</code>+<code>Z</code>，它会发送<code>SIGTSTP</code>信号。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sleep 1000</span><br><span class=\"line\">^Z</span><br><span class=\"line\">[2]+  已停止               sleep 1000</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>注意</strong>：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。</p>\n<p>方括号中的数字是shell自动为程序分配的<em>作业号</em>。shell将shell中运行的每个进程成为<em>作业</em>，并为其分配唯一的作业号。</p>\n<p>退出shell时发现有停止的进程，用<code>ps</code>命令查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">有停止的任务。</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">0 S  1000  5438  5433  0  80   0 -  6153 wait   pts/4    00:00:00 bash</span><br><span class=\"line\">0 T  1000  5452  5438  0  80   0 -  2258 signal pts/4    00:00:00 sleep</span><br><span class=\"line\">0 T  1000  5456  5438  0  80   0 -  2258 signal pts/4    00:00:00 sleep</span><br><span class=\"line\">4 R  1000  5525  5438  0  80   0 -  7665 -      pts/4    00:00:00 ps</span><br></pre></td></tr></table></figure>\n<p>在表示进程状态的S列中，<code>ps</code>命令将已经停止作业的状态显示为<code>T</code>。这说明命令要么被跟踪，要么被停止了。</p>\n<p>如果你仍想退出shell，只需要再输入一遍<code>exit</code>。也可以用<code>kill</code>生成<code>SIGKILL</code>信号标识上<code>PID</code>杀死进程。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ kill 5456</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ kill -9 5456</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ kill -9 5452</span><br><span class=\"line\">[1]-  已杀死               sleep 1000</span><br><span class=\"line\">[2]+  已杀死               sleep 1000</span><br></pre></td></tr></table></figure>\n<h3 id=\"捕获信号\"><a href=\"#捕获信号\" class=\"headerlink\" title=\"捕获信号\"></a>捕获信号</h3><p><code>trap</code>命令允许我们来指定shell脚本要监看并从shell中拦截的Linux信号。</p>\n<p>格式为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trap commands signals</span><br></pre></td></tr></table></figure>\n<p>下面展示一个简单的例子，看如何使用<code>trap</code>命令忽略<code>SIGINT</code>信号，并控制脚本的行为。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test1.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing signal trapping</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo ' Sorry! I have trapped Ctrl-C'\" SIGINT</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo This is a test script</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 10 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"This is the end of the test script\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n<p>来运行测试一下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test1.sh</span><br><span class=\"line\">This is a test script</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br><span class=\"line\">Loop #6</span><br><span class=\"line\">^C Sorry! I have trapped Ctrl-C</span><br><span class=\"line\">Loop #7</span><br><span class=\"line\">Loop #8</span><br><span class=\"line\">Loop #9</span><br><span class=\"line\">Loop #10</span><br><span class=\"line\">This is the end of the test script</span><br></pre></td></tr></table></figure>\n<h3 id=\"捕获信号-1\"><a href=\"#捕获信号-1\" class=\"headerlink\" title=\"捕获信号\"></a>捕获信号</h3><p>我们也可以在shell脚本退出时进行捕获。这是<strong>在shell完成任务时执行命令的一种简便方法</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test2.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Trapping the script <span class=\"built_in\">exit</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo Goodbye...\" EXIT</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test2.sh</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br><span class=\"line\">Goodbye...</span><br></pre></td></tr></table></figure>\n<p>当该脚本运行到退出位置，捕获就触发了，shell会执行在<code>trap</code>命令行指定的命令。就算提取退出，也能够成功捕获。</p>\n<h3 id=\"修改或移除捕获\"><a href=\"#修改或移除捕获\" class=\"headerlink\" title=\"修改或移除捕获\"></a>修改或移除捕获</h3><p>想在不同的位置进行不同的捕获处理，只需要重新使用带新选项的<code>trap</code>命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test3.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Modifying a <span class=\"built_in\">set</span> <span class=\"built_in\">trap</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo ' Sorry... Ctrc-C is trapped.'\" SIGINT # SIGINT是退出信号</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]  # 当count&lt;5的时候</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1    # 睡1秒</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo ' I modified the trap!'\" SIGINT</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]  # 当count&lt;5的时候</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1    # 睡1秒</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test3.sh</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">^C Sorry... Ctrc-C is trapped.</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">^C I modified the trap!</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br></pre></td></tr></table></figure>\n<p>相当于两次不同的捕获。</p>\n<p>我们也可以删除已经设置好的捕获。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test3.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Modifying a <span class=\"built_in\">set</span> <span class=\"built_in\">trap</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo ' Sorry... Ctrc-C is trapped.'\" SIGINT # SIGINT是退出信号  在这里设置捕获</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]  # 当count&lt;5的时候</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1    # 睡1秒</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap -- SIGINT # 在这里删除捕获</span><br><span class=\"line\">echo \"I modified the trap!\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]  # 当count&lt;5的时候</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1    # 睡1秒</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test3.sh</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br><span class=\"line\">I modified the trap!</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">^C</span><br></pre></td></tr></table></figure>\n<p>信号捕获被移除之后，脚本会按照原来的方式处理<code>SIGINT</code>信号。所以使用<code>Ctrl+C</code>键时，脚本运行会退出。当然，如果是在这个信号捕获移除前接受到<code>SIGINT</code>信号，那么脚本还是会捕获。（因为shell脚本运行是按步的，前面没有接收到信号捕获的移除，自然不会实现信号捕获的移除）</p>\n<h2 id=\"以后台模式运行脚本\"><a href=\"#以后台模式运行脚本\" class=\"headerlink\" title=\"以后台模式运行脚本\"></a>以后台模式运行脚本</h2><h3 id=\"后台运行脚本\"><a href=\"#后台运行脚本\" class=\"headerlink\" title=\"后台运行脚本\"></a>后台运行脚本</h3><p>以后台模式运行shell脚本非常简单，只要再命令后加<code>&amp;</code>符就可以了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test4.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing running <span class=\"keyword\">in</span> the background</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 10 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    sleep 1</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~$ ./test4.sh &amp;</span><br><span class=\"line\">[1] 69</span><br></pre></td></tr></table></figure>\n<p>当添加<code>&amp;</code>符号后，命令和bash shell会分离而作为一个独立的后台进行运行。并返回作业号（方括号内）和进程ID（PID），Linux系统上运行的每一个进程都必须有一个唯一的PID。</p>\n<p>当后台进程结束后，它会在终端显示出消息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1]   已完成               ./test4.sh</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，当后台程序运行时，它仍然会使用终端显示器显示<code>STDOUT</code>和<code>STDERR</code>消息。最好是将<code>STDOUT</code>和<code>STDERR</code>进行重定向。</p>\n<h3 id=\"运行多个后台作业\"><a href=\"#运行多个后台作业\" class=\"headerlink\" title=\"运行多个后台作业\"></a>运行多个后台作业</h3><p>我们可以在命令提示符中同时启动多个后台作用，然后用<code>ps</code>命令查看。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ./test4.sh &amp;</span><br><span class=\"line\">[1] 117</span><br><span class=\"line\">wangsx@SC-201708020022:~$ ./test5.sh &amp;</span><br><span class=\"line\">[2] 122</span><br><span class=\"line\">wangsx@SC-201708020022:~$ ./test6.sh &amp;</span><br><span class=\"line\">[3] 128</span><br><span class=\"line\">wangsx@SC-201708020022:~$ ps</span><br><span class=\"line\">  PID TTY          TIME CMD</span><br><span class=\"line\">    2 tty1     00:00:00 bash</span><br><span class=\"line\">  117 tty1     00:00:00 test4.sh</span><br><span class=\"line\">  122 tty1     00:00:00 test5.sh</span><br><span class=\"line\">  128 tty1     00:00:00 test6.sh</span><br><span class=\"line\">  135 tty1     00:00:00 sleep</span><br><span class=\"line\">  136 tty1     00:00:00 sleep</span><br><span class=\"line\">  137 tty1     00:00:00 ps</span><br><span class=\"line\">  138 tty1     00:00:00 sleep</span><br></pre></td></tr></table></figure>\n<p>我们特别需要注意，如果终端退出，后台程序也会随之退出。</p>\n<h2 id=\"在非控制台下运行脚本\"><a href=\"#在非控制台下运行脚本\" class=\"headerlink\" title=\"在非控制台下运行脚本\"></a>在非控制台下运行脚本</h2><p>如果我们不想出现终端退出后台程序退出的情况，可以使用<code>nohup</code>命令来实现。</p>\n<p><strong><code>nohup</code>命令运行了另外一个命令来阻断所有发送给该进程的<code>SIGHUP</code>信号。这会在退出终端会话时阻止进程退出。</strong></p>\n<p>其格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ nohup ./test4.sh  &amp;</span><br><span class=\"line\">[1] 156</span><br><span class=\"line\">wangsx@SC-201708020022:~$ nohup: 忽略输入并把输出追加到'nohup.out'</span><br></pre></td></tr></table></figure>\n<p>由于<code>nohup</code>命令会解除终端与进程的关联，进程也就不再同<code>STDOUT</code>和<code>STDERR</code>联系在一起。它会自动将这两者重定向到名为<code>nohup.out</code>的文件中。</p>\n<h2 id=\"作业控制\"><a href=\"#作业控制\" class=\"headerlink\" title=\"作业控制\"></a>作业控制</h2><p>启动、停止终止以及恢复作业统称为<strong>作业控制</strong>。我们可以通过这几种方式完全控制shell环境中所有的进程的运行方式。</p>\n<h3 id=\"查看作业\"><a href=\"#查看作业\" class=\"headerlink\" title=\"查看作业\"></a>查看作业</h3><p>作业控制的<strong>关键命令</strong>是<code>jobs</code>命令。它允许查看shell当前正在处理的作业。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test10.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Test job control</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"Script Process ID: $$\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 10 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 10</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"End of script...\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">wangsx@SC-201708020022:~$ ./test10.sh</span><br><span class=\"line\">Script Process ID: 27</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">^Z^C # 我的ctrl+z好像不起作用</span><br></pre></td></tr></table></figure>\n<p>脚本用<code>$$</code>变量来显示系统分配给脚本的PID。使用Ctrl+Z组合键来停止脚本（我的在这不起作用~之前好像也是）。</p>\n<p>我们使用同样的脚本，利用<code>&amp;</code>将另外一个作业作为后台进程启动。我们通过<code>jobs -l</code>命令查看作业的PID。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[1] 121</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]+   121 运行中               ./test10.sh &gt; test10.out &amp;</span><br></pre></td></tr></table></figure>\n<p>下面看<code>jobs</code>命令的一些参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>语法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-l</td>\n<td>列出进程的PID以及作业号</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>只列出上次shell发出的通知后改变了状态的作业</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>只列出作业的PID</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>只列出运行中的作业</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>只列出已停止的作业</td>\n</tr>\n</tbody>\n</table>\n<p>如果仔细注意的话，我们发现作业号后面有<code>+</code>号。带加号的作业会被当成默认作业。当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候只有一个带加号的作业和一个带减号的作业。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]    132 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2]-   134 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[3]+   136 运行中               ./test10.sh &gt; test10.out &amp;</span><br></pre></td></tr></table></figure>\n<p>可以发现最好运行的脚本输出排在最前面。</p>\n<p>我们调用了<code>kill</code>命令向默认进程发送了一个<code>SIGHUP</code>信号，终止了该作业。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[1] 165</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2] 167</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[3] 169</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]    165 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2]-   167 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[3]+   169 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ kill 169</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]    165 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2]-   167 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[3]+   169 已终止               ./test10.sh &gt; test10.out</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]-   165 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2]+   167 运行中               ./test10.sh &gt; test10.out &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重启停止的作业\"><a href=\"#重启停止的作业\" class=\"headerlink\" title=\"重启停止的作业\"></a>重启停止的作业</h3><p>我们可以将已经停止的作业作为后台进程或者前台进程重启。前台进程会接管当前工作的终端，所以使用时需要注意。</p>\n<p>要以后台模式重启一个作业，可以用<code>bg</code>命令加上作业号（我的Window10子系统好像确实不能使用Ctrl+Z的功能，有兴趣可以自己测试一下）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh</span><br><span class=\"line\">Script Process ID: 13</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">^ZLoop #2</span><br><span class=\"line\">^C</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ bg</span><br><span class=\"line\">bash: bg: 当前: 无此任务</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs</span><br></pre></td></tr></table></figure>\n<p>如果是默认作业，只需要使用<code>bg</code>命令。如果有多个作业，你得在<code>bg</code>命令后加上作业号。</p>\n<h2 id=\"调整谦让度\"><a href=\"#调整谦让度\" class=\"headerlink\" title=\"调整谦让度\"></a>调整谦让度</h2><p>在Linux中，内核负责将CPU时间分配给系统上运行的每一个进程。<strong>调度优先级</strong>是内核分配给进程的CPU时间。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。</p>\n<p>调度优先级是一个整数值，从-20（最高）到+19（最低）。默认bash shell以优先级0来启动所有进程。</p>\n<p>我们可以使用<code>nice</code>命令来改变shell脚本的优先级。</p>\n<h3 id=\"nice命令\"><a href=\"#nice命令\" class=\"headerlink\" title=\"nice命令\"></a>nice命令</h3><p>要让命令以更低的优先级运行，只要用<code>nice</code>的<code>-n</code>命令行来指定新的优先级级别。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@ubuntu:~/tmp$ nice -n 10 ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[5] 18953</span><br><span class=\"line\">wsx@ubuntu:~/tmp$ ps -p 18953 -o pid,ppid,ni,cmd</span><br><span class=\"line\">   PID   PPID  NI CMD</span><br><span class=\"line\"> 18953  18782  10 /bin/bash ./test10.sh</span><br></pre></td></tr></table></figure>\n<p>如果想要提高优先级，需要使用超级用户权限。<code>nice</code>命令的<code>-n</code>选项不是必须的，只需要在破折号后面跟上优先级就行了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@ubuntu:~/tmp$ nice -10 ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[6] 18999</span><br><span class=\"line\">[5]   Done                    nice -n 10 ./test10.sh &gt; test10.out</span><br><span class=\"line\">wsx@ubuntu:~/tmp$ ps -p 18999 -o pid,ppid,ni,cmd</span><br><span class=\"line\">   PID   PPID  NI CMD</span><br><span class=\"line\"> 18999  18782  10 /bin/bash ./test10.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"renice命令\"><a href=\"#renice命令\" class=\"headerlink\" title=\"renice命令\"></a>renice命令</h3><p>有时候我们想要改变系统上已经运行命令的优先级，这是<code>renice</code>命令可以做到的。它允许我们指定PID来改变它的优先级。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@ubuntu:~/tmp$ ./test10.sh &amp;</span><br><span class=\"line\">[3] 19086</span><br><span class=\"line\">wsx@ubuntu:~$ ps -p 19086 -o pid,ppid,ni,cmd</span><br><span class=\"line\">   PID   PPID  NI CMD</span><br><span class=\"line\"> 19086  19070   0 /bin/bash ./test10.sh</span><br><span class=\"line\">wsx@ubuntu:~$ renice -n 10 -p 19086</span><br><span class=\"line\">19086 (process ID) old priority 0, new priority 10</span><br><span class=\"line\">wsx@ubuntu:~$ ps -p 19086 -o pid,ppid,ni,cmd</span><br><span class=\"line\">   PID   PPID  NI CMD</span><br><span class=\"line\"> 19086  19070  10 /bin/bash ./test10.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"定时运行脚本\"><a href=\"#定时运行脚本\" class=\"headerlink\" title=\"定时运行脚本\"></a>定时运行脚本</h2><p>Linux系统提供了多个在预定时间运行脚本的方法：<code>at</code>命令和<code>cron</code>表。</p>\n<h3 id=\"用at命令来计划执行任务\"><a href=\"#用at命令来计划执行任务\" class=\"headerlink\" title=\"用at命令来计划执行任务\"></a>用at命令来计划执行任务</h3><p><code>at</code>命令允许指定Linux系统何时运行脚本。<code>at</code>命令会将作业提交到队列中，指定shell何时运行该作业。<code>at</code>的守护进程<code>atd</code>会以后台模式运行，检查作业队列来运行作业。</p>\n<p><code>atd</code>守护进程会检查系统上的一个特殊目录（通常位于<code>/var/spool/at</code>）来获取用<code>at</code>命令提交的作业。</p>\n<h4 id=\"at命令的格式\"><a href=\"#at命令的格式\" class=\"headerlink\" title=\"at命令的格式\"></a>at命令的格式</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at [-f filename] time</span><br></pre></td></tr></table></figure>\n<p>默认，<code>at</code>命令会将<code>STDIN</code>的输入放入队列中。我们可以用<code>-f</code>参数来指定用于读取命令的文件名。<code>time</code>参数指定了Linux系统何时运行该脚本。</p>\n<p><code>at</code>命令能识别多种不同的时间格式。</p>\n<ul>\n<li>标准的小时和分钟格式，比如10:15</li>\n<li>AM/PM指示符，比如10:15 PM</li>\n<li>特定可命令的时间，比如now, noon, midnight或teatime （4 PM）</li>\n</ul>\n<p>除了指定运行时间，还可以指定运行的日期。</p>\n<ul>\n<li>标准日期格式，比如MMDDYY, MM/DD/YY或DD.MM.YY</li>\n<li>文本日期，比如Jul 4或Dec 25，加不加年份都可以</li>\n<li>还可以指定时间增量<ul>\n<li>当前时间+25min</li>\n<li>明天10:15PM</li>\n<li>10:15+7天</li>\n</ul>\n</li>\n</ul>\n<p>针对不同的优先级，存在26种不同的作业队列。作业队列通常用小写字母a-z和大写字母A-Z来指代。</p>\n<p>作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。可以用<code>-q</code>参数指定不同的队列字母。</p>\n<h4 id=\"获取作业的输出\"><a href=\"#获取作业的输出\" class=\"headerlink\" title=\"获取作业的输出\"></a>获取作业的输出</h4><p>Linux系统会将提交作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给用户。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 解决atd没启动的问题</span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test13.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Test using at <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"This script ran at $(date +%B%d,%T)\"</span><br><span class=\"line\">echo</span><br><span class=\"line\">sleep 5</span><br><span class=\"line\">echo \"This is the script's end...\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -f test13.sh now</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 4 at Tue Sep 26 12:12:00 2017</span><br></pre></td></tr></table></figure>\n<p><code>at</code>命令会显示分配给作业的作业号以及为作业安排的运行时间。<code>at</code>命令利用<code>sendmail</code>应用程序来发送邮件。如果没有安装这个工具就无法获得输出，因此在使用<code>at</code>命令时，最好在脚本中对STDOUT和STDERR进行重定向。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test13b.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Test using at <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"This script ran at $(date +%B%d,%T)\" &gt; test13b.out</span><br><span class=\"line\">echo &gt;&gt; test13b.out</span><br><span class=\"line\">sleep 5</span><br><span class=\"line\">echo \"This is the script's end...\" &gt;&gt; test13b.out</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh now</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 7 at Tue Sep 26 12:16:00 2017</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test13b.out</span><br><span class=\"line\">This script ran at 九月26,12:16:24</span><br><span class=\"line\"></span><br><span class=\"line\">This is the script's end...</span><br></pre></td></tr></table></figure>\n<p>这里使用了<code>-M</code>选项来屏蔽作业产生的输出信息。</p>\n<h4 id=\"列出等待的作业\"><a href=\"#列出等待的作业\" class=\"headerlink\" title=\"列出等待的作业\"></a>列出等待的作业</h4><p><code>atq</code>命令可以查看系统中有哪些作业再等待。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 11 at Wed Sep 27 16:00:00 2017</span><br><span class=\"line\">Can't open /var/run/atd.pid to signal atd. No atd running?</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start</span><br><span class=\"line\">[sudo] wangsx 的密码：</span><br><span class=\"line\"> * Starting deferred execution scheduler atd                                                                     [ OK ]</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 12 at Wed Sep 27 16:00:00 2017</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh tomorrow</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 13 at Wed Sep 27 21:44:00 2017</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh 13:30</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 14 at Wed Sep 27 13:30:00 2017</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ atq</span><br><span class=\"line\">11      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">12      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">13      Wed Sep 27 21:44:00 2017 a wangsx</span><br><span class=\"line\">14      Wed Sep 27 13:30:00 2017 a wangsx</span><br></pre></td></tr></table></figure>\n<p>作业列表中显示了作业号、系统运行该作业的日期和时间以及它所在的队列位置。</p>\n<h4 id=\"删除作业\"><a href=\"#删除作业\" class=\"headerlink\" title=\"删除作业\"></a>删除作业</h4><p>使用<code>atrm</code>命令删除等待中的作业。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ atq</span><br><span class=\"line\">11      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">12      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">13      Wed Sep 27 21:44:00 2017 a wangsx</span><br><span class=\"line\">14      Wed Sep 27 13:30:00 2017 a wangsx</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ atrm 11</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ atq</span><br><span class=\"line\">12      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">13      Wed Sep 27 21:44:00 2017 a wangsx</span><br><span class=\"line\">14      Wed Sep 27 13:30:00 2017 a wangsx</span><br></pre></td></tr></table></figure>\n<p>只能删除自己提交的作业，不能删除其他人的。</p>\n<h3 id=\"安排需要定期执行的脚本\"><a href=\"#安排需要定期执行的脚本\" class=\"headerlink\" title=\"安排需要定期执行的脚本\"></a>安排需要定期执行的脚本</h3><p>如果是需要定期执行的脚本，我们不需要使用<code>at</code>不断提交作业，而是可以利用Linux系统的另一个功能。</p>\n<p><strong>Linux系统使用<code>cron</code>程序来安排要定期执行的作业。它会在后台运行并检查一个特殊的表（成为cron时间表），以获得已安排执行的作业。</strong></p>\n<h4 id=\"cron时间表\"><a href=\"#cron时间表\" class=\"headerlink\" title=\"cron时间表\"></a>cron时间表</h4><p><code>cron</code>时间表的格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min hour dayofmonth month dayofweek command</span><br></pre></td></tr></table></figure>\n<p><code>cron</code>时间表允许我们用特定值、取值范围（比如1-5）或者通配符（星号）来指定条目。</p>\n<p>例如，我们想在每天的10:15运行一个命令，可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15 10 * * * command</span><br></pre></td></tr></table></figure>\n<p>在其中三个字段使用了通配符，表明<code>cron</code>会在每个月的每天的10:15执行该命令。</p>\n<p>要指定在每周一4:15PM运行命令，可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15 16 * * 1 command</span><br></pre></td></tr></table></figure>\n<p>可以用三字符的文本值mon,tue,wed,thu,fri,sat,sum或数值（0为周日，6为周六）来指定dayofweek的表项。</p>\n<p><code>dayofmonth</code>可以用1-31表示。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 怎么在每个月的最后一天执行命令？</span></span><br><span class=\"line\">00 12 * * * if [`date +%d -d tomorrow` = 01 ]; then ; command</span><br></pre></td></tr></table></figure>\n<p>命令列表必须指定要运行的命令或脚本的全路径名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例如</span></span><br><span class=\"line\">15 10 * * * /home/rich/test4.sh &gt; test4out</span><br></pre></td></tr></table></figure>\n<p>注意：<code>corn</code>会用提交作业的用户账户运行脚本，所以我们在操作指定文件时必须有相应权限。</p>\n<h4 id=\"构建cron时间表\"><a href=\"#构建cron时间表\" class=\"headerlink\" title=\"构建cron时间表\"></a>构建cron时间表</h4><p>Linux提供了<code>crontab</code>命令来处理<code>cron</code>时间表。我们可以使用<code>-l</code>选项列出时间表。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ crontab -l</span><br><span class=\"line\">no crontab for wangsx</span><br></pre></td></tr></table></figure>\n<p>要添加条目，使用<code>-e</code>选项。在添加条目时，<code>crontab</code>命令会启动一个文本编辑器，使用已有的<code>cron</code>时间表作为文件内容。</p>\n<h4 id=\"浏览cron目录\"><a href=\"#浏览cron目录\" class=\"headerlink\" title=\"浏览cron目录\"></a>浏览cron目录</h4><p>如果对时间精确性要求不高，用预配置的<code>cron</code>脚本目录会更方便。有4个基本目录：hourly, daily, monthly和weekly。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ls /etc/cron.*ly</span><br><span class=\"line\">/etc/cron.daily:</span><br><span class=\"line\">apport      bsdmainutils  man-db   passwd                  upstart</span><br><span class=\"line\">apt-compat  dpkg          mdadm    popularity-contest</span><br><span class=\"line\">aptitude    logrotate     mlocate  update-notifier-common</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/cron.hourly:</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/cron.monthly:</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/cron.weekly:</span><br><span class=\"line\">fstrim  man-db  update-notifier-common</span><br></pre></td></tr></table></figure>\n<p>如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron每天会执行它。</p>\n<h4 id=\"anacron程序\"><a href=\"#anacron程序\" class=\"headerlink\" title=\"anacron程序\"></a>anacron程序</h4><p>如果提交的作业需要运行时系统处于关机状态，<code>cron</code>不会运行那些错过的脚本。为了解决这个问题，<code>anacron</code>程序诞生了。</p>\n<p>如果<code>anacron</code>知道某个作业错过了执行时间，它会尽快运行该作业。这个功能常用于进行常规日志维护的脚本。</p>\n<p><code>anacron</code>程序只会处理位于<code>cron</code>目录下的程序，比如<code>/etc/cron.monthly</code>。它使用时间戳来决定作业是否在正确的计划间隔内运行了，每个<code>cron</code>目录都有个时间戳文件，该文件位于<code>/var/spool/anacron</code>。</p>\n<p><code>anacron</code>程序使用自己的时间表来检查作业目录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@ubuntu:~$ sudo cat /var/spool/anacron/cron.monthly</span><br><span class=\"line\">[sudo] password for wsx:</span><br><span class=\"line\">20170926</span><br><span class=\"line\">wsx@ubuntu:~$ sudo cat /etc/anacrontab</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> /etc/anacrontab: configuration file <span class=\"keyword\">for</span> anacron</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> See anacron(8) and anacrontab(5) <span class=\"keyword\">for</span> details.</span></span><br><span class=\"line\"></span><br><span class=\"line\">SHELL=/bin/sh</span><br><span class=\"line\">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class=\"line\">HOME=/root</span><br><span class=\"line\">LOGNAME=root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> These replace cron<span class=\"string\">'s entries</span></span></span><br><span class=\"line\">1       5       cron.daily      run-parts --report /etc/cron.daily</span><br><span class=\"line\">7       10      cron.weekly     run-parts --report /etc/cron.weekly</span><br><span class=\"line\">@monthly        15      cron.monthly    run-parts --report /etc/cron.monthly</span><br></pre></td></tr></table></figure>\n<p><code>anacron</code>的时间表的基本格式和<code>cron</code>时间表略有不同：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">period delay identifier command</span><br></pre></td></tr></table></figure>\n<p><code>period</code>定义了作业多久运行一次，以天为单位。<code>anacron</code>用此条目来检查作业的时间戳文件。<code>delay</code>条目会指定系统启动后<code>anacron</code>程序需要等待多少分钟再开始运行错过的脚本。<code>command</code>条目包含了<code>run-parts</code>程序和一个<code>cron</code>脚本目录名。<code>run-parts</code>程序负责运行目录中传给它的任何脚本。</p>\n<p>注意了，<code>anacron</code>不会处理执行时间需求小于一天的脚本，所以它是不会运行<code>/etc/cron.hourly</code>的脚本。</p>\n<p><code>identifier</code>条目是一种特别的非空字符串，如<code>cron-weekly</code>。它用于唯一标识日志消息和错误邮件中的作业。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong>内容</strong></p>\n<ul>\n<li>处理信号</li>\n<li>以后台模式运行脚本</li>\n<li>禁止挂起</li>\n<li>作业控制</li>\n<li>修改脚本优先级</li>\n<li>脚本执行自动化</li>\n</ul>\n</blockquote>","more":"<p>除了在命令行界面世界运行脚本，还存在一些方法：<strong>向脚本发送信号、修改脚本的优先级以及在脚本运行时切换到运行模式</strong>。</p>\n<p>下面逐一讲述。</p>\n<h2 id=\"处理信号\"><a href=\"#处理信号\" class=\"headerlink\" title=\"处理信号\"></a>处理信号</h2><p>Linux利用信号与运行在系统中的进程进行通信。我们可以通过对脚本编程，使其在收到特定信号时执行某些命令，从而实现对脚本运行的控制。</p>\n<h3 id=\"Linux信号\"><a href=\"#Linux信号\" class=\"headerlink\" title=\"Linux信号\"></a>Linux信号</h3><p>Linux和应用程序可以生成超过30个信号。下面列出最常见的系统信号。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">信号</th>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">SIGHUP</td>\n<td style=\"text-align:center\">挂起进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">SIGINT</td>\n<td style=\"text-align:center\">终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">SIGQUIT</td>\n<td style=\"text-align:center\">停止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">SIGKILL</td>\n<td style=\"text-align:center\">无条件终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">SIGTERM</td>\n<td style=\"text-align:center\">尽可能终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">SIGSTOP</td>\n<td style=\"text-align:center\">无条件停止进程，但不是终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">SIGTSTP</td>\n<td style=\"text-align:center\">停止或暂停进程，但不是终止进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">SIGCONT</td>\n<td style=\"text-align:center\">继续运行停止的进程</td>\n</tr>\n</tbody>\n</table>\n<p>默认情况下，bash shell会忽略收到的任何<code>SIGQUIT</code>和<code>SIGTERM</code>信号（所以交互式shell不会被终止）。但是bash shell会处理收到的<code>SIGHUP</code>和<code>SIGINT</code>信号。</p>\n<p>Shell会将这些信号传给shell脚本程序来处理。而shell脚本默认是忽略这些信号的，为了避免它，我们可以在脚本中加入识别信号的代码，并执行命令来处理信号。</p>\n<h3 id=\"生成信号\"><a href=\"#生成信号\" class=\"headerlink\" title=\"生成信号\"></a>生成信号</h3><p>键盘上的组合可以生成两种基本的Linux信号。它在停止或暂停失控程序时非常有用。</p>\n<ol>\n<li><p>中断程序： 使用<code>Ctrl</code>+<code>C</code>，它会发送<code>SIGINT</code>信号。</p>\n<p><del>（测试没起作用，尴尬了～）</del></p>\n</li>\n<li><p>暂停进程：使用<code>Ctrl</code>+<code>Z</code>，它会发送<code>SIGTSTP</code>信号。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ sleep 1000</span><br><span class=\"line\">^Z</span><br><span class=\"line\">[2]+  已停止               sleep 1000</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>注意</strong>：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。</p>\n<p>方括号中的数字是shell自动为程序分配的<em>作业号</em>。shell将shell中运行的每个进程成为<em>作业</em>，并为其分配唯一的作业号。</p>\n<p>退出shell时发现有停止的进程，用<code>ps</code>命令查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ exit</span><br><span class=\"line\">exit</span><br><span class=\"line\">有停止的任务。</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ ps -l</span><br><span class=\"line\">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class=\"line\">0 S  1000  5438  5433  0  80   0 -  6153 wait   pts/4    00:00:00 bash</span><br><span class=\"line\">0 T  1000  5452  5438  0  80   0 -  2258 signal pts/4    00:00:00 sleep</span><br><span class=\"line\">0 T  1000  5456  5438  0  80   0 -  2258 signal pts/4    00:00:00 sleep</span><br><span class=\"line\">4 R  1000  5525  5438  0  80   0 -  7665 -      pts/4    00:00:00 ps</span><br></pre></td></tr></table></figure>\n<p>在表示进程状态的S列中，<code>ps</code>命令将已经停止作业的状态显示为<code>T</code>。这说明命令要么被跟踪，要么被停止了。</p>\n<p>如果你仍想退出shell，只需要再输入一遍<code>exit</code>。也可以用<code>kill</code>生成<code>SIGKILL</code>信号标识上<code>PID</code>杀死进程。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx-ubuntu:~$ kill 5456</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ kill -9 5456</span><br><span class=\"line\">wsx@wsx-ubuntu:~$ kill -9 5452</span><br><span class=\"line\">[1]-  已杀死               sleep 1000</span><br><span class=\"line\">[2]+  已杀死               sleep 1000</span><br></pre></td></tr></table></figure>\n<h3 id=\"捕获信号\"><a href=\"#捕获信号\" class=\"headerlink\" title=\"捕获信号\"></a>捕获信号</h3><p><code>trap</code>命令允许我们来指定shell脚本要监看并从shell中拦截的Linux信号。</p>\n<p>格式为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">trap commands signals</span><br></pre></td></tr></table></figure>\n<p>下面展示一个简单的例子，看如何使用<code>trap</code>命令忽略<code>SIGINT</code>信号，并控制脚本的行为。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test1.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing signal trapping</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo ' Sorry! I have trapped Ctrl-C'\" SIGINT</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo This is a test script</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 10 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"This is the end of the test script\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br></pre></td></tr></table></figure>\n<p>来运行测试一下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test1.sh</span><br><span class=\"line\">This is a test script</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br><span class=\"line\">Loop #6</span><br><span class=\"line\">^C Sorry! I have trapped Ctrl-C</span><br><span class=\"line\">Loop #7</span><br><span class=\"line\">Loop #8</span><br><span class=\"line\">Loop #9</span><br><span class=\"line\">Loop #10</span><br><span class=\"line\">This is the end of the test script</span><br></pre></td></tr></table></figure>\n<h3 id=\"捕获信号-1\"><a href=\"#捕获信号-1\" class=\"headerlink\" title=\"捕获信号\"></a>捕获信号</h3><p>我们也可以在shell脚本退出时进行捕获。这是<strong>在shell完成任务时执行命令的一种简便方法</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test2.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Trapping the script <span class=\"built_in\">exit</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo Goodbye...\" EXIT</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\"></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test2.sh</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br><span class=\"line\">Goodbye...</span><br></pre></td></tr></table></figure>\n<p>当该脚本运行到退出位置，捕获就触发了，shell会执行在<code>trap</code>命令行指定的命令。就算提取退出，也能够成功捕获。</p>\n<h3 id=\"修改或移除捕获\"><a href=\"#修改或移除捕获\" class=\"headerlink\" title=\"修改或移除捕获\"></a>修改或移除捕获</h3><p>想在不同的位置进行不同的捕获处理，只需要重新使用带新选项的<code>trap</code>命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test3.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Modifying a <span class=\"built_in\">set</span> <span class=\"built_in\">trap</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo ' Sorry... Ctrc-C is trapped.'\" SIGINT # SIGINT是退出信号</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]  # 当count&lt;5的时候</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1    # 睡1秒</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo ' I modified the trap!'\" SIGINT</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]  # 当count&lt;5的时候</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1    # 睡1秒</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test3.sh</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">^C Sorry... Ctrc-C is trapped.</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">^C I modified the trap!</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br></pre></td></tr></table></figure>\n<p>相当于两次不同的捕获。</p>\n<p>我们也可以删除已经设置好的捕获。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test3.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Modifying a <span class=\"built_in\">set</span> <span class=\"built_in\">trap</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap \"echo ' Sorry... Ctrc-C is trapped.'\" SIGINT # SIGINT是退出信号  在这里设置捕获</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]  # 当count&lt;5的时候</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1    # 睡1秒</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">trap -- SIGINT # 在这里删除捕获</span><br><span class=\"line\">echo \"I modified the trap!\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]  # 当count&lt;5的时候</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 1    # 睡1秒</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test3.sh</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">Loop #4</span><br><span class=\"line\">Loop #5</span><br><span class=\"line\">I modified the trap!</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">Loop #3</span><br><span class=\"line\">^C</span><br></pre></td></tr></table></figure>\n<p>信号捕获被移除之后，脚本会按照原来的方式处理<code>SIGINT</code>信号。所以使用<code>Ctrl+C</code>键时，脚本运行会退出。当然，如果是在这个信号捕获移除前接受到<code>SIGINT</code>信号，那么脚本还是会捕获。（因为shell脚本运行是按步的，前面没有接收到信号捕获的移除，自然不会实现信号捕获的移除）</p>\n<h2 id=\"以后台模式运行脚本\"><a href=\"#以后台模式运行脚本\" class=\"headerlink\" title=\"以后台模式运行脚本\"></a>以后台模式运行脚本</h2><h3 id=\"后台运行脚本\"><a href=\"#后台运行脚本\" class=\"headerlink\" title=\"后台运行脚本\"></a>后台运行脚本</h3><p>以后台模式运行shell脚本非常简单，只要再命令后加<code>&amp;</code>符就可以了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test4.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Testing running <span class=\"keyword\">in</span> the background</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 10 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    sleep 1</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\">wangsx@SC-201708020022:~$ ./test4.sh &amp;</span><br><span class=\"line\">[1] 69</span><br></pre></td></tr></table></figure>\n<p>当添加<code>&amp;</code>符号后，命令和bash shell会分离而作为一个独立的后台进行运行。并返回作业号（方括号内）和进程ID（PID），Linux系统上运行的每一个进程都必须有一个唯一的PID。</p>\n<p>当后台进程结束后，它会在终端显示出消息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1]   已完成               ./test4.sh</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，当后台程序运行时，它仍然会使用终端显示器显示<code>STDOUT</code>和<code>STDERR</code>消息。最好是将<code>STDOUT</code>和<code>STDERR</code>进行重定向。</p>\n<h3 id=\"运行多个后台作业\"><a href=\"#运行多个后台作业\" class=\"headerlink\" title=\"运行多个后台作业\"></a>运行多个后台作业</h3><p>我们可以在命令提示符中同时启动多个后台作用，然后用<code>ps</code>命令查看。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ ./test4.sh &amp;</span><br><span class=\"line\">[1] 117</span><br><span class=\"line\">wangsx@SC-201708020022:~$ ./test5.sh &amp;</span><br><span class=\"line\">[2] 122</span><br><span class=\"line\">wangsx@SC-201708020022:~$ ./test6.sh &amp;</span><br><span class=\"line\">[3] 128</span><br><span class=\"line\">wangsx@SC-201708020022:~$ ps</span><br><span class=\"line\">  PID TTY          TIME CMD</span><br><span class=\"line\">    2 tty1     00:00:00 bash</span><br><span class=\"line\">  117 tty1     00:00:00 test4.sh</span><br><span class=\"line\">  122 tty1     00:00:00 test5.sh</span><br><span class=\"line\">  128 tty1     00:00:00 test6.sh</span><br><span class=\"line\">  135 tty1     00:00:00 sleep</span><br><span class=\"line\">  136 tty1     00:00:00 sleep</span><br><span class=\"line\">  137 tty1     00:00:00 ps</span><br><span class=\"line\">  138 tty1     00:00:00 sleep</span><br></pre></td></tr></table></figure>\n<p>我们特别需要注意，如果终端退出，后台程序也会随之退出。</p>\n<h2 id=\"在非控制台下运行脚本\"><a href=\"#在非控制台下运行脚本\" class=\"headerlink\" title=\"在非控制台下运行脚本\"></a>在非控制台下运行脚本</h2><p>如果我们不想出现终端退出后台程序退出的情况，可以使用<code>nohup</code>命令来实现。</p>\n<p><strong><code>nohup</code>命令运行了另外一个命令来阻断所有发送给该进程的<code>SIGHUP</code>信号。这会在退出终端会话时阻止进程退出。</strong></p>\n<p>其格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ nohup ./test4.sh  &amp;</span><br><span class=\"line\">[1] 156</span><br><span class=\"line\">wangsx@SC-201708020022:~$ nohup: 忽略输入并把输出追加到'nohup.out'</span><br></pre></td></tr></table></figure>\n<p>由于<code>nohup</code>命令会解除终端与进程的关联，进程也就不再同<code>STDOUT</code>和<code>STDERR</code>联系在一起。它会自动将这两者重定向到名为<code>nohup.out</code>的文件中。</p>\n<h2 id=\"作业控制\"><a href=\"#作业控制\" class=\"headerlink\" title=\"作业控制\"></a>作业控制</h2><p>启动、停止终止以及恢复作业统称为<strong>作业控制</strong>。我们可以通过这几种方式完全控制shell环境中所有的进程的运行方式。</p>\n<h3 id=\"查看作业\"><a href=\"#查看作业\" class=\"headerlink\" title=\"查看作业\"></a>查看作业</h3><p>作业控制的<strong>关键命令</strong>是<code>jobs</code>命令。它允许查看shell当前正在处理的作业。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~$ cat test10.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Test job control</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"Script Process ID: $$\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 10 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"Loop #$count\"</span><br><span class=\"line\">    sleep 10</span><br><span class=\"line\">    count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"End of script...\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">wangsx@SC-201708020022:~$ ./test10.sh</span><br><span class=\"line\">Script Process ID: 27</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">Loop #2</span><br><span class=\"line\">^Z^C # 我的ctrl+z好像不起作用</span><br></pre></td></tr></table></figure>\n<p>脚本用<code>$$</code>变量来显示系统分配给脚本的PID。使用Ctrl+Z组合键来停止脚本（我的在这不起作用~之前好像也是）。</p>\n<p>我们使用同样的脚本，利用<code>&amp;</code>将另外一个作业作为后台进程启动。我们通过<code>jobs -l</code>命令查看作业的PID。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[1] 121</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]+   121 运行中               ./test10.sh &gt; test10.out &amp;</span><br></pre></td></tr></table></figure>\n<p>下面看<code>jobs</code>命令的一些参数：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>语法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-l</td>\n<td>列出进程的PID以及作业号</td>\n</tr>\n<tr>\n<td>-n</td>\n<td>只列出上次shell发出的通知后改变了状态的作业</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>只列出作业的PID</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>只列出运行中的作业</td>\n</tr>\n<tr>\n<td>-s</td>\n<td>只列出已停止的作业</td>\n</tr>\n</tbody>\n</table>\n<p>如果仔细注意的话，我们发现作业号后面有<code>+</code>号。带加号的作业会被当成默认作业。当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候只有一个带加号的作业和一个带减号的作业。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]    132 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2]-   134 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[3]+   136 运行中               ./test10.sh &gt; test10.out &amp;</span><br></pre></td></tr></table></figure>\n<p>可以发现最好运行的脚本输出排在最前面。</p>\n<p>我们调用了<code>kill</code>命令向默认进程发送了一个<code>SIGHUP</code>信号，终止了该作业。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[1] 165</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2] 167</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[3] 169</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]    165 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2]-   167 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[3]+   169 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ kill 169</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]    165 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2]-   167 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[3]+   169 已终止               ./test10.sh &gt; test10.out</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs -l</span><br><span class=\"line\">[1]-   165 运行中               ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[2]+   167 运行中               ./test10.sh &gt; test10.out &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重启停止的作业\"><a href=\"#重启停止的作业\" class=\"headerlink\" title=\"重启停止的作业\"></a>重启停止的作业</h3><p>我们可以将已经停止的作业作为后台进程或者前台进程重启。前台进程会接管当前工作的终端，所以使用时需要注意。</p>\n<p>要以后台模式重启一个作业，可以用<code>bg</code>命令加上作业号（我的Window10子系统好像确实不能使用Ctrl+Z的功能，有兴趣可以自己测试一下）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ./test10.sh</span><br><span class=\"line\">Script Process ID: 13</span><br><span class=\"line\">Loop #1</span><br><span class=\"line\">^ZLoop #2</span><br><span class=\"line\">^C</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ bg</span><br><span class=\"line\">bash: bg: 当前: 无此任务</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ jobs</span><br></pre></td></tr></table></figure>\n<p>如果是默认作业，只需要使用<code>bg</code>命令。如果有多个作业，你得在<code>bg</code>命令后加上作业号。</p>\n<h2 id=\"调整谦让度\"><a href=\"#调整谦让度\" class=\"headerlink\" title=\"调整谦让度\"></a>调整谦让度</h2><p>在Linux中，内核负责将CPU时间分配给系统上运行的每一个进程。<strong>调度优先级</strong>是内核分配给进程的CPU时间。在Linux系统中，由shell启动的所有进程的调度优先级默认都是相同的。</p>\n<p>调度优先级是一个整数值，从-20（最高）到+19（最低）。默认bash shell以优先级0来启动所有进程。</p>\n<p>我们可以使用<code>nice</code>命令来改变shell脚本的优先级。</p>\n<h3 id=\"nice命令\"><a href=\"#nice命令\" class=\"headerlink\" title=\"nice命令\"></a>nice命令</h3><p>要让命令以更低的优先级运行，只要用<code>nice</code>的<code>-n</code>命令行来指定新的优先级级别。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@ubuntu:~/tmp$ nice -n 10 ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[5] 18953</span><br><span class=\"line\">wsx@ubuntu:~/tmp$ ps -p 18953 -o pid,ppid,ni,cmd</span><br><span class=\"line\">   PID   PPID  NI CMD</span><br><span class=\"line\"> 18953  18782  10 /bin/bash ./test10.sh</span><br></pre></td></tr></table></figure>\n<p>如果想要提高优先级，需要使用超级用户权限。<code>nice</code>命令的<code>-n</code>选项不是必须的，只需要在破折号后面跟上优先级就行了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@ubuntu:~/tmp$ nice -10 ./test10.sh &gt; test10.out &amp;</span><br><span class=\"line\">[6] 18999</span><br><span class=\"line\">[5]   Done                    nice -n 10 ./test10.sh &gt; test10.out</span><br><span class=\"line\">wsx@ubuntu:~/tmp$ ps -p 18999 -o pid,ppid,ni,cmd</span><br><span class=\"line\">   PID   PPID  NI CMD</span><br><span class=\"line\"> 18999  18782  10 /bin/bash ./test10.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"renice命令\"><a href=\"#renice命令\" class=\"headerlink\" title=\"renice命令\"></a>renice命令</h3><p>有时候我们想要改变系统上已经运行命令的优先级，这是<code>renice</code>命令可以做到的。它允许我们指定PID来改变它的优先级。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@ubuntu:~/tmp$ ./test10.sh &amp;</span><br><span class=\"line\">[3] 19086</span><br><span class=\"line\">wsx@ubuntu:~$ ps -p 19086 -o pid,ppid,ni,cmd</span><br><span class=\"line\">   PID   PPID  NI CMD</span><br><span class=\"line\"> 19086  19070   0 /bin/bash ./test10.sh</span><br><span class=\"line\">wsx@ubuntu:~$ renice -n 10 -p 19086</span><br><span class=\"line\">19086 (process ID) old priority 0, new priority 10</span><br><span class=\"line\">wsx@ubuntu:~$ ps -p 19086 -o pid,ppid,ni,cmd</span><br><span class=\"line\">   PID   PPID  NI CMD</span><br><span class=\"line\"> 19086  19070  10 /bin/bash ./test10.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"定时运行脚本\"><a href=\"#定时运行脚本\" class=\"headerlink\" title=\"定时运行脚本\"></a>定时运行脚本</h2><p>Linux系统提供了多个在预定时间运行脚本的方法：<code>at</code>命令和<code>cron</code>表。</p>\n<h3 id=\"用at命令来计划执行任务\"><a href=\"#用at命令来计划执行任务\" class=\"headerlink\" title=\"用at命令来计划执行任务\"></a>用at命令来计划执行任务</h3><p><code>at</code>命令允许指定Linux系统何时运行脚本。<code>at</code>命令会将作业提交到队列中，指定shell何时运行该作业。<code>at</code>的守护进程<code>atd</code>会以后台模式运行，检查作业队列来运行作业。</p>\n<p><code>atd</code>守护进程会检查系统上的一个特殊目录（通常位于<code>/var/spool/at</code>）来获取用<code>at</code>命令提交的作业。</p>\n<h4 id=\"at命令的格式\"><a href=\"#at命令的格式\" class=\"headerlink\" title=\"at命令的格式\"></a>at命令的格式</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at [-f filename] time</span><br></pre></td></tr></table></figure>\n<p>默认，<code>at</code>命令会将<code>STDIN</code>的输入放入队列中。我们可以用<code>-f</code>参数来指定用于读取命令的文件名。<code>time</code>参数指定了Linux系统何时运行该脚本。</p>\n<p><code>at</code>命令能识别多种不同的时间格式。</p>\n<ul>\n<li>标准的小时和分钟格式，比如10:15</li>\n<li>AM/PM指示符，比如10:15 PM</li>\n<li>特定可命令的时间，比如now, noon, midnight或teatime （4 PM）</li>\n</ul>\n<p>除了指定运行时间，还可以指定运行的日期。</p>\n<ul>\n<li>标准日期格式，比如MMDDYY, MM/DD/YY或DD.MM.YY</li>\n<li>文本日期，比如Jul 4或Dec 25，加不加年份都可以</li>\n<li>还可以指定时间增量<ul>\n<li>当前时间+25min</li>\n<li>明天10:15PM</li>\n<li>10:15+7天</li>\n</ul>\n</li>\n</ul>\n<p>针对不同的优先级，存在26种不同的作业队列。作业队列通常用小写字母a-z和大写字母A-Z来指代。</p>\n<p>作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值）。可以用<code>-q</code>参数指定不同的队列字母。</p>\n<h4 id=\"获取作业的输出\"><a href=\"#获取作业的输出\" class=\"headerlink\" title=\"获取作业的输出\"></a>获取作业的输出</h4><p>Linux系统会将提交作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给用户。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 解决atd没启动的问题</span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test13.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Test using at <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"This script ran at $(date +%B%d,%T)\"</span><br><span class=\"line\">echo</span><br><span class=\"line\">sleep 5</span><br><span class=\"line\">echo \"This is the script's end...\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -f test13.sh now</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 4 at Tue Sep 26 12:12:00 2017</span><br></pre></td></tr></table></figure>\n<p><code>at</code>命令会显示分配给作业的作业号以及为作业安排的运行时间。<code>at</code>命令利用<code>sendmail</code>应用程序来发送邮件。如果没有安装这个工具就无法获得输出，因此在使用<code>at</code>命令时，最好在脚本中对STDOUT和STDERR进行重定向。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test13b.sh</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Test using at <span class=\"built_in\">command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">echo \"This script ran at $(date +%B%d,%T)\" &gt; test13b.out</span><br><span class=\"line\">echo &gt;&gt; test13b.out</span><br><span class=\"line\">sleep 5</span><br><span class=\"line\">echo \"This is the script's end...\" &gt;&gt; test13b.out</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"></span></span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh now</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 7 at Tue Sep 26 12:16:00 2017</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ cat test13b.out</span><br><span class=\"line\">This script ran at 九月26,12:16:24</span><br><span class=\"line\"></span><br><span class=\"line\">This is the script's end...</span><br></pre></td></tr></table></figure>\n<p>这里使用了<code>-M</code>选项来屏蔽作业产生的输出信息。</p>\n<h4 id=\"列出等待的作业\"><a href=\"#列出等待的作业\" class=\"headerlink\" title=\"列出等待的作业\"></a>列出等待的作业</h4><p><code>atq</code>命令可以查看系统中有哪些作业再等待。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 11 at Wed Sep 27 16:00:00 2017</span><br><span class=\"line\">Can't open /var/run/atd.pid to signal atd. No atd running?</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ sudo /etc/init.d/atd start</span><br><span class=\"line\">[sudo] wangsx 的密码：</span><br><span class=\"line\"> * Starting deferred execution scheduler atd                                                                     [ OK ]</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh teatime</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 12 at Wed Sep 27 16:00:00 2017</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh tomorrow</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 13 at Wed Sep 27 21:44:00 2017</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ at -M -f test13b.sh 13:30</span><br><span class=\"line\">warning: commands will be executed using /bin/sh</span><br><span class=\"line\">job 14 at Wed Sep 27 13:30:00 2017</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ atq</span><br><span class=\"line\">11      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">12      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">13      Wed Sep 27 21:44:00 2017 a wangsx</span><br><span class=\"line\">14      Wed Sep 27 13:30:00 2017 a wangsx</span><br></pre></td></tr></table></figure>\n<p>作业列表中显示了作业号、系统运行该作业的日期和时间以及它所在的队列位置。</p>\n<h4 id=\"删除作业\"><a href=\"#删除作业\" class=\"headerlink\" title=\"删除作业\"></a>删除作业</h4><p>使用<code>atrm</code>命令删除等待中的作业。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ atq</span><br><span class=\"line\">11      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">12      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">13      Wed Sep 27 21:44:00 2017 a wangsx</span><br><span class=\"line\">14      Wed Sep 27 13:30:00 2017 a wangsx</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ atrm 11</span><br><span class=\"line\">wangsx@SC-201708020022:~/tmp$ atq</span><br><span class=\"line\">12      Wed Sep 27 16:00:00 2017 a wangsx</span><br><span class=\"line\">13      Wed Sep 27 21:44:00 2017 a wangsx</span><br><span class=\"line\">14      Wed Sep 27 13:30:00 2017 a wangsx</span><br></pre></td></tr></table></figure>\n<p>只能删除自己提交的作业，不能删除其他人的。</p>\n<h3 id=\"安排需要定期执行的脚本\"><a href=\"#安排需要定期执行的脚本\" class=\"headerlink\" title=\"安排需要定期执行的脚本\"></a>安排需要定期执行的脚本</h3><p>如果是需要定期执行的脚本，我们不需要使用<code>at</code>不断提交作业，而是可以利用Linux系统的另一个功能。</p>\n<p><strong>Linux系统使用<code>cron</code>程序来安排要定期执行的作业。它会在后台运行并检查一个特殊的表（成为cron时间表），以获得已安排执行的作业。</strong></p>\n<h4 id=\"cron时间表\"><a href=\"#cron时间表\" class=\"headerlink\" title=\"cron时间表\"></a>cron时间表</h4><p><code>cron</code>时间表的格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min hour dayofmonth month dayofweek command</span><br></pre></td></tr></table></figure>\n<p><code>cron</code>时间表允许我们用特定值、取值范围（比如1-5）或者通配符（星号）来指定条目。</p>\n<p>例如，我们想在每天的10:15运行一个命令，可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15 10 * * * command</span><br></pre></td></tr></table></figure>\n<p>在其中三个字段使用了通配符，表明<code>cron</code>会在每个月的每天的10:15执行该命令。</p>\n<p>要指定在每周一4:15PM运行命令，可以使用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15 16 * * 1 command</span><br></pre></td></tr></table></figure>\n<p>可以用三字符的文本值mon,tue,wed,thu,fri,sat,sum或数值（0为周日，6为周六）来指定dayofweek的表项。</p>\n<p><code>dayofmonth</code>可以用1-31表示。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 怎么在每个月的最后一天执行命令？</span></span><br><span class=\"line\">00 12 * * * if [`date +%d -d tomorrow` = 01 ]; then ; command</span><br></pre></td></tr></table></figure>\n<p>命令列表必须指定要运行的命令或脚本的全路径名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例如</span></span><br><span class=\"line\">15 10 * * * /home/rich/test4.sh &gt; test4out</span><br></pre></td></tr></table></figure>\n<p>注意：<code>corn</code>会用提交作业的用户账户运行脚本，所以我们在操作指定文件时必须有相应权限。</p>\n<h4 id=\"构建cron时间表\"><a href=\"#构建cron时间表\" class=\"headerlink\" title=\"构建cron时间表\"></a>构建cron时间表</h4><p>Linux提供了<code>crontab</code>命令来处理<code>cron</code>时间表。我们可以使用<code>-l</code>选项列出时间表。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ crontab -l</span><br><span class=\"line\">no crontab for wangsx</span><br></pre></td></tr></table></figure>\n<p>要添加条目，使用<code>-e</code>选项。在添加条目时，<code>crontab</code>命令会启动一个文本编辑器，使用已有的<code>cron</code>时间表作为文件内容。</p>\n<h4 id=\"浏览cron目录\"><a href=\"#浏览cron目录\" class=\"headerlink\" title=\"浏览cron目录\"></a>浏览cron目录</h4><p>如果对时间精确性要求不高，用预配置的<code>cron</code>脚本目录会更方便。有4个基本目录：hourly, daily, monthly和weekly。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wangsx@SC-201708020022:~/tmp$ ls /etc/cron.*ly</span><br><span class=\"line\">/etc/cron.daily:</span><br><span class=\"line\">apport      bsdmainutils  man-db   passwd                  upstart</span><br><span class=\"line\">apt-compat  dpkg          mdadm    popularity-contest</span><br><span class=\"line\">aptitude    logrotate     mlocate  update-notifier-common</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/cron.hourly:</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/cron.monthly:</span><br><span class=\"line\"></span><br><span class=\"line\">/etc/cron.weekly:</span><br><span class=\"line\">fstrim  man-db  update-notifier-common</span><br></pre></td></tr></table></figure>\n<p>如果脚本需要每天运行一次，只要将脚本复制到daily目录，cron每天会执行它。</p>\n<h4 id=\"anacron程序\"><a href=\"#anacron程序\" class=\"headerlink\" title=\"anacron程序\"></a>anacron程序</h4><p>如果提交的作业需要运行时系统处于关机状态，<code>cron</code>不会运行那些错过的脚本。为了解决这个问题，<code>anacron</code>程序诞生了。</p>\n<p>如果<code>anacron</code>知道某个作业错过了执行时间，它会尽快运行该作业。这个功能常用于进行常规日志维护的脚本。</p>\n<p><code>anacron</code>程序只会处理位于<code>cron</code>目录下的程序，比如<code>/etc/cron.monthly</code>。它使用时间戳来决定作业是否在正确的计划间隔内运行了，每个<code>cron</code>目录都有个时间戳文件，该文件位于<code>/var/spool/anacron</code>。</p>\n<p><code>anacron</code>程序使用自己的时间表来检查作业目录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@ubuntu:~$ sudo cat /var/spool/anacron/cron.monthly</span><br><span class=\"line\">[sudo] password for wsx:</span><br><span class=\"line\">20170926</span><br><span class=\"line\">wsx@ubuntu:~$ sudo cat /etc/anacrontab</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> /etc/anacrontab: configuration file <span class=\"keyword\">for</span> anacron</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> See anacron(8) and anacrontab(5) <span class=\"keyword\">for</span> details.</span></span><br><span class=\"line\"></span><br><span class=\"line\">SHELL=/bin/sh</span><br><span class=\"line\">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class=\"line\">HOME=/root</span><br><span class=\"line\">LOGNAME=root</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> These replace cron<span class=\"string\">'s entries</span></span></span><br><span class=\"line\">1       5       cron.daily      run-parts --report /etc/cron.daily</span><br><span class=\"line\">7       10      cron.weekly     run-parts --report /etc/cron.weekly</span><br><span class=\"line\">@monthly        15      cron.monthly    run-parts --report /etc/cron.monthly</span><br></pre></td></tr></table></figure>\n<p><code>anacron</code>的时间表的基本格式和<code>cron</code>时间表略有不同：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">period delay identifier command</span><br></pre></td></tr></table></figure>\n<p><code>period</code>定义了作业多久运行一次，以天为单位。<code>anacron</code>用此条目来检查作业的时间戳文件。<code>delay</code>条目会指定系统启动后<code>anacron</code>程序需要等待多少分钟再开始运行错过的脚本。<code>command</code>条目包含了<code>run-parts</code>程序和一个<code>cron</code>脚本目录名。<code>run-parts</code>程序负责运行目录中传给它的任何脚本。</p>\n<p>注意了，<code>anacron</code>不会处理执行时间需求小于一天的脚本，所以它是不会运行<code>/etc/cron.hourly</code>的脚本。</p>\n<p><code>identifier</code>条目是一种特别的非空字符串，如<code>cron-weekly</code>。它用于唯一标识日志消息和错误邮件中的作业。</p>"},{"title":"创建和使用shell函数","author":"王诗翔","date":"2017-11-25T16:00:00.000Z","_content":"\n*来源： Linux命令行与shell脚本编程大全*\n\n**内容**\n\n>- 基本的脚本函数\n>- 返回值\n>- 在函数中使用变量\n>- 数组变量和函数\n>- 函数递归\n>- 创建库\n>- 在命令行上使用函数\n\n\n\n我们可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用它了。\n\n下面我们来逐步了解如何创建自己的shell脚本函数并在应用中使用它们。\n\n<!-- more -->\n\n## 基本的脚本函数\n\n函数是一个脚本代码块，我们可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块，只要使用所起的函数名就行了。\n\n### 创建函数\n\n有两种格式可以创建函数。第一种格式是使用关键字`function`，后跟分配给该代码块的函数名。\n\n```shell\nfuntion name{\n\tcommands\n}\n```\n\n`name`属性定义了赋予函数的唯一名称，`commands`是构成函数的一条或多条bash shell命令。\n\n第二种格式更接近其他编程语言中定义函数的方式：\n\n```shell\nname() {\n  commands\n}\n```\n\n### 使用函数\n\n要使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。\n\n```shell\nwsx@wsx:~/tmp$ cat test1\n#!/bin/bash\n# using a function in a script\n\nfunction func1 {\n    echo \"This is an example of a function\"\n}\n\ncount=1\nwhile [ $count -le 5 ]\ndo\n  func1\n  count=$[ $count + 1 ]\ndone\n\necho \"This is the end of the loop\"\nfunc1\necho \"Now, this is the end of the script\"\n\nwsx@wsx:~/tmp$ ./test1\nThis is an example of a function\nThis is an example of a function\nThis is an example of a function\nThis is an example of a function\nThis is an example of a function\nThis is the end of the loop\nThis is an example of a function\nNow, this is the end of the script\n```\n\n注意，定义函数名`func1`的后面一定要跟`{`有空格隔开，不然会报错。**函数要先定义再使用，接触过编程的想必不陌生吧**。\n\n## 返回值\n\nbash shell会把函数当做一个小型脚本，运行结束时会返回一个退出状态码，有3种不同的方法来为函数生成退出状态码。\n\n### 默认退出状态码\n\n默认函数的退出状态码是函数中最后一条命令返回的退出状态码。我们可以使用标准变量`$?`在函数执行结束后确定函数的状态码。\n\n```shell\nwsx@wsx:~/tmp$ cat test2\n#!/bin/bash\n# testing the exit status of a function\n\nfunc1() {\n\techo \"trying to display a non-existent file\"\n\tls -l badfile\n}\n\necho \"testing the function\"\nfunc1\necho \"The exit status is: $?\"\nwsx@wsx:~/tmp$ ./test2\ntesting the function\ntrying to display a non-existent file\nls: 无法访问'badfile': 没有那个文件或目录\nThe exit status is: 2\n```\n\n函数的退出状态码是2，说明函数的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行，我们来看看下面一个例子。\n\n```shell\nwsx@wsx:~/tmp$ cat test3\n#!/bin/bash\n# testing the exit status of a function\n\nfunc1(){\n\tls -l badfile\n\techo \"This was a test of a bad command\"\n}\n\necho \"testing the function:\"\nfunc1\necho \"The exit status is: $?\"\nwsx@wsx:~/tmp$ ./test3\ntesting the function:\nls: 无法访问'badfile': 没有那个文件或目录\nThis was a test of a bad command\nThe exit status is: 0\n```\n\n这次函数的退出状态码是0，尽管其中有一条命令没有正常运行。可见使用函数的默认退出状态码是很危险的，幸运的是，我们有几种办法解决它。\n\n### 使用return命令\n\n`return`命令允许指定一个**整数值**来定义函数的退出状态码，从而提供了一种简单的途径来编码设定函数退出状态码。\n\n```shell\nwsx@wsx:~/tmp$ cat test4\n#!/bin/bash\n# using the return command in a function\n\nfunction db1 {\n\tread -p \"Enter a value: \" value\n\techo \"doubling the value\"\n\treturn $[ $value * 2 ]\n}\n\ndb1\necho \"The new value is $?\"\nwsx@wsx:~/tmp$ ./test4\nEnter a value: 4\ndoubling the value\nThe new value is 8\n```\n\n当使用这种方法时要小心，记住下面两条技巧来避免问题：\n\n- 函数一结束就取返回值\n- 退出状态码必须是0~255\n\n如果在用`$?`变量提取函数的返回值之前使用了其他命令，函数的返回值就会丢失。任何大于255的整数值都会产生一个错误值。\n\n```shell\nwsx@wsx:~/tmp$ ./test4\nEnter a value: 200\ndoubling the value\nThe new value is 144\n```\n\n### 使用函数输出\n\n如同可以将命令的输出保存到shell变量一样，我们也可以对函数的输出采用同样的处理办法。\n\n```shell\nresult=`db1`\n```\n\n这个命令会将`db1`函数的输出赋值给`$result`变量。下面是脚本的一个实例：\n\n```shell\nwsx@wsx:~/tmp$ cat test4b\n#!/bin/bash\n# using the echo to return a value\n\nfunction db1 {\n\tread -p \"Enter a value: \" value\n\techo $[ $value * 2 ]\n}\n\nresult=$(db1)\necho \"The new value is $result\"\nwsx@wsx:~/tmp$ ./test4b\nEnter a value: 200\nThe new value is 400\n```\n\n函数会用`echo`语句来显示计算的结果，该脚本会查看`db1`函数的输出，而不是查看退出状态码。\n\n> 通过这种技术，我们还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。\n\n\n\n## 在函数中使用变量\n\n在函数中使用变量时，我们需要注意它们的定义方式以及处理方法。这是shell脚本常见错误的根源。\n\n### 向函数传递参数\n\n函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`定义。也可以用特殊变量`$#`来判断给函数的参数数目。\n\n指定函数时，必须将参数和函数放在同一行：\n\n```shell\nfunc1 $value1 10\n```\n\n然后函数可以用参数环境变量来获得参数值。下面是一个例子：\n\n```shell\nwsx@wsx:~/tmp$ cat test5\n#!/bin/bash\n# passing parameters to a function\n\nfunction addem {\n\tif [ $# -eq 0 ] || [ $# -gt 2 ]\n\tthen\n\t\techo -1\n\telif [ $# -eq 1 ]\n\tthen\n\t\techo $[ $1 + $1 ]\n\telse\n\t\techo $[ $1 + $2 ]\n\tfi\n}\n\necho -n \"Adding 10 and 15: \"\nvalue=$(addem 10 15)\necho $value\necho -n \"Let's try adding just one number: \"\nvalue=$(addem 10)\necho $value\necho -n \"Now trying adding no numbers: \"\nvalue=$(addem)\necho $value\necho -n \"Finally, try add three numbers: \"\nvalue=$(addem 10 15 20)\necho $value\nwsx@wsx:~/tmp$ ./test5\nAdding 10 and 15: 25\nLet's try adding just one number: 20\nNow trying adding no numbers: -1\nFinally, try add three numbers: -1\n\n```\n\n`addem`函数首先会检查脚本传给它的参数数目。如果没有任何参数，或者参数多于两个，`addem`会返回`-1`。如果只有一个参数，`addem`会将参数与自身相加。如果有两个参数，`addem`会将它们相加。\n\n**由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。**下面是个失败的例子：\n\n```shell\nwsx@wsx:~/tmp$ cat badtest1\n#!/bin/bash\n# trying to access script parameters inside a function\n\nfunction badfunc1 {\n\techo $[ $1 * $2 ]\n}\n\nif [ $# -eq 2 ]\nthen\n\tvalue=$(badfunc1)\n\techo \"The result is $value\"\nelse\n\techo \"Usage: badtest1 a b\"\nfi\n\nwsx@wsx:~/tmp$ ./badtest1 10 15\n./badtest1: 行 5: *  : 语法错误: 需要操作数 (错误符号是 \"*  \")\nThe result is\n\n```\n\n尽管函数也使用了`$1`与`$2`变量，但它们与主脚本中的变量不同，要使用它们必须在调用函数时手动传入。\n\n```shell\nwsx@wsx:~/tmp$ cat test6\n#!/bin/bash\n# trying to access script parameters inside a function\n\nfunction func1 {\n\techo $[ $1 * $2 ]\n}\n\nif [ $# -eq 2 ]\nthen\n\tvalue=$(func1 $1 $2)\n\techo \"The result is $value\"\nelse\n\techo \"Usage: badtest1 a b\"\nfi\n\nwsx@wsx:~/tmp$ ./test6\nUsage: badtest1 a b\nwsx@wsx:~/tmp$ ./test6 10 15\nThe result is 150\n\n```\n\n### 在函数中处理变量\n\n**作用域**是变量可见的区域。对脚本的其他部分而言，函数定义的变量是隐藏的。这些概念其实是编程语言中通用的，想必学过一些其他编程的朋友早已有所理解了。\n\n函数使用两种类型的变量：\n\n- 全局变量\n- 局部变量\n\n#### 全局变量\n\n**全局变量**是在shell脚本中任何地方都有效的变量，如果你在函数内定义了一个全局变量，也可以在脚本的主体部分读取它的值。\n\n默认情况下，我们在脚本中定义的任何变量都是全局变量。\n\n```shell\nwsx@wsx:~/tmp$ cat test7\n#!/bin/bash\n# using a global variable to pass a value\n\nfunction db1 {\n\tvalue=$[ $value * 2 ]\n}\n\nread -p \"Enter a value: \" value\ndb1\necho \"The new value is: $value\"\n\nwsx@wsx:~/tmp$ ./test7\nEnter a value: 10\nThe new value is: 20\n\n```\n\n无论变量在函数内外定义，在脚本中引用该变量都有效。这样其实非常危险，尤其是如果你想在不同的shell脚本中使用函数的话。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。下面是一个如何搞砸的例子：\n\n```shell\nwsx@wsx:~/tmp$ cat badtest2\n#!/bin/bash\n# demonstrating a bad use of variable\n\nfunction func1 {\n\ttemp=$[ $value + 5 ]\n\tresult=$[ $temp * 2 ]\n}\n\ntemp=4\nvalue=6\n\nfunc1\necho \"The result is $result\"\nif [ $temp -gt $value ]\nthen\n\techo \"temp is larger\"\nelse\n\techo \"temp is smaller\"\nfi\nwsx@wsx:~/tmp$ ./badtest2\nThe result is 22\ntemp is larger\n\n```\n\n由于函数中用到了`$temp`变量，它的值在脚本中使用时受到了影响，产生了意想不到的后果。后面我们会学习如何处理这样的问题。\n\n#### 局部变量\n\n无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。**我们只需要在变量声明前加上local关键字就可以了**。\n\n```shell\nlocal temp\n```\n\n也可以在变量赋值时使用local关键字：\n\n```shell\nlocal temp=$[ $value + 5 ]\n```\n\n`local`关键字保证了变量只局限于该函数中。我们再回看刚才的例子：\n\n```shell\nwsx@wsx:~/tmp$ cat test8\n#!/bin/bash\n# demonstrating the local keyword\n\nfunction func1 {\n\tlocal temp=$[ $value + 5 ]\n\tresult=$[ $temp * 2 ]\n}\n\ntemp=4\nvalue=6\n\nfunc1\necho \"The result is $result\"\nif [ $temp -gt $value ]\nthen\n\techo \"temp is larger\"\nelse\n\techo \"temp is smaller\"\nfi\n\nwsx@wsx:~/tmp$ ./test8\nThe result is 22\ntemp is smaller\n\n```\n\n\n\n## 数组变量和函数\n\n在函数中使用数组变量值有点麻烦，还需要一些特殊考虑。下面我们使用一种方法来解决问题。\n\n### 向函数传数组参数\n\n这个方法有点不好理解，将数组变量当做单个参数传递的话不起作用，下面我们看一个bad例子：\n\n```shell\nwsx@wsx:~/tmp$ cat badtest3\n#!/bin/bash\n# trying to pass an array variable\n\nfunction testit {\n\techo \"The parameters are: $@\"\n\tthisarray=$1\n\techo \"The received array is ${thisarray[*]}\"\n}\n\nmyarray=(1 2 3 4 5)\necho \"The original array is: ${myarray[*]}\"\ntestit $myarray\nwsx@wsx:~/tmp$ ./badtest3\nThe original array is: 1 2 3 4 5\nThe parameters are: 1\nThe received array is 1\n```\n\n可以看到，当我们将数组变量当做函数参数传递时，函数只会取数组变量的第一个值。\n\n针对这个问题，我们的一个解决方案是将数组变量全部拆分为单个值，然后作为参数传入函数，在函数内部又重新对这些值进行组装。\n\n```shell\nwsx@wsx:~/tmp$ cat test9\n#!/bin/bash\n# array variable to function test\n\nfunction testit {\n\tlocal newarray\n\tnewarray=(`echo \"$@\"`)\n\techo \"The new array value is: ${newarray[*]}\"\n}\n\nmyarray=(1 2 3 4 5)\necho ${myarray[*]}\ntestit ${myarray[*]}\n\nwsx@wsx:~/tmp$ ./test9\n1 2 3 4 5\nThe new array value is: 1 2 3 4 5\n\n```\n\n\n\n### 从函数中返回数组\n\n采用与上面类似的方法，函数用`echo`语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。\n\n```shell\nwsx@wsx:~/tmp$ cat test10\n#!/bin/bash\n# returning an array value\n\nfunction arraydblr {\n\tlocal origarray\n\tlocal newarray\n\tlocal elements\n\tlocal i\n\torigarray=($(echo \"$@\"))\n\tnewarray=($(echo \"$@\"))\n\telements=$[ $# - 1 ]\n\tfor (( i = 0; i <= $elements; i++ ))\n\t{\n\t\tnewarray[$i]=$[ ${origarray[$i]} * 2]\n\t}\n\techo ${newarray[*]}\n}\n\nmyarray=(1 2 3 4 5)\necho \"The orignal array is ${myarray[*]}\"\narg1=$(echo ${myarray[*]})\nresult=($(arraydblr $arg1))\necho \"The new array is: ${result[*]}\"\n\nwsx@wsx:~/tmp$ ./test10\nThe orignal array is 1 2 3 4 5\nThe new array is: 2 4 6 8 10\n\n```\n\n该脚本用`$arg1`变量将数组值传给`arraydblr`函数。该函数将数组重组到新的数组变量中，生成输出数组变量的一个副本，然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。\n\n\n\n## 函数递归\n\n局部函数变量的一个特征是**自成体系**。这个特性使得函数可以递归地调用，也就是函数可以调用自己来得到结果。**通常递归函数都有一个最终可以迭代到的基准值。**\n\n递归算法的经典例子是计算阶乘：一个数的阶乘是该数之前的所有数乘以该数的值。\n\n比如5的阶乘：\n\n```\n5! = 1 * 2 * 3 * 4 * 5\n```\n\n方程可以简化为通用形式：\n\n```\nx! = x * (x-1)!\n```\n\n这可以用简单的递归脚本表达为：\n\n```shell\nfunction factorial {\n  if [ $1 -eq 1 ]\n  then\n  \techo 1\n  else\n  \tlocal temp=$[ $1 - 1 ]\n  \tlocal result=`factorial $temp`\n  \techo $[ $result * $1 ]\n  fi\n}\n```\n\n下面用它来进行计算：\n\n```shell\nwsx@wsx:~/tmp$ cat test11\n#!/bin/bash\n# using recursion\n\nfunction factorial {\n\tif [ $1 -eq 1 ]\n\tthen\n\t\techo 1\n\telse\n\t\tlocal temp=$[ $1 - 1]\n\t\tlocal result=`factorial $temp`\n\t\techo $[ $result * $1 ]\n\tfi\n}\n\nread -p \"Enter value: \" value\nresult=$(factorial $value)\necho \"The factorial of $value is: $result\"\n\nwsx@wsx:~/tmp$ ./test11\nEnter value: 5\nThe factorial of 5 is: 120\n\n```\n\n\n\n## 创建库\n\n如果你碰巧要在多个脚本中使用同一段代码呢？显然在每个脚本中都定义同样的函数太麻烦了，一种解决方法就是创建**库文件**，然后在脚本中引用它。\n\n**第一步**是创建一个包含脚本中所需函数的公用库文件。下面是一个叫做myfuncs的库文件，定义了3个简单的函数。\n\n```shell\nwsx@wsx:~/tmp$ cat myfuncs\n#!/bin/bash\n# my script functions\n\nfunction addem {\n\techo $[ $1 + $2 ]\n}\n\nfunction multem {\n\techo $[ $1 * $2 ]\n}\n\nfunction divem {\n\tif [ $2 -ne 0 ]\n\tthen\n\t\techo $[ $1 / $2 ]\n\telse\n\t\techo -1\n\tfi\n}\n```\n\n**下一步**是在用到这些函数的脚本文件中包含myfuncs库文件。\n\n这里有点复杂，主要问题出在shell函数的作用域上。如果我们尝试像普通脚本一样运行库文件，函数不会出现在脚本中。\n\n使用函数库的**关键**在于`source`命令。**`source`命令会在当前shell上下文中执行命令，而不是创建一个新的shell。**通过`source`命令就可以使用库中的函数了。\n\n`source`命令有一个**快捷别名**，称为**点操作符**。要在shell脚本中运行myfuncs库文件，只需要使用下面这行：\n\n```shell\n. ./myfuncs\n```\n\n注意第一个点是点操作符，而第二个点指向当前目录（相对路径）。\n\n下面这个例子假定myfuncs库文件与要使用它的脚本位于同一目录，不然需要使用相对应的路径进行访问。\n\n```shell\nwsx@wsx:~/tmp$ cat test12\n#!/bin/bash\n# using functions defined in a library file\n\n. ./myfuncs\n\nvalue1=10\nvalue2=5\nresult1=$(addem $value1 $value2)\nresult2=$(multem $value1 $value2)\nresult3=$(divem $value1 $value2)\necho \"The result of adding them is: $result1\"\necho \"The result of multiplying them is: $result2\"\necho \"The result of dividing them is: $result3\"\n\n```\n\n运行：\n\n```shell\nwsx@wsx:~/tmp$ ./test12\nThe result of adding them is: 15\nThe result of multiplying them is: 50\nThe result of dividing them is: 2\n```\n\n\n\n## 在命令行上使用函数\n\n有时候有必要在命令行界面的提示符下直接使用这些函数。这是个灰常不错的功能，在shell中定义的函数可以在整个系统中使用它，无需担心脚本是不是在PATH环境变量中。\n\n**重点在于让shell能够识别这些函数**。以下有几种方法可以实现。\n\n### 在命令行上创建函数\n\nshell会解释用户输入的命令，所以可以在命令行上直接定义一个函数。\n\n有两种方法。\n\n**一种是采用单行方式定义函数。**\n\n```shell\nwsx@wsx:~/tmp$ function divem { echo $[ $1 / $2 ]; }\nwsx@wsx:~/tmp$ divem 100 5\n20\n```\n\n当在命令行上定义函数时，你**必须**记得在每个命令后面加个分号，这样shell能识别命令的起始。\n\n**另一种是采用多行方式来定义函数。**在定义时bash shell会使用次提示符来提示输入更多命令。这种方法不必在命令末尾加分号，只要按回车键就可。\n\n```shell\nwsx@wsx:~/tmp$ function multem {\n> echo $[ $1 * $2 ]\n> }\nwsx@wsx:~/tmp$ multem 2 5\n10\n```\n\n**注意**：在命令行上创建函数不要跟内建命令重名，函数会覆盖原来的命令。\n\n### 在.bashrc文件中定义函数\n\n在bash shell每次启动时都会在主目录下查找`.bashrc`文件，不管是交互式shell还是shell中启动的新shell。所以我们可以将函数写入该文件，或者在脚本中写入命令读取函数文件。操作前面都讲过，不再赘述，**只要把该文件当做脚本对待就可以了**。理解这一点这部分就会了。\n\n\n\n## 实例\n\n**在开源的世界里，共享代码才是关键，而这一点同样适用于脚本函数。**我们可以下载大量各式各样的函数然后用于自己的应用程序。\n\n这一节介绍**如何下载、安装和使用GNU shtool shell脚本函数库**。shtool库提供了一些简单的shell脚本函数，可以用来完成日常的shell功能。\n\n### 下载和安装\n\nshtool软件包下载地址：\n\n```shell\nhttp://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz # China\n```\n\n可以浏览器或者命令行下载：\n\n```shell\nwsx@wsx:~/tmp$ wget http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz\n--2017-11-24 00:34:32--  http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz\n正在解析主机 mirrors.ustc.edu.cn (mirrors.ustc.edu.cn)... 202.141.176.110, 218.104.71.170, 2001:da8:d800:95::110\n正在连接 mirrors.ustc.edu.cn (mirrors.ustc.edu.cn)|202.141.176.110|:80... 已连接。\n已发出 HTTP 请求，正在等待回应... 200 OK\n长度： 97033 (95K) [application/gzip]\n正在保存至: “shtool-2.0.8.tar.gz”\n\nshtool-2.0.8.tar.gz 100%[===================>]  94.76K  --.-KB/s    用时 0.1s\n\n2017-11-24 00:34:32 (783 KB/s) - 已保存 “shtool-2.0.8.tar.gz” [97033/97033])\n```\n\n复制到主目录，然后用`tar`命令提取文件：\n\n```shell\nwsx@wsx:~$ tar -zxvf shtool-2.0.8.tar.gz\nshtool-2.0.8/AUTHORS\nshtool-2.0.8/COPYING\nshtool-2.0.8/ChangeLog\nshtool-2.0.8/INSTALL\nshtool-2.0.8/Makefile.in\nshtool-2.0.8/NEWS\nshtool-2.0.8/RATIONAL\nshtool-2.0.8/README\nshtool-2.0.8/THANKS\nshtool-2.0.8/VERSION\nshtool-2.0.8/configure\nshtool-2.0.8/configure.ac\nshtool-2.0.8/sh.arx\nshtool-2.0.8/sh.common\nshtool-2.0.8/sh.echo\nshtool-2.0.8/sh.fixperm\nshtool-2.0.8/sh.install\nshtool-2.0.8/sh.mdate\nshtool-2.0.8/sh.mkdir\nshtool-2.0.8/sh.mkln\nshtool-2.0.8/sh.mkshadow\nshtool-2.0.8/sh.move\nshtool-2.0.8/sh.path\nshtool-2.0.8/sh.platform\nshtool-2.0.8/sh.prop\nshtool-2.0.8/sh.rotate\nshtool-2.0.8/sh.scpp\nshtool-2.0.8/sh.slo\nshtool-2.0.8/sh.subst\nshtool-2.0.8/sh.table\nshtool-2.0.8/sh.tarball\nshtool-2.0.8/sh.version\nshtool-2.0.8/shtool.m4\nshtool-2.0.8/shtool.pod\nshtool-2.0.8/shtool.spec\nshtool-2.0.8/shtoolize.in\nshtool-2.0.8/shtoolize.pod\nshtool-2.0.8/test.db\nshtool-2.0.8/test.sh\n\n```\n\n接下来可以构建shell脚本库文件了。\n\n### 构建库\n\nshtool文件必须针对特定的Linux环境进行配置。**配置工作必须使用标准的configure和make命令**：\n\n```shell\nwsx@wsx:~$ cd shtool-2.0.8/\nwsx@wsx:~/shtool-2.0.8$ ./configure\nConfiguring GNU shtool (Portable Shell Tool), version 2.0.8 (18-Jul-2008)\nCopyright (c) 1994-2008 Ralf S. Engelschall <rse@engelschall.com>\nchecking whether make sets $(MAKE)... yes\nchecking for perl interpreter... /usr/bin/perl\nchecking for pod2man conversion tool... /usr/bin/pod2man\nconfigure: creating ./config.status\nconfig.status: creating Makefile\nconfig.status: creating shtoolize\nconfig.status: executing adjustment commands\nwsx@wsx:~/shtool-2.0.8$ make\nbuilding program shtool\n./shtoolize -o shtool all\nUse of assignment to $[ is deprecated at ./shtoolize line 60.\nGenerating shtool...(echo 11808/12742 bytes)...(mdate 3695/4690 bytes)...(table 1818/2753 bytes)...(prop 1109/2038 bytes)...(move 2685/3614 bytes)...(install 4567/5495 bytes)...(mkdir 2904/3821 bytes)...(mkln 4429/5361 bytes)...(mkshadow 3260/4193 bytes)...(fixperm 1471/2403 bytes)...(rotate 13425/14331 bytes)...(tarball 5297/6214 bytes)...(subst 5255/6180 bytes)...(platform 21739/22662 bytes)...(arx 2401/3312 bytes)...(slo 4139/5066 bytes)...(scpp 6295/7206 bytes)...(version 10234/11160 bytes)...(path 4041/4952 bytes)\nbuilding manpage shtoolize.1\nbuilding manpage shtool.1\nbuilding manpage shtool-echo.1\nbuilding manpage shtool-mdate.1\nshtool-mdate.tmp around line 222: You forgot a '=back' before '=head1'\nPOD document had syntax errors at /usr/bin/pod2man line 71.\nbuilding manpage shtool-table.1\nbuilding manpage shtool-prop.1\nbuilding manpage shtool-move.1\nbuilding manpage shtool-install.1\nbuilding manpage shtool-mkdir.1\nshtool-mkdir.tmp around line 186: You forgot a '=back' before '=head1'\nPOD document had syntax errors at /usr/bin/pod2man line 71.\nbuilding manpage shtool-mkln.1\nbuilding manpage shtool-mkshadow.1\nshtool-mkshadow.tmp around line 191: You forgot a '=back' before '=head1'\nPOD document had syntax errors at /usr/bin/pod2man line 71.\nbuilding manpage shtool-fixperm.1\nbuilding manpage shtool-rotate.1\nbuilding manpage shtool-tarball.1\nbuilding manpage shtool-subst.1\nbuilding manpage shtool-platform.1\nbuilding manpage shtool-arx.1\nbuilding manpage shtool-slo.1\nbuilding manpage shtool-scpp.1\nbuilding manpage shtool-version.1\nbuilding manpage shtool-path.1\n\n```\n\n`configure`命令会检查构建shtool库文件所必需的软件。一旦发现所需工具，它会使用工具路径修改配置文件。\n\n`make`命令负责构建shtool库文件。最终的结果（shtool）是一个完整的库软件包。\n\n我们可以测试下这个库文件：\n\n```shell\nwsx@wsx:~/shtool-2.0.8$ make test\nRunning test suite:\necho..........FAILED\n+---Test------------------------------\n| test \".`../shtool echo foo bar quux`\" = \".foo bar quux\" || exit 1\n| bytes=`../shtool echo -n foo | wc -c | awk '{ printf(\"%s\", $1); }'` || exit 1\n| test \".$bytes\" = .3 || exit 1\n| bytes=`../shtool echo '\\1' | wc -c | awk '{ printf(\"%s\", $1); }'` || exit 1\n| test \".$bytes\" = .3 || exit 1\n| exit 0\n+---Trace-----------------------------\n| + ../shtool echo foo bar quux\n| + test .foo bar quux = .foo bar quux\n| + ../shtool echo -n foo\n| + wc -c\n| + awk { printf(\"%s\", $1); }\n| + bytes=3\n| + test .3 = .3\n| + ../shtool echo \\1\n| + wc -c\n| + awk { printf(\"%s\", $1); }\n| + bytes=2\n| + test .2 = .3\n| + exit 1\n+-------------------------------------\nmdate.........ok\ntable.........ok\nprop..........ok\nmove..........ok\ninstall.......ok\nmkdir.........ok\nmkln..........ok\nmkshadow......ok\nfixperm.......ok\nrotate........ok\ntarball.......ok\nsubst.........ok\nplatform......ok\narx...........ok\nslo...........ok\nscpp..........ok\nversion.......ok\npath..........ok\nFAILED: passed: 18/19, failed: 1/19\n\n```\n\n（有一个没通过～）\n\n如果全部通过测试，就可以将库安装到系统中，这样所有脚本都能使用这个库了。\n\n要完成安装，需要使用`make`命令的`install`选项。需要使用root权限。\n\n```shell\nwsx@wsx:~/shtool-2.0.8$ make install\n./shtool mkdir -f -p -m 755 /usr/local\n./shtool mkdir -f -p -m 755 /usr/local/bin\n./shtool mkdir -f -p -m 755 /usr/local/share/man/man1\nmkdir: cannot create directory '/usr/local/share/man/man1': Permission denied\nchmod: cannot access '/usr/local/share/man/man1': No such file or directory\nMakefile:94: recipe for target 'install' failed\nmake: *** [install] Error 1\nwsx@wsx:~/shtool-2.0.8$ sudo make install\n[sudo] wsx 的密码：\n./shtool mkdir -f -p -m 755 /usr/local\n./shtool mkdir -f -p -m 755 /usr/local/bin\n./shtool mkdir -f -p -m 755 /usr/local/share/man/man1\n./shtool mkdir -f -p -m 755 /usr/local/share/aclocal\n./shtool mkdir -f -p -m 755 /usr/local/share/shtool\n./shtool install -c -m 755 shtool /usr/local/bin/shtool\n./shtool install -c -m 755 shtoolize /usr/local/bin/shtoolize\n./shtool install -c -m 644 shtoolize.1 /usr/local/share/man/man1/shtoolize.1\n./shtool install -c -m 644 shtool.1 /usr/local/share/man/man1/shtool.1\n./shtool install -c -m 644 shtool-echo.1 /usr/local/share/man/man1/shtool-echo.1\n./shtool install -c -m 644 shtool-mdate.1 /usr/local/share/man/man1/shtool-mdate.1\n./shtool install -c -m 644 shtool-table.1 /usr/local/share/man/man1/shtool-table.1\n./shtool install -c -m 644 shtool-prop.1 /usr/local/share/man/man1/shtool-prop.1\n./shtool install -c -m 644 shtool-move.1 /usr/local/share/man/man1/shtool-move.1\n./shtool install -c -m 644 shtool-install.1 /usr/local/share/man/man1/shtool-install.1\n./shtool install -c -m 644 shtool-mkdir.1 /usr/local/share/man/man1/shtool-mkdir.1\n./shtool install -c -m 644 shtool-mkln.1 /usr/local/share/man/man1/shtool-mkln.1\n./shtool install -c -m 644 shtool-mkshadow.1 /usr/local/share/man/man1/shtool-mkshadow.1\n./shtool install -c -m 644 shtool-fixperm.1 /usr/local/share/man/man1/shtool-fixperm.1\n./shtool install -c -m 644 shtool-rotate.1 /usr/local/share/man/man1/shtool-rotate.1\n./shtool install -c -m 644 shtool-tarball.1 /usr/local/share/man/man1/shtool-tarball.1\n./shtool install -c -m 644 shtool-subst.1 /usr/local/share/man/man1/shtool-subst.1\n./shtool install -c -m 644 shtool-platform.1 /usr/local/share/man/man1/shtool-platform.1\n./shtool install -c -m 644 shtool-arx.1 /usr/local/share/man/man1/shtool-arx.1\n./shtool install -c -m 644 shtool-slo.1 /usr/local/share/man/man1/shtool-slo.1\n./shtool install -c -m 644 shtool-scpp.1 /usr/local/share/man/man1/shtool-scpp.1\n./shtool install -c -m 644 shtool-version.1 /usr/local/share/man/man1/shtool-version.1\n./shtool install -c -m 644 shtool-path.1 /usr/local/share/man/man1/shtool-path.1\n./shtool install -c -m 644 shtool.m4 /usr/local/share/aclocal/shtool.m4\n./shtool install -c -m 644 sh.common /usr/local/share/shtool/sh.common\n./shtool install -c -m 644 sh.echo /usr/local/share/shtool/sh.echo\n./shtool install -c -m 644 sh.mdate /usr/local/share/shtool/sh.mdate\n./shtool install -c -m 644 sh.table /usr/local/share/shtool/sh.table\n./shtool install -c -m 644 sh.prop /usr/local/share/shtool/sh.prop\n./shtool install -c -m 644 sh.move /usr/local/share/shtool/sh.move\n./shtool install -c -m 644 sh.install /usr/local/share/shtool/sh.install\n./shtool install -c -m 644 sh.mkdir /usr/local/share/shtool/sh.mkdir\n./shtool install -c -m 644 sh.mkln /usr/local/share/shtool/sh.mkln\n./shtool install -c -m 644 sh.mkshadow /usr/local/share/shtool/sh.mkshadow\n./shtool install -c -m 644 sh.fixperm /usr/local/share/shtool/sh.fixperm\n./shtool install -c -m 644 sh.rotate /usr/local/share/shtool/sh.rotate\n./shtool install -c -m 644 sh.tarball /usr/local/share/shtool/sh.tarball\n./shtool install -c -m 644 sh.subst /usr/local/share/shtool/sh.subst\n./shtool install -c -m 644 sh.platform /usr/local/share/shtool/sh.platform\n./shtool install -c -m 644 sh.arx /usr/local/share/shtool/sh.arx\n./shtool install -c -m 644 sh.slo /usr/local/share/shtool/sh.slo\n./shtool install -c -m 644 sh.scpp /usr/local/share/shtool/sh.scpp\n./shtool install -c -m 644 sh.version /usr/local/share/shtool/sh.version\n./shtool install -c -m 644 sh.path /usr/local/share/shtool/sh.path\n\n```\n\n现在我们能在自己的shell脚本中使用这些函数咯。\n\n### shtool库函数\n\n| 函数       | 描述               |\n| -------- | ---------------- |\n| Arx      | 创建归档文件（包含一些扩展功能） |\n| Echo     | 显示字符串，并提供了一些扩展构件 |\n| fixperm  | 改变目录树的文件权限       |\n| install  | 安装脚本或文件          |\n| mdate    | 显示文件或目录修改时间      |\n| mkdir    | 创建一个或更多目录        |\n| Mkln     | 使用相对路径创建链接       |\n| mkshadow | 创建一棵阴影树          |\n| move     | 带有替换功能的文件移动      |\n| Path     | 处理程序路径           |\n| platform | 显示平台标识           |\n| Prop     | 显示一个带有动画效果的进度条   |\n| rotate   | 转置日志文件           |\n| Scpp     | 共享的C预处理器         |\n| Slo      | 根据库的类别，分离链接器选项   |\n| Subst    | 使用sed的替换操作       |\n| Table    | 以表格的形式显示由字段分隔的数据 |\n| tarball  | 从文件和目录中创建tar文件   |\n| version  | 创建版本信息文件         |\n\n每个shtool函数都包含大量的选项和参数。下面是使用格式：\n\n```shell\nshtool [option] [function [option] [args]]\n```\n\n\n\n### 使用库\n\n我们能直接在命令行或者在自己构建的脚本中使用shtool的函数。\n\n下面是在脚本中使用的简单例子：\n\n```shell\nwsx@wsx:~/tmp$ cat test13\n#!/bin/bash\nshtool platform\nwsx@wsx:~/tmp$ ./test13\nUbuntu 17.10 (AMD64)\n\n```\n\n`platform`函数会返回Linux发行版以及系统使用的CPU硬件相关信息。\n\n`prop`函数可以使用`\\`,`|`,`/`和`-`字符创建一个旋转的进度条。它可以告诉shell脚本用户目前正在处理一些后台处理工作。\n\n```shell\nwsx@wsx:~/tmp$ ls -al /usr/bin | shtool prop -p \"waiting...\"\nwaiting...\n```\n\n\n\n在脚本学习中涉及到诸多的符号，在运行时我们可能会感觉到顺利，但自己写的时候往往会用不太对，推荐阅读一下常用的一些符号区分，像小括号、中括号、花括号等等。觉的不懂的可以看看[Linux_Bash脚本_单引号’双引号“”反引号`小括号()中括号[]大括号{}](http://blog.csdn.net/yangtalent1206/article/details/12996797)以及相关的百度资料。\n","source":"_posts/2017-11-26-shell-create-function.md","raw":"---\ntitle: 创建和使用shell函数\nauthor: 王诗翔\ndate: 2017-11-26\ncategories:\n- Linux杂烩\n- shell编程\ntags:\n- linux\n- shell笔记\n---\n\n*来源： Linux命令行与shell脚本编程大全*\n\n**内容**\n\n>- 基本的脚本函数\n>- 返回值\n>- 在函数中使用变量\n>- 数组变量和函数\n>- 函数递归\n>- 创建库\n>- 在命令行上使用函数\n\n\n\n我们可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用它了。\n\n下面我们来逐步了解如何创建自己的shell脚本函数并在应用中使用它们。\n\n<!-- more -->\n\n## 基本的脚本函数\n\n函数是一个脚本代码块，我们可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块，只要使用所起的函数名就行了。\n\n### 创建函数\n\n有两种格式可以创建函数。第一种格式是使用关键字`function`，后跟分配给该代码块的函数名。\n\n```shell\nfuntion name{\n\tcommands\n}\n```\n\n`name`属性定义了赋予函数的唯一名称，`commands`是构成函数的一条或多条bash shell命令。\n\n第二种格式更接近其他编程语言中定义函数的方式：\n\n```shell\nname() {\n  commands\n}\n```\n\n### 使用函数\n\n要使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。\n\n```shell\nwsx@wsx:~/tmp$ cat test1\n#!/bin/bash\n# using a function in a script\n\nfunction func1 {\n    echo \"This is an example of a function\"\n}\n\ncount=1\nwhile [ $count -le 5 ]\ndo\n  func1\n  count=$[ $count + 1 ]\ndone\n\necho \"This is the end of the loop\"\nfunc1\necho \"Now, this is the end of the script\"\n\nwsx@wsx:~/tmp$ ./test1\nThis is an example of a function\nThis is an example of a function\nThis is an example of a function\nThis is an example of a function\nThis is an example of a function\nThis is the end of the loop\nThis is an example of a function\nNow, this is the end of the script\n```\n\n注意，定义函数名`func1`的后面一定要跟`{`有空格隔开，不然会报错。**函数要先定义再使用，接触过编程的想必不陌生吧**。\n\n## 返回值\n\nbash shell会把函数当做一个小型脚本，运行结束时会返回一个退出状态码，有3种不同的方法来为函数生成退出状态码。\n\n### 默认退出状态码\n\n默认函数的退出状态码是函数中最后一条命令返回的退出状态码。我们可以使用标准变量`$?`在函数执行结束后确定函数的状态码。\n\n```shell\nwsx@wsx:~/tmp$ cat test2\n#!/bin/bash\n# testing the exit status of a function\n\nfunc1() {\n\techo \"trying to display a non-existent file\"\n\tls -l badfile\n}\n\necho \"testing the function\"\nfunc1\necho \"The exit status is: $?\"\nwsx@wsx:~/tmp$ ./test2\ntesting the function\ntrying to display a non-existent file\nls: 无法访问'badfile': 没有那个文件或目录\nThe exit status is: 2\n```\n\n函数的退出状态码是2，说明函数的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行，我们来看看下面一个例子。\n\n```shell\nwsx@wsx:~/tmp$ cat test3\n#!/bin/bash\n# testing the exit status of a function\n\nfunc1(){\n\tls -l badfile\n\techo \"This was a test of a bad command\"\n}\n\necho \"testing the function:\"\nfunc1\necho \"The exit status is: $?\"\nwsx@wsx:~/tmp$ ./test3\ntesting the function:\nls: 无法访问'badfile': 没有那个文件或目录\nThis was a test of a bad command\nThe exit status is: 0\n```\n\n这次函数的退出状态码是0，尽管其中有一条命令没有正常运行。可见使用函数的默认退出状态码是很危险的，幸运的是，我们有几种办法解决它。\n\n### 使用return命令\n\n`return`命令允许指定一个**整数值**来定义函数的退出状态码，从而提供了一种简单的途径来编码设定函数退出状态码。\n\n```shell\nwsx@wsx:~/tmp$ cat test4\n#!/bin/bash\n# using the return command in a function\n\nfunction db1 {\n\tread -p \"Enter a value: \" value\n\techo \"doubling the value\"\n\treturn $[ $value * 2 ]\n}\n\ndb1\necho \"The new value is $?\"\nwsx@wsx:~/tmp$ ./test4\nEnter a value: 4\ndoubling the value\nThe new value is 8\n```\n\n当使用这种方法时要小心，记住下面两条技巧来避免问题：\n\n- 函数一结束就取返回值\n- 退出状态码必须是0~255\n\n如果在用`$?`变量提取函数的返回值之前使用了其他命令，函数的返回值就会丢失。任何大于255的整数值都会产生一个错误值。\n\n```shell\nwsx@wsx:~/tmp$ ./test4\nEnter a value: 200\ndoubling the value\nThe new value is 144\n```\n\n### 使用函数输出\n\n如同可以将命令的输出保存到shell变量一样，我们也可以对函数的输出采用同样的处理办法。\n\n```shell\nresult=`db1`\n```\n\n这个命令会将`db1`函数的输出赋值给`$result`变量。下面是脚本的一个实例：\n\n```shell\nwsx@wsx:~/tmp$ cat test4b\n#!/bin/bash\n# using the echo to return a value\n\nfunction db1 {\n\tread -p \"Enter a value: \" value\n\techo $[ $value * 2 ]\n}\n\nresult=$(db1)\necho \"The new value is $result\"\nwsx@wsx:~/tmp$ ./test4b\nEnter a value: 200\nThe new value is 400\n```\n\n函数会用`echo`语句来显示计算的结果，该脚本会查看`db1`函数的输出，而不是查看退出状态码。\n\n> 通过这种技术，我们还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。\n\n\n\n## 在函数中使用变量\n\n在函数中使用变量时，我们需要注意它们的定义方式以及处理方法。这是shell脚本常见错误的根源。\n\n### 向函数传递参数\n\n函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`定义。也可以用特殊变量`$#`来判断给函数的参数数目。\n\n指定函数时，必须将参数和函数放在同一行：\n\n```shell\nfunc1 $value1 10\n```\n\n然后函数可以用参数环境变量来获得参数值。下面是一个例子：\n\n```shell\nwsx@wsx:~/tmp$ cat test5\n#!/bin/bash\n# passing parameters to a function\n\nfunction addem {\n\tif [ $# -eq 0 ] || [ $# -gt 2 ]\n\tthen\n\t\techo -1\n\telif [ $# -eq 1 ]\n\tthen\n\t\techo $[ $1 + $1 ]\n\telse\n\t\techo $[ $1 + $2 ]\n\tfi\n}\n\necho -n \"Adding 10 and 15: \"\nvalue=$(addem 10 15)\necho $value\necho -n \"Let's try adding just one number: \"\nvalue=$(addem 10)\necho $value\necho -n \"Now trying adding no numbers: \"\nvalue=$(addem)\necho $value\necho -n \"Finally, try add three numbers: \"\nvalue=$(addem 10 15 20)\necho $value\nwsx@wsx:~/tmp$ ./test5\nAdding 10 and 15: 25\nLet's try adding just one number: 20\nNow trying adding no numbers: -1\nFinally, try add three numbers: -1\n\n```\n\n`addem`函数首先会检查脚本传给它的参数数目。如果没有任何参数，或者参数多于两个，`addem`会返回`-1`。如果只有一个参数，`addem`会将参数与自身相加。如果有两个参数，`addem`会将它们相加。\n\n**由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。**下面是个失败的例子：\n\n```shell\nwsx@wsx:~/tmp$ cat badtest1\n#!/bin/bash\n# trying to access script parameters inside a function\n\nfunction badfunc1 {\n\techo $[ $1 * $2 ]\n}\n\nif [ $# -eq 2 ]\nthen\n\tvalue=$(badfunc1)\n\techo \"The result is $value\"\nelse\n\techo \"Usage: badtest1 a b\"\nfi\n\nwsx@wsx:~/tmp$ ./badtest1 10 15\n./badtest1: 行 5: *  : 语法错误: 需要操作数 (错误符号是 \"*  \")\nThe result is\n\n```\n\n尽管函数也使用了`$1`与`$2`变量，但它们与主脚本中的变量不同，要使用它们必须在调用函数时手动传入。\n\n```shell\nwsx@wsx:~/tmp$ cat test6\n#!/bin/bash\n# trying to access script parameters inside a function\n\nfunction func1 {\n\techo $[ $1 * $2 ]\n}\n\nif [ $# -eq 2 ]\nthen\n\tvalue=$(func1 $1 $2)\n\techo \"The result is $value\"\nelse\n\techo \"Usage: badtest1 a b\"\nfi\n\nwsx@wsx:~/tmp$ ./test6\nUsage: badtest1 a b\nwsx@wsx:~/tmp$ ./test6 10 15\nThe result is 150\n\n```\n\n### 在函数中处理变量\n\n**作用域**是变量可见的区域。对脚本的其他部分而言，函数定义的变量是隐藏的。这些概念其实是编程语言中通用的，想必学过一些其他编程的朋友早已有所理解了。\n\n函数使用两种类型的变量：\n\n- 全局变量\n- 局部变量\n\n#### 全局变量\n\n**全局变量**是在shell脚本中任何地方都有效的变量，如果你在函数内定义了一个全局变量，也可以在脚本的主体部分读取它的值。\n\n默认情况下，我们在脚本中定义的任何变量都是全局变量。\n\n```shell\nwsx@wsx:~/tmp$ cat test7\n#!/bin/bash\n# using a global variable to pass a value\n\nfunction db1 {\n\tvalue=$[ $value * 2 ]\n}\n\nread -p \"Enter a value: \" value\ndb1\necho \"The new value is: $value\"\n\nwsx@wsx:~/tmp$ ./test7\nEnter a value: 10\nThe new value is: 20\n\n```\n\n无论变量在函数内外定义，在脚本中引用该变量都有效。这样其实非常危险，尤其是如果你想在不同的shell脚本中使用函数的话。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。下面是一个如何搞砸的例子：\n\n```shell\nwsx@wsx:~/tmp$ cat badtest2\n#!/bin/bash\n# demonstrating a bad use of variable\n\nfunction func1 {\n\ttemp=$[ $value + 5 ]\n\tresult=$[ $temp * 2 ]\n}\n\ntemp=4\nvalue=6\n\nfunc1\necho \"The result is $result\"\nif [ $temp -gt $value ]\nthen\n\techo \"temp is larger\"\nelse\n\techo \"temp is smaller\"\nfi\nwsx@wsx:~/tmp$ ./badtest2\nThe result is 22\ntemp is larger\n\n```\n\n由于函数中用到了`$temp`变量，它的值在脚本中使用时受到了影响，产生了意想不到的后果。后面我们会学习如何处理这样的问题。\n\n#### 局部变量\n\n无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。**我们只需要在变量声明前加上local关键字就可以了**。\n\n```shell\nlocal temp\n```\n\n也可以在变量赋值时使用local关键字：\n\n```shell\nlocal temp=$[ $value + 5 ]\n```\n\n`local`关键字保证了变量只局限于该函数中。我们再回看刚才的例子：\n\n```shell\nwsx@wsx:~/tmp$ cat test8\n#!/bin/bash\n# demonstrating the local keyword\n\nfunction func1 {\n\tlocal temp=$[ $value + 5 ]\n\tresult=$[ $temp * 2 ]\n}\n\ntemp=4\nvalue=6\n\nfunc1\necho \"The result is $result\"\nif [ $temp -gt $value ]\nthen\n\techo \"temp is larger\"\nelse\n\techo \"temp is smaller\"\nfi\n\nwsx@wsx:~/tmp$ ./test8\nThe result is 22\ntemp is smaller\n\n```\n\n\n\n## 数组变量和函数\n\n在函数中使用数组变量值有点麻烦，还需要一些特殊考虑。下面我们使用一种方法来解决问题。\n\n### 向函数传数组参数\n\n这个方法有点不好理解，将数组变量当做单个参数传递的话不起作用，下面我们看一个bad例子：\n\n```shell\nwsx@wsx:~/tmp$ cat badtest3\n#!/bin/bash\n# trying to pass an array variable\n\nfunction testit {\n\techo \"The parameters are: $@\"\n\tthisarray=$1\n\techo \"The received array is ${thisarray[*]}\"\n}\n\nmyarray=(1 2 3 4 5)\necho \"The original array is: ${myarray[*]}\"\ntestit $myarray\nwsx@wsx:~/tmp$ ./badtest3\nThe original array is: 1 2 3 4 5\nThe parameters are: 1\nThe received array is 1\n```\n\n可以看到，当我们将数组变量当做函数参数传递时，函数只会取数组变量的第一个值。\n\n针对这个问题，我们的一个解决方案是将数组变量全部拆分为单个值，然后作为参数传入函数，在函数内部又重新对这些值进行组装。\n\n```shell\nwsx@wsx:~/tmp$ cat test9\n#!/bin/bash\n# array variable to function test\n\nfunction testit {\n\tlocal newarray\n\tnewarray=(`echo \"$@\"`)\n\techo \"The new array value is: ${newarray[*]}\"\n}\n\nmyarray=(1 2 3 4 5)\necho ${myarray[*]}\ntestit ${myarray[*]}\n\nwsx@wsx:~/tmp$ ./test9\n1 2 3 4 5\nThe new array value is: 1 2 3 4 5\n\n```\n\n\n\n### 从函数中返回数组\n\n采用与上面类似的方法，函数用`echo`语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。\n\n```shell\nwsx@wsx:~/tmp$ cat test10\n#!/bin/bash\n# returning an array value\n\nfunction arraydblr {\n\tlocal origarray\n\tlocal newarray\n\tlocal elements\n\tlocal i\n\torigarray=($(echo \"$@\"))\n\tnewarray=($(echo \"$@\"))\n\telements=$[ $# - 1 ]\n\tfor (( i = 0; i <= $elements; i++ ))\n\t{\n\t\tnewarray[$i]=$[ ${origarray[$i]} * 2]\n\t}\n\techo ${newarray[*]}\n}\n\nmyarray=(1 2 3 4 5)\necho \"The orignal array is ${myarray[*]}\"\narg1=$(echo ${myarray[*]})\nresult=($(arraydblr $arg1))\necho \"The new array is: ${result[*]}\"\n\nwsx@wsx:~/tmp$ ./test10\nThe orignal array is 1 2 3 4 5\nThe new array is: 2 4 6 8 10\n\n```\n\n该脚本用`$arg1`变量将数组值传给`arraydblr`函数。该函数将数组重组到新的数组变量中，生成输出数组变量的一个副本，然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。\n\n\n\n## 函数递归\n\n局部函数变量的一个特征是**自成体系**。这个特性使得函数可以递归地调用，也就是函数可以调用自己来得到结果。**通常递归函数都有一个最终可以迭代到的基准值。**\n\n递归算法的经典例子是计算阶乘：一个数的阶乘是该数之前的所有数乘以该数的值。\n\n比如5的阶乘：\n\n```\n5! = 1 * 2 * 3 * 4 * 5\n```\n\n方程可以简化为通用形式：\n\n```\nx! = x * (x-1)!\n```\n\n这可以用简单的递归脚本表达为：\n\n```shell\nfunction factorial {\n  if [ $1 -eq 1 ]\n  then\n  \techo 1\n  else\n  \tlocal temp=$[ $1 - 1 ]\n  \tlocal result=`factorial $temp`\n  \techo $[ $result * $1 ]\n  fi\n}\n```\n\n下面用它来进行计算：\n\n```shell\nwsx@wsx:~/tmp$ cat test11\n#!/bin/bash\n# using recursion\n\nfunction factorial {\n\tif [ $1 -eq 1 ]\n\tthen\n\t\techo 1\n\telse\n\t\tlocal temp=$[ $1 - 1]\n\t\tlocal result=`factorial $temp`\n\t\techo $[ $result * $1 ]\n\tfi\n}\n\nread -p \"Enter value: \" value\nresult=$(factorial $value)\necho \"The factorial of $value is: $result\"\n\nwsx@wsx:~/tmp$ ./test11\nEnter value: 5\nThe factorial of 5 is: 120\n\n```\n\n\n\n## 创建库\n\n如果你碰巧要在多个脚本中使用同一段代码呢？显然在每个脚本中都定义同样的函数太麻烦了，一种解决方法就是创建**库文件**，然后在脚本中引用它。\n\n**第一步**是创建一个包含脚本中所需函数的公用库文件。下面是一个叫做myfuncs的库文件，定义了3个简单的函数。\n\n```shell\nwsx@wsx:~/tmp$ cat myfuncs\n#!/bin/bash\n# my script functions\n\nfunction addem {\n\techo $[ $1 + $2 ]\n}\n\nfunction multem {\n\techo $[ $1 * $2 ]\n}\n\nfunction divem {\n\tif [ $2 -ne 0 ]\n\tthen\n\t\techo $[ $1 / $2 ]\n\telse\n\t\techo -1\n\tfi\n}\n```\n\n**下一步**是在用到这些函数的脚本文件中包含myfuncs库文件。\n\n这里有点复杂，主要问题出在shell函数的作用域上。如果我们尝试像普通脚本一样运行库文件，函数不会出现在脚本中。\n\n使用函数库的**关键**在于`source`命令。**`source`命令会在当前shell上下文中执行命令，而不是创建一个新的shell。**通过`source`命令就可以使用库中的函数了。\n\n`source`命令有一个**快捷别名**，称为**点操作符**。要在shell脚本中运行myfuncs库文件，只需要使用下面这行：\n\n```shell\n. ./myfuncs\n```\n\n注意第一个点是点操作符，而第二个点指向当前目录（相对路径）。\n\n下面这个例子假定myfuncs库文件与要使用它的脚本位于同一目录，不然需要使用相对应的路径进行访问。\n\n```shell\nwsx@wsx:~/tmp$ cat test12\n#!/bin/bash\n# using functions defined in a library file\n\n. ./myfuncs\n\nvalue1=10\nvalue2=5\nresult1=$(addem $value1 $value2)\nresult2=$(multem $value1 $value2)\nresult3=$(divem $value1 $value2)\necho \"The result of adding them is: $result1\"\necho \"The result of multiplying them is: $result2\"\necho \"The result of dividing them is: $result3\"\n\n```\n\n运行：\n\n```shell\nwsx@wsx:~/tmp$ ./test12\nThe result of adding them is: 15\nThe result of multiplying them is: 50\nThe result of dividing them is: 2\n```\n\n\n\n## 在命令行上使用函数\n\n有时候有必要在命令行界面的提示符下直接使用这些函数。这是个灰常不错的功能，在shell中定义的函数可以在整个系统中使用它，无需担心脚本是不是在PATH环境变量中。\n\n**重点在于让shell能够识别这些函数**。以下有几种方法可以实现。\n\n### 在命令行上创建函数\n\nshell会解释用户输入的命令，所以可以在命令行上直接定义一个函数。\n\n有两种方法。\n\n**一种是采用单行方式定义函数。**\n\n```shell\nwsx@wsx:~/tmp$ function divem { echo $[ $1 / $2 ]; }\nwsx@wsx:~/tmp$ divem 100 5\n20\n```\n\n当在命令行上定义函数时，你**必须**记得在每个命令后面加个分号，这样shell能识别命令的起始。\n\n**另一种是采用多行方式来定义函数。**在定义时bash shell会使用次提示符来提示输入更多命令。这种方法不必在命令末尾加分号，只要按回车键就可。\n\n```shell\nwsx@wsx:~/tmp$ function multem {\n> echo $[ $1 * $2 ]\n> }\nwsx@wsx:~/tmp$ multem 2 5\n10\n```\n\n**注意**：在命令行上创建函数不要跟内建命令重名，函数会覆盖原来的命令。\n\n### 在.bashrc文件中定义函数\n\n在bash shell每次启动时都会在主目录下查找`.bashrc`文件，不管是交互式shell还是shell中启动的新shell。所以我们可以将函数写入该文件，或者在脚本中写入命令读取函数文件。操作前面都讲过，不再赘述，**只要把该文件当做脚本对待就可以了**。理解这一点这部分就会了。\n\n\n\n## 实例\n\n**在开源的世界里，共享代码才是关键，而这一点同样适用于脚本函数。**我们可以下载大量各式各样的函数然后用于自己的应用程序。\n\n这一节介绍**如何下载、安装和使用GNU shtool shell脚本函数库**。shtool库提供了一些简单的shell脚本函数，可以用来完成日常的shell功能。\n\n### 下载和安装\n\nshtool软件包下载地址：\n\n```shell\nhttp://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz # China\n```\n\n可以浏览器或者命令行下载：\n\n```shell\nwsx@wsx:~/tmp$ wget http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz\n--2017-11-24 00:34:32--  http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz\n正在解析主机 mirrors.ustc.edu.cn (mirrors.ustc.edu.cn)... 202.141.176.110, 218.104.71.170, 2001:da8:d800:95::110\n正在连接 mirrors.ustc.edu.cn (mirrors.ustc.edu.cn)|202.141.176.110|:80... 已连接。\n已发出 HTTP 请求，正在等待回应... 200 OK\n长度： 97033 (95K) [application/gzip]\n正在保存至: “shtool-2.0.8.tar.gz”\n\nshtool-2.0.8.tar.gz 100%[===================>]  94.76K  --.-KB/s    用时 0.1s\n\n2017-11-24 00:34:32 (783 KB/s) - 已保存 “shtool-2.0.8.tar.gz” [97033/97033])\n```\n\n复制到主目录，然后用`tar`命令提取文件：\n\n```shell\nwsx@wsx:~$ tar -zxvf shtool-2.0.8.tar.gz\nshtool-2.0.8/AUTHORS\nshtool-2.0.8/COPYING\nshtool-2.0.8/ChangeLog\nshtool-2.0.8/INSTALL\nshtool-2.0.8/Makefile.in\nshtool-2.0.8/NEWS\nshtool-2.0.8/RATIONAL\nshtool-2.0.8/README\nshtool-2.0.8/THANKS\nshtool-2.0.8/VERSION\nshtool-2.0.8/configure\nshtool-2.0.8/configure.ac\nshtool-2.0.8/sh.arx\nshtool-2.0.8/sh.common\nshtool-2.0.8/sh.echo\nshtool-2.0.8/sh.fixperm\nshtool-2.0.8/sh.install\nshtool-2.0.8/sh.mdate\nshtool-2.0.8/sh.mkdir\nshtool-2.0.8/sh.mkln\nshtool-2.0.8/sh.mkshadow\nshtool-2.0.8/sh.move\nshtool-2.0.8/sh.path\nshtool-2.0.8/sh.platform\nshtool-2.0.8/sh.prop\nshtool-2.0.8/sh.rotate\nshtool-2.0.8/sh.scpp\nshtool-2.0.8/sh.slo\nshtool-2.0.8/sh.subst\nshtool-2.0.8/sh.table\nshtool-2.0.8/sh.tarball\nshtool-2.0.8/sh.version\nshtool-2.0.8/shtool.m4\nshtool-2.0.8/shtool.pod\nshtool-2.0.8/shtool.spec\nshtool-2.0.8/shtoolize.in\nshtool-2.0.8/shtoolize.pod\nshtool-2.0.8/test.db\nshtool-2.0.8/test.sh\n\n```\n\n接下来可以构建shell脚本库文件了。\n\n### 构建库\n\nshtool文件必须针对特定的Linux环境进行配置。**配置工作必须使用标准的configure和make命令**：\n\n```shell\nwsx@wsx:~$ cd shtool-2.0.8/\nwsx@wsx:~/shtool-2.0.8$ ./configure\nConfiguring GNU shtool (Portable Shell Tool), version 2.0.8 (18-Jul-2008)\nCopyright (c) 1994-2008 Ralf S. Engelschall <rse@engelschall.com>\nchecking whether make sets $(MAKE)... yes\nchecking for perl interpreter... /usr/bin/perl\nchecking for pod2man conversion tool... /usr/bin/pod2man\nconfigure: creating ./config.status\nconfig.status: creating Makefile\nconfig.status: creating shtoolize\nconfig.status: executing adjustment commands\nwsx@wsx:~/shtool-2.0.8$ make\nbuilding program shtool\n./shtoolize -o shtool all\nUse of assignment to $[ is deprecated at ./shtoolize line 60.\nGenerating shtool...(echo 11808/12742 bytes)...(mdate 3695/4690 bytes)...(table 1818/2753 bytes)...(prop 1109/2038 bytes)...(move 2685/3614 bytes)...(install 4567/5495 bytes)...(mkdir 2904/3821 bytes)...(mkln 4429/5361 bytes)...(mkshadow 3260/4193 bytes)...(fixperm 1471/2403 bytes)...(rotate 13425/14331 bytes)...(tarball 5297/6214 bytes)...(subst 5255/6180 bytes)...(platform 21739/22662 bytes)...(arx 2401/3312 bytes)...(slo 4139/5066 bytes)...(scpp 6295/7206 bytes)...(version 10234/11160 bytes)...(path 4041/4952 bytes)\nbuilding manpage shtoolize.1\nbuilding manpage shtool.1\nbuilding manpage shtool-echo.1\nbuilding manpage shtool-mdate.1\nshtool-mdate.tmp around line 222: You forgot a '=back' before '=head1'\nPOD document had syntax errors at /usr/bin/pod2man line 71.\nbuilding manpage shtool-table.1\nbuilding manpage shtool-prop.1\nbuilding manpage shtool-move.1\nbuilding manpage shtool-install.1\nbuilding manpage shtool-mkdir.1\nshtool-mkdir.tmp around line 186: You forgot a '=back' before '=head1'\nPOD document had syntax errors at /usr/bin/pod2man line 71.\nbuilding manpage shtool-mkln.1\nbuilding manpage shtool-mkshadow.1\nshtool-mkshadow.tmp around line 191: You forgot a '=back' before '=head1'\nPOD document had syntax errors at /usr/bin/pod2man line 71.\nbuilding manpage shtool-fixperm.1\nbuilding manpage shtool-rotate.1\nbuilding manpage shtool-tarball.1\nbuilding manpage shtool-subst.1\nbuilding manpage shtool-platform.1\nbuilding manpage shtool-arx.1\nbuilding manpage shtool-slo.1\nbuilding manpage shtool-scpp.1\nbuilding manpage shtool-version.1\nbuilding manpage shtool-path.1\n\n```\n\n`configure`命令会检查构建shtool库文件所必需的软件。一旦发现所需工具，它会使用工具路径修改配置文件。\n\n`make`命令负责构建shtool库文件。最终的结果（shtool）是一个完整的库软件包。\n\n我们可以测试下这个库文件：\n\n```shell\nwsx@wsx:~/shtool-2.0.8$ make test\nRunning test suite:\necho..........FAILED\n+---Test------------------------------\n| test \".`../shtool echo foo bar quux`\" = \".foo bar quux\" || exit 1\n| bytes=`../shtool echo -n foo | wc -c | awk '{ printf(\"%s\", $1); }'` || exit 1\n| test \".$bytes\" = .3 || exit 1\n| bytes=`../shtool echo '\\1' | wc -c | awk '{ printf(\"%s\", $1); }'` || exit 1\n| test \".$bytes\" = .3 || exit 1\n| exit 0\n+---Trace-----------------------------\n| + ../shtool echo foo bar quux\n| + test .foo bar quux = .foo bar quux\n| + ../shtool echo -n foo\n| + wc -c\n| + awk { printf(\"%s\", $1); }\n| + bytes=3\n| + test .3 = .3\n| + ../shtool echo \\1\n| + wc -c\n| + awk { printf(\"%s\", $1); }\n| + bytes=2\n| + test .2 = .3\n| + exit 1\n+-------------------------------------\nmdate.........ok\ntable.........ok\nprop..........ok\nmove..........ok\ninstall.......ok\nmkdir.........ok\nmkln..........ok\nmkshadow......ok\nfixperm.......ok\nrotate........ok\ntarball.......ok\nsubst.........ok\nplatform......ok\narx...........ok\nslo...........ok\nscpp..........ok\nversion.......ok\npath..........ok\nFAILED: passed: 18/19, failed: 1/19\n\n```\n\n（有一个没通过～）\n\n如果全部通过测试，就可以将库安装到系统中，这样所有脚本都能使用这个库了。\n\n要完成安装，需要使用`make`命令的`install`选项。需要使用root权限。\n\n```shell\nwsx@wsx:~/shtool-2.0.8$ make install\n./shtool mkdir -f -p -m 755 /usr/local\n./shtool mkdir -f -p -m 755 /usr/local/bin\n./shtool mkdir -f -p -m 755 /usr/local/share/man/man1\nmkdir: cannot create directory '/usr/local/share/man/man1': Permission denied\nchmod: cannot access '/usr/local/share/man/man1': No such file or directory\nMakefile:94: recipe for target 'install' failed\nmake: *** [install] Error 1\nwsx@wsx:~/shtool-2.0.8$ sudo make install\n[sudo] wsx 的密码：\n./shtool mkdir -f -p -m 755 /usr/local\n./shtool mkdir -f -p -m 755 /usr/local/bin\n./shtool mkdir -f -p -m 755 /usr/local/share/man/man1\n./shtool mkdir -f -p -m 755 /usr/local/share/aclocal\n./shtool mkdir -f -p -m 755 /usr/local/share/shtool\n./shtool install -c -m 755 shtool /usr/local/bin/shtool\n./shtool install -c -m 755 shtoolize /usr/local/bin/shtoolize\n./shtool install -c -m 644 shtoolize.1 /usr/local/share/man/man1/shtoolize.1\n./shtool install -c -m 644 shtool.1 /usr/local/share/man/man1/shtool.1\n./shtool install -c -m 644 shtool-echo.1 /usr/local/share/man/man1/shtool-echo.1\n./shtool install -c -m 644 shtool-mdate.1 /usr/local/share/man/man1/shtool-mdate.1\n./shtool install -c -m 644 shtool-table.1 /usr/local/share/man/man1/shtool-table.1\n./shtool install -c -m 644 shtool-prop.1 /usr/local/share/man/man1/shtool-prop.1\n./shtool install -c -m 644 shtool-move.1 /usr/local/share/man/man1/shtool-move.1\n./shtool install -c -m 644 shtool-install.1 /usr/local/share/man/man1/shtool-install.1\n./shtool install -c -m 644 shtool-mkdir.1 /usr/local/share/man/man1/shtool-mkdir.1\n./shtool install -c -m 644 shtool-mkln.1 /usr/local/share/man/man1/shtool-mkln.1\n./shtool install -c -m 644 shtool-mkshadow.1 /usr/local/share/man/man1/shtool-mkshadow.1\n./shtool install -c -m 644 shtool-fixperm.1 /usr/local/share/man/man1/shtool-fixperm.1\n./shtool install -c -m 644 shtool-rotate.1 /usr/local/share/man/man1/shtool-rotate.1\n./shtool install -c -m 644 shtool-tarball.1 /usr/local/share/man/man1/shtool-tarball.1\n./shtool install -c -m 644 shtool-subst.1 /usr/local/share/man/man1/shtool-subst.1\n./shtool install -c -m 644 shtool-platform.1 /usr/local/share/man/man1/shtool-platform.1\n./shtool install -c -m 644 shtool-arx.1 /usr/local/share/man/man1/shtool-arx.1\n./shtool install -c -m 644 shtool-slo.1 /usr/local/share/man/man1/shtool-slo.1\n./shtool install -c -m 644 shtool-scpp.1 /usr/local/share/man/man1/shtool-scpp.1\n./shtool install -c -m 644 shtool-version.1 /usr/local/share/man/man1/shtool-version.1\n./shtool install -c -m 644 shtool-path.1 /usr/local/share/man/man1/shtool-path.1\n./shtool install -c -m 644 shtool.m4 /usr/local/share/aclocal/shtool.m4\n./shtool install -c -m 644 sh.common /usr/local/share/shtool/sh.common\n./shtool install -c -m 644 sh.echo /usr/local/share/shtool/sh.echo\n./shtool install -c -m 644 sh.mdate /usr/local/share/shtool/sh.mdate\n./shtool install -c -m 644 sh.table /usr/local/share/shtool/sh.table\n./shtool install -c -m 644 sh.prop /usr/local/share/shtool/sh.prop\n./shtool install -c -m 644 sh.move /usr/local/share/shtool/sh.move\n./shtool install -c -m 644 sh.install /usr/local/share/shtool/sh.install\n./shtool install -c -m 644 sh.mkdir /usr/local/share/shtool/sh.mkdir\n./shtool install -c -m 644 sh.mkln /usr/local/share/shtool/sh.mkln\n./shtool install -c -m 644 sh.mkshadow /usr/local/share/shtool/sh.mkshadow\n./shtool install -c -m 644 sh.fixperm /usr/local/share/shtool/sh.fixperm\n./shtool install -c -m 644 sh.rotate /usr/local/share/shtool/sh.rotate\n./shtool install -c -m 644 sh.tarball /usr/local/share/shtool/sh.tarball\n./shtool install -c -m 644 sh.subst /usr/local/share/shtool/sh.subst\n./shtool install -c -m 644 sh.platform /usr/local/share/shtool/sh.platform\n./shtool install -c -m 644 sh.arx /usr/local/share/shtool/sh.arx\n./shtool install -c -m 644 sh.slo /usr/local/share/shtool/sh.slo\n./shtool install -c -m 644 sh.scpp /usr/local/share/shtool/sh.scpp\n./shtool install -c -m 644 sh.version /usr/local/share/shtool/sh.version\n./shtool install -c -m 644 sh.path /usr/local/share/shtool/sh.path\n\n```\n\n现在我们能在自己的shell脚本中使用这些函数咯。\n\n### shtool库函数\n\n| 函数       | 描述               |\n| -------- | ---------------- |\n| Arx      | 创建归档文件（包含一些扩展功能） |\n| Echo     | 显示字符串，并提供了一些扩展构件 |\n| fixperm  | 改变目录树的文件权限       |\n| install  | 安装脚本或文件          |\n| mdate    | 显示文件或目录修改时间      |\n| mkdir    | 创建一个或更多目录        |\n| Mkln     | 使用相对路径创建链接       |\n| mkshadow | 创建一棵阴影树          |\n| move     | 带有替换功能的文件移动      |\n| Path     | 处理程序路径           |\n| platform | 显示平台标识           |\n| Prop     | 显示一个带有动画效果的进度条   |\n| rotate   | 转置日志文件           |\n| Scpp     | 共享的C预处理器         |\n| Slo      | 根据库的类别，分离链接器选项   |\n| Subst    | 使用sed的替换操作       |\n| Table    | 以表格的形式显示由字段分隔的数据 |\n| tarball  | 从文件和目录中创建tar文件   |\n| version  | 创建版本信息文件         |\n\n每个shtool函数都包含大量的选项和参数。下面是使用格式：\n\n```shell\nshtool [option] [function [option] [args]]\n```\n\n\n\n### 使用库\n\n我们能直接在命令行或者在自己构建的脚本中使用shtool的函数。\n\n下面是在脚本中使用的简单例子：\n\n```shell\nwsx@wsx:~/tmp$ cat test13\n#!/bin/bash\nshtool platform\nwsx@wsx:~/tmp$ ./test13\nUbuntu 17.10 (AMD64)\n\n```\n\n`platform`函数会返回Linux发行版以及系统使用的CPU硬件相关信息。\n\n`prop`函数可以使用`\\`,`|`,`/`和`-`字符创建一个旋转的进度条。它可以告诉shell脚本用户目前正在处理一些后台处理工作。\n\n```shell\nwsx@wsx:~/tmp$ ls -al /usr/bin | shtool prop -p \"waiting...\"\nwaiting...\n```\n\n\n\n在脚本学习中涉及到诸多的符号，在运行时我们可能会感觉到顺利，但自己写的时候往往会用不太对，推荐阅读一下常用的一些符号区分，像小括号、中括号、花括号等等。觉的不懂的可以看看[Linux_Bash脚本_单引号’双引号“”反引号`小括号()中括号[]大括号{}](http://blog.csdn.net/yangtalent1206/article/details/12996797)以及相关的百度资料。\n","slug":"shell-create-function","published":1,"updated":"2018-01-27T04:08:42.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjda3cwv1000r9taxxdmeulul","content":"<p><em>来源： Linux命令行与shell脚本编程大全</em></p>\n<p><strong>内容</strong></p>\n<blockquote>\n<ul>\n<li>基本的脚本函数</li>\n<li>返回值</li>\n<li>在函数中使用变量</li>\n<li>数组变量和函数</li>\n<li>函数递归</li>\n<li>创建库</li>\n<li>在命令行上使用函数</li>\n</ul>\n</blockquote>\n<p>我们可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用它了。</p>\n<p>下面我们来逐步了解如何创建自己的shell脚本函数并在应用中使用它们。</p>\n<a id=\"more\"></a>\n<h2 id=\"基本的脚本函数\"><a href=\"#基本的脚本函数\" class=\"headerlink\" title=\"基本的脚本函数\"></a>基本的脚本函数</h2><p>函数是一个脚本代码块，我们可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块，只要使用所起的函数名就行了。</p>\n<h3 id=\"创建函数\"><a href=\"#创建函数\" class=\"headerlink\" title=\"创建函数\"></a>创建函数</h3><p>有两种格式可以创建函数。第一种格式是使用关键字<code>function</code>，后跟分配给该代码块的函数名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funtion name&#123;</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>name</code>属性定义了赋予函数的唯一名称，<code>commands</code>是构成函数的一条或多条bash shell命令。</p>\n<p>第二种格式更接近其他编程语言中定义函数的方式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name() &#123;</span><br><span class=\"line\">  commands</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用函数\"><a href=\"#使用函数\" class=\"headerlink\" title=\"使用函数\"></a>使用函数</h3><p>要使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using a <span class=\"keyword\">function</span> <span class=\"keyword\">in</span> a script</span></span><br><span class=\"line\"></span><br><span class=\"line\">function func1 &#123;</span><br><span class=\"line\">    echo \"This is an example of a function\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">  func1</span><br><span class=\"line\">  count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This is the end of the loop\"</span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"Now, this is the end of the script\"</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test1</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is the end of the loop</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">Now, this is the end of the script</span><br></pre></td></tr></table></figure>\n<p>注意，定义函数名<code>func1</code>的后面一定要跟<code>{</code>有空格隔开，不然会报错。<strong>函数要先定义再使用，接触过编程的想必不陌生吧</strong>。</p>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>bash shell会把函数当做一个小型脚本，运行结束时会返回一个退出状态码，有3种不同的方法来为函数生成退出状态码。</p>\n<h3 id=\"默认退出状态码\"><a href=\"#默认退出状态码\" class=\"headerlink\" title=\"默认退出状态码\"></a>默认退出状态码</h3><p>默认函数的退出状态码是函数中最后一条命令返回的退出状态码。我们可以使用标准变量<code>$?</code>在函数执行结束后确定函数的状态码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the <span class=\"built_in\">exit</span> status of a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">func1() &#123;</span><br><span class=\"line\">trueecho \"trying to display a non-existent file\"</span><br><span class=\"line\">truels -l badfile</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"testing the function\"</span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"The exit status is: $?\"</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test2</span><br><span class=\"line\">testing the function</span><br><span class=\"line\">trying to display a non-existent file</span><br><span class=\"line\">ls: 无法访问'badfile': 没有那个文件或目录</span><br><span class=\"line\">The exit status is: 2</span><br></pre></td></tr></table></figure>\n<p>函数的退出状态码是2，说明函数的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行，我们来看看下面一个例子。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the <span class=\"built_in\">exit</span> status of a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">func1()&#123;</span><br><span class=\"line\">truels -l badfile</span><br><span class=\"line\">trueecho \"This was a test of a bad command\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"testing the function:\"</span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"The exit status is: $?\"</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test3</span><br><span class=\"line\">testing the function:</span><br><span class=\"line\">ls: 无法访问'badfile': 没有那个文件或目录</span><br><span class=\"line\">This was a test of a bad command</span><br><span class=\"line\">The exit status is: 0</span><br></pre></td></tr></table></figure>\n<p>这次函数的退出状态码是0，尽管其中有一条命令没有正常运行。可见使用函数的默认退出状态码是很危险的，幸运的是，我们有几种办法解决它。</p>\n<h3 id=\"使用return命令\"><a href=\"#使用return命令\" class=\"headerlink\" title=\"使用return命令\"></a>使用return命令</h3><p><code>return</code>命令允许指定一个<strong>整数值</strong>来定义函数的退出状态码，从而提供了一种简单的途径来编码设定函数退出状态码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using the <span class=\"built_in\">return</span> <span class=\"built_in\">command</span> <span class=\"keyword\">in</span> a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function db1 &#123;</span><br><span class=\"line\">trueread -p \"Enter a value: \" value</span><br><span class=\"line\">trueecho \"doubling the value\"</span><br><span class=\"line\">truereturn $[ $value * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db1</span><br><span class=\"line\">echo \"The new value is $?\"</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test4</span><br><span class=\"line\">Enter a value: 4</span><br><span class=\"line\">doubling the value</span><br><span class=\"line\">The new value is 8</span><br></pre></td></tr></table></figure>\n<p>当使用这种方法时要小心，记住下面两条技巧来避免问题：</p>\n<ul>\n<li>函数一结束就取返回值</li>\n<li>退出状态码必须是0~255</li>\n</ul>\n<p>如果在用<code>$?</code>变量提取函数的返回值之前使用了其他命令，函数的返回值就会丢失。任何大于255的整数值都会产生一个错误值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ ./test4</span><br><span class=\"line\">Enter a value: 200</span><br><span class=\"line\">doubling the value</span><br><span class=\"line\">The new value is 144</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用函数输出\"><a href=\"#使用函数输出\" class=\"headerlink\" title=\"使用函数输出\"></a>使用函数输出</h3><p>如同可以将命令的输出保存到shell变量一样，我们也可以对函数的输出采用同样的处理办法。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result=`db1`</span><br></pre></td></tr></table></figure>\n<p>这个命令会将<code>db1</code>函数的输出赋值给<code>$result</code>变量。下面是脚本的一个实例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test4b</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using the <span class=\"built_in\">echo</span> to <span class=\"built_in\">return</span> a value</span></span><br><span class=\"line\"></span><br><span class=\"line\">function db1 &#123;</span><br><span class=\"line\">trueread -p \"Enter a value: \" value</span><br><span class=\"line\">trueecho $[ $value * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">result=$(db1)</span><br><span class=\"line\">echo \"The new value is $result\"</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test4b</span><br><span class=\"line\">Enter a value: 200</span><br><span class=\"line\">The new value is 400</span><br></pre></td></tr></table></figure>\n<p>函数会用<code>echo</code>语句来显示计算的结果，该脚本会查看<code>db1</code>函数的输出，而不是查看退出状态码。</p>\n<blockquote>\n<p>通过这种技术，我们还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。</p>\n</blockquote>\n<h2 id=\"在函数中使用变量\"><a href=\"#在函数中使用变量\" class=\"headerlink\" title=\"在函数中使用变量\"></a>在函数中使用变量</h2><p>在函数中使用变量时，我们需要注意它们的定义方式以及处理方法。这是shell脚本常见错误的根源。</p>\n<h3 id=\"向函数传递参数\"><a href=\"#向函数传递参数\" class=\"headerlink\" title=\"向函数传递参数\"></a>向函数传递参数</h3><p>函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在<code>$0</code>变量中定义，函数命令行上的任何参数都会通过<code>$1</code>、<code>$2</code>定义。也可以用特殊变量<code>$#</code>来判断给函数的参数数目。</p>\n<p>指定函数时，必须将参数和函数放在同一行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func1 $value1 10</span><br></pre></td></tr></table></figure>\n<p>然后函数可以用参数环境变量来获得参数值。下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test5</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> passing parameters to a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function addem &#123;</span><br><span class=\"line\">trueif [ $# -eq 0 ] || [ $# -gt 2 ]</span><br><span class=\"line\">truethen</span><br><span class=\"line\">truetrueecho -1</span><br><span class=\"line\">trueelif [ $# -eq 1 ]</span><br><span class=\"line\">truethen</span><br><span class=\"line\">truetrueecho $[ $1 + $1 ]</span><br><span class=\"line\">trueelse</span><br><span class=\"line\">truetrueecho $[ $1 + $2 ]</span><br><span class=\"line\">truefi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">echo -n \"Adding 10 and 15: \"</span><br><span class=\"line\">value=$(addem 10 15)</span><br><span class=\"line\">echo $value</span><br><span class=\"line\">echo -n \"Let's try adding just one number: \"</span><br><span class=\"line\">value=$(addem 10)</span><br><span class=\"line\">echo $value</span><br><span class=\"line\">echo -n \"Now trying adding no numbers: \"</span><br><span class=\"line\">value=$(addem)</span><br><span class=\"line\">echo $value</span><br><span class=\"line\">echo -n \"Finally, try add three numbers: \"</span><br><span class=\"line\">value=$(addem 10 15 20)</span><br><span class=\"line\">echo $value</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test5</span><br><span class=\"line\">Adding 10 and 15: 25</span><br><span class=\"line\">Let's try adding just one number: 20</span><br><span class=\"line\">Now trying adding no numbers: -1</span><br><span class=\"line\">Finally, try add three numbers: -1</span><br></pre></td></tr></table></figure>\n<p><code>addem</code>函数首先会检查脚本传给它的参数数目。如果没有任何参数，或者参数多于两个，<code>addem</code>会返回<code>-1</code>。如果只有一个参数，<code>addem</code>会将参数与自身相加。如果有两个参数，<code>addem</code>会将它们相加。</p>\n<p><strong>由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。</strong>下面是个失败的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat badtest1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> trying to access script parameters inside a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function badfunc1 &#123;</span><br><span class=\"line\">trueecho $[ $1 * $2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $# -eq 2 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">truevalue=$(badfunc1)</span><br><span class=\"line\">trueecho \"The result is $value\"</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"Usage: badtest1 a b\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./badtest1 10 15</span><br><span class=\"line\">./badtest1: 行 5: *  : 语法错误: 需要操作数 (错误符号是 \"*  \")</span><br><span class=\"line\">The result is</span><br></pre></td></tr></table></figure>\n<p>尽管函数也使用了<code>$1</code>与<code>$2</code>变量，但它们与主脚本中的变量不同，要使用它们必须在调用函数时手动传入。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test6</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> trying to access script parameters inside a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function func1 &#123;</span><br><span class=\"line\">trueecho $[ $1 * $2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $# -eq 2 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">truevalue=$(func1 $1 $2)</span><br><span class=\"line\">trueecho \"The result is $value\"</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"Usage: badtest1 a b\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test6</span><br><span class=\"line\">Usage: badtest1 a b</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test6 10 15</span><br><span class=\"line\">The result is 150</span><br></pre></td></tr></table></figure>\n<h3 id=\"在函数中处理变量\"><a href=\"#在函数中处理变量\" class=\"headerlink\" title=\"在函数中处理变量\"></a>在函数中处理变量</h3><p><strong>作用域</strong>是变量可见的区域。对脚本的其他部分而言，函数定义的变量是隐藏的。这些概念其实是编程语言中通用的，想必学过一些其他编程的朋友早已有所理解了。</p>\n<p>函数使用两种类型的变量：</p>\n<ul>\n<li>全局变量</li>\n<li>局部变量</li>\n</ul>\n<h4 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h4><p><strong>全局变量</strong>是在shell脚本中任何地方都有效的变量，如果你在函数内定义了一个全局变量，也可以在脚本的主体部分读取它的值。</p>\n<p>默认情况下，我们在脚本中定义的任何变量都是全局变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test7</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using a global variable to pass a value</span></span><br><span class=\"line\"></span><br><span class=\"line\">function db1 &#123;</span><br><span class=\"line\">truevalue=$[ $value * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">read -p \"Enter a value: \" value</span><br><span class=\"line\">db1</span><br><span class=\"line\">echo \"The new value is: $value\"</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test7</span><br><span class=\"line\">Enter a value: 10</span><br><span class=\"line\">The new value is: 20</span><br></pre></td></tr></table></figure>\n<p>无论变量在函数内外定义，在脚本中引用该变量都有效。这样其实非常危险，尤其是如果你想在不同的shell脚本中使用函数的话。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。下面是一个如何搞砸的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat badtest2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> demonstrating a bad use of variable</span></span><br><span class=\"line\"></span><br><span class=\"line\">function func1 &#123;</span><br><span class=\"line\">truetemp=$[ $value + 5 ]</span><br><span class=\"line\">trueresult=$[ $temp * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">temp=4</span><br><span class=\"line\">value=6</span><br><span class=\"line\"></span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"The result is $result\"</span><br><span class=\"line\">if [ $temp -gt $value ]</span><br><span class=\"line\">then</span><br><span class=\"line\">trueecho \"temp is larger\"</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"temp is smaller\"</span><br><span class=\"line\">fi</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./badtest2</span><br><span class=\"line\">The result is 22</span><br><span class=\"line\">temp is larger</span><br></pre></td></tr></table></figure>\n<p>由于函数中用到了<code>$temp</code>变量，它的值在脚本中使用时受到了影响，产生了意想不到的后果。后面我们会学习如何处理这样的问题。</p>\n<h4 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h4><p>无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。<strong>我们只需要在变量声明前加上local关键字就可以了</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local temp</span><br></pre></td></tr></table></figure>\n<p>也可以在变量赋值时使用local关键字：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local temp=$[ $value + 5 ]</span><br></pre></td></tr></table></figure>\n<p><code>local</code>关键字保证了变量只局限于该函数中。我们再回看刚才的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test8</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> demonstrating the <span class=\"built_in\">local</span> keyword</span></span><br><span class=\"line\"></span><br><span class=\"line\">function func1 &#123;</span><br><span class=\"line\">truelocal temp=$[ $value + 5 ]</span><br><span class=\"line\">trueresult=$[ $temp * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">temp=4</span><br><span class=\"line\">value=6</span><br><span class=\"line\"></span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"The result is $result\"</span><br><span class=\"line\">if [ $temp -gt $value ]</span><br><span class=\"line\">then</span><br><span class=\"line\">trueecho \"temp is larger\"</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"temp is smaller\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test8</span><br><span class=\"line\">The result is 22</span><br><span class=\"line\">temp is smaller</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组变量和函数\"><a href=\"#数组变量和函数\" class=\"headerlink\" title=\"数组变量和函数\"></a>数组变量和函数</h2><p>在函数中使用数组变量值有点麻烦，还需要一些特殊考虑。下面我们使用一种方法来解决问题。</p>\n<h3 id=\"向函数传数组参数\"><a href=\"#向函数传数组参数\" class=\"headerlink\" title=\"向函数传数组参数\"></a>向函数传数组参数</h3><p>这个方法有点不好理解，将数组变量当做单个参数传递的话不起作用，下面我们看一个bad例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat badtest3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> trying to pass an array variable</span></span><br><span class=\"line\"></span><br><span class=\"line\">function testit &#123;</span><br><span class=\"line\">trueecho \"The parameters are: $@\"</span><br><span class=\"line\">truethisarray=$1</span><br><span class=\"line\">trueecho \"The received array is $&#123;thisarray[*]&#125;\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myarray=(1 2 3 4 5)</span><br><span class=\"line\">echo \"The original array is: $&#123;myarray[*]&#125;\"</span><br><span class=\"line\">testit $myarray</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./badtest3</span><br><span class=\"line\">The original array is: 1 2 3 4 5</span><br><span class=\"line\">The parameters are: 1</span><br><span class=\"line\">The received array is 1</span><br></pre></td></tr></table></figure>\n<p>可以看到，当我们将数组变量当做函数参数传递时，函数只会取数组变量的第一个值。</p>\n<p>针对这个问题，我们的一个解决方案是将数组变量全部拆分为单个值，然后作为参数传入函数，在函数内部又重新对这些值进行组装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test9</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> array variable to <span class=\"keyword\">function</span> <span class=\"built_in\">test</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function testit &#123;</span><br><span class=\"line\">truelocal newarray</span><br><span class=\"line\">truenewarray=(`echo \"$@\"`)</span><br><span class=\"line\">trueecho \"The new array value is: $&#123;newarray[*]&#125;\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myarray=(1 2 3 4 5)</span><br><span class=\"line\">echo $&#123;myarray[*]&#125;</span><br><span class=\"line\">testit $&#123;myarray[*]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test9</span><br><span class=\"line\">1 2 3 4 5</span><br><span class=\"line\">The new array value is: 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n<h3 id=\"从函数中返回数组\"><a href=\"#从函数中返回数组\" class=\"headerlink\" title=\"从函数中返回数组\"></a>从函数中返回数组</h3><p>采用与上面类似的方法，函数用<code>echo</code>语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test10</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> returning an array value</span></span><br><span class=\"line\"></span><br><span class=\"line\">function arraydblr &#123;</span><br><span class=\"line\">truelocal origarray</span><br><span class=\"line\">truelocal newarray</span><br><span class=\"line\">truelocal elements</span><br><span class=\"line\">truelocal i</span><br><span class=\"line\">trueorigarray=($(echo \"$@\"))</span><br><span class=\"line\">truenewarray=($(echo \"$@\"))</span><br><span class=\"line\">trueelements=$[ $# - 1 ]</span><br><span class=\"line\">truefor (( i = 0; i &lt;= $elements; i++ ))</span><br><span class=\"line\">true&#123;</span><br><span class=\"line\"><span class=\"meta\">\t\tnewarray[$</span><span class=\"bash\">i]=$[ <span class=\"variable\">$&#123;origarray[$i]&#125;</span> * 2]</span></span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">trueecho $&#123;newarray[*]&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myarray=(1 2 3 4 5)</span><br><span class=\"line\">echo \"The orignal array is $&#123;myarray[*]&#125;\"</span><br><span class=\"line\">arg1=$(echo $&#123;myarray[*]&#125;)</span><br><span class=\"line\">result=($(arraydblr $arg1))</span><br><span class=\"line\">echo \"The new array is: $&#123;result[*]&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test10</span><br><span class=\"line\">The orignal array is 1 2 3 4 5</span><br><span class=\"line\">The new array is: 2 4 6 8 10</span><br></pre></td></tr></table></figure>\n<p>该脚本用<code>$arg1</code>变量将数组值传给<code>arraydblr</code>函数。该函数将数组重组到新的数组变量中，生成输出数组变量的一个副本，然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。</p>\n<h2 id=\"函数递归\"><a href=\"#函数递归\" class=\"headerlink\" title=\"函数递归\"></a>函数递归</h2><p>局部函数变量的一个特征是<strong>自成体系</strong>。这个特性使得函数可以递归地调用，也就是函数可以调用自己来得到结果。<strong>通常递归函数都有一个最终可以迭代到的基准值。</strong></p>\n<p>递归算法的经典例子是计算阶乘：一个数的阶乘是该数之前的所有数乘以该数的值。</p>\n<p>比如5的阶乘：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span>! = <span class=\"number\">1</span> * <span class=\"number\">2</span> * <span class=\"number\">3</span> * <span class=\"number\">4</span> * <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>方程可以简化为通用形式：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">x</span>! = <span class=\"keyword\">x</span> * (<span class=\"keyword\">x</span><span class=\"number\">-1</span>)!</span><br></pre></td></tr></table></figure>\n<p>这可以用简单的递归脚本表达为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial &#123;</span><br><span class=\"line\">  if [ $1 -eq 1 ]</span><br><span class=\"line\">  then</span><br><span class=\"line\">  \techo 1</span><br><span class=\"line\">  else</span><br><span class=\"line\">  \tlocal temp=$[ $1 - 1 ]</span><br><span class=\"line\">  \tlocal result=`factorial $temp`</span><br><span class=\"line\">  \techo $[ $result * $1 ]</span><br><span class=\"line\">  fi</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面用它来进行计算：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test11</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using recursion</span></span><br><span class=\"line\"></span><br><span class=\"line\">function factorial &#123;</span><br><span class=\"line\">trueif [ $1 -eq 1 ]</span><br><span class=\"line\">truethen</span><br><span class=\"line\">truetrueecho 1</span><br><span class=\"line\">trueelse</span><br><span class=\"line\">truetruelocal temp=$[ $1 - 1]</span><br><span class=\"line\">truetruelocal result=`factorial $temp`</span><br><span class=\"line\">truetrueecho $[ $result * $1 ]</span><br><span class=\"line\">truefi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">read -p \"Enter value: \" value</span><br><span class=\"line\">result=$(factorial $value)</span><br><span class=\"line\">echo \"The factorial of $value is: $result\"</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test11</span><br><span class=\"line\">Enter value: 5</span><br><span class=\"line\">The factorial of 5 is: 120</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建库\"><a href=\"#创建库\" class=\"headerlink\" title=\"创建库\"></a>创建库</h2><p>如果你碰巧要在多个脚本中使用同一段代码呢？显然在每个脚本中都定义同样的函数太麻烦了，一种解决方法就是创建<strong>库文件</strong>，然后在脚本中引用它。</p>\n<p><strong>第一步</strong>是创建一个包含脚本中所需函数的公用库文件。下面是一个叫做myfuncs的库文件，定义了3个简单的函数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat myfuncs</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> my script <span class=\"built_in\">functions</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function addem &#123;</span><br><span class=\"line\">trueecho $[ $1 + $2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function multem &#123;</span><br><span class=\"line\">trueecho $[ $1 * $2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function divem &#123;</span><br><span class=\"line\">trueif [ $2 -ne 0 ]</span><br><span class=\"line\">truethen</span><br><span class=\"line\">truetrueecho $[ $1 / $2 ]</span><br><span class=\"line\">trueelse</span><br><span class=\"line\">truetrueecho -1</span><br><span class=\"line\">truefi</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>下一步</strong>是在用到这些函数的脚本文件中包含myfuncs库文件。</p>\n<p>这里有点复杂，主要问题出在shell函数的作用域上。如果我们尝试像普通脚本一样运行库文件，函数不会出现在脚本中。</p>\n<p>使用函数库的<strong>关键</strong>在于<code>source</code>命令。<strong><code>source</code>命令会在当前shell上下文中执行命令，而不是创建一个新的shell。</strong>通过<code>source</code>命令就可以使用库中的函数了。</p>\n<p><code>source</code>命令有一个<strong>快捷别名</strong>，称为<strong>点操作符</strong>。要在shell脚本中运行myfuncs库文件，只需要使用下面这行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">. ./myfuncs</span><br></pre></td></tr></table></figure>\n<p>注意第一个点是点操作符，而第二个点指向当前目录（相对路径）。</p>\n<p>下面这个例子假定myfuncs库文件与要使用它的脚本位于同一目录，不然需要使用相对应的路径进行访问。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test12</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using <span class=\"built_in\">functions</span> defined <span class=\"keyword\">in</span> a library file</span></span><br><span class=\"line\"></span><br><span class=\"line\">. ./myfuncs</span><br><span class=\"line\"></span><br><span class=\"line\">value1=10</span><br><span class=\"line\">value2=5</span><br><span class=\"line\">result1=$(addem $value1 $value2)</span><br><span class=\"line\">result2=$(multem $value1 $value2)</span><br><span class=\"line\">result3=$(divem $value1 $value2)</span><br><span class=\"line\">echo \"The result of adding them is: $result1\"</span><br><span class=\"line\">echo \"The result of multiplying them is: $result2\"</span><br><span class=\"line\">echo \"The result of dividing them is: $result3\"</span><br></pre></td></tr></table></figure>\n<p>运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ ./test12</span><br><span class=\"line\">The result of adding them is: 15</span><br><span class=\"line\">The result of multiplying them is: 50</span><br><span class=\"line\">The result of dividing them is: 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"在命令行上使用函数\"><a href=\"#在命令行上使用函数\" class=\"headerlink\" title=\"在命令行上使用函数\"></a>在命令行上使用函数</h2><p>有时候有必要在命令行界面的提示符下直接使用这些函数。这是个灰常不错的功能，在shell中定义的函数可以在整个系统中使用它，无需担心脚本是不是在PATH环境变量中。</p>\n<p><strong>重点在于让shell能够识别这些函数</strong>。以下有几种方法可以实现。</p>\n<h3 id=\"在命令行上创建函数\"><a href=\"#在命令行上创建函数\" class=\"headerlink\" title=\"在命令行上创建函数\"></a>在命令行上创建函数</h3><p>shell会解释用户输入的命令，所以可以在命令行上直接定义一个函数。</p>\n<p>有两种方法。</p>\n<p><strong>一种是采用单行方式定义函数。</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ function divem &#123; echo $[ $1 / $2 ]; &#125;</span><br><span class=\"line\">wsx@wsx:~/tmp$ divem 100 5</span><br><span class=\"line\">20</span><br></pre></td></tr></table></figure>\n<p>当在命令行上定义函数时，你<strong>必须</strong>记得在每个命令后面加个分号，这样shell能识别命令的起始。</p>\n<p><strong>另一种是采用多行方式来定义函数。</strong>在定义时bash shell会使用次提示符来提示输入更多命令。这种方法不必在命令末尾加分号，只要按回车键就可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ function multem &#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> ]</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#125;</span></span><br><span class=\"line\">wsx@wsx:~/tmp$ multem 2 5</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：在命令行上创建函数不要跟内建命令重名，函数会覆盖原来的命令。</p>\n<h3 id=\"在-bashrc文件中定义函数\"><a href=\"#在-bashrc文件中定义函数\" class=\"headerlink\" title=\"在.bashrc文件中定义函数\"></a>在.bashrc文件中定义函数</h3><p>在bash shell每次启动时都会在主目录下查找<code>.bashrc</code>文件，不管是交互式shell还是shell中启动的新shell。所以我们可以将函数写入该文件，或者在脚本中写入命令读取函数文件。操作前面都讲过，不再赘述，<strong>只要把该文件当做脚本对待就可以了</strong>。理解这一点这部分就会了。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p><strong>在开源的世界里，共享代码才是关键，而这一点同样适用于脚本函数。</strong>我们可以下载大量各式各样的函数然后用于自己的应用程序。</p>\n<p>这一节介绍<strong>如何下载、安装和使用GNU shtool shell脚本函数库</strong>。shtool库提供了一些简单的shell脚本函数，可以用来完成日常的shell功能。</p>\n<h3 id=\"下载和安装\"><a href=\"#下载和安装\" class=\"headerlink\" title=\"下载和安装\"></a>下载和安装</h3><p>shtool软件包下载地址：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz # China</span><br></pre></td></tr></table></figure>\n<p>可以浏览器或者命令行下载：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ wget http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz</span><br><span class=\"line\">--2017-11-24 00:34:32--  http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz</span><br><span class=\"line\">正在解析主机 mirrors.ustc.edu.cn (mirrors.ustc.edu.cn)... 202.141.176.110, 218.104.71.170, 2001:da8:d800:95::110</span><br><span class=\"line\">正在连接 mirrors.ustc.edu.cn (mirrors.ustc.edu.cn)|202.141.176.110|:80... 已连接。</span><br><span class=\"line\">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class=\"line\">长度： 97033 (95K) [application/gzip]</span><br><span class=\"line\">正在保存至: “shtool-2.0.8.tar.gz”</span><br><span class=\"line\"></span><br><span class=\"line\">shtool-2.0.8.tar.gz 100%[===================&gt;]  94.76K  --.-KB/s    用时 0.1s</span><br><span class=\"line\"></span><br><span class=\"line\">2017-11-24 00:34:32 (783 KB/s) - 已保存 “shtool-2.0.8.tar.gz” [97033/97033])</span><br></pre></td></tr></table></figure>\n<p>复制到主目录，然后用<code>tar</code>命令提取文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~$ tar -zxvf shtool-2.0.8.tar.gz</span><br><span class=\"line\">shtool-2.0.8/AUTHORS</span><br><span class=\"line\">shtool-2.0.8/COPYING</span><br><span class=\"line\">shtool-2.0.8/ChangeLog</span><br><span class=\"line\">shtool-2.0.8/INSTALL</span><br><span class=\"line\">shtool-2.0.8/Makefile.in</span><br><span class=\"line\">shtool-2.0.8/NEWS</span><br><span class=\"line\">shtool-2.0.8/RATIONAL</span><br><span class=\"line\">shtool-2.0.8/README</span><br><span class=\"line\">shtool-2.0.8/THANKS</span><br><span class=\"line\">shtool-2.0.8/VERSION</span><br><span class=\"line\">shtool-2.0.8/configure</span><br><span class=\"line\">shtool-2.0.8/configure.ac</span><br><span class=\"line\">shtool-2.0.8/sh.arx</span><br><span class=\"line\">shtool-2.0.8/sh.common</span><br><span class=\"line\">shtool-2.0.8/sh.echo</span><br><span class=\"line\">shtool-2.0.8/sh.fixperm</span><br><span class=\"line\">shtool-2.0.8/sh.install</span><br><span class=\"line\">shtool-2.0.8/sh.mdate</span><br><span class=\"line\">shtool-2.0.8/sh.mkdir</span><br><span class=\"line\">shtool-2.0.8/sh.mkln</span><br><span class=\"line\">shtool-2.0.8/sh.mkshadow</span><br><span class=\"line\">shtool-2.0.8/sh.move</span><br><span class=\"line\">shtool-2.0.8/sh.path</span><br><span class=\"line\">shtool-2.0.8/sh.platform</span><br><span class=\"line\">shtool-2.0.8/sh.prop</span><br><span class=\"line\">shtool-2.0.8/sh.rotate</span><br><span class=\"line\">shtool-2.0.8/sh.scpp</span><br><span class=\"line\">shtool-2.0.8/sh.slo</span><br><span class=\"line\">shtool-2.0.8/sh.subst</span><br><span class=\"line\">shtool-2.0.8/sh.table</span><br><span class=\"line\">shtool-2.0.8/sh.tarball</span><br><span class=\"line\">shtool-2.0.8/sh.version</span><br><span class=\"line\">shtool-2.0.8/shtool.m4</span><br><span class=\"line\">shtool-2.0.8/shtool.pod</span><br><span class=\"line\">shtool-2.0.8/shtool.spec</span><br><span class=\"line\">shtool-2.0.8/shtoolize.in</span><br><span class=\"line\">shtool-2.0.8/shtoolize.pod</span><br><span class=\"line\">shtool-2.0.8/test.db</span><br><span class=\"line\">shtool-2.0.8/test.sh</span><br></pre></td></tr></table></figure>\n<p>接下来可以构建shell脚本库文件了。</p>\n<h3 id=\"构建库\"><a href=\"#构建库\" class=\"headerlink\" title=\"构建库\"></a>构建库</h3><p>shtool文件必须针对特定的Linux环境进行配置。<strong>配置工作必须使用标准的configure和make命令</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~$ cd shtool-2.0.8/</span><br><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ ./configure</span><br><span class=\"line\">Configuring GNU shtool (Portable Shell Tool), version 2.0.8 (18-Jul-2008)</span><br><span class=\"line\">Copyright (c) 1994-2008 Ralf S. Engelschall &lt;rse@engelschall.com&gt;</span><br><span class=\"line\">checking whether make sets $(MAKE)... yes</span><br><span class=\"line\">checking for perl interpreter... /usr/bin/perl</span><br><span class=\"line\">checking for pod2man conversion tool... /usr/bin/pod2man</span><br><span class=\"line\">configure: creating ./config.status</span><br><span class=\"line\">config.status: creating Makefile</span><br><span class=\"line\">config.status: creating shtoolize</span><br><span class=\"line\">config.status: executing adjustment commands</span><br><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ make</span><br><span class=\"line\">building program shtool</span><br><span class=\"line\">./shtoolize -o shtool all</span><br><span class=\"line\">Use of assignment to $[ is deprecated at ./shtoolize line 60.</span><br><span class=\"line\">Generating shtool...(echo 11808/12742 bytes)...(mdate 3695/4690 bytes)...(table 1818/2753 bytes)...(prop 1109/2038 bytes)...(move 2685/3614 bytes)...(install 4567/5495 bytes)...(mkdir 2904/3821 bytes)...(mkln 4429/5361 bytes)...(mkshadow 3260/4193 bytes)...(fixperm 1471/2403 bytes)...(rotate 13425/14331 bytes)...(tarball 5297/6214 bytes)...(subst 5255/6180 bytes)...(platform 21739/22662 bytes)...(arx 2401/3312 bytes)...(slo 4139/5066 bytes)...(scpp 6295/7206 bytes)...(version 10234/11160 bytes)...(path 4041/4952 bytes)</span><br><span class=\"line\">building manpage shtoolize.1</span><br><span class=\"line\">building manpage shtool.1</span><br><span class=\"line\">building manpage shtool-echo.1</span><br><span class=\"line\">building manpage shtool-mdate.1</span><br><span class=\"line\">shtool-mdate.tmp around line 222: You forgot a '=back' before '=head1'</span><br><span class=\"line\">POD document had syntax errors at /usr/bin/pod2man line 71.</span><br><span class=\"line\">building manpage shtool-table.1</span><br><span class=\"line\">building manpage shtool-prop.1</span><br><span class=\"line\">building manpage shtool-move.1</span><br><span class=\"line\">building manpage shtool-install.1</span><br><span class=\"line\">building manpage shtool-mkdir.1</span><br><span class=\"line\">shtool-mkdir.tmp around line 186: You forgot a '=back' before '=head1'</span><br><span class=\"line\">POD document had syntax errors at /usr/bin/pod2man line 71.</span><br><span class=\"line\">building manpage shtool-mkln.1</span><br><span class=\"line\">building manpage shtool-mkshadow.1</span><br><span class=\"line\">shtool-mkshadow.tmp around line 191: You forgot a '=back' before '=head1'</span><br><span class=\"line\">POD document had syntax errors at /usr/bin/pod2man line 71.</span><br><span class=\"line\">building manpage shtool-fixperm.1</span><br><span class=\"line\">building manpage shtool-rotate.1</span><br><span class=\"line\">building manpage shtool-tarball.1</span><br><span class=\"line\">building manpage shtool-subst.1</span><br><span class=\"line\">building manpage shtool-platform.1</span><br><span class=\"line\">building manpage shtool-arx.1</span><br><span class=\"line\">building manpage shtool-slo.1</span><br><span class=\"line\">building manpage shtool-scpp.1</span><br><span class=\"line\">building manpage shtool-version.1</span><br><span class=\"line\">building manpage shtool-path.1</span><br></pre></td></tr></table></figure>\n<p><code>configure</code>命令会检查构建shtool库文件所必需的软件。一旦发现所需工具，它会使用工具路径修改配置文件。</p>\n<p><code>make</code>命令负责构建shtool库文件。最终的结果（shtool）是一个完整的库软件包。</p>\n<p>我们可以测试下这个库文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ make test</span><br><span class=\"line\">Running test suite:</span><br><span class=\"line\">echo..........FAILED</span><br><span class=\"line\">+---Test------------------------------</span><br><span class=\"line\">| test \".`../shtool echo foo bar quux`\" = \".foo bar quux\" || exit 1</span><br><span class=\"line\">| bytes=`../shtool echo -n foo | wc -c | awk '&#123; printf(\"%s\", $1); &#125;'` || exit 1</span><br><span class=\"line\">| test \".$bytes\" = .3 || exit 1</span><br><span class=\"line\">| bytes=`../shtool echo '\\1' | wc -c | awk '&#123; printf(\"%s\", $1); &#125;'` || exit 1</span><br><span class=\"line\">| test \".$bytes\" = .3 || exit 1</span><br><span class=\"line\">| exit 0</span><br><span class=\"line\">+---Trace-----------------------------</span><br><span class=\"line\">| + ../shtool echo foo bar quux</span><br><span class=\"line\">| + test .foo bar quux = .foo bar quux</span><br><span class=\"line\">| + ../shtool echo -n foo</span><br><span class=\"line\">| + wc -c</span><br><span class=\"line\">| + awk &#123; printf(\"%s\", $1); &#125;</span><br><span class=\"line\">| + bytes=3</span><br><span class=\"line\">| + test .3 = .3</span><br><span class=\"line\">| + ../shtool echo \\1</span><br><span class=\"line\">| + wc -c</span><br><span class=\"line\">| + awk &#123; printf(\"%s\", $1); &#125;</span><br><span class=\"line\">| + bytes=2</span><br><span class=\"line\">| + test .2 = .3</span><br><span class=\"line\">| + exit 1</span><br><span class=\"line\">+-------------------------------------</span><br><span class=\"line\">mdate.........ok</span><br><span class=\"line\">table.........ok</span><br><span class=\"line\">prop..........ok</span><br><span class=\"line\">move..........ok</span><br><span class=\"line\">install.......ok</span><br><span class=\"line\">mkdir.........ok</span><br><span class=\"line\">mkln..........ok</span><br><span class=\"line\">mkshadow......ok</span><br><span class=\"line\">fixperm.......ok</span><br><span class=\"line\">rotate........ok</span><br><span class=\"line\">tarball.......ok</span><br><span class=\"line\">subst.........ok</span><br><span class=\"line\">platform......ok</span><br><span class=\"line\">arx...........ok</span><br><span class=\"line\">slo...........ok</span><br><span class=\"line\">scpp..........ok</span><br><span class=\"line\">version.......ok</span><br><span class=\"line\">path..........ok</span><br><span class=\"line\">FAILED: passed: 18/19, failed: 1/19</span><br></pre></td></tr></table></figure>\n<p>（有一个没通过～）</p>\n<p>如果全部通过测试，就可以将库安装到系统中，这样所有脚本都能使用这个库了。</p>\n<p>要完成安装，需要使用<code>make</code>命令的<code>install</code>选项。需要使用root权限。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ make install</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/bin</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/share/man/man1</span><br><span class=\"line\">mkdir: cannot create directory '/usr/local/share/man/man1': Permission denied</span><br><span class=\"line\">chmod: cannot access '/usr/local/share/man/man1': No such file or directory</span><br><span class=\"line\">Makefile:94: recipe for target 'install' failed</span><br><span class=\"line\">make: *** [install] Error 1</span><br><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ sudo make install</span><br><span class=\"line\">[sudo] wsx 的密码：</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/bin</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/share/man/man1</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/share/aclocal</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/share/shtool</span><br><span class=\"line\">./shtool install -c -m 755 shtool /usr/local/bin/shtool</span><br><span class=\"line\">./shtool install -c -m 755 shtoolize /usr/local/bin/shtoolize</span><br><span class=\"line\">./shtool install -c -m 644 shtoolize.1 /usr/local/share/man/man1/shtoolize.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool.1 /usr/local/share/man/man1/shtool.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-echo.1 /usr/local/share/man/man1/shtool-echo.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-mdate.1 /usr/local/share/man/man1/shtool-mdate.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-table.1 /usr/local/share/man/man1/shtool-table.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-prop.1 /usr/local/share/man/man1/shtool-prop.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-move.1 /usr/local/share/man/man1/shtool-move.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-install.1 /usr/local/share/man/man1/shtool-install.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-mkdir.1 /usr/local/share/man/man1/shtool-mkdir.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-mkln.1 /usr/local/share/man/man1/shtool-mkln.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-mkshadow.1 /usr/local/share/man/man1/shtool-mkshadow.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-fixperm.1 /usr/local/share/man/man1/shtool-fixperm.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-rotate.1 /usr/local/share/man/man1/shtool-rotate.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-tarball.1 /usr/local/share/man/man1/shtool-tarball.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-subst.1 /usr/local/share/man/man1/shtool-subst.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-platform.1 /usr/local/share/man/man1/shtool-platform.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-arx.1 /usr/local/share/man/man1/shtool-arx.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-slo.1 /usr/local/share/man/man1/shtool-slo.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-scpp.1 /usr/local/share/man/man1/shtool-scpp.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-version.1 /usr/local/share/man/man1/shtool-version.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-path.1 /usr/local/share/man/man1/shtool-path.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool.m4 /usr/local/share/aclocal/shtool.m4</span><br><span class=\"line\">./shtool install -c -m 644 sh.common /usr/local/share/shtool/sh.common</span><br><span class=\"line\">./shtool install -c -m 644 sh.echo /usr/local/share/shtool/sh.echo</span><br><span class=\"line\">./shtool install -c -m 644 sh.mdate /usr/local/share/shtool/sh.mdate</span><br><span class=\"line\">./shtool install -c -m 644 sh.table /usr/local/share/shtool/sh.table</span><br><span class=\"line\">./shtool install -c -m 644 sh.prop /usr/local/share/shtool/sh.prop</span><br><span class=\"line\">./shtool install -c -m 644 sh.move /usr/local/share/shtool/sh.move</span><br><span class=\"line\">./shtool install -c -m 644 sh.install /usr/local/share/shtool/sh.install</span><br><span class=\"line\">./shtool install -c -m 644 sh.mkdir /usr/local/share/shtool/sh.mkdir</span><br><span class=\"line\">./shtool install -c -m 644 sh.mkln /usr/local/share/shtool/sh.mkln</span><br><span class=\"line\">./shtool install -c -m 644 sh.mkshadow /usr/local/share/shtool/sh.mkshadow</span><br><span class=\"line\">./shtool install -c -m 644 sh.fixperm /usr/local/share/shtool/sh.fixperm</span><br><span class=\"line\">./shtool install -c -m 644 sh.rotate /usr/local/share/shtool/sh.rotate</span><br><span class=\"line\">./shtool install -c -m 644 sh.tarball /usr/local/share/shtool/sh.tarball</span><br><span class=\"line\">./shtool install -c -m 644 sh.subst /usr/local/share/shtool/sh.subst</span><br><span class=\"line\">./shtool install -c -m 644 sh.platform /usr/local/share/shtool/sh.platform</span><br><span class=\"line\">./shtool install -c -m 644 sh.arx /usr/local/share/shtool/sh.arx</span><br><span class=\"line\">./shtool install -c -m 644 sh.slo /usr/local/share/shtool/sh.slo</span><br><span class=\"line\">./shtool install -c -m 644 sh.scpp /usr/local/share/shtool/sh.scpp</span><br><span class=\"line\">./shtool install -c -m 644 sh.version /usr/local/share/shtool/sh.version</span><br><span class=\"line\">./shtool install -c -m 644 sh.path /usr/local/share/shtool/sh.path</span><br></pre></td></tr></table></figure>\n<p>现在我们能在自己的shell脚本中使用这些函数咯。</p>\n<h3 id=\"shtool库函数\"><a href=\"#shtool库函数\" class=\"headerlink\" title=\"shtool库函数\"></a>shtool库函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Arx</td>\n<td>创建归档文件（包含一些扩展功能）</td>\n</tr>\n<tr>\n<td>Echo</td>\n<td>显示字符串，并提供了一些扩展构件</td>\n</tr>\n<tr>\n<td>fixperm</td>\n<td>改变目录树的文件权限</td>\n</tr>\n<tr>\n<td>install</td>\n<td>安装脚本或文件</td>\n</tr>\n<tr>\n<td>mdate</td>\n<td>显示文件或目录修改时间</td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td>创建一个或更多目录</td>\n</tr>\n<tr>\n<td>Mkln</td>\n<td>使用相对路径创建链接</td>\n</tr>\n<tr>\n<td>mkshadow</td>\n<td>创建一棵阴影树</td>\n</tr>\n<tr>\n<td>move</td>\n<td>带有替换功能的文件移动</td>\n</tr>\n<tr>\n<td>Path</td>\n<td>处理程序路径</td>\n</tr>\n<tr>\n<td>platform</td>\n<td>显示平台标识</td>\n</tr>\n<tr>\n<td>Prop</td>\n<td>显示一个带有动画效果的进度条</td>\n</tr>\n<tr>\n<td>rotate</td>\n<td>转置日志文件</td>\n</tr>\n<tr>\n<td>Scpp</td>\n<td>共享的C预处理器</td>\n</tr>\n<tr>\n<td>Slo</td>\n<td>根据库的类别，分离链接器选项</td>\n</tr>\n<tr>\n<td>Subst</td>\n<td>使用sed的替换操作</td>\n</tr>\n<tr>\n<td>Table</td>\n<td>以表格的形式显示由字段分隔的数据</td>\n</tr>\n<tr>\n<td>tarball</td>\n<td>从文件和目录中创建tar文件</td>\n</tr>\n<tr>\n<td>version</td>\n<td>创建版本信息文件</td>\n</tr>\n</tbody>\n</table>\n<p>每个shtool函数都包含大量的选项和参数。下面是使用格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shtool [option] [function [option] [args]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用库\"><a href=\"#使用库\" class=\"headerlink\" title=\"使用库\"></a>使用库</h3><p>我们能直接在命令行或者在自己构建的脚本中使用shtool的函数。</p>\n<p>下面是在脚本中使用的简单例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test13</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">shtool platform</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test13</span><br><span class=\"line\">Ubuntu 17.10 (AMD64)</span><br></pre></td></tr></table></figure>\n<p><code>platform</code>函数会返回Linux发行版以及系统使用的CPU硬件相关信息。</p>\n<p><code>prop</code>函数可以使用<code>\\</code>,<code>|</code>,<code>/</code>和<code>-</code>字符创建一个旋转的进度条。它可以告诉shell脚本用户目前正在处理一些后台处理工作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ ls -al /usr/bin | shtool prop -p \"waiting...\"</span><br><span class=\"line\">waiting...</span><br></pre></td></tr></table></figure>\n<p>在脚本学习中涉及到诸多的符号，在运行时我们可能会感觉到顺利，但自己写的时候往往会用不太对，推荐阅读一下常用的一些符号区分，像小括号、中括号、花括号等等。觉的不懂的可以看看<a href=\"http://blog.csdn.net/yangtalent1206/article/details/12996797\" target=\"_blank\" rel=\"noopener\">Linux<em>Bash脚本</em>单引号’双引号“”反引号`小括号()中括号[]大括号{}</a>以及相关的百度资料。</p>\n","site":{"data":{}},"excerpt":"<p><em>来源： Linux命令行与shell脚本编程大全</em></p>\n<p><strong>内容</strong></p>\n<blockquote>\n<ul>\n<li>基本的脚本函数</li>\n<li>返回值</li>\n<li>在函数中使用变量</li>\n<li>数组变量和函数</li>\n<li>函数递归</li>\n<li>创建库</li>\n<li>在命令行上使用函数</li>\n</ul>\n</blockquote>\n<p>我们可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用它了。</p>\n<p>下面我们来逐步了解如何创建自己的shell脚本函数并在应用中使用它们。</p>","more":"<h2 id=\"基本的脚本函数\"><a href=\"#基本的脚本函数\" class=\"headerlink\" title=\"基本的脚本函数\"></a>基本的脚本函数</h2><p>函数是一个脚本代码块，我们可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块，只要使用所起的函数名就行了。</p>\n<h3 id=\"创建函数\"><a href=\"#创建函数\" class=\"headerlink\" title=\"创建函数\"></a>创建函数</h3><p>有两种格式可以创建函数。第一种格式是使用关键字<code>function</code>，后跟分配给该代码块的函数名。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">funtion name&#123;</span><br><span class=\"line\">truecommands</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>name</code>属性定义了赋予函数的唯一名称，<code>commands</code>是构成函数的一条或多条bash shell命令。</p>\n<p>第二种格式更接近其他编程语言中定义函数的方式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name() &#123;</span><br><span class=\"line\">  commands</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用函数\"><a href=\"#使用函数\" class=\"headerlink\" title=\"使用函数\"></a>使用函数</h3><p>要使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using a <span class=\"keyword\">function</span> <span class=\"keyword\">in</span> a script</span></span><br><span class=\"line\"></span><br><span class=\"line\">function func1 &#123;</span><br><span class=\"line\">    echo \"This is an example of a function\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">count=1</span><br><span class=\"line\">while [ $count -le 5 ]</span><br><span class=\"line\">do</span><br><span class=\"line\">  func1</span><br><span class=\"line\">  count=$[ $count + 1 ]</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"This is the end of the loop\"</span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"Now, this is the end of the script\"</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test1</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">This is the end of the loop</span><br><span class=\"line\">This is an example of a function</span><br><span class=\"line\">Now, this is the end of the script</span><br></pre></td></tr></table></figure>\n<p>注意，定义函数名<code>func1</code>的后面一定要跟<code>{</code>有空格隔开，不然会报错。<strong>函数要先定义再使用，接触过编程的想必不陌生吧</strong>。</p>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>bash shell会把函数当做一个小型脚本，运行结束时会返回一个退出状态码，有3种不同的方法来为函数生成退出状态码。</p>\n<h3 id=\"默认退出状态码\"><a href=\"#默认退出状态码\" class=\"headerlink\" title=\"默认退出状态码\"></a>默认退出状态码</h3><p>默认函数的退出状态码是函数中最后一条命令返回的退出状态码。我们可以使用标准变量<code>$?</code>在函数执行结束后确定函数的状态码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the <span class=\"built_in\">exit</span> status of a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">func1() &#123;</span><br><span class=\"line\">trueecho \"trying to display a non-existent file\"</span><br><span class=\"line\">truels -l badfile</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"testing the function\"</span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"The exit status is: $?\"</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test2</span><br><span class=\"line\">testing the function</span><br><span class=\"line\">trying to display a non-existent file</span><br><span class=\"line\">ls: 无法访问'badfile': 没有那个文件或目录</span><br><span class=\"line\">The exit status is: 2</span><br></pre></td></tr></table></figure>\n<p>函数的退出状态码是2，说明函数的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行，我们来看看下面一个例子。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> testing the <span class=\"built_in\">exit</span> status of a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">func1()&#123;</span><br><span class=\"line\">truels -l badfile</span><br><span class=\"line\">trueecho \"This was a test of a bad command\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"testing the function:\"</span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"The exit status is: $?\"</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test3</span><br><span class=\"line\">testing the function:</span><br><span class=\"line\">ls: 无法访问'badfile': 没有那个文件或目录</span><br><span class=\"line\">This was a test of a bad command</span><br><span class=\"line\">The exit status is: 0</span><br></pre></td></tr></table></figure>\n<p>这次函数的退出状态码是0，尽管其中有一条命令没有正常运行。可见使用函数的默认退出状态码是很危险的，幸运的是，我们有几种办法解决它。</p>\n<h3 id=\"使用return命令\"><a href=\"#使用return命令\" class=\"headerlink\" title=\"使用return命令\"></a>使用return命令</h3><p><code>return</code>命令允许指定一个<strong>整数值</strong>来定义函数的退出状态码，从而提供了一种简单的途径来编码设定函数退出状态码。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using the <span class=\"built_in\">return</span> <span class=\"built_in\">command</span> <span class=\"keyword\">in</span> a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function db1 &#123;</span><br><span class=\"line\">trueread -p \"Enter a value: \" value</span><br><span class=\"line\">trueecho \"doubling the value\"</span><br><span class=\"line\">truereturn $[ $value * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db1</span><br><span class=\"line\">echo \"The new value is $?\"</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test4</span><br><span class=\"line\">Enter a value: 4</span><br><span class=\"line\">doubling the value</span><br><span class=\"line\">The new value is 8</span><br></pre></td></tr></table></figure>\n<p>当使用这种方法时要小心，记住下面两条技巧来避免问题：</p>\n<ul>\n<li>函数一结束就取返回值</li>\n<li>退出状态码必须是0~255</li>\n</ul>\n<p>如果在用<code>$?</code>变量提取函数的返回值之前使用了其他命令，函数的返回值就会丢失。任何大于255的整数值都会产生一个错误值。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ ./test4</span><br><span class=\"line\">Enter a value: 200</span><br><span class=\"line\">doubling the value</span><br><span class=\"line\">The new value is 144</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用函数输出\"><a href=\"#使用函数输出\" class=\"headerlink\" title=\"使用函数输出\"></a>使用函数输出</h3><p>如同可以将命令的输出保存到shell变量一样，我们也可以对函数的输出采用同样的处理办法。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result=`db1`</span><br></pre></td></tr></table></figure>\n<p>这个命令会将<code>db1</code>函数的输出赋值给<code>$result</code>变量。下面是脚本的一个实例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test4b</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using the <span class=\"built_in\">echo</span> to <span class=\"built_in\">return</span> a value</span></span><br><span class=\"line\"></span><br><span class=\"line\">function db1 &#123;</span><br><span class=\"line\">trueread -p \"Enter a value: \" value</span><br><span class=\"line\">trueecho $[ $value * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">result=$(db1)</span><br><span class=\"line\">echo \"The new value is $result\"</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test4b</span><br><span class=\"line\">Enter a value: 200</span><br><span class=\"line\">The new value is 400</span><br></pre></td></tr></table></figure>\n<p>函数会用<code>echo</code>语句来显示计算的结果，该脚本会查看<code>db1</code>函数的输出，而不是查看退出状态码。</p>\n<blockquote>\n<p>通过这种技术，我们还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。</p>\n</blockquote>\n<h2 id=\"在函数中使用变量\"><a href=\"#在函数中使用变量\" class=\"headerlink\" title=\"在函数中使用变量\"></a>在函数中使用变量</h2><p>在函数中使用变量时，我们需要注意它们的定义方式以及处理方法。这是shell脚本常见错误的根源。</p>\n<h3 id=\"向函数传递参数\"><a href=\"#向函数传递参数\" class=\"headerlink\" title=\"向函数传递参数\"></a>向函数传递参数</h3><p>函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在<code>$0</code>变量中定义，函数命令行上的任何参数都会通过<code>$1</code>、<code>$2</code>定义。也可以用特殊变量<code>$#</code>来判断给函数的参数数目。</p>\n<p>指定函数时，必须将参数和函数放在同一行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func1 $value1 10</span><br></pre></td></tr></table></figure>\n<p>然后函数可以用参数环境变量来获得参数值。下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test5</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> passing parameters to a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function addem &#123;</span><br><span class=\"line\">trueif [ $# -eq 0 ] || [ $# -gt 2 ]</span><br><span class=\"line\">truethen</span><br><span class=\"line\">truetrueecho -1</span><br><span class=\"line\">trueelif [ $# -eq 1 ]</span><br><span class=\"line\">truethen</span><br><span class=\"line\">truetrueecho $[ $1 + $1 ]</span><br><span class=\"line\">trueelse</span><br><span class=\"line\">truetrueecho $[ $1 + $2 ]</span><br><span class=\"line\">truefi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">echo -n \"Adding 10 and 15: \"</span><br><span class=\"line\">value=$(addem 10 15)</span><br><span class=\"line\">echo $value</span><br><span class=\"line\">echo -n \"Let's try adding just one number: \"</span><br><span class=\"line\">value=$(addem 10)</span><br><span class=\"line\">echo $value</span><br><span class=\"line\">echo -n \"Now trying adding no numbers: \"</span><br><span class=\"line\">value=$(addem)</span><br><span class=\"line\">echo $value</span><br><span class=\"line\">echo -n \"Finally, try add three numbers: \"</span><br><span class=\"line\">value=$(addem 10 15 20)</span><br><span class=\"line\">echo $value</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test5</span><br><span class=\"line\">Adding 10 and 15: 25</span><br><span class=\"line\">Let's try adding just one number: 20</span><br><span class=\"line\">Now trying adding no numbers: -1</span><br><span class=\"line\">Finally, try add three numbers: -1</span><br></pre></td></tr></table></figure>\n<p><code>addem</code>函数首先会检查脚本传给它的参数数目。如果没有任何参数，或者参数多于两个，<code>addem</code>会返回<code>-1</code>。如果只有一个参数，<code>addem</code>会将参数与自身相加。如果有两个参数，<code>addem</code>会将它们相加。</p>\n<p><strong>由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。</strong>下面是个失败的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat badtest1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> trying to access script parameters inside a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function badfunc1 &#123;</span><br><span class=\"line\">trueecho $[ $1 * $2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $# -eq 2 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">truevalue=$(badfunc1)</span><br><span class=\"line\">trueecho \"The result is $value\"</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"Usage: badtest1 a b\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./badtest1 10 15</span><br><span class=\"line\">./badtest1: 行 5: *  : 语法错误: 需要操作数 (错误符号是 \"*  \")</span><br><span class=\"line\">The result is</span><br></pre></td></tr></table></figure>\n<p>尽管函数也使用了<code>$1</code>与<code>$2</code>变量，但它们与主脚本中的变量不同，要使用它们必须在调用函数时手动传入。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test6</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> trying to access script parameters inside a <span class=\"keyword\">function</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function func1 &#123;</span><br><span class=\"line\">trueecho $[ $1 * $2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $# -eq 2 ]</span><br><span class=\"line\">then</span><br><span class=\"line\">truevalue=$(func1 $1 $2)</span><br><span class=\"line\">trueecho \"The result is $value\"</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"Usage: badtest1 a b\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test6</span><br><span class=\"line\">Usage: badtest1 a b</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test6 10 15</span><br><span class=\"line\">The result is 150</span><br></pre></td></tr></table></figure>\n<h3 id=\"在函数中处理变量\"><a href=\"#在函数中处理变量\" class=\"headerlink\" title=\"在函数中处理变量\"></a>在函数中处理变量</h3><p><strong>作用域</strong>是变量可见的区域。对脚本的其他部分而言，函数定义的变量是隐藏的。这些概念其实是编程语言中通用的，想必学过一些其他编程的朋友早已有所理解了。</p>\n<p>函数使用两种类型的变量：</p>\n<ul>\n<li>全局变量</li>\n<li>局部变量</li>\n</ul>\n<h4 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h4><p><strong>全局变量</strong>是在shell脚本中任何地方都有效的变量，如果你在函数内定义了一个全局变量，也可以在脚本的主体部分读取它的值。</p>\n<p>默认情况下，我们在脚本中定义的任何变量都是全局变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test7</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using a global variable to pass a value</span></span><br><span class=\"line\"></span><br><span class=\"line\">function db1 &#123;</span><br><span class=\"line\">truevalue=$[ $value * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">read -p \"Enter a value: \" value</span><br><span class=\"line\">db1</span><br><span class=\"line\">echo \"The new value is: $value\"</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test7</span><br><span class=\"line\">Enter a value: 10</span><br><span class=\"line\">The new value is: 20</span><br></pre></td></tr></table></figure>\n<p>无论变量在函数内外定义，在脚本中引用该变量都有效。这样其实非常危险，尤其是如果你想在不同的shell脚本中使用函数的话。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。下面是一个如何搞砸的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat badtest2</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> demonstrating a bad use of variable</span></span><br><span class=\"line\"></span><br><span class=\"line\">function func1 &#123;</span><br><span class=\"line\">truetemp=$[ $value + 5 ]</span><br><span class=\"line\">trueresult=$[ $temp * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">temp=4</span><br><span class=\"line\">value=6</span><br><span class=\"line\"></span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"The result is $result\"</span><br><span class=\"line\">if [ $temp -gt $value ]</span><br><span class=\"line\">then</span><br><span class=\"line\">trueecho \"temp is larger\"</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"temp is smaller\"</span><br><span class=\"line\">fi</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./badtest2</span><br><span class=\"line\">The result is 22</span><br><span class=\"line\">temp is larger</span><br></pre></td></tr></table></figure>\n<p>由于函数中用到了<code>$temp</code>变量，它的值在脚本中使用时受到了影响，产生了意想不到的后果。后面我们会学习如何处理这样的问题。</p>\n<h4 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h4><p>无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。<strong>我们只需要在变量声明前加上local关键字就可以了</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local temp</span><br></pre></td></tr></table></figure>\n<p>也可以在变量赋值时使用local关键字：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local temp=$[ $value + 5 ]</span><br></pre></td></tr></table></figure>\n<p><code>local</code>关键字保证了变量只局限于该函数中。我们再回看刚才的例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test8</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> demonstrating the <span class=\"built_in\">local</span> keyword</span></span><br><span class=\"line\"></span><br><span class=\"line\">function func1 &#123;</span><br><span class=\"line\">truelocal temp=$[ $value + 5 ]</span><br><span class=\"line\">trueresult=$[ $temp * 2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">temp=4</span><br><span class=\"line\">value=6</span><br><span class=\"line\"></span><br><span class=\"line\">func1</span><br><span class=\"line\">echo \"The result is $result\"</span><br><span class=\"line\">if [ $temp -gt $value ]</span><br><span class=\"line\">then</span><br><span class=\"line\">trueecho \"temp is larger\"</span><br><span class=\"line\">else</span><br><span class=\"line\">trueecho \"temp is smaller\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test8</span><br><span class=\"line\">The result is 22</span><br><span class=\"line\">temp is smaller</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组变量和函数\"><a href=\"#数组变量和函数\" class=\"headerlink\" title=\"数组变量和函数\"></a>数组变量和函数</h2><p>在函数中使用数组变量值有点麻烦，还需要一些特殊考虑。下面我们使用一种方法来解决问题。</p>\n<h3 id=\"向函数传数组参数\"><a href=\"#向函数传数组参数\" class=\"headerlink\" title=\"向函数传数组参数\"></a>向函数传数组参数</h3><p>这个方法有点不好理解，将数组变量当做单个参数传递的话不起作用，下面我们看一个bad例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat badtest3</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> trying to pass an array variable</span></span><br><span class=\"line\"></span><br><span class=\"line\">function testit &#123;</span><br><span class=\"line\">trueecho \"The parameters are: $@\"</span><br><span class=\"line\">truethisarray=$1</span><br><span class=\"line\">trueecho \"The received array is $&#123;thisarray[*]&#125;\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myarray=(1 2 3 4 5)</span><br><span class=\"line\">echo \"The original array is: $&#123;myarray[*]&#125;\"</span><br><span class=\"line\">testit $myarray</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./badtest3</span><br><span class=\"line\">The original array is: 1 2 3 4 5</span><br><span class=\"line\">The parameters are: 1</span><br><span class=\"line\">The received array is 1</span><br></pre></td></tr></table></figure>\n<p>可以看到，当我们将数组变量当做函数参数传递时，函数只会取数组变量的第一个值。</p>\n<p>针对这个问题，我们的一个解决方案是将数组变量全部拆分为单个值，然后作为参数传入函数，在函数内部又重新对这些值进行组装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test9</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> array variable to <span class=\"keyword\">function</span> <span class=\"built_in\">test</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function testit &#123;</span><br><span class=\"line\">truelocal newarray</span><br><span class=\"line\">truenewarray=(`echo \"$@\"`)</span><br><span class=\"line\">trueecho \"The new array value is: $&#123;newarray[*]&#125;\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myarray=(1 2 3 4 5)</span><br><span class=\"line\">echo $&#123;myarray[*]&#125;</span><br><span class=\"line\">testit $&#123;myarray[*]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test9</span><br><span class=\"line\">1 2 3 4 5</span><br><span class=\"line\">The new array value is: 1 2 3 4 5</span><br></pre></td></tr></table></figure>\n<h3 id=\"从函数中返回数组\"><a href=\"#从函数中返回数组\" class=\"headerlink\" title=\"从函数中返回数组\"></a>从函数中返回数组</h3><p>采用与上面类似的方法，函数用<code>echo</code>语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test10</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> returning an array value</span></span><br><span class=\"line\"></span><br><span class=\"line\">function arraydblr &#123;</span><br><span class=\"line\">truelocal origarray</span><br><span class=\"line\">truelocal newarray</span><br><span class=\"line\">truelocal elements</span><br><span class=\"line\">truelocal i</span><br><span class=\"line\">trueorigarray=($(echo \"$@\"))</span><br><span class=\"line\">truenewarray=($(echo \"$@\"))</span><br><span class=\"line\">trueelements=$[ $# - 1 ]</span><br><span class=\"line\">truefor (( i = 0; i &lt;= $elements; i++ ))</span><br><span class=\"line\">true&#123;</span><br><span class=\"line\"><span class=\"meta\">\t\tnewarray[$</span><span class=\"bash\">i]=$[ <span class=\"variable\">$&#123;origarray[$i]&#125;</span> * 2]</span></span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">trueecho $&#123;newarray[*]&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myarray=(1 2 3 4 5)</span><br><span class=\"line\">echo \"The orignal array is $&#123;myarray[*]&#125;\"</span><br><span class=\"line\">arg1=$(echo $&#123;myarray[*]&#125;)</span><br><span class=\"line\">result=($(arraydblr $arg1))</span><br><span class=\"line\">echo \"The new array is: $&#123;result[*]&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test10</span><br><span class=\"line\">The orignal array is 1 2 3 4 5</span><br><span class=\"line\">The new array is: 2 4 6 8 10</span><br></pre></td></tr></table></figure>\n<p>该脚本用<code>$arg1</code>变量将数组值传给<code>arraydblr</code>函数。该函数将数组重组到新的数组变量中，生成输出数组变量的一个副本，然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。</p>\n<h2 id=\"函数递归\"><a href=\"#函数递归\" class=\"headerlink\" title=\"函数递归\"></a>函数递归</h2><p>局部函数变量的一个特征是<strong>自成体系</strong>。这个特性使得函数可以递归地调用，也就是函数可以调用自己来得到结果。<strong>通常递归函数都有一个最终可以迭代到的基准值。</strong></p>\n<p>递归算法的经典例子是计算阶乘：一个数的阶乘是该数之前的所有数乘以该数的值。</p>\n<p>比如5的阶乘：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span>! = <span class=\"number\">1</span> * <span class=\"number\">2</span> * <span class=\"number\">3</span> * <span class=\"number\">4</span> * <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>方程可以简化为通用形式：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">x</span>! = <span class=\"keyword\">x</span> * (<span class=\"keyword\">x</span><span class=\"number\">-1</span>)!</span><br></pre></td></tr></table></figure>\n<p>这可以用简单的递归脚本表达为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial &#123;</span><br><span class=\"line\">  if [ $1 -eq 1 ]</span><br><span class=\"line\">  then</span><br><span class=\"line\">  \techo 1</span><br><span class=\"line\">  else</span><br><span class=\"line\">  \tlocal temp=$[ $1 - 1 ]</span><br><span class=\"line\">  \tlocal result=`factorial $temp`</span><br><span class=\"line\">  \techo $[ $result * $1 ]</span><br><span class=\"line\">  fi</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面用它来进行计算：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test11</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using recursion</span></span><br><span class=\"line\"></span><br><span class=\"line\">function factorial &#123;</span><br><span class=\"line\">trueif [ $1 -eq 1 ]</span><br><span class=\"line\">truethen</span><br><span class=\"line\">truetrueecho 1</span><br><span class=\"line\">trueelse</span><br><span class=\"line\">truetruelocal temp=$[ $1 - 1]</span><br><span class=\"line\">truetruelocal result=`factorial $temp`</span><br><span class=\"line\">truetrueecho $[ $result * $1 ]</span><br><span class=\"line\">truefi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">read -p \"Enter value: \" value</span><br><span class=\"line\">result=$(factorial $value)</span><br><span class=\"line\">echo \"The factorial of $value is: $result\"</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test11</span><br><span class=\"line\">Enter value: 5</span><br><span class=\"line\">The factorial of 5 is: 120</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建库\"><a href=\"#创建库\" class=\"headerlink\" title=\"创建库\"></a>创建库</h2><p>如果你碰巧要在多个脚本中使用同一段代码呢？显然在每个脚本中都定义同样的函数太麻烦了，一种解决方法就是创建<strong>库文件</strong>，然后在脚本中引用它。</p>\n<p><strong>第一步</strong>是创建一个包含脚本中所需函数的公用库文件。下面是一个叫做myfuncs的库文件，定义了3个简单的函数。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat myfuncs</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> my script <span class=\"built_in\">functions</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">function addem &#123;</span><br><span class=\"line\">trueecho $[ $1 + $2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function multem &#123;</span><br><span class=\"line\">trueecho $[ $1 * $2 ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function divem &#123;</span><br><span class=\"line\">trueif [ $2 -ne 0 ]</span><br><span class=\"line\">truethen</span><br><span class=\"line\">truetrueecho $[ $1 / $2 ]</span><br><span class=\"line\">trueelse</span><br><span class=\"line\">truetrueecho -1</span><br><span class=\"line\">truefi</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>下一步</strong>是在用到这些函数的脚本文件中包含myfuncs库文件。</p>\n<p>这里有点复杂，主要问题出在shell函数的作用域上。如果我们尝试像普通脚本一样运行库文件，函数不会出现在脚本中。</p>\n<p>使用函数库的<strong>关键</strong>在于<code>source</code>命令。<strong><code>source</code>命令会在当前shell上下文中执行命令，而不是创建一个新的shell。</strong>通过<code>source</code>命令就可以使用库中的函数了。</p>\n<p><code>source</code>命令有一个<strong>快捷别名</strong>，称为<strong>点操作符</strong>。要在shell脚本中运行myfuncs库文件，只需要使用下面这行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">. ./myfuncs</span><br></pre></td></tr></table></figure>\n<p>注意第一个点是点操作符，而第二个点指向当前目录（相对路径）。</p>\n<p>下面这个例子假定myfuncs库文件与要使用它的脚本位于同一目录，不然需要使用相对应的路径进行访问。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test12</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> using <span class=\"built_in\">functions</span> defined <span class=\"keyword\">in</span> a library file</span></span><br><span class=\"line\"></span><br><span class=\"line\">. ./myfuncs</span><br><span class=\"line\"></span><br><span class=\"line\">value1=10</span><br><span class=\"line\">value2=5</span><br><span class=\"line\">result1=$(addem $value1 $value2)</span><br><span class=\"line\">result2=$(multem $value1 $value2)</span><br><span class=\"line\">result3=$(divem $value1 $value2)</span><br><span class=\"line\">echo \"The result of adding them is: $result1\"</span><br><span class=\"line\">echo \"The result of multiplying them is: $result2\"</span><br><span class=\"line\">echo \"The result of dividing them is: $result3\"</span><br></pre></td></tr></table></figure>\n<p>运行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ ./test12</span><br><span class=\"line\">The result of adding them is: 15</span><br><span class=\"line\">The result of multiplying them is: 50</span><br><span class=\"line\">The result of dividing them is: 2</span><br></pre></td></tr></table></figure>\n<h2 id=\"在命令行上使用函数\"><a href=\"#在命令行上使用函数\" class=\"headerlink\" title=\"在命令行上使用函数\"></a>在命令行上使用函数</h2><p>有时候有必要在命令行界面的提示符下直接使用这些函数。这是个灰常不错的功能，在shell中定义的函数可以在整个系统中使用它，无需担心脚本是不是在PATH环境变量中。</p>\n<p><strong>重点在于让shell能够识别这些函数</strong>。以下有几种方法可以实现。</p>\n<h3 id=\"在命令行上创建函数\"><a href=\"#在命令行上创建函数\" class=\"headerlink\" title=\"在命令行上创建函数\"></a>在命令行上创建函数</h3><p>shell会解释用户输入的命令，所以可以在命令行上直接定义一个函数。</p>\n<p>有两种方法。</p>\n<p><strong>一种是采用单行方式定义函数。</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ function divem &#123; echo $[ $1 / $2 ]; &#125;</span><br><span class=\"line\">wsx@wsx:~/tmp$ divem 100 5</span><br><span class=\"line\">20</span><br></pre></td></tr></table></figure>\n<p>当在命令行上定义函数时，你<strong>必须</strong>记得在每个命令后面加个分号，这样shell能识别命令的起始。</p>\n<p><strong>另一种是采用多行方式来定义函数。</strong>在定义时bash shell会使用次提示符来提示输入更多命令。这种方法不必在命令末尾加分号，只要按回车键就可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ function multem &#123;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">echo</span> $[ <span class=\"variable\">$1</span> * <span class=\"variable\">$2</span> ]</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> &#125;</span></span><br><span class=\"line\">wsx@wsx:~/tmp$ multem 2 5</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：在命令行上创建函数不要跟内建命令重名，函数会覆盖原来的命令。</p>\n<h3 id=\"在-bashrc文件中定义函数\"><a href=\"#在-bashrc文件中定义函数\" class=\"headerlink\" title=\"在.bashrc文件中定义函数\"></a>在.bashrc文件中定义函数</h3><p>在bash shell每次启动时都会在主目录下查找<code>.bashrc</code>文件，不管是交互式shell还是shell中启动的新shell。所以我们可以将函数写入该文件，或者在脚本中写入命令读取函数文件。操作前面都讲过，不再赘述，<strong>只要把该文件当做脚本对待就可以了</strong>。理解这一点这部分就会了。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p><strong>在开源的世界里，共享代码才是关键，而这一点同样适用于脚本函数。</strong>我们可以下载大量各式各样的函数然后用于自己的应用程序。</p>\n<p>这一节介绍<strong>如何下载、安装和使用GNU shtool shell脚本函数库</strong>。shtool库提供了一些简单的shell脚本函数，可以用来完成日常的shell功能。</p>\n<h3 id=\"下载和安装\"><a href=\"#下载和安装\" class=\"headerlink\" title=\"下载和安装\"></a>下载和安装</h3><p>shtool软件包下载地址：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz # China</span><br></pre></td></tr></table></figure>\n<p>可以浏览器或者命令行下载：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ wget http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz</span><br><span class=\"line\">--2017-11-24 00:34:32--  http://mirrors.ustc.edu.cn/gnu/shtool/shtool-2.0.8.tar.gz</span><br><span class=\"line\">正在解析主机 mirrors.ustc.edu.cn (mirrors.ustc.edu.cn)... 202.141.176.110, 218.104.71.170, 2001:da8:d800:95::110</span><br><span class=\"line\">正在连接 mirrors.ustc.edu.cn (mirrors.ustc.edu.cn)|202.141.176.110|:80... 已连接。</span><br><span class=\"line\">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class=\"line\">长度： 97033 (95K) [application/gzip]</span><br><span class=\"line\">正在保存至: “shtool-2.0.8.tar.gz”</span><br><span class=\"line\"></span><br><span class=\"line\">shtool-2.0.8.tar.gz 100%[===================&gt;]  94.76K  --.-KB/s    用时 0.1s</span><br><span class=\"line\"></span><br><span class=\"line\">2017-11-24 00:34:32 (783 KB/s) - 已保存 “shtool-2.0.8.tar.gz” [97033/97033])</span><br></pre></td></tr></table></figure>\n<p>复制到主目录，然后用<code>tar</code>命令提取文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~$ tar -zxvf shtool-2.0.8.tar.gz</span><br><span class=\"line\">shtool-2.0.8/AUTHORS</span><br><span class=\"line\">shtool-2.0.8/COPYING</span><br><span class=\"line\">shtool-2.0.8/ChangeLog</span><br><span class=\"line\">shtool-2.0.8/INSTALL</span><br><span class=\"line\">shtool-2.0.8/Makefile.in</span><br><span class=\"line\">shtool-2.0.8/NEWS</span><br><span class=\"line\">shtool-2.0.8/RATIONAL</span><br><span class=\"line\">shtool-2.0.8/README</span><br><span class=\"line\">shtool-2.0.8/THANKS</span><br><span class=\"line\">shtool-2.0.8/VERSION</span><br><span class=\"line\">shtool-2.0.8/configure</span><br><span class=\"line\">shtool-2.0.8/configure.ac</span><br><span class=\"line\">shtool-2.0.8/sh.arx</span><br><span class=\"line\">shtool-2.0.8/sh.common</span><br><span class=\"line\">shtool-2.0.8/sh.echo</span><br><span class=\"line\">shtool-2.0.8/sh.fixperm</span><br><span class=\"line\">shtool-2.0.8/sh.install</span><br><span class=\"line\">shtool-2.0.8/sh.mdate</span><br><span class=\"line\">shtool-2.0.8/sh.mkdir</span><br><span class=\"line\">shtool-2.0.8/sh.mkln</span><br><span class=\"line\">shtool-2.0.8/sh.mkshadow</span><br><span class=\"line\">shtool-2.0.8/sh.move</span><br><span class=\"line\">shtool-2.0.8/sh.path</span><br><span class=\"line\">shtool-2.0.8/sh.platform</span><br><span class=\"line\">shtool-2.0.8/sh.prop</span><br><span class=\"line\">shtool-2.0.8/sh.rotate</span><br><span class=\"line\">shtool-2.0.8/sh.scpp</span><br><span class=\"line\">shtool-2.0.8/sh.slo</span><br><span class=\"line\">shtool-2.0.8/sh.subst</span><br><span class=\"line\">shtool-2.0.8/sh.table</span><br><span class=\"line\">shtool-2.0.8/sh.tarball</span><br><span class=\"line\">shtool-2.0.8/sh.version</span><br><span class=\"line\">shtool-2.0.8/shtool.m4</span><br><span class=\"line\">shtool-2.0.8/shtool.pod</span><br><span class=\"line\">shtool-2.0.8/shtool.spec</span><br><span class=\"line\">shtool-2.0.8/shtoolize.in</span><br><span class=\"line\">shtool-2.0.8/shtoolize.pod</span><br><span class=\"line\">shtool-2.0.8/test.db</span><br><span class=\"line\">shtool-2.0.8/test.sh</span><br></pre></td></tr></table></figure>\n<p>接下来可以构建shell脚本库文件了。</p>\n<h3 id=\"构建库\"><a href=\"#构建库\" class=\"headerlink\" title=\"构建库\"></a>构建库</h3><p>shtool文件必须针对特定的Linux环境进行配置。<strong>配置工作必须使用标准的configure和make命令</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~$ cd shtool-2.0.8/</span><br><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ ./configure</span><br><span class=\"line\">Configuring GNU shtool (Portable Shell Tool), version 2.0.8 (18-Jul-2008)</span><br><span class=\"line\">Copyright (c) 1994-2008 Ralf S. Engelschall &lt;rse@engelschall.com&gt;</span><br><span class=\"line\">checking whether make sets $(MAKE)... yes</span><br><span class=\"line\">checking for perl interpreter... /usr/bin/perl</span><br><span class=\"line\">checking for pod2man conversion tool... /usr/bin/pod2man</span><br><span class=\"line\">configure: creating ./config.status</span><br><span class=\"line\">config.status: creating Makefile</span><br><span class=\"line\">config.status: creating shtoolize</span><br><span class=\"line\">config.status: executing adjustment commands</span><br><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ make</span><br><span class=\"line\">building program shtool</span><br><span class=\"line\">./shtoolize -o shtool all</span><br><span class=\"line\">Use of assignment to $[ is deprecated at ./shtoolize line 60.</span><br><span class=\"line\">Generating shtool...(echo 11808/12742 bytes)...(mdate 3695/4690 bytes)...(table 1818/2753 bytes)...(prop 1109/2038 bytes)...(move 2685/3614 bytes)...(install 4567/5495 bytes)...(mkdir 2904/3821 bytes)...(mkln 4429/5361 bytes)...(mkshadow 3260/4193 bytes)...(fixperm 1471/2403 bytes)...(rotate 13425/14331 bytes)...(tarball 5297/6214 bytes)...(subst 5255/6180 bytes)...(platform 21739/22662 bytes)...(arx 2401/3312 bytes)...(slo 4139/5066 bytes)...(scpp 6295/7206 bytes)...(version 10234/11160 bytes)...(path 4041/4952 bytes)</span><br><span class=\"line\">building manpage shtoolize.1</span><br><span class=\"line\">building manpage shtool.1</span><br><span class=\"line\">building manpage shtool-echo.1</span><br><span class=\"line\">building manpage shtool-mdate.1</span><br><span class=\"line\">shtool-mdate.tmp around line 222: You forgot a '=back' before '=head1'</span><br><span class=\"line\">POD document had syntax errors at /usr/bin/pod2man line 71.</span><br><span class=\"line\">building manpage shtool-table.1</span><br><span class=\"line\">building manpage shtool-prop.1</span><br><span class=\"line\">building manpage shtool-move.1</span><br><span class=\"line\">building manpage shtool-install.1</span><br><span class=\"line\">building manpage shtool-mkdir.1</span><br><span class=\"line\">shtool-mkdir.tmp around line 186: You forgot a '=back' before '=head1'</span><br><span class=\"line\">POD document had syntax errors at /usr/bin/pod2man line 71.</span><br><span class=\"line\">building manpage shtool-mkln.1</span><br><span class=\"line\">building manpage shtool-mkshadow.1</span><br><span class=\"line\">shtool-mkshadow.tmp around line 191: You forgot a '=back' before '=head1'</span><br><span class=\"line\">POD document had syntax errors at /usr/bin/pod2man line 71.</span><br><span class=\"line\">building manpage shtool-fixperm.1</span><br><span class=\"line\">building manpage shtool-rotate.1</span><br><span class=\"line\">building manpage shtool-tarball.1</span><br><span class=\"line\">building manpage shtool-subst.1</span><br><span class=\"line\">building manpage shtool-platform.1</span><br><span class=\"line\">building manpage shtool-arx.1</span><br><span class=\"line\">building manpage shtool-slo.1</span><br><span class=\"line\">building manpage shtool-scpp.1</span><br><span class=\"line\">building manpage shtool-version.1</span><br><span class=\"line\">building manpage shtool-path.1</span><br></pre></td></tr></table></figure>\n<p><code>configure</code>命令会检查构建shtool库文件所必需的软件。一旦发现所需工具，它会使用工具路径修改配置文件。</p>\n<p><code>make</code>命令负责构建shtool库文件。最终的结果（shtool）是一个完整的库软件包。</p>\n<p>我们可以测试下这个库文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ make test</span><br><span class=\"line\">Running test suite:</span><br><span class=\"line\">echo..........FAILED</span><br><span class=\"line\">+---Test------------------------------</span><br><span class=\"line\">| test \".`../shtool echo foo bar quux`\" = \".foo bar quux\" || exit 1</span><br><span class=\"line\">| bytes=`../shtool echo -n foo | wc -c | awk '&#123; printf(\"%s\", $1); &#125;'` || exit 1</span><br><span class=\"line\">| test \".$bytes\" = .3 || exit 1</span><br><span class=\"line\">| bytes=`../shtool echo '\\1' | wc -c | awk '&#123; printf(\"%s\", $1); &#125;'` || exit 1</span><br><span class=\"line\">| test \".$bytes\" = .3 || exit 1</span><br><span class=\"line\">| exit 0</span><br><span class=\"line\">+---Trace-----------------------------</span><br><span class=\"line\">| + ../shtool echo foo bar quux</span><br><span class=\"line\">| + test .foo bar quux = .foo bar quux</span><br><span class=\"line\">| + ../shtool echo -n foo</span><br><span class=\"line\">| + wc -c</span><br><span class=\"line\">| + awk &#123; printf(\"%s\", $1); &#125;</span><br><span class=\"line\">| + bytes=3</span><br><span class=\"line\">| + test .3 = .3</span><br><span class=\"line\">| + ../shtool echo \\1</span><br><span class=\"line\">| + wc -c</span><br><span class=\"line\">| + awk &#123; printf(\"%s\", $1); &#125;</span><br><span class=\"line\">| + bytes=2</span><br><span class=\"line\">| + test .2 = .3</span><br><span class=\"line\">| + exit 1</span><br><span class=\"line\">+-------------------------------------</span><br><span class=\"line\">mdate.........ok</span><br><span class=\"line\">table.........ok</span><br><span class=\"line\">prop..........ok</span><br><span class=\"line\">move..........ok</span><br><span class=\"line\">install.......ok</span><br><span class=\"line\">mkdir.........ok</span><br><span class=\"line\">mkln..........ok</span><br><span class=\"line\">mkshadow......ok</span><br><span class=\"line\">fixperm.......ok</span><br><span class=\"line\">rotate........ok</span><br><span class=\"line\">tarball.......ok</span><br><span class=\"line\">subst.........ok</span><br><span class=\"line\">platform......ok</span><br><span class=\"line\">arx...........ok</span><br><span class=\"line\">slo...........ok</span><br><span class=\"line\">scpp..........ok</span><br><span class=\"line\">version.......ok</span><br><span class=\"line\">path..........ok</span><br><span class=\"line\">FAILED: passed: 18/19, failed: 1/19</span><br></pre></td></tr></table></figure>\n<p>（有一个没通过～）</p>\n<p>如果全部通过测试，就可以将库安装到系统中，这样所有脚本都能使用这个库了。</p>\n<p>要完成安装，需要使用<code>make</code>命令的<code>install</code>选项。需要使用root权限。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ make install</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/bin</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/share/man/man1</span><br><span class=\"line\">mkdir: cannot create directory '/usr/local/share/man/man1': Permission denied</span><br><span class=\"line\">chmod: cannot access '/usr/local/share/man/man1': No such file or directory</span><br><span class=\"line\">Makefile:94: recipe for target 'install' failed</span><br><span class=\"line\">make: *** [install] Error 1</span><br><span class=\"line\">wsx@wsx:~/shtool-2.0.8$ sudo make install</span><br><span class=\"line\">[sudo] wsx 的密码：</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/bin</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/share/man/man1</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/share/aclocal</span><br><span class=\"line\">./shtool mkdir -f -p -m 755 /usr/local/share/shtool</span><br><span class=\"line\">./shtool install -c -m 755 shtool /usr/local/bin/shtool</span><br><span class=\"line\">./shtool install -c -m 755 shtoolize /usr/local/bin/shtoolize</span><br><span class=\"line\">./shtool install -c -m 644 shtoolize.1 /usr/local/share/man/man1/shtoolize.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool.1 /usr/local/share/man/man1/shtool.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-echo.1 /usr/local/share/man/man1/shtool-echo.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-mdate.1 /usr/local/share/man/man1/shtool-mdate.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-table.1 /usr/local/share/man/man1/shtool-table.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-prop.1 /usr/local/share/man/man1/shtool-prop.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-move.1 /usr/local/share/man/man1/shtool-move.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-install.1 /usr/local/share/man/man1/shtool-install.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-mkdir.1 /usr/local/share/man/man1/shtool-mkdir.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-mkln.1 /usr/local/share/man/man1/shtool-mkln.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-mkshadow.1 /usr/local/share/man/man1/shtool-mkshadow.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-fixperm.1 /usr/local/share/man/man1/shtool-fixperm.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-rotate.1 /usr/local/share/man/man1/shtool-rotate.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-tarball.1 /usr/local/share/man/man1/shtool-tarball.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-subst.1 /usr/local/share/man/man1/shtool-subst.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-platform.1 /usr/local/share/man/man1/shtool-platform.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-arx.1 /usr/local/share/man/man1/shtool-arx.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-slo.1 /usr/local/share/man/man1/shtool-slo.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-scpp.1 /usr/local/share/man/man1/shtool-scpp.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-version.1 /usr/local/share/man/man1/shtool-version.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool-path.1 /usr/local/share/man/man1/shtool-path.1</span><br><span class=\"line\">./shtool install -c -m 644 shtool.m4 /usr/local/share/aclocal/shtool.m4</span><br><span class=\"line\">./shtool install -c -m 644 sh.common /usr/local/share/shtool/sh.common</span><br><span class=\"line\">./shtool install -c -m 644 sh.echo /usr/local/share/shtool/sh.echo</span><br><span class=\"line\">./shtool install -c -m 644 sh.mdate /usr/local/share/shtool/sh.mdate</span><br><span class=\"line\">./shtool install -c -m 644 sh.table /usr/local/share/shtool/sh.table</span><br><span class=\"line\">./shtool install -c -m 644 sh.prop /usr/local/share/shtool/sh.prop</span><br><span class=\"line\">./shtool install -c -m 644 sh.move /usr/local/share/shtool/sh.move</span><br><span class=\"line\">./shtool install -c -m 644 sh.install /usr/local/share/shtool/sh.install</span><br><span class=\"line\">./shtool install -c -m 644 sh.mkdir /usr/local/share/shtool/sh.mkdir</span><br><span class=\"line\">./shtool install -c -m 644 sh.mkln /usr/local/share/shtool/sh.mkln</span><br><span class=\"line\">./shtool install -c -m 644 sh.mkshadow /usr/local/share/shtool/sh.mkshadow</span><br><span class=\"line\">./shtool install -c -m 644 sh.fixperm /usr/local/share/shtool/sh.fixperm</span><br><span class=\"line\">./shtool install -c -m 644 sh.rotate /usr/local/share/shtool/sh.rotate</span><br><span class=\"line\">./shtool install -c -m 644 sh.tarball /usr/local/share/shtool/sh.tarball</span><br><span class=\"line\">./shtool install -c -m 644 sh.subst /usr/local/share/shtool/sh.subst</span><br><span class=\"line\">./shtool install -c -m 644 sh.platform /usr/local/share/shtool/sh.platform</span><br><span class=\"line\">./shtool install -c -m 644 sh.arx /usr/local/share/shtool/sh.arx</span><br><span class=\"line\">./shtool install -c -m 644 sh.slo /usr/local/share/shtool/sh.slo</span><br><span class=\"line\">./shtool install -c -m 644 sh.scpp /usr/local/share/shtool/sh.scpp</span><br><span class=\"line\">./shtool install -c -m 644 sh.version /usr/local/share/shtool/sh.version</span><br><span class=\"line\">./shtool install -c -m 644 sh.path /usr/local/share/shtool/sh.path</span><br></pre></td></tr></table></figure>\n<p>现在我们能在自己的shell脚本中使用这些函数咯。</p>\n<h3 id=\"shtool库函数\"><a href=\"#shtool库函数\" class=\"headerlink\" title=\"shtool库函数\"></a>shtool库函数</h3><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Arx</td>\n<td>创建归档文件（包含一些扩展功能）</td>\n</tr>\n<tr>\n<td>Echo</td>\n<td>显示字符串，并提供了一些扩展构件</td>\n</tr>\n<tr>\n<td>fixperm</td>\n<td>改变目录树的文件权限</td>\n</tr>\n<tr>\n<td>install</td>\n<td>安装脚本或文件</td>\n</tr>\n<tr>\n<td>mdate</td>\n<td>显示文件或目录修改时间</td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td>创建一个或更多目录</td>\n</tr>\n<tr>\n<td>Mkln</td>\n<td>使用相对路径创建链接</td>\n</tr>\n<tr>\n<td>mkshadow</td>\n<td>创建一棵阴影树</td>\n</tr>\n<tr>\n<td>move</td>\n<td>带有替换功能的文件移动</td>\n</tr>\n<tr>\n<td>Path</td>\n<td>处理程序路径</td>\n</tr>\n<tr>\n<td>platform</td>\n<td>显示平台标识</td>\n</tr>\n<tr>\n<td>Prop</td>\n<td>显示一个带有动画效果的进度条</td>\n</tr>\n<tr>\n<td>rotate</td>\n<td>转置日志文件</td>\n</tr>\n<tr>\n<td>Scpp</td>\n<td>共享的C预处理器</td>\n</tr>\n<tr>\n<td>Slo</td>\n<td>根据库的类别，分离链接器选项</td>\n</tr>\n<tr>\n<td>Subst</td>\n<td>使用sed的替换操作</td>\n</tr>\n<tr>\n<td>Table</td>\n<td>以表格的形式显示由字段分隔的数据</td>\n</tr>\n<tr>\n<td>tarball</td>\n<td>从文件和目录中创建tar文件</td>\n</tr>\n<tr>\n<td>version</td>\n<td>创建版本信息文件</td>\n</tr>\n</tbody>\n</table>\n<p>每个shtool函数都包含大量的选项和参数。下面是使用格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shtool [option] [function [option] [args]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用库\"><a href=\"#使用库\" class=\"headerlink\" title=\"使用库\"></a>使用库</h3><p>我们能直接在命令行或者在自己构建的脚本中使用shtool的函数。</p>\n<p>下面是在脚本中使用的简单例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ cat test13</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">!/bin/bash</span></span><br><span class=\"line\">shtool platform</span><br><span class=\"line\">wsx@wsx:~/tmp$ ./test13</span><br><span class=\"line\">Ubuntu 17.10 (AMD64)</span><br></pre></td></tr></table></figure>\n<p><code>platform</code>函数会返回Linux发行版以及系统使用的CPU硬件相关信息。</p>\n<p><code>prop</code>函数可以使用<code>\\</code>,<code>|</code>,<code>/</code>和<code>-</code>字符创建一个旋转的进度条。它可以告诉shell脚本用户目前正在处理一些后台处理工作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@wsx:~/tmp$ ls -al /usr/bin | shtool prop -p \"waiting...\"</span><br><span class=\"line\">waiting...</span><br></pre></td></tr></table></figure>\n<p>在脚本学习中涉及到诸多的符号，在运行时我们可能会感觉到顺利，但自己写的时候往往会用不太对，推荐阅读一下常用的一些符号区分，像小括号、中括号、花括号等等。觉的不懂的可以看看<a href=\"http://blog.csdn.net/yangtalent1206/article/details/12996797\" target=\"_blank\" rel=\"noopener\">Linux<em>Bash脚本</em>单引号’双引号“”反引号`小括号()中括号[]大括号{}</a>以及相关的百度资料。</p>"},{"title":"Sync deploy 命令工具","author":"王诗翔","date":"2018-01-31T13:05:55.000Z","top":true,"_content":"\n该命令集可以非常方便地向远程主机/服务器上传文件、运行远程脚本、下载文件等。\n\n<div class=\"github-widget\" data-repo=\"ShixiangWang/sync-deploy\"></div>\n\n\n<!-- more -->\n\n**目录**：\n\n- [目的](https://github.com/ShixiangWang/sync-deploy#目的)\n- [下载与使用](https://github.com/ShixiangWang/sync-deploy#下载与使用)\n- [准备与配置](https://github.com/ShixiangWang/sync-deploy#准备与配置)\n- [命令说明](https://github.com/ShixiangWang/sync-deploy#命令说明)\n    \n    - [sync-command](https://github.com/ShixiangWang/sync-deploy#sync-command)\n    - [sync-upload](https://github.com/ShixiangWang/sync-deploy#sync-upload)\n    - [sync-download](https://github.com/ShixiangWang/sync-deploy#sync-download)\n    - [sync-run](https://github.com/ShixiangWang/sync-deploy#sync-run)\n    - [sync-deploy](https://github.com/ShixiangWang/sync-deploy#sync-deploy)\n    - [sync-check](https://github.com/ShixiangWang/sync-deploy#sync-check)\n- [计算操作实例](https://github.com/ShixiangWang/sync-deploy#计算操作实例)\n\n\n## 目的\n\n交互式地输入ssh、scp命令进行远端主机命令/脚本的执行、文件的上传与下载并不是很方便，有时候频繁地键入`hostname@ip`也是一件非常痛苦的事情。另外一方面，如果是向计算平台提交任务脚本，在远端文本命令窗口内修改作业参数以及调试运行脚本也是蛮不方便。所以仓库里脚本是为了能够比较方便地执行这一些任务。\n\n命令集内置`ssh`、`scp`、`qsub`、`qstat`命令，分别用于运行远程脚本、命令、上传/下载文件、提交作业和查看作业状态。\n\n## 下载与使用\n\n[点击下载](https://github.com/ShixiangWang/sync-deploy/releases)\n\n或克隆：\n\n```\ngit clone https://github.com/ShixiangWang/sync-deploy.git\n```\n\n下载后执行`add_path.sh`脚本将命令添加到环境路径中，这样无论你处于什么目录都能使用。\n\n```shell\ncd sync-deploy/src\n./add_path.sh\n```\n\n除了`sync-command`命令没有选项，其他命令基本都有选项需要指定。\n\n**对应地，除了`sync-command`其他命令都有`-h`选项，你可以获取帮助**。\n\n```shell\nsync-upload -h\nsync-download -h\nsync-run -h\nsync-deploy -h\nsync-check -h\n```\n\n## 准备与配置\n\n首先在服务器端配置本地机器的公钥，以便于实现无密码文件传输。\n\n参考文章[ssh-keygen基本用法](https://www.liaohuqiu.net/cn/posts/ssh-keygen-abc/)或其他资料生成公钥和私钥(搜索引擎可以找到一大堆这样的博文，我就不啰嗦了)。\n\n将公钥`id_sra.pub`（本地机器.ssh子目录下）中文本内容拷贝到服务器.ssh子目录中的`authorized_keys`中，放在已有文本后面。如果该文件不存在则创建。\n\n进行测试，如果不需要密码登录则成功。\n\n**然后点击打开当前目录（src/）的`sync-setting`文件，将远程主机的host名与ip地址改为你自己的**。\n\n\n*****\n\n**如果你想要在计算平台部署任务**，请点击打开当前目录下的`qsub_header`文件填入PBS参数，设置可以参考[我整理的](https://github.com/ShixiangWang/mytoolkit/blob/master/hpc_info.md)或者百度上的其他资源，例如[1](https://wenku.baidu.com/view/5ab820293169a4517723a3ec.html)，[2](https://wenku.baidu.com/view/14ef7c230722192e4536f6f8.html)等。\n\n**接着在当前目录的`commands`文件夹填入你要运行的命令。如果你想要运行其他脚本，请在该文件中调用执行**。\n\n## 命令说明\n\n### sync-command\n\n这个命令最简单粗暴，直接在`sync-command`后接你想要在远端执行的命令。\n\n```shell\n$ sync-command ls -l '~/test'\n总用量 0\n-rw-rw-r-- 1 liuxs liuxs  12 1月  30 19:20 job_id\n-rw-rw-r-- 1 liuxs liuxs  34 1月  30 19:20 result.txt\n-rw-rw-r-- 1 liuxs liuxs 110 1月  29 11:40 test.R\n-rwxrw-r-- 1 liuxs liuxs 240 1月  30 19:20 work.sh\n```\n\n**需要注意的是如果是想使用类似`~`这种映射到某个路径的符号，需要添加引号，不然它会被解析为本地地址，那当然会出问题的**\n\n\n### sync-upload\n\n上传文件到远程主机。\n\n用法：\n\n```shell\n    Usage: sync-upload -n local_files -d 'destdir'\n```\n\n`-n`选项后接你要上传的（本地机器）文件/目录路径，`-d`选项接远程主机上的目录路径。\n\n用法示例：\n\n```shell\n==> examples:\n              sync-upload -n work.sh -d /public/home/liuxs/test\n         or\n              sync-upload -n work.sh -d '~/test'\n```\n\n同样注意使用`~`时需要加引号。\n\n**重点注意不支持-n与-d倒过来写，也就是选项是有顺序的**，为什么如此的原因是为了使`-n`选项后能够接大于1个的路径参数，命令脚本内部利用了`-n`和`-d`的位置特点运用正则表达式抓取所有路径名，你可以利用该命令同时上传不止一个文件/目录（也算是有得有失吧）。\n\n### sync-download\n\n从远程主机下载文件到本地机器。\n\n用法：\n\n```shell\n    Usage: sync-download -n 'remote_files' -d localdir\n```\n\n这个命令的使用基本和`sync-upload`一致。\n\n用法示例：\n\n```shell\n==> examples:\n              sync-download -n '~/test/*' -d ./test\n         or\n              sync-download -n /public/home/liuxs/test/* -d ./test\n```\n\n**同样地，不支持`-n`与`-d`选项顺序反着写。**\n\n### sync-run\n\n提交远程主机的作业，内置`qsub`命令向计算平台提交任务脚本。如果只是想要运行远程脚本或命令，请查看`sync-command`命令。\n\n用法：\n\n```shell\n    sync-run -f work_script\n```\n\n`-f`选项后接你要运行的**一个**脚本（需要指定脚本的路径哈）。\n\n用法示例：\n\n```shell\n    sync-run -f /home/wsx/work.sh\n```\n\n## sync-deploy\n\n上传文件、提交作业一气呵成。\n\n该命令内置调用`sync-upload`和`sync-run`这两个命令，以及其他几个脚本。在进行相关配置后，它可以根据`qsub_header`和`commands`两个文本自动生成作业脚本`work.sh`，上传指定文档（`work.sh`不指定也会上传），然后提交到任务节点进行运算。\n\n用法：\n\n```shell\n    Usage: sync-deploy -n local_files -d 'destdir'\n```\n\n同样注意`~`的使用问题，另外，如果你只部署运行`work.sh`文档，那么请在`-n`选项后加`work.sh`，（因为`-n`选项后不加内容会报错）虽然该文本会被上传两次，但不会影响使用。\n\n一个实例如下：\n\n```shell\n$ sync-deploy -n work.sh -d '~/test'\n==> command used: scp -pr -P 22 work.sh /home/wsx/working/sync-deploy/src/work.sh liuxs@10.15.22.110:~/test\n==>\nwork.sh                                                                                                         100%  240     0.2KB/s   00:00\nwork.sh                                                                                                         100%  240     0.2KB/s   00:00\n==> Files upload successfully.\n\n==> run as batch mode.......\njob_id file locate at ~/test/job_id , id is\n87728.node1\n==>\n==> The work deploy successfully.\n\n```\n\n### sync-check\n\n用来查看作业状态。\n\n用法：\n\n```shell\n    Usage: sync-deploy -n id\n```\n\n如果指定`-n`选项加上作业号，会查询指定的作业状态，如果不指定，会查看所有的作业状态。\n\n任务部署后会返回作业号，刚提交了两个作业，我们来查一查。\n\n```shell\n$ sync-check -n 87730\nJob ID                    Name             User            Time Use S Queue\n------------------------- ---------------- --------------- -------- - -----\n87730.node1                work.sh          liuxs           00:00:00 C normal_3\n\n$ sync-check -n 87730.node1\nJob ID                    Name             User            Time Use S Queue\n------------------------- ---------------- --------------- -------- - -----\n87730.node1                work.sh          liuxs           00:00:00 C normal_3\n\n$ sync-check\nJob ID                    Name             User            Time Use S Queue\n------------------------- ---------------- --------------- -------- - -----\n87729.node1                work.sh          liuxs           00:00:00 C normal_3\n87730.node1                work.sh          liuxs           00:00:00 C normal_3\n\n```\n\n## 计算操作实例\n\n我们来通过一个完整的实例来了解这些命令。\n\n**我们的任务是**利用远程的计算平台运行一些shell命令，执行一个R脚本。\n\n该R脚本位于`src/`的`test`目录下，这个脚本我们可以看做我们日常工作运行的主脚本。\n\n我们需要准备什么呢？\n\n只需要正确填写`qsub_header`与`commands`文档即可。\n\n我们先看看`qsub_header`的内容：\n\n```\n#PBS -l nodes=1:ppn=10\n#PBS -S /bin/bash\n#PBS -j oe\n#PBS -q normal_3\n\n# Please set PBS arguments above\n```\n\n上述就是一些PBS选项和参数，按你自己的需求和正确写法填写即可。这里测试我就简单地设定了节点与队列。具体参数你可以百度或者参考说明文档前面提供的信息。\n\n再瞧瞧`commands`文档：\n\n```shell\n# This job's working directory\ncd ~/test\n\n# Following are commands\nsleep 20\necho \"Thi mission is run successfully!!\" > ~/test/result.txt\n\n# call Rscripts\nRscript ~/test/test.R > ~/test/result2.txt\n```\n\n这个文档可能是我们工作主要需要修改的地方，这里我们用`cd`命令设定（作业的）工作目录，为避免任务结束太快，调用`sleep`命令让机器睡几秒，然后调用`echo`将一些文字结果传入一个结果文件，最后调用一个R脚本，并将结果传入另一个文件。\n\nR脚本的内容也非常简单,就是输入几行文本：\n\n```shell\nprint(\"==>\")\nprint(\"==> Hello world!!!!!!!!\")\nprint(\"==> \")\n```\n\n为避免程序找不到或者找错文件，我们最好指定文件所在的全部路径。\n\n**让我们开始跑命令吧～**\n\n任务方案很简单，我们将`test.R`上传到远程主机的工作目录下，注意，`work.sh`也会自动生成并上传，它的内容就是`qsub_header`与`commands`的结合体。然后执行`work.sh`文本，然后将输出结果传回来。\n\n上传与运行可以利用`sync-deploy`命令一步搞定：\n```shell\n# 利用add_path.sh将命令加入环境路径后，我们可以利用tab补全查找命令\nwsx@Desktop-berry:~$ sync-\nsync-check     sync-command   sync-deploy    sync-download  sync-run       sync-upload\n\n# 利用sync-command查看目标路径情况\nwsx@Desktop-berry:~$ sync-command \"ls -al  ~/test\"\n总用量 8\ndrwxrwxr-x  2 liuxs liuxs 4096 1月  30 23:52 .\ndrwx------ 10 liuxs liuxs 4096 1月  30 22:51 ..\n\n# 部署任务到远程\n\nwsx@Desktop-berry:~$ sync-deploy -n ~/working/sync-deploy/src/test/test.R -d '~/test/'\n==> command used: scp -pr -P 22 /home/wsx/working/sync-deploy/src/test/test.R /home/wsx/working/sync-deploy/src/work.sh liuxs@10.15.22.110:~/test/\n==>\ntest.R                                                                                                          100%   60     0.1KB/s   00:00\nwork.sh                                                                                                         100%  300     0.3KB/s   00:00\n==> Files upload successfully.\n\n==> run as batch mode.......\njob_id file locate at ~/test/job_id , id is\n87732.node1\n==>\n==> The work deploy successfully.\n\n```\n\n可以看到任务成功部署并返回了`job id`，利用`sync-check`命令查询\n\n```shell\nwsx@Desktop-berry:~$ sync-check 87732\nJob ID                    Name             User            Time Use S Queue\n------------------------- ---------------- --------------- -------- - -----\n87732.node1                work.sh          liuxs           00:00:00 C normal_3\n```\n\n因为任务时间不长，很快就搞定了，已经出现了`C`标志（完成）。\n\n我们查看一下远程目录情况：\n\n```shell\nwsx@Desktop-berry:~$ sync-command ls '~/test'\njob_id\nresult2.txt\nresult.txt\ntest.R\nwork.sh\n```\n\n`job_id`文件是用来保存作业号信息的，就是前面输出的`87732.node1`。其他不用解释了。\n\n最后一步，将需要的结果下载回本地。\n\n我们创建一个临时目录单独存储，然后查看文件内容：\n\n```shell\nwsx@Desktop-berry:~$ mkdir test\nwsx@Desktop-berry:~$ sync-download -n \"~/test/*\" -d ~/test\n==> command used: scp -pr -P 22 liuxs@10.15.22.110:~/test/* /home/wsx/test\n==>\njob_id                                                                                                          100%   12     0.0KB/s   00:00\nresult2.txt                                                                                                     100%   51     0.1KB/s   00:00\nresult.txt                                                                                                      100%   34     0.0KB/s   00:00\ntest.R                                                                                                          100%   60     0.1KB/s   00:00\nwork.sh                                                                                                         100%  300     0.3KB/s   00:00\n==> Files download successfully.\n\nwsx@Desktop-berry:~$ cd test/\nwsx@Desktop-berry:~/test$ ls\njob_id  result2.txt  result.txt  test.R  work.sh\nwsx@Desktop-berry:~/test$ cat result.txt\nThi mission is run successfully!!\nwsx@Desktop-berry:~/test$ cat result2.txt\n[1] \"==>\"\n[1] \"==> Hello world!!!!!!!!\"\n[1] \"==> \"\n```\n\n**任务完成！**\n\n## 问题\n\n有问题欢迎[提交issue](https://github.com/ShixiangWang/sync-deploy/issues)进行讨论。\n","source":"_posts/2018-01-31-sync-deploy-tools.md","raw":"---\ntitle: Sync deploy 命令工具\nauthor: 王诗翔\ncategories: 开源工具\ndate: 2018-01-31 21:05:55\ntop: true\ntags:\n---\n\n该命令集可以非常方便地向远程主机/服务器上传文件、运行远程脚本、下载文件等。\n\n<div class=\"github-widget\" data-repo=\"ShixiangWang/sync-deploy\"></div>\n\n\n<!-- more -->\n\n**目录**：\n\n- [目的](https://github.com/ShixiangWang/sync-deploy#目的)\n- [下载与使用](https://github.com/ShixiangWang/sync-deploy#下载与使用)\n- [准备与配置](https://github.com/ShixiangWang/sync-deploy#准备与配置)\n- [命令说明](https://github.com/ShixiangWang/sync-deploy#命令说明)\n    \n    - [sync-command](https://github.com/ShixiangWang/sync-deploy#sync-command)\n    - [sync-upload](https://github.com/ShixiangWang/sync-deploy#sync-upload)\n    - [sync-download](https://github.com/ShixiangWang/sync-deploy#sync-download)\n    - [sync-run](https://github.com/ShixiangWang/sync-deploy#sync-run)\n    - [sync-deploy](https://github.com/ShixiangWang/sync-deploy#sync-deploy)\n    - [sync-check](https://github.com/ShixiangWang/sync-deploy#sync-check)\n- [计算操作实例](https://github.com/ShixiangWang/sync-deploy#计算操作实例)\n\n\n## 目的\n\n交互式地输入ssh、scp命令进行远端主机命令/脚本的执行、文件的上传与下载并不是很方便，有时候频繁地键入`hostname@ip`也是一件非常痛苦的事情。另外一方面，如果是向计算平台提交任务脚本，在远端文本命令窗口内修改作业参数以及调试运行脚本也是蛮不方便。所以仓库里脚本是为了能够比较方便地执行这一些任务。\n\n命令集内置`ssh`、`scp`、`qsub`、`qstat`命令，分别用于运行远程脚本、命令、上传/下载文件、提交作业和查看作业状态。\n\n## 下载与使用\n\n[点击下载](https://github.com/ShixiangWang/sync-deploy/releases)\n\n或克隆：\n\n```\ngit clone https://github.com/ShixiangWang/sync-deploy.git\n```\n\n下载后执行`add_path.sh`脚本将命令添加到环境路径中，这样无论你处于什么目录都能使用。\n\n```shell\ncd sync-deploy/src\n./add_path.sh\n```\n\n除了`sync-command`命令没有选项，其他命令基本都有选项需要指定。\n\n**对应地，除了`sync-command`其他命令都有`-h`选项，你可以获取帮助**。\n\n```shell\nsync-upload -h\nsync-download -h\nsync-run -h\nsync-deploy -h\nsync-check -h\n```\n\n## 准备与配置\n\n首先在服务器端配置本地机器的公钥，以便于实现无密码文件传输。\n\n参考文章[ssh-keygen基本用法](https://www.liaohuqiu.net/cn/posts/ssh-keygen-abc/)或其他资料生成公钥和私钥(搜索引擎可以找到一大堆这样的博文，我就不啰嗦了)。\n\n将公钥`id_sra.pub`（本地机器.ssh子目录下）中文本内容拷贝到服务器.ssh子目录中的`authorized_keys`中，放在已有文本后面。如果该文件不存在则创建。\n\n进行测试，如果不需要密码登录则成功。\n\n**然后点击打开当前目录（src/）的`sync-setting`文件，将远程主机的host名与ip地址改为你自己的**。\n\n\n*****\n\n**如果你想要在计算平台部署任务**，请点击打开当前目录下的`qsub_header`文件填入PBS参数，设置可以参考[我整理的](https://github.com/ShixiangWang/mytoolkit/blob/master/hpc_info.md)或者百度上的其他资源，例如[1](https://wenku.baidu.com/view/5ab820293169a4517723a3ec.html)，[2](https://wenku.baidu.com/view/14ef7c230722192e4536f6f8.html)等。\n\n**接着在当前目录的`commands`文件夹填入你要运行的命令。如果你想要运行其他脚本，请在该文件中调用执行**。\n\n## 命令说明\n\n### sync-command\n\n这个命令最简单粗暴，直接在`sync-command`后接你想要在远端执行的命令。\n\n```shell\n$ sync-command ls -l '~/test'\n总用量 0\n-rw-rw-r-- 1 liuxs liuxs  12 1月  30 19:20 job_id\n-rw-rw-r-- 1 liuxs liuxs  34 1月  30 19:20 result.txt\n-rw-rw-r-- 1 liuxs liuxs 110 1月  29 11:40 test.R\n-rwxrw-r-- 1 liuxs liuxs 240 1月  30 19:20 work.sh\n```\n\n**需要注意的是如果是想使用类似`~`这种映射到某个路径的符号，需要添加引号，不然它会被解析为本地地址，那当然会出问题的**\n\n\n### sync-upload\n\n上传文件到远程主机。\n\n用法：\n\n```shell\n    Usage: sync-upload -n local_files -d 'destdir'\n```\n\n`-n`选项后接你要上传的（本地机器）文件/目录路径，`-d`选项接远程主机上的目录路径。\n\n用法示例：\n\n```shell\n==> examples:\n              sync-upload -n work.sh -d /public/home/liuxs/test\n         or\n              sync-upload -n work.sh -d '~/test'\n```\n\n同样注意使用`~`时需要加引号。\n\n**重点注意不支持-n与-d倒过来写，也就是选项是有顺序的**，为什么如此的原因是为了使`-n`选项后能够接大于1个的路径参数，命令脚本内部利用了`-n`和`-d`的位置特点运用正则表达式抓取所有路径名，你可以利用该命令同时上传不止一个文件/目录（也算是有得有失吧）。\n\n### sync-download\n\n从远程主机下载文件到本地机器。\n\n用法：\n\n```shell\n    Usage: sync-download -n 'remote_files' -d localdir\n```\n\n这个命令的使用基本和`sync-upload`一致。\n\n用法示例：\n\n```shell\n==> examples:\n              sync-download -n '~/test/*' -d ./test\n         or\n              sync-download -n /public/home/liuxs/test/* -d ./test\n```\n\n**同样地，不支持`-n`与`-d`选项顺序反着写。**\n\n### sync-run\n\n提交远程主机的作业，内置`qsub`命令向计算平台提交任务脚本。如果只是想要运行远程脚本或命令，请查看`sync-command`命令。\n\n用法：\n\n```shell\n    sync-run -f work_script\n```\n\n`-f`选项后接你要运行的**一个**脚本（需要指定脚本的路径哈）。\n\n用法示例：\n\n```shell\n    sync-run -f /home/wsx/work.sh\n```\n\n## sync-deploy\n\n上传文件、提交作业一气呵成。\n\n该命令内置调用`sync-upload`和`sync-run`这两个命令，以及其他几个脚本。在进行相关配置后，它可以根据`qsub_header`和`commands`两个文本自动生成作业脚本`work.sh`，上传指定文档（`work.sh`不指定也会上传），然后提交到任务节点进行运算。\n\n用法：\n\n```shell\n    Usage: sync-deploy -n local_files -d 'destdir'\n```\n\n同样注意`~`的使用问题，另外，如果你只部署运行`work.sh`文档，那么请在`-n`选项后加`work.sh`，（因为`-n`选项后不加内容会报错）虽然该文本会被上传两次，但不会影响使用。\n\n一个实例如下：\n\n```shell\n$ sync-deploy -n work.sh -d '~/test'\n==> command used: scp -pr -P 22 work.sh /home/wsx/working/sync-deploy/src/work.sh liuxs@10.15.22.110:~/test\n==>\nwork.sh                                                                                                         100%  240     0.2KB/s   00:00\nwork.sh                                                                                                         100%  240     0.2KB/s   00:00\n==> Files upload successfully.\n\n==> run as batch mode.......\njob_id file locate at ~/test/job_id , id is\n87728.node1\n==>\n==> The work deploy successfully.\n\n```\n\n### sync-check\n\n用来查看作业状态。\n\n用法：\n\n```shell\n    Usage: sync-deploy -n id\n```\n\n如果指定`-n`选项加上作业号，会查询指定的作业状态，如果不指定，会查看所有的作业状态。\n\n任务部署后会返回作业号，刚提交了两个作业，我们来查一查。\n\n```shell\n$ sync-check -n 87730\nJob ID                    Name             User            Time Use S Queue\n------------------------- ---------------- --------------- -------- - -----\n87730.node1                work.sh          liuxs           00:00:00 C normal_3\n\n$ sync-check -n 87730.node1\nJob ID                    Name             User            Time Use S Queue\n------------------------- ---------------- --------------- -------- - -----\n87730.node1                work.sh          liuxs           00:00:00 C normal_3\n\n$ sync-check\nJob ID                    Name             User            Time Use S Queue\n------------------------- ---------------- --------------- -------- - -----\n87729.node1                work.sh          liuxs           00:00:00 C normal_3\n87730.node1                work.sh          liuxs           00:00:00 C normal_3\n\n```\n\n## 计算操作实例\n\n我们来通过一个完整的实例来了解这些命令。\n\n**我们的任务是**利用远程的计算平台运行一些shell命令，执行一个R脚本。\n\n该R脚本位于`src/`的`test`目录下，这个脚本我们可以看做我们日常工作运行的主脚本。\n\n我们需要准备什么呢？\n\n只需要正确填写`qsub_header`与`commands`文档即可。\n\n我们先看看`qsub_header`的内容：\n\n```\n#PBS -l nodes=1:ppn=10\n#PBS -S /bin/bash\n#PBS -j oe\n#PBS -q normal_3\n\n# Please set PBS arguments above\n```\n\n上述就是一些PBS选项和参数，按你自己的需求和正确写法填写即可。这里测试我就简单地设定了节点与队列。具体参数你可以百度或者参考说明文档前面提供的信息。\n\n再瞧瞧`commands`文档：\n\n```shell\n# This job's working directory\ncd ~/test\n\n# Following are commands\nsleep 20\necho \"Thi mission is run successfully!!\" > ~/test/result.txt\n\n# call Rscripts\nRscript ~/test/test.R > ~/test/result2.txt\n```\n\n这个文档可能是我们工作主要需要修改的地方，这里我们用`cd`命令设定（作业的）工作目录，为避免任务结束太快，调用`sleep`命令让机器睡几秒，然后调用`echo`将一些文字结果传入一个结果文件，最后调用一个R脚本，并将结果传入另一个文件。\n\nR脚本的内容也非常简单,就是输入几行文本：\n\n```shell\nprint(\"==>\")\nprint(\"==> Hello world!!!!!!!!\")\nprint(\"==> \")\n```\n\n为避免程序找不到或者找错文件，我们最好指定文件所在的全部路径。\n\n**让我们开始跑命令吧～**\n\n任务方案很简单，我们将`test.R`上传到远程主机的工作目录下，注意，`work.sh`也会自动生成并上传，它的内容就是`qsub_header`与`commands`的结合体。然后执行`work.sh`文本，然后将输出结果传回来。\n\n上传与运行可以利用`sync-deploy`命令一步搞定：\n```shell\n# 利用add_path.sh将命令加入环境路径后，我们可以利用tab补全查找命令\nwsx@Desktop-berry:~$ sync-\nsync-check     sync-command   sync-deploy    sync-download  sync-run       sync-upload\n\n# 利用sync-command查看目标路径情况\nwsx@Desktop-berry:~$ sync-command \"ls -al  ~/test\"\n总用量 8\ndrwxrwxr-x  2 liuxs liuxs 4096 1月  30 23:52 .\ndrwx------ 10 liuxs liuxs 4096 1月  30 22:51 ..\n\n# 部署任务到远程\n\nwsx@Desktop-berry:~$ sync-deploy -n ~/working/sync-deploy/src/test/test.R -d '~/test/'\n==> command used: scp -pr -P 22 /home/wsx/working/sync-deploy/src/test/test.R /home/wsx/working/sync-deploy/src/work.sh liuxs@10.15.22.110:~/test/\n==>\ntest.R                                                                                                          100%   60     0.1KB/s   00:00\nwork.sh                                                                                                         100%  300     0.3KB/s   00:00\n==> Files upload successfully.\n\n==> run as batch mode.......\njob_id file locate at ~/test/job_id , id is\n87732.node1\n==>\n==> The work deploy successfully.\n\n```\n\n可以看到任务成功部署并返回了`job id`，利用`sync-check`命令查询\n\n```shell\nwsx@Desktop-berry:~$ sync-check 87732\nJob ID                    Name             User            Time Use S Queue\n------------------------- ---------------- --------------- -------- - -----\n87732.node1                work.sh          liuxs           00:00:00 C normal_3\n```\n\n因为任务时间不长，很快就搞定了，已经出现了`C`标志（完成）。\n\n我们查看一下远程目录情况：\n\n```shell\nwsx@Desktop-berry:~$ sync-command ls '~/test'\njob_id\nresult2.txt\nresult.txt\ntest.R\nwork.sh\n```\n\n`job_id`文件是用来保存作业号信息的，就是前面输出的`87732.node1`。其他不用解释了。\n\n最后一步，将需要的结果下载回本地。\n\n我们创建一个临时目录单独存储，然后查看文件内容：\n\n```shell\nwsx@Desktop-berry:~$ mkdir test\nwsx@Desktop-berry:~$ sync-download -n \"~/test/*\" -d ~/test\n==> command used: scp -pr -P 22 liuxs@10.15.22.110:~/test/* /home/wsx/test\n==>\njob_id                                                                                                          100%   12     0.0KB/s   00:00\nresult2.txt                                                                                                     100%   51     0.1KB/s   00:00\nresult.txt                                                                                                      100%   34     0.0KB/s   00:00\ntest.R                                                                                                          100%   60     0.1KB/s   00:00\nwork.sh                                                                                                         100%  300     0.3KB/s   00:00\n==> Files download successfully.\n\nwsx@Desktop-berry:~$ cd test/\nwsx@Desktop-berry:~/test$ ls\njob_id  result2.txt  result.txt  test.R  work.sh\nwsx@Desktop-berry:~/test$ cat result.txt\nThi mission is run successfully!!\nwsx@Desktop-berry:~/test$ cat result2.txt\n[1] \"==>\"\n[1] \"==> Hello world!!!!!!!!\"\n[1] \"==> \"\n```\n\n**任务完成！**\n\n## 问题\n\n有问题欢迎[提交issue](https://github.com/ShixiangWang/sync-deploy/issues)进行讨论。\n","slug":"sync-deploy-tools","published":1,"updated":"2018-02-05T11:10:52.150Z","_id":"cjda3cwv3000w9taxmpnez83h","comments":1,"layout":"post","photos":[],"link":"","content":"<p>该命令集可以非常方便地向远程主机/服务器上传文件、运行远程脚本、下载文件等。</p>\n<div class=\"github-widget\" data-repo=\"ShixiangWang/sync-deploy\"></div>\n\n\n<a id=\"more\"></a>\n<p><strong>目录</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#目的\" target=\"_blank\" rel=\"noopener\">目的</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#下载与使用\" target=\"_blank\" rel=\"noopener\">下载与使用</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#准备与配置\" target=\"_blank\" rel=\"noopener\">准备与配置</a></li>\n<li><p><a href=\"https://github.com/ShixiangWang/sync-deploy#命令说明\" target=\"_blank\" rel=\"noopener\">命令说明</a></p>\n<ul>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-command\" target=\"_blank\" rel=\"noopener\">sync-command</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-upload\" target=\"_blank\" rel=\"noopener\">sync-upload</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-download\" target=\"_blank\" rel=\"noopener\">sync-download</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-run\" target=\"_blank\" rel=\"noopener\">sync-run</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-deploy\" target=\"_blank\" rel=\"noopener\">sync-deploy</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-check\" target=\"_blank\" rel=\"noopener\">sync-check</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#计算操作实例\" target=\"_blank\" rel=\"noopener\">计算操作实例</a></li>\n</ul>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>交互式地输入ssh、scp命令进行远端主机命令/脚本的执行、文件的上传与下载并不是很方便，有时候频繁地键入<code>hostname@ip</code>也是一件非常痛苦的事情。另外一方面，如果是向计算平台提交任务脚本，在远端文本命令窗口内修改作业参数以及调试运行脚本也是蛮不方便。所以仓库里脚本是为了能够比较方便地执行这一些任务。</p>\n<p>命令集内置<code>ssh</code>、<code>scp</code>、<code>qsub</code>、<code>qstat</code>命令，分别用于运行远程脚本、命令、上传/下载文件、提交作业和查看作业状态。</p>\n<h2 id=\"下载与使用\"><a href=\"#下载与使用\" class=\"headerlink\" title=\"下载与使用\"></a>下载与使用</h2><p><a href=\"https://github.com/ShixiangWang/sync-deploy/releases\" target=\"_blank\" rel=\"noopener\">点击下载</a></p>\n<p>或克隆：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">clone</span> <span class=\"title\">https</span>://github.com/ShixiangWang/sync-deploy.git</span><br></pre></td></tr></table></figure>\n<p>下载后执行<code>add_path.sh</code>脚本将命令添加到环境路径中，这样无论你处于什么目录都能使用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd sync-deploy/src</span><br><span class=\"line\">./add_path.sh</span><br></pre></td></tr></table></figure>\n<p>除了<code>sync-command</code>命令没有选项，其他命令基本都有选项需要指定。</p>\n<p><strong>对应地，除了<code>sync-command</code>其他命令都有<code>-h</code>选项，你可以获取帮助</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync-upload -h</span><br><span class=\"line\">sync-download -h</span><br><span class=\"line\">sync-run -h</span><br><span class=\"line\">sync-deploy -h</span><br><span class=\"line\">sync-check -h</span><br></pre></td></tr></table></figure>\n<h2 id=\"准备与配置\"><a href=\"#准备与配置\" class=\"headerlink\" title=\"准备与配置\"></a>准备与配置</h2><p>首先在服务器端配置本地机器的公钥，以便于实现无密码文件传输。</p>\n<p>参考文章<a href=\"https://www.liaohuqiu.net/cn/posts/ssh-keygen-abc/\" target=\"_blank\" rel=\"noopener\">ssh-keygen基本用法</a>或其他资料生成公钥和私钥(搜索引擎可以找到一大堆这样的博文，我就不啰嗦了)。</p>\n<p>将公钥<code>id_sra.pub</code>（本地机器.ssh子目录下）中文本内容拷贝到服务器.ssh子目录中的<code>authorized_keys</code>中，放在已有文本后面。如果该文件不存在则创建。</p>\n<p>进行测试，如果不需要密码登录则成功。</p>\n<p><strong>然后点击打开当前目录（src/）的<code>sync-setting</code>文件，将远程主机的host名与ip地址改为你自己的</strong>。</p>\n<hr>\n<p><strong>如果你想要在计算平台部署任务</strong>，请点击打开当前目录下的<code>qsub_header</code>文件填入PBS参数，设置可以参考<a href=\"https://github.com/ShixiangWang/mytoolkit/blob/master/hpc_info.md\" target=\"_blank\" rel=\"noopener\">我整理的</a>或者百度上的其他资源，例如<a href=\"https://wenku.baidu.com/view/5ab820293169a4517723a3ec.html\" target=\"_blank\" rel=\"noopener\">1</a>，<a href=\"https://wenku.baidu.com/view/14ef7c230722192e4536f6f8.html\" target=\"_blank\" rel=\"noopener\">2</a>等。</p>\n<p><strong>接着在当前目录的<code>commands</code>文件夹填入你要运行的命令。如果你想要运行其他脚本，请在该文件中调用执行</strong>。</p>\n<h2 id=\"命令说明\"><a href=\"#命令说明\" class=\"headerlink\" title=\"命令说明\"></a>命令说明</h2><h3 id=\"sync-command\"><a href=\"#sync-command\" class=\"headerlink\" title=\"sync-command\"></a>sync-command</h3><p>这个命令最简单粗暴，直接在<code>sync-command</code>后接你想要在远端执行的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-command ls -l <span class=\"string\">'~/test'</span></span></span><br><span class=\"line\">总用量 0</span><br><span class=\"line\">-rw-rw-r-- 1 liuxs liuxs  12 1月  30 19:20 job_id</span><br><span class=\"line\">-rw-rw-r-- 1 liuxs liuxs  34 1月  30 19:20 result.txt</span><br><span class=\"line\">-rw-rw-r-- 1 liuxs liuxs 110 1月  29 11:40 test.R</span><br><span class=\"line\">-rwxrw-r-- 1 liuxs liuxs 240 1月  30 19:20 work.sh</span><br></pre></td></tr></table></figure>\n<p><strong>需要注意的是如果是想使用类似<code>~</code>这种映射到某个路径的符号，需要添加引号，不然它会被解析为本地地址，那当然会出问题的</strong></p>\n<h3 id=\"sync-upload\"><a href=\"#sync-upload\" class=\"headerlink\" title=\"sync-upload\"></a>sync-upload</h3><p>上传文件到远程主机。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: sync-upload -n local_files -d 'destdir'</span><br></pre></td></tr></table></figure>\n<p><code>-n</code>选项后接你要上传的（本地机器）文件/目录路径，<code>-d</code>选项接远程主机上的目录路径。</p>\n<p>用法示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; examples:</span><br><span class=\"line\">              sync-upload -n work.sh -d /public/home/liuxs/test</span><br><span class=\"line\">         or</span><br><span class=\"line\">              sync-upload -n work.sh -d '~/test'</span><br></pre></td></tr></table></figure>\n<p>同样注意使用<code>~</code>时需要加引号。</p>\n<p><strong>重点注意不支持-n与-d倒过来写，也就是选项是有顺序的</strong>，为什么如此的原因是为了使<code>-n</code>选项后能够接大于1个的路径参数，命令脚本内部利用了<code>-n</code>和<code>-d</code>的位置特点运用正则表达式抓取所有路径名，你可以利用该命令同时上传不止一个文件/目录（也算是有得有失吧）。</p>\n<h3 id=\"sync-download\"><a href=\"#sync-download\" class=\"headerlink\" title=\"sync-download\"></a>sync-download</h3><p>从远程主机下载文件到本地机器。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: sync-download -n 'remote_files' -d localdir</span><br></pre></td></tr></table></figure>\n<p>这个命令的使用基本和<code>sync-upload</code>一致。</p>\n<p>用法示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; examples:</span><br><span class=\"line\">              sync-download -n '~/test/*' -d ./test</span><br><span class=\"line\">         or</span><br><span class=\"line\">              sync-download -n /public/home/liuxs/test/* -d ./test</span><br></pre></td></tr></table></figure>\n<p><strong>同样地，不支持<code>-n</code>与<code>-d</code>选项顺序反着写。</strong></p>\n<h3 id=\"sync-run\"><a href=\"#sync-run\" class=\"headerlink\" title=\"sync-run\"></a>sync-run</h3><p>提交远程主机的作业，内置<code>qsub</code>命令向计算平台提交任务脚本。如果只是想要运行远程脚本或命令，请查看<code>sync-command</code>命令。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync-run -f work_script</span><br></pre></td></tr></table></figure>\n<p><code>-f</code>选项后接你要运行的<strong>一个</strong>脚本（需要指定脚本的路径哈）。</p>\n<p>用法示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync-run -f /home/wsx/work.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"sync-deploy\"><a href=\"#sync-deploy\" class=\"headerlink\" title=\"sync-deploy\"></a>sync-deploy</h2><p>上传文件、提交作业一气呵成。</p>\n<p>该命令内置调用<code>sync-upload</code>和<code>sync-run</code>这两个命令，以及其他几个脚本。在进行相关配置后，它可以根据<code>qsub_header</code>和<code>commands</code>两个文本自动生成作业脚本<code>work.sh</code>，上传指定文档（<code>work.sh</code>不指定也会上传），然后提交到任务节点进行运算。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: sync-deploy -n local_files -d 'destdir'</span><br></pre></td></tr></table></figure>\n<p>同样注意<code>~</code>的使用问题，另外，如果你只部署运行<code>work.sh</code>文档，那么请在<code>-n</code>选项后加<code>work.sh</code>，（因为<code>-n</code>选项后不加内容会报错）虽然该文本会被上传两次，但不会影响使用。</p>\n<p>一个实例如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-deploy -n work.sh -d <span class=\"string\">'~/test'</span></span></span><br><span class=\"line\">==&gt; command used: scp -pr -P 22 work.sh /home/wsx/working/sync-deploy/src/work.sh liuxs@10.15.22.110:~/test</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">work.sh                                                                                                         100%  240     0.2KB/s   00:00</span><br><span class=\"line\">work.sh                                                                                                         100%  240     0.2KB/s   00:00</span><br><span class=\"line\">==&gt; Files upload successfully.</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; run as batch mode.......</span><br><span class=\"line\">job_id file locate at ~/test/job_id , id is</span><br><span class=\"line\">87728.node1</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">==&gt; The work deploy successfully.</span><br></pre></td></tr></table></figure>\n<h3 id=\"sync-check\"><a href=\"#sync-check\" class=\"headerlink\" title=\"sync-check\"></a>sync-check</h3><p>用来查看作业状态。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: sync-deploy -n id</span><br></pre></td></tr></table></figure>\n<p>如果指定<code>-n</code>选项加上作业号，会查询指定的作业状态，如果不指定，会查看所有的作业状态。</p>\n<p>任务部署后会返回作业号，刚提交了两个作业，我们来查一查。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-check -n 87730</span></span><br><span class=\"line\">Job ID                    Name             User            Time Use S Queue</span><br><span class=\"line\">------------------------- ---------------- --------------- -------- - -----</span><br><span class=\"line\">87730.node1                work.sh          liuxs           00:00:00 C normal_3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-check -n 87730.node1</span></span><br><span class=\"line\">Job ID                    Name             User            Time Use S Queue</span><br><span class=\"line\">------------------------- ---------------- --------------- -------- - -----</span><br><span class=\"line\">87730.node1                work.sh          liuxs           00:00:00 C normal_3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-check</span></span><br><span class=\"line\">Job ID                    Name             User            Time Use S Queue</span><br><span class=\"line\">------------------------- ---------------- --------------- -------- - -----</span><br><span class=\"line\">87729.node1                work.sh          liuxs           00:00:00 C normal_3</span><br><span class=\"line\">87730.node1                work.sh          liuxs           00:00:00 C normal_3</span><br></pre></td></tr></table></figure>\n<h2 id=\"计算操作实例\"><a href=\"#计算操作实例\" class=\"headerlink\" title=\"计算操作实例\"></a>计算操作实例</h2><p>我们来通过一个完整的实例来了解这些命令。</p>\n<p><strong>我们的任务是</strong>利用远程的计算平台运行一些shell命令，执行一个R脚本。</p>\n<p>该R脚本位于<code>src/</code>的<code>test</code>目录下，这个脚本我们可以看做我们日常工作运行的主脚本。</p>\n<p>我们需要准备什么呢？</p>\n<p>只需要正确填写<code>qsub_header</code>与<code>commands</code>文档即可。</p>\n<p>我们先看看<code>qsub_header</code>的内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">PBS -l nodes=1:ppn=10</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">PBS -S /bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">PBS -j oe</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">PBS -q normal_3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Please <span class=\"built_in\">set</span> PBS arguments above</span></span><br></pre></td></tr></table></figure>\n<p>上述就是一些PBS选项和参数，按你自己的需求和正确写法填写即可。这里测试我就简单地设定了节点与队列。具体参数你可以百度或者参考说明文档前面提供的信息。</p>\n<p>再瞧瞧<code>commands</code>文档：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This job<span class=\"string\">'s working directory</span></span></span><br><span class=\"line\">cd ~/test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Following are commands</span></span><br><span class=\"line\">sleep 20</span><br><span class=\"line\">echo \"Thi mission is run successfully!!\" &gt; ~/test/result.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> call Rscripts</span></span><br><span class=\"line\">Rscript ~/test/test.R &gt; ~/test/result2.txt</span><br></pre></td></tr></table></figure>\n<p>这个文档可能是我们工作主要需要修改的地方，这里我们用<code>cd</code>命令设定（作业的）工作目录，为避免任务结束太快，调用<code>sleep</code>命令让机器睡几秒，然后调用<code>echo</code>将一些文字结果传入一个结果文件，最后调用一个R脚本，并将结果传入另一个文件。</p>\n<p>R脚本的内容也非常简单,就是输入几行文本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(\"==&gt;\")</span><br><span class=\"line\">print(\"==&gt; Hello world!!!!!!!!\")</span><br><span class=\"line\">print(\"==&gt; \")</span><br></pre></td></tr></table></figure>\n<p>为避免程序找不到或者找错文件，我们最好指定文件所在的全部路径。</p>\n<p><strong>让我们开始跑命令吧～</strong></p>\n<p>任务方案很简单，我们将<code>test.R</code>上传到远程主机的工作目录下，注意，<code>work.sh</code>也会自动生成并上传，它的内容就是<code>qsub_header</code>与<code>commands</code>的结合体。然后执行<code>work.sh</code>文本，然后将输出结果传回来。</p>\n<p>上传与运行可以利用<code>sync-deploy</code>命令一步搞定：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 利用add_path.sh将命令加入环境路径后，我们可以利用tab补全查找命令</span></span><br><span class=\"line\">wsx@Desktop-berry:~$ sync-</span><br><span class=\"line\">sync-check     sync-command   sync-deploy    sync-download  sync-run       sync-upload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 利用sync-command查看目标路径情况</span></span><br><span class=\"line\">wsx@Desktop-berry:~$ sync-command \"ls -al  ~/test\"</span><br><span class=\"line\">总用量 8</span><br><span class=\"line\">drwxrwxr-x  2 liuxs liuxs 4096 1月  30 23:52 .</span><br><span class=\"line\">drwx------ 10 liuxs liuxs 4096 1月  30 22:51 ..</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 部署任务到远程</span></span><br><span class=\"line\"></span><br><span class=\"line\">wsx@Desktop-berry:~$ sync-deploy -n ~/working/sync-deploy/src/test/test.R -d '~/test/'</span><br><span class=\"line\">==&gt; command used: scp -pr -P 22 /home/wsx/working/sync-deploy/src/test/test.R /home/wsx/working/sync-deploy/src/work.sh liuxs@10.15.22.110:~/test/</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">test.R                                                                                                          100%   60     0.1KB/s   00:00</span><br><span class=\"line\">work.sh                                                                                                         100%  300     0.3KB/s   00:00</span><br><span class=\"line\">==&gt; Files upload successfully.</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; run as batch mode.......</span><br><span class=\"line\">job_id file locate at ~/test/job_id , id is</span><br><span class=\"line\">87732.node1</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">==&gt; The work deploy successfully.</span><br></pre></td></tr></table></figure></p>\n<p>可以看到任务成功部署并返回了<code>job id</code>，利用<code>sync-check</code>命令查询</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@Desktop-berry:~$ sync-check 87732</span><br><span class=\"line\">Job ID                    Name             User            Time Use S Queue</span><br><span class=\"line\">------------------------- ---------------- --------------- -------- - -----</span><br><span class=\"line\">87732.node1                work.sh          liuxs           00:00:00 C normal_3</span><br></pre></td></tr></table></figure>\n<p>因为任务时间不长，很快就搞定了，已经出现了<code>C</code>标志（完成）。</p>\n<p>我们查看一下远程目录情况：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@Desktop-berry:~$ sync-command ls '~/test'</span><br><span class=\"line\">job_id</span><br><span class=\"line\">result2.txt</span><br><span class=\"line\">result.txt</span><br><span class=\"line\">test.R</span><br><span class=\"line\">work.sh</span><br></pre></td></tr></table></figure>\n<p><code>job_id</code>文件是用来保存作业号信息的，就是前面输出的<code>87732.node1</code>。其他不用解释了。</p>\n<p>最后一步，将需要的结果下载回本地。</p>\n<p>我们创建一个临时目录单独存储，然后查看文件内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@Desktop-berry:~$ mkdir test</span><br><span class=\"line\">wsx@Desktop-berry:~$ sync-download -n \"~/test/*\" -d ~/test</span><br><span class=\"line\">==&gt; command used: scp -pr -P 22 liuxs@10.15.22.110:~/test/* /home/wsx/test</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">job_id                                                                                                          100%   12     0.0KB/s   00:00</span><br><span class=\"line\">result2.txt                                                                                                     100%   51     0.1KB/s   00:00</span><br><span class=\"line\">result.txt                                                                                                      100%   34     0.0KB/s   00:00</span><br><span class=\"line\">test.R                                                                                                          100%   60     0.1KB/s   00:00</span><br><span class=\"line\">work.sh                                                                                                         100%  300     0.3KB/s   00:00</span><br><span class=\"line\">==&gt; Files download successfully.</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@Desktop-berry:~$ cd test/</span><br><span class=\"line\">wsx@Desktop-berry:~/test$ ls</span><br><span class=\"line\">job_id  result2.txt  result.txt  test.R  work.sh</span><br><span class=\"line\">wsx@Desktop-berry:~/test$ cat result.txt</span><br><span class=\"line\">Thi mission is run successfully!!</span><br><span class=\"line\">wsx@Desktop-berry:~/test$ cat result2.txt</span><br><span class=\"line\">[1] \"==&gt;\"</span><br><span class=\"line\">[1] \"==&gt; Hello world!!!!!!!!\"</span><br><span class=\"line\">[1] \"==&gt; \"</span><br></pre></td></tr></table></figure>\n<p><strong>任务完成！</strong></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>有问题欢迎<a href=\"https://github.com/ShixiangWang/sync-deploy/issues\" target=\"_blank\" rel=\"noopener\">提交issue</a>进行讨论。</p>\n","site":{"data":{}},"excerpt":"<p>该命令集可以非常方便地向远程主机/服务器上传文件、运行远程脚本、下载文件等。</p>\n<div class=\"github-widget\" data-repo=\"ShixiangWang/sync-deploy\"></div>","more":"<p><strong>目录</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#目的\" target=\"_blank\" rel=\"noopener\">目的</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#下载与使用\" target=\"_blank\" rel=\"noopener\">下载与使用</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#准备与配置\" target=\"_blank\" rel=\"noopener\">准备与配置</a></li>\n<li><p><a href=\"https://github.com/ShixiangWang/sync-deploy#命令说明\" target=\"_blank\" rel=\"noopener\">命令说明</a></p>\n<ul>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-command\" target=\"_blank\" rel=\"noopener\">sync-command</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-upload\" target=\"_blank\" rel=\"noopener\">sync-upload</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-download\" target=\"_blank\" rel=\"noopener\">sync-download</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-run\" target=\"_blank\" rel=\"noopener\">sync-run</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-deploy\" target=\"_blank\" rel=\"noopener\">sync-deploy</a></li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#sync-check\" target=\"_blank\" rel=\"noopener\">sync-check</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/ShixiangWang/sync-deploy#计算操作实例\" target=\"_blank\" rel=\"noopener\">计算操作实例</a></li>\n</ul>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>交互式地输入ssh、scp命令进行远端主机命令/脚本的执行、文件的上传与下载并不是很方便，有时候频繁地键入<code>hostname@ip</code>也是一件非常痛苦的事情。另外一方面，如果是向计算平台提交任务脚本，在远端文本命令窗口内修改作业参数以及调试运行脚本也是蛮不方便。所以仓库里脚本是为了能够比较方便地执行这一些任务。</p>\n<p>命令集内置<code>ssh</code>、<code>scp</code>、<code>qsub</code>、<code>qstat</code>命令，分别用于运行远程脚本、命令、上传/下载文件、提交作业和查看作业状态。</p>\n<h2 id=\"下载与使用\"><a href=\"#下载与使用\" class=\"headerlink\" title=\"下载与使用\"></a>下载与使用</h2><p><a href=\"https://github.com/ShixiangWang/sync-deploy/releases\" target=\"_blank\" rel=\"noopener\">点击下载</a></p>\n<p>或克隆：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"keyword\">clone</span> <span class=\"title\">https</span>://github.com/ShixiangWang/sync-deploy.git</span><br></pre></td></tr></table></figure>\n<p>下载后执行<code>add_path.sh</code>脚本将命令添加到环境路径中，这样无论你处于什么目录都能使用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd sync-deploy/src</span><br><span class=\"line\">./add_path.sh</span><br></pre></td></tr></table></figure>\n<p>除了<code>sync-command</code>命令没有选项，其他命令基本都有选项需要指定。</p>\n<p><strong>对应地，除了<code>sync-command</code>其他命令都有<code>-h</code>选项，你可以获取帮助</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync-upload -h</span><br><span class=\"line\">sync-download -h</span><br><span class=\"line\">sync-run -h</span><br><span class=\"line\">sync-deploy -h</span><br><span class=\"line\">sync-check -h</span><br></pre></td></tr></table></figure>\n<h2 id=\"准备与配置\"><a href=\"#准备与配置\" class=\"headerlink\" title=\"准备与配置\"></a>准备与配置</h2><p>首先在服务器端配置本地机器的公钥，以便于实现无密码文件传输。</p>\n<p>参考文章<a href=\"https://www.liaohuqiu.net/cn/posts/ssh-keygen-abc/\" target=\"_blank\" rel=\"noopener\">ssh-keygen基本用法</a>或其他资料生成公钥和私钥(搜索引擎可以找到一大堆这样的博文，我就不啰嗦了)。</p>\n<p>将公钥<code>id_sra.pub</code>（本地机器.ssh子目录下）中文本内容拷贝到服务器.ssh子目录中的<code>authorized_keys</code>中，放在已有文本后面。如果该文件不存在则创建。</p>\n<p>进行测试，如果不需要密码登录则成功。</p>\n<p><strong>然后点击打开当前目录（src/）的<code>sync-setting</code>文件，将远程主机的host名与ip地址改为你自己的</strong>。</p>\n<hr>\n<p><strong>如果你想要在计算平台部署任务</strong>，请点击打开当前目录下的<code>qsub_header</code>文件填入PBS参数，设置可以参考<a href=\"https://github.com/ShixiangWang/mytoolkit/blob/master/hpc_info.md\" target=\"_blank\" rel=\"noopener\">我整理的</a>或者百度上的其他资源，例如<a href=\"https://wenku.baidu.com/view/5ab820293169a4517723a3ec.html\" target=\"_blank\" rel=\"noopener\">1</a>，<a href=\"https://wenku.baidu.com/view/14ef7c230722192e4536f6f8.html\" target=\"_blank\" rel=\"noopener\">2</a>等。</p>\n<p><strong>接着在当前目录的<code>commands</code>文件夹填入你要运行的命令。如果你想要运行其他脚本，请在该文件中调用执行</strong>。</p>\n<h2 id=\"命令说明\"><a href=\"#命令说明\" class=\"headerlink\" title=\"命令说明\"></a>命令说明</h2><h3 id=\"sync-command\"><a href=\"#sync-command\" class=\"headerlink\" title=\"sync-command\"></a>sync-command</h3><p>这个命令最简单粗暴，直接在<code>sync-command</code>后接你想要在远端执行的命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-command ls -l <span class=\"string\">'~/test'</span></span></span><br><span class=\"line\">总用量 0</span><br><span class=\"line\">-rw-rw-r-- 1 liuxs liuxs  12 1月  30 19:20 job_id</span><br><span class=\"line\">-rw-rw-r-- 1 liuxs liuxs  34 1月  30 19:20 result.txt</span><br><span class=\"line\">-rw-rw-r-- 1 liuxs liuxs 110 1月  29 11:40 test.R</span><br><span class=\"line\">-rwxrw-r-- 1 liuxs liuxs 240 1月  30 19:20 work.sh</span><br></pre></td></tr></table></figure>\n<p><strong>需要注意的是如果是想使用类似<code>~</code>这种映射到某个路径的符号，需要添加引号，不然它会被解析为本地地址，那当然会出问题的</strong></p>\n<h3 id=\"sync-upload\"><a href=\"#sync-upload\" class=\"headerlink\" title=\"sync-upload\"></a>sync-upload</h3><p>上传文件到远程主机。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: sync-upload -n local_files -d 'destdir'</span><br></pre></td></tr></table></figure>\n<p><code>-n</code>选项后接你要上传的（本地机器）文件/目录路径，<code>-d</code>选项接远程主机上的目录路径。</p>\n<p>用法示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; examples:</span><br><span class=\"line\">              sync-upload -n work.sh -d /public/home/liuxs/test</span><br><span class=\"line\">         or</span><br><span class=\"line\">              sync-upload -n work.sh -d '~/test'</span><br></pre></td></tr></table></figure>\n<p>同样注意使用<code>~</code>时需要加引号。</p>\n<p><strong>重点注意不支持-n与-d倒过来写，也就是选项是有顺序的</strong>，为什么如此的原因是为了使<code>-n</code>选项后能够接大于1个的路径参数，命令脚本内部利用了<code>-n</code>和<code>-d</code>的位置特点运用正则表达式抓取所有路径名，你可以利用该命令同时上传不止一个文件/目录（也算是有得有失吧）。</p>\n<h3 id=\"sync-download\"><a href=\"#sync-download\" class=\"headerlink\" title=\"sync-download\"></a>sync-download</h3><p>从远程主机下载文件到本地机器。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: sync-download -n 'remote_files' -d localdir</span><br></pre></td></tr></table></figure>\n<p>这个命令的使用基本和<code>sync-upload</code>一致。</p>\n<p>用法示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==&gt; examples:</span><br><span class=\"line\">              sync-download -n '~/test/*' -d ./test</span><br><span class=\"line\">         or</span><br><span class=\"line\">              sync-download -n /public/home/liuxs/test/* -d ./test</span><br></pre></td></tr></table></figure>\n<p><strong>同样地，不支持<code>-n</code>与<code>-d</code>选项顺序反着写。</strong></p>\n<h3 id=\"sync-run\"><a href=\"#sync-run\" class=\"headerlink\" title=\"sync-run\"></a>sync-run</h3><p>提交远程主机的作业，内置<code>qsub</code>命令向计算平台提交任务脚本。如果只是想要运行远程脚本或命令，请查看<code>sync-command</code>命令。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync-run -f work_script</span><br></pre></td></tr></table></figure>\n<p><code>-f</code>选项后接你要运行的<strong>一个</strong>脚本（需要指定脚本的路径哈）。</p>\n<p>用法示例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync-run -f /home/wsx/work.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"sync-deploy\"><a href=\"#sync-deploy\" class=\"headerlink\" title=\"sync-deploy\"></a>sync-deploy</h2><p>上传文件、提交作业一气呵成。</p>\n<p>该命令内置调用<code>sync-upload</code>和<code>sync-run</code>这两个命令，以及其他几个脚本。在进行相关配置后，它可以根据<code>qsub_header</code>和<code>commands</code>两个文本自动生成作业脚本<code>work.sh</code>，上传指定文档（<code>work.sh</code>不指定也会上传），然后提交到任务节点进行运算。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: sync-deploy -n local_files -d 'destdir'</span><br></pre></td></tr></table></figure>\n<p>同样注意<code>~</code>的使用问题，另外，如果你只部署运行<code>work.sh</code>文档，那么请在<code>-n</code>选项后加<code>work.sh</code>，（因为<code>-n</code>选项后不加内容会报错）虽然该文本会被上传两次，但不会影响使用。</p>\n<p>一个实例如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-deploy -n work.sh -d <span class=\"string\">'~/test'</span></span></span><br><span class=\"line\">==&gt; command used: scp -pr -P 22 work.sh /home/wsx/working/sync-deploy/src/work.sh liuxs@10.15.22.110:~/test</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">work.sh                                                                                                         100%  240     0.2KB/s   00:00</span><br><span class=\"line\">work.sh                                                                                                         100%  240     0.2KB/s   00:00</span><br><span class=\"line\">==&gt; Files upload successfully.</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; run as batch mode.......</span><br><span class=\"line\">job_id file locate at ~/test/job_id , id is</span><br><span class=\"line\">87728.node1</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">==&gt; The work deploy successfully.</span><br></pre></td></tr></table></figure>\n<h3 id=\"sync-check\"><a href=\"#sync-check\" class=\"headerlink\" title=\"sync-check\"></a>sync-check</h3><p>用来查看作业状态。</p>\n<p>用法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: sync-deploy -n id</span><br></pre></td></tr></table></figure>\n<p>如果指定<code>-n</code>选项加上作业号，会查询指定的作业状态，如果不指定，会查看所有的作业状态。</p>\n<p>任务部署后会返回作业号，刚提交了两个作业，我们来查一查。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-check -n 87730</span></span><br><span class=\"line\">Job ID                    Name             User            Time Use S Queue</span><br><span class=\"line\">------------------------- ---------------- --------------- -------- - -----</span><br><span class=\"line\">87730.node1                work.sh          liuxs           00:00:00 C normal_3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-check -n 87730.node1</span></span><br><span class=\"line\">Job ID                    Name             User            Time Use S Queue</span><br><span class=\"line\">------------------------- ---------------- --------------- -------- - -----</span><br><span class=\"line\">87730.node1                work.sh          liuxs           00:00:00 C normal_3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> sync-check</span></span><br><span class=\"line\">Job ID                    Name             User            Time Use S Queue</span><br><span class=\"line\">------------------------- ---------------- --------------- -------- - -----</span><br><span class=\"line\">87729.node1                work.sh          liuxs           00:00:00 C normal_3</span><br><span class=\"line\">87730.node1                work.sh          liuxs           00:00:00 C normal_3</span><br></pre></td></tr></table></figure>\n<h2 id=\"计算操作实例\"><a href=\"#计算操作实例\" class=\"headerlink\" title=\"计算操作实例\"></a>计算操作实例</h2><p>我们来通过一个完整的实例来了解这些命令。</p>\n<p><strong>我们的任务是</strong>利用远程的计算平台运行一些shell命令，执行一个R脚本。</p>\n<p>该R脚本位于<code>src/</code>的<code>test</code>目录下，这个脚本我们可以看做我们日常工作运行的主脚本。</p>\n<p>我们需要准备什么呢？</p>\n<p>只需要正确填写<code>qsub_header</code>与<code>commands</code>文档即可。</p>\n<p>我们先看看<code>qsub_header</code>的内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">PBS -l nodes=1:ppn=10</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">PBS -S /bin/bash</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">PBS -j oe</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">PBS -q normal_3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Please <span class=\"built_in\">set</span> PBS arguments above</span></span><br></pre></td></tr></table></figure>\n<p>上述就是一些PBS选项和参数，按你自己的需求和正确写法填写即可。这里测试我就简单地设定了节点与队列。具体参数你可以百度或者参考说明文档前面提供的信息。</p>\n<p>再瞧瞧<code>commands</code>文档：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> This job<span class=\"string\">'s working directory</span></span></span><br><span class=\"line\">cd ~/test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Following are commands</span></span><br><span class=\"line\">sleep 20</span><br><span class=\"line\">echo \"Thi mission is run successfully!!\" &gt; ~/test/result.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> call Rscripts</span></span><br><span class=\"line\">Rscript ~/test/test.R &gt; ~/test/result2.txt</span><br></pre></td></tr></table></figure>\n<p>这个文档可能是我们工作主要需要修改的地方，这里我们用<code>cd</code>命令设定（作业的）工作目录，为避免任务结束太快，调用<code>sleep</code>命令让机器睡几秒，然后调用<code>echo</code>将一些文字结果传入一个结果文件，最后调用一个R脚本，并将结果传入另一个文件。</p>\n<p>R脚本的内容也非常简单,就是输入几行文本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(\"==&gt;\")</span><br><span class=\"line\">print(\"==&gt; Hello world!!!!!!!!\")</span><br><span class=\"line\">print(\"==&gt; \")</span><br></pre></td></tr></table></figure>\n<p>为避免程序找不到或者找错文件，我们最好指定文件所在的全部路径。</p>\n<p><strong>让我们开始跑命令吧～</strong></p>\n<p>任务方案很简单，我们将<code>test.R</code>上传到远程主机的工作目录下，注意，<code>work.sh</code>也会自动生成并上传，它的内容就是<code>qsub_header</code>与<code>commands</code>的结合体。然后执行<code>work.sh</code>文本，然后将输出结果传回来。</p>\n<p>上传与运行可以利用<code>sync-deploy</code>命令一步搞定：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 利用add_path.sh将命令加入环境路径后，我们可以利用tab补全查找命令</span></span><br><span class=\"line\">wsx@Desktop-berry:~$ sync-</span><br><span class=\"line\">sync-check     sync-command   sync-deploy    sync-download  sync-run       sync-upload</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 利用sync-command查看目标路径情况</span></span><br><span class=\"line\">wsx@Desktop-berry:~$ sync-command \"ls -al  ~/test\"</span><br><span class=\"line\">总用量 8</span><br><span class=\"line\">drwxrwxr-x  2 liuxs liuxs 4096 1月  30 23:52 .</span><br><span class=\"line\">drwx------ 10 liuxs liuxs 4096 1月  30 22:51 ..</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 部署任务到远程</span></span><br><span class=\"line\"></span><br><span class=\"line\">wsx@Desktop-berry:~$ sync-deploy -n ~/working/sync-deploy/src/test/test.R -d '~/test/'</span><br><span class=\"line\">==&gt; command used: scp -pr -P 22 /home/wsx/working/sync-deploy/src/test/test.R /home/wsx/working/sync-deploy/src/work.sh liuxs@10.15.22.110:~/test/</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">test.R                                                                                                          100%   60     0.1KB/s   00:00</span><br><span class=\"line\">work.sh                                                                                                         100%  300     0.3KB/s   00:00</span><br><span class=\"line\">==&gt; Files upload successfully.</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; run as batch mode.......</span><br><span class=\"line\">job_id file locate at ~/test/job_id , id is</span><br><span class=\"line\">87732.node1</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">==&gt; The work deploy successfully.</span><br></pre></td></tr></table></figure></p>\n<p>可以看到任务成功部署并返回了<code>job id</code>，利用<code>sync-check</code>命令查询</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@Desktop-berry:~$ sync-check 87732</span><br><span class=\"line\">Job ID                    Name             User            Time Use S Queue</span><br><span class=\"line\">------------------------- ---------------- --------------- -------- - -----</span><br><span class=\"line\">87732.node1                work.sh          liuxs           00:00:00 C normal_3</span><br></pre></td></tr></table></figure>\n<p>因为任务时间不长，很快就搞定了，已经出现了<code>C</code>标志（完成）。</p>\n<p>我们查看一下远程目录情况：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@Desktop-berry:~$ sync-command ls '~/test'</span><br><span class=\"line\">job_id</span><br><span class=\"line\">result2.txt</span><br><span class=\"line\">result.txt</span><br><span class=\"line\">test.R</span><br><span class=\"line\">work.sh</span><br></pre></td></tr></table></figure>\n<p><code>job_id</code>文件是用来保存作业号信息的，就是前面输出的<code>87732.node1</code>。其他不用解释了。</p>\n<p>最后一步，将需要的结果下载回本地。</p>\n<p>我们创建一个临时目录单独存储，然后查看文件内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsx@Desktop-berry:~$ mkdir test</span><br><span class=\"line\">wsx@Desktop-berry:~$ sync-download -n \"~/test/*\" -d ~/test</span><br><span class=\"line\">==&gt; command used: scp -pr -P 22 liuxs@10.15.22.110:~/test/* /home/wsx/test</span><br><span class=\"line\">==&gt;</span><br><span class=\"line\">job_id                                                                                                          100%   12     0.0KB/s   00:00</span><br><span class=\"line\">result2.txt                                                                                                     100%   51     0.1KB/s   00:00</span><br><span class=\"line\">result.txt                                                                                                      100%   34     0.0KB/s   00:00</span><br><span class=\"line\">test.R                                                                                                          100%   60     0.1KB/s   00:00</span><br><span class=\"line\">work.sh                                                                                                         100%  300     0.3KB/s   00:00</span><br><span class=\"line\">==&gt; Files download successfully.</span><br><span class=\"line\"></span><br><span class=\"line\">wsx@Desktop-berry:~$ cd test/</span><br><span class=\"line\">wsx@Desktop-berry:~/test$ ls</span><br><span class=\"line\">job_id  result2.txt  result.txt  test.R  work.sh</span><br><span class=\"line\">wsx@Desktop-berry:~/test$ cat result.txt</span><br><span class=\"line\">Thi mission is run successfully!!</span><br><span class=\"line\">wsx@Desktop-berry:~/test$ cat result2.txt</span><br><span class=\"line\">[1] \"==&gt;\"</span><br><span class=\"line\">[1] \"==&gt; Hello world!!!!!!!!\"</span><br><span class=\"line\">[1] \"==&gt; \"</span><br></pre></td></tr></table></figure>\n<p><strong>任务完成！</strong></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>有问题欢迎<a href=\"https://github.com/ShixiangWang/sync-deploy/issues\" target=\"_blank\" rel=\"noopener\">提交issue</a>进行讨论。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjda3cwus000l9tax74xlw580","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwv2000s9tax6nf4wi0o"},{"post_id":"cjda3cwu900079tax6a3exgys","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwv5000x9taxl1we0fzl"},{"post_id":"cjda3cwu900079tax6a3exgys","category_id":"cjda3cwur000i9taxevvfv109","_id":"cjda3cwv6000y9taxwp3rwx12"},{"post_id":"cjda3cwuz000p9taxwckty66v","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwv900119tax1wvhswkj"},{"post_id":"cjda3cwuz000p9taxwckty66v","category_id":"cjda3cwur000i9taxevvfv109","_id":"cjda3cwva00139taxileesd0u"},{"post_id":"cjda3cwtk00009taxuz8xf5q2","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwvc00179taxvlmn432v"},{"post_id":"cjda3cwtk00009taxuz8xf5q2","category_id":"cjda3cwur000i9taxevvfv109","_id":"cjda3cwve00199taxx4m09ibj"},{"post_id":"cjda3cwv1000r9taxxdmeulul","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwvf001d9taxt4ji01em"},{"post_id":"cjda3cwv1000r9taxxdmeulul","category_id":"cjda3cwur000i9taxevvfv109","_id":"cjda3cwvg001e9taxmvhr1la7"},{"post_id":"cjda3cwuc00089taxfwifgjbf","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwvh001h9taxp5dspu3k"},{"post_id":"cjda3cwuc00089taxfwifgjbf","category_id":"cjda3cwv2000u9taxssoh092o","_id":"cjda3cwvh001j9taxsxgegxi4"},{"post_id":"cjda3cwtu00029tax6ywo9ajr","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwvi001m9taxptgrqpt5"},{"post_id":"cjda3cwtu00029tax6ywo9ajr","category_id":"cjda3cwur000i9taxevvfv109","_id":"cjda3cwvj001o9taxuvrnpkoe"},{"post_id":"cjda3cwuh000c9tax7uumsh2f","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwvk001q9taxjtm6krqc"},{"post_id":"cjda3cwuh000c9tax7uumsh2f","category_id":"cjda3cwur000i9taxevvfv109","_id":"cjda3cwvk001s9taxhyk91h1l"},{"post_id":"cjda3cwu600069taxrntd4cmt","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwvl001u9tax6zloumer"},{"post_id":"cjda3cwu600069taxrntd4cmt","category_id":"cjda3cwur000i9taxevvfv109","_id":"cjda3cwvm001y9tax9p9l4md5"},{"post_id":"cjda3cwup000h9taxid0q9iw3","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwvn00219taxr6hadu9b"},{"post_id":"cjda3cwup000h9taxid0q9iw3","category_id":"cjda3cwvk001p9taxupuy7vlf","_id":"cjda3cwvn00249taxlmx7hl91"},{"post_id":"cjda3cwuw000m9taxcev33qo9","category_id":"cjda3cwu000049taxkkw9vdgx","_id":"cjda3cwvn00259taxpkj1tzwm"},{"post_id":"cjda3cwuw000m9taxcev33qo9","category_id":"cjda3cwv2000u9taxssoh092o","_id":"cjda3cwvo00289tax298vl5s4"},{"post_id":"cjda3cwv3000w9taxmpnez83h","category_id":"cjda3cwvm00209taxhoep72u8","_id":"cjda3cwvo002a9taxd3w9o662"},{"post_id":"cjda3cwuf000b9taxwb5w0q4z","category_id":"cjda3cwv700109taxg9a2un47","_id":"cjda3cwvp002e9taxmwjikovg"},{"post_id":"cjda3cwuf000b9taxwb5w0q4z","category_id":"cjda3cwvo00269taxxieiecut","_id":"cjda3cwvp002g9taxff6b1w9d"},{"post_id":"cjda3cwum000f9taxevzggt3q","category_id":"cjda3cwv700109taxg9a2un47","_id":"cjda3cwvq002h9tax91azd0rm"},{"post_id":"cjda3cwum000f9taxevzggt3q","category_id":"cjda3cwvo00269taxxieiecut","_id":"cjda3cwvq002j9taxfg77bwpw"}],"PostTag":[{"post_id":"cjda3cwtk00009taxuz8xf5q2","tag_id":"cjda3cwu500059taxd0f37q74","_id":"cjda3cwuo000g9taxref5xq8s"},{"post_id":"cjda3cwtk00009taxuz8xf5q2","tag_id":"cjda3cwud000a9tax62q8niw5","_id":"cjda3cwur000j9taxqujxj7ul"},{"post_id":"cjda3cwtu00029tax6ywo9ajr","tag_id":"cjda3cwu500059taxd0f37q74","_id":"cjda3cwv0000q9taxke99pwui"},{"post_id":"cjda3cwtu00029tax6ywo9ajr","tag_id":"cjda3cwud000a9tax62q8niw5","_id":"cjda3cwv2000t9tax0bipf8w0"},{"post_id":"cjda3cwu600069taxrntd4cmt","tag_id":"cjda3cwu500059taxd0f37q74","_id":"cjda3cwva00129tax6ofi0xar"},{"post_id":"cjda3cwu600069taxrntd4cmt","tag_id":"cjda3cwud000a9tax62q8niw5","_id":"cjda3cwva00149tax0knqxs6f"},{"post_id":"cjda3cwu900079tax6a3exgys","tag_id":"cjda3cwu500059taxd0f37q74","_id":"cjda3cwvc00189tax056evmd3"},{"post_id":"cjda3cwu900079tax6a3exgys","tag_id":"cjda3cwud000a9tax62q8niw5","_id":"cjda3cwve001a9tax55h203vn"},{"post_id":"cjda3cwuc00089taxfwifgjbf","tag_id":"cjda3cwvb00159taxm1erox2g","_id":"cjda3cwvh001i9tax63lq06hl"},{"post_id":"cjda3cwuc00089taxfwifgjbf","tag_id":"cjda3cwve001b9tax22sv2o18","_id":"cjda3cwvi001k9taxatxusar6"},{"post_id":"cjda3cwuf000b9taxwb5w0q4z","tag_id":"cjda3cwvg001g9taxvm4hdvz3","_id":"cjda3cwvk001t9taxer6wp6lx"},{"post_id":"cjda3cwuf000b9taxwb5w0q4z","tag_id":"cjda3cwvj001n9taxy8umubgo","_id":"cjda3cwvm001w9taxn0fvj3m5"},{"post_id":"cjda3cwuh000c9tax7uumsh2f","tag_id":"cjda3cwvk001r9taxpbpou72z","_id":"cjda3cwvm001z9tax13k0yna5"},{"post_id":"cjda3cwuh000c9tax7uumsh2f","tag_id":"cjda3cwud000a9tax62q8niw5","_id":"cjda3cwvn00229taxu4vs1xbk"},{"post_id":"cjda3cwum000f9taxevzggt3q","tag_id":"cjda3cwvg001g9taxvm4hdvz3","_id":"cjda3cwvo00299taxkrt0a76c"},{"post_id":"cjda3cwum000f9taxevzggt3q","tag_id":"cjda3cwvn00239taxznlid05t","_id":"cjda3cwvp002c9taxiyisrahl"},{"post_id":"cjda3cwup000h9taxid0q9iw3","tag_id":"cjda3cwvk001r9taxpbpou72z","_id":"cjda3cwvq002k9taxskxrgl83"},{"post_id":"cjda3cwup000h9taxid0q9iw3","tag_id":"cjda3cwvp002d9taxct4jh3lw","_id":"cjda3cwvq002l9taxp0zelbqs"},{"post_id":"cjda3cwup000h9taxid0q9iw3","tag_id":"cjda3cwvp002f9taxrkjfus32","_id":"cjda3cwvq002n9taxst6244ot"},{"post_id":"cjda3cwus000l9tax74xlw580","tag_id":"cjda3cwvq002i9taxe0sziih3","_id":"cjda3cwvs002r9taxnbou75t5"},{"post_id":"cjda3cwus000l9tax74xlw580","tag_id":"cjda3cwvq002m9taxcf0rfh4z","_id":"cjda3cwvs002s9taxdyqo2d72"},{"post_id":"cjda3cwus000l9tax74xlw580","tag_id":"cjda3cwvq002o9taxmus5bge2","_id":"cjda3cwvt002u9taxt26psfw5"},{"post_id":"cjda3cwus000l9tax74xlw580","tag_id":"cjda3cwvr002p9taxxkztond9","_id":"cjda3cwvu002v9taxi1zjqv8z"},{"post_id":"cjda3cwuw000m9taxcev33qo9","tag_id":"cjda3cwvk001r9taxpbpou72z","_id":"cjda3cwvv002x9tax7k3a1huq"},{"post_id":"cjda3cwuw000m9taxcev33qo9","tag_id":"cjda3cwud000a9tax62q8niw5","_id":"cjda3cwvv002y9taxnsfsbm63"},{"post_id":"cjda3cwuz000p9taxwckty66v","tag_id":"cjda3cwvk001r9taxpbpou72z","_id":"cjda3cwvv002z9tax8hhpe7nx"},{"post_id":"cjda3cwuz000p9taxwckty66v","tag_id":"cjda3cwud000a9tax62q8niw5","_id":"cjda3cwvv00309tax12xk02p9"},{"post_id":"cjda3cwv1000r9taxxdmeulul","tag_id":"cjda3cwvk001r9taxpbpou72z","_id":"cjda3cwvv00319tax22q366kt"},{"post_id":"cjda3cwv1000r9taxxdmeulul","tag_id":"cjda3cwud000a9tax62q8niw5","_id":"cjda3cwvw00329tax07nkdzg6"}],"Tag":[{"name":"bash shell","_id":"cjda3cwu500059taxd0f37q74"},{"name":"shell笔记","_id":"cjda3cwud000a9tax62q8niw5"},{"name":"Linux shell","_id":"cjda3cwvb00159taxm1erox2g"},{"name":"数据处理","_id":"cjda3cwve001b9tax22sv2o18"},{"name":"R","_id":"cjda3cwvg001g9taxvm4hdvz3"},{"name":"类","_id":"cjda3cwvj001n9taxy8umubgo"},{"name":"linux","_id":"cjda3cwvk001r9taxpbpou72z"},{"name":"OOP","_id":"cjda3cwvn00239taxznlid05t"},{"name":"git","_id":"cjda3cwvp002d9taxct4jh3lw"},{"name":"github","_id":"cjda3cwvp002f9taxrkjfus32"},{"name":"sed","_id":"cjda3cwvq002i9taxe0sziih3"},{"name":"生物信息学","_id":"cjda3cwvq002m9taxcf0rfh4z"},{"name":"文本处理","_id":"cjda3cwvq002o9taxmus5bge2"},{"name":"fasta","_id":"cjda3cwvr002p9taxxkztond9"}]}}